// ignore_for_file: invalid_annotation_target, camel_case_types

import 'package:freezed_annotation/freezed_annotation.dart';
import 'search_params.dart';

part 'resource_search_params.freezed.dart';

@freezed
class AccountSearchParams with _$AccountSearchParams {
  const AccountSearchParams._();
  const factory AccountSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [identifier] Account number
    @Default([]) List<SearchParamToken> identifier,

    /// [name] Human-readable label
    @Default([]) List<SearchParamString> name,

    /// [owner] Entity managing the Account
    @Default([]) List<SearchParamReference> owner,

    /// [patient] The entity that caused the expenses
    @Default([]) List<SearchParamReference> patient,

    /// [period] Transaction window
    @Default([]) List<SearchParamDate> period,

    /// [status] active | inactive | entered-in-error | on-hold | unknown
    @Default([]) List<SearchParamToken> status,

    /// [subject] The entity that caused the expenses
    @Default([]) List<SearchParamReference> subject,

    /// [type] E.g. patient, expense, depreciation
    @Default([]) List<SearchParamToken> type,
  }) = _AccountSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (owner.isNotEmpty) {
      owner.forEach(
          (element) => returnStrings.add('owner${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (period.isNotEmpty) {
      period.forEach(
          (element) => returnStrings.add('period${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ActivityDefinitionSearchParams with _$ActivityDefinitionSearchParams {
  const ActivityDefinitionSearchParams._();
  const factory ActivityDefinitionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [composedOf] What resource is being referenced
    @Default([])
    @JsonKey(name: 'composed-of')
        List<SearchParamReference> composedOf,

    /// [context] A use context assigned to the activity definition
    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] A quantity- or range-valued use context assigned to the activity definition
    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] A type of use context assigned to the activity definition
    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] The activity definition publication date
    @Default([]) List<SearchParamDate> date,

    /// [dependsOn] What resource is being referenced
    @Default([])
    @JsonKey(name: 'depends-on')
        List<SearchParamReference> dependsOn,

    /// [derivedFrom] What resource is being referenced
    @Default([])
    @JsonKey(name: 'derived-from')
        List<SearchParamReference> derivedFrom,

    /// [description] The description of the activity definition
    @Default([]) List<SearchParamString> description,

    /// [effective] The time during which the activity definition is intended to be in use
    @Default([]) List<SearchParamDate> effective,

    /// [identifier] External identifier for the activity definition
    @Default([]) List<SearchParamToken> identifier,

    /// [jurisdiction] Intended jurisdiction for the activity definition
    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Computationally friendly name of the activity definition
    @Default([]) List<SearchParamString> name,

    /// [predecessor] What resource is being referenced
    @Default([]) List<SearchParamReference> predecessor,

    /// [publisher] Name of the publisher of the activity definition
    @Default([]) List<SearchParamString> publisher,

    /// [status] The current status of the activity definition
    @Default([]) List<SearchParamToken> status,

    /// [successor] What resource is being referenced
    @Default([]) List<SearchParamReference> successor,

    /// [title] The human-friendly name of the activity definition
    @Default([]) List<SearchParamString> title,

    /// [topic] Topics associated with the module
    @Default([]) List<SearchParamToken> topic,

    /// [url] The uri that identifies the activity definition
    @Default([]) List<SearchParamUri> url,

    /// [version] The business version of the activity definition
    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] A use context type and quantity- or range-based value assigned to the activity definition
    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] A use context type and value assigned to the activity definition
    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,
  }) = _ActivityDefinitionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (composedOf.isNotEmpty) {
      composedOf.forEach(
          (element) => returnStrings.add('composed-of${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (dependsOn.isNotEmpty) {
      dependsOn.forEach(
          (element) => returnStrings.add('depends-on${element.toRequest()}'));
    }
    if (derivedFrom.isNotEmpty) {
      derivedFrom.forEach(
          (element) => returnStrings.add('derived-from${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (effective.isNotEmpty) {
      effective.forEach(
          (element) => returnStrings.add('effective${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (predecessor.isNotEmpty) {
      predecessor.forEach(
          (element) => returnStrings.add('predecessor${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (successor.isNotEmpty) {
      successor.forEach(
          (element) => returnStrings.add('successor${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (topic.isNotEmpty) {
      topic.forEach(
          (element) => returnStrings.add('topic${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class AdministrableProductDefinitionSearchParams
    with _$AdministrableProductDefinitionSearchParams {
  const AdministrableProductDefinitionSearchParams._();
  const factory AdministrableProductDefinitionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [device] A device that is integral to the medicinal product, in effect being considered as an "ingredient" of the medicinal product. This is not intended for devices that are just co-packaged
    @Default([]) List<SearchParamReference> device,

    /// [doseForm] The administrable dose form, i.e. the dose form of the final product after necessary reconstitution or processing
    @Default([]) @JsonKey(name: 'dose-form') List<SearchParamToken> doseForm,

    /// [formOf] The medicinal product that this is an administrable form of. This is not a reference to the item(s) that make up this administrable form - it is the whole product
    @Default([]) @JsonKey(name: 'form-of') List<SearchParamReference> formOf,

    /// [identifier] An identifier for the administrable product
    @Default([]) List<SearchParamToken> identifier,

    /// [ingredient] The ingredients of this administrable medicinal product
    @Default([]) List<SearchParamToken> ingredient,

    /// [manufacturedItem] The manufactured item(s) that this administrable product is produced from. Either a single item, or several that are mixed before administration (e.g. a power item and a solution item). Note that these are not raw ingredients
    @Default([])
    @JsonKey(name: 'manufactured-item')
        List<SearchParamReference> manufacturedItem,

    /// [route] Coded expression for the route
    @Default([]) List<SearchParamToken> route,

    /// [targetSpecies] Coded expression for the species
    @Default([])
    @JsonKey(name: 'target-species')
        List<SearchParamToken> targetSpecies,
  }) = _AdministrableProductDefinitionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (device.isNotEmpty) {
      device.forEach(
          (element) => returnStrings.add('device${element.toRequest()}'));
    }
    if (doseForm.isNotEmpty) {
      doseForm.forEach(
          (element) => returnStrings.add('dose-form${element.toRequest()}'));
    }
    if (formOf.isNotEmpty) {
      formOf.forEach(
          (element) => returnStrings.add('form-of${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (ingredient.isNotEmpty) {
      ingredient.forEach(
          (element) => returnStrings.add('ingredient${element.toRequest()}'));
    }
    if (manufacturedItem.isNotEmpty) {
      manufacturedItem.forEach((element) =>
          returnStrings.add('manufactured-item${element.toRequest()}'));
    }
    if (route.isNotEmpty) {
      route.forEach(
          (element) => returnStrings.add('route${element.toRequest()}'));
    }
    if (targetSpecies.isNotEmpty) {
      targetSpecies.forEach((element) =>
          returnStrings.add('target-species${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class AdverseEventSearchParams with _$AdverseEventSearchParams {
  const AdverseEventSearchParams._();
  const factory AdverseEventSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [actuality] actual | potential
    @Default([]) List<SearchParamToken> actuality,

    /// [category] product-problem | product-quality | product-use-error | wrong-dose | incorrect-prescribing-information | wrong-technique | wrong-route-of-administration | wrong-rate | wrong-duration | wrong-time | expired-drug | medical-device-use-error | problem-different-manufacturer | unsafe-physical-environment
    @Default([]) List<SearchParamToken> category,

    /// [date] When the event occurred
    @Default([]) List<SearchParamDate> date,

    /// [event] Type of the event itself in relation to the subject
    @Default([]) List<SearchParamToken> event,

    /// [location] Location where adverse event occurred
    @Default([]) List<SearchParamReference> location,

    /// [recorder] Who recorded the adverse event
    @Default([]) List<SearchParamReference> recorder,

    /// [resultingcondition] Effect on the subject due to this event
    @Default([]) List<SearchParamReference> resultingcondition,

    /// [seriousness] Seriousness of the event
    @Default([]) List<SearchParamToken> seriousness,

    /// [severity] mild | moderate | severe
    @Default([]) List<SearchParamToken> severity,

    /// [study] AdverseEvent.study
    @Default([]) List<SearchParamReference> study,

    /// [subject] Subject impacted by event
    @Default([]) List<SearchParamReference> subject,

    /// [substance] Refers to the specific entity that caused the adverse event
    @Default([]) List<SearchParamReference> substance,
  }) = _AdverseEventSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (actuality.isNotEmpty) {
      actuality.forEach(
          (element) => returnStrings.add('actuality${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (event.isNotEmpty) {
      event.forEach(
          (element) => returnStrings.add('event${element.toRequest()}'));
    }
    if (location.isNotEmpty) {
      location.forEach(
          (element) => returnStrings.add('location${element.toRequest()}'));
    }
    if (recorder.isNotEmpty) {
      recorder.forEach(
          (element) => returnStrings.add('recorder${element.toRequest()}'));
    }
    if (resultingcondition.isNotEmpty) {
      resultingcondition.forEach((element) =>
          returnStrings.add('resultingcondition${element.toRequest()}'));
    }
    if (seriousness.isNotEmpty) {
      seriousness.forEach(
          (element) => returnStrings.add('seriousness${element.toRequest()}'));
    }
    if (severity.isNotEmpty) {
      severity.forEach(
          (element) => returnStrings.add('severity${element.toRequest()}'));
    }
    if (study.isNotEmpty) {
      study.forEach(
          (element) => returnStrings.add('study${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    if (substance.isNotEmpty) {
      substance.forEach(
          (element) => returnStrings.add('substance${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class AllergyIntoleranceSearchParams with _$AllergyIntoleranceSearchParams {
  const AllergyIntoleranceSearchParams._();
  const factory AllergyIntoleranceSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [asserter] Source of the information about the allergy
    @Default([]) List<SearchParamReference> asserter,

    /// [category] food | medication | environment | biologic
    @Default([]) List<SearchParamToken> category,

    /// [clinicalStatus] active | inactive | resolved
    @Default([])
    @JsonKey(name: 'clinical-status')
        List<SearchParamToken> clinicalStatus,

    /// [code] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Code that identifies the allergy or intolerance
    /// * [Condition](condition.html): Code for the condition
    /// * [DeviceRequest](devicerequest.html): Code for what is being requested/ordered
    /// * [DiagnosticReport](diagnosticreport.html): The code for the report, as opposed to codes for the atomic results, which are the names on the observation resource referred to from the result
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a condition code
    /// * [List](list.html): What the purpose of this list is
    /// * [Medication](medication.html): Returns medications for a specific code
    /// * [MedicationAdministration](medicationadministration.html): Return administrations of this medication code
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine code
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions of this medication code
    /// * [MedicationStatement](medicationstatement.html): Return statements of this medication code
    /// * [Observation](observation.html): The code of the observation type
    /// * [Procedure](procedure.html): A code to identify a  procedure
    /// * [ServiceRequest](servicerequest.html): What is being requested/ordered

    @Default([]) List<SearchParamToken> code,

    /// [criticality] low | high | unable-to-assess
    @Default([]) List<SearchParamToken> criticality,

    /// [date] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Date first version of the resource instance was recorded
    /// * [CarePlan](careplan.html): Time period plan covers
    /// * [CareTeam](careteam.html): Time period team covers
    /// * [ClinicalImpression](clinicalimpression.html): When the assessment was documented
    /// * [Composition](composition.html): Composition editing time
    /// * [Consent](consent.html): When this Consent was created or indexed
    /// * [DiagnosticReport](diagnosticreport.html): The clinically relevant time of the report
    /// * [Encounter](encounter.html): A date within the period the Encounter lasted
    /// * [EpisodeOfCare](episodeofcare.html): The provided date search value falls within the episode of care's period
    /// * [FamilyMemberHistory](familymemberhistory.html): When history was recorded or last updated
    /// * [Flag](flag.html): Time period when flag is active
    /// * [Immunization](immunization.html): Vaccination  (non)-Administration Date
    /// * [List](list.html): When the list was prepared
    /// * [Observation](observation.html): Obtained date/time. If the obtained element is a period, a date that falls in the period
    /// * [Procedure](procedure.html): When the procedure was performed
    /// * [RiskAssessment](riskassessment.html): When was assessment made?
    /// * [SupplyRequest](supplyrequest.html): When the request was made

    @Default([]) List<SearchParamDate> date,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [lastDate] Date(/time) of last known occurrence of a reaction
    @Default([]) @JsonKey(name: 'last-date') List<SearchParamDate> lastDate,

    /// [manifestation] Clinical symptoms/signs associated with the Event
    @Default([]) List<SearchParamToken> manifestation,

    /// [onset] Date(/time) when manifestations showed
    @Default([]) List<SearchParamDate> onset,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [recorder] Who recorded the sensitivity
    @Default([]) List<SearchParamReference> recorder,

    /// [route] How the subject was exposed to the substance
    @Default([]) List<SearchParamToken> route,

    /// [severity] mild | moderate | severe (of event as a whole)
    @Default([]) List<SearchParamToken> severity,

    /// [type] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): allergy | intolerance - Underlying mechanism (if known)
    /// * [Composition](composition.html): Kind of composition (LOINC if possible)
    /// * [DocumentManifest](documentmanifest.html): Kind of document set
    /// * [DocumentReference](documentreference.html): Kind of document (LOINC if possible)
    /// * [Encounter](encounter.html): Specific type of encounter
    /// * [EpisodeOfCare](episodeofcare.html): Type/class  - e.g. specialist referral, disease management

    @Default([]) List<SearchParamToken> type,

    /// [verificationStatus] unconfirmed | confirmed | refuted | entered-in-error
    @Default([])
    @JsonKey(name: 'verification-status')
        List<SearchParamToken> verificationStatus,
  }) = _AllergyIntoleranceSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (asserter.isNotEmpty) {
      asserter.forEach(
          (element) => returnStrings.add('asserter${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (clinicalStatus.isNotEmpty) {
      clinicalStatus.forEach((element) =>
          returnStrings.add('clinical-status${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (criticality.isNotEmpty) {
      criticality.forEach(
          (element) => returnStrings.add('criticality${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (lastDate.isNotEmpty) {
      lastDate.forEach(
          (element) => returnStrings.add('last-date${element.toRequest()}'));
    }
    if (manifestation.isNotEmpty) {
      manifestation.forEach((element) =>
          returnStrings.add('manifestation${element.toRequest()}'));
    }
    if (onset.isNotEmpty) {
      onset.forEach(
          (element) => returnStrings.add('onset${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (recorder.isNotEmpty) {
      recorder.forEach(
          (element) => returnStrings.add('recorder${element.toRequest()}'));
    }
    if (route.isNotEmpty) {
      route.forEach(
          (element) => returnStrings.add('route${element.toRequest()}'));
    }
    if (severity.isNotEmpty) {
      severity.forEach(
          (element) => returnStrings.add('severity${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    if (verificationStatus.isNotEmpty) {
      verificationStatus.forEach((element) =>
          returnStrings.add('verification-status${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ConditionSearchParams with _$ConditionSearchParams {
  const ConditionSearchParams._();
  const factory ConditionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [code] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Code that identifies the allergy or intolerance
    /// * [Condition](condition.html): Code for the condition
    /// * [DeviceRequest](devicerequest.html): Code for what is being requested/ordered
    /// * [DiagnosticReport](diagnosticreport.html): The code for the report, as opposed to codes for the atomic results, which are the names on the observation resource referred to from the result
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a condition code
    /// * [List](list.html): What the purpose of this list is
    /// * [Medication](medication.html): Returns medications for a specific code
    /// * [MedicationAdministration](medicationadministration.html): Return administrations of this medication code
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine code
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions of this medication code
    /// * [MedicationStatement](medicationstatement.html): Return statements of this medication code
    /// * [Observation](observation.html): The code of the observation type
    /// * [Procedure](procedure.html): A code to identify a  procedure
    /// * [ServiceRequest](servicerequest.html): What is being requested/ordered

    @Default([]) List<SearchParamToken> code,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [abatementAge] Abatement as age or age range
    @Default([])
    @JsonKey(name: 'abatement-age')
        List<SearchParamQuantity> abatementAge,

    /// [abatementDate] Date-related abatements (dateTime and period)
    @Default([])
    @JsonKey(name: 'abatement-date')
        List<SearchParamDate> abatementDate,

    /// [abatementString] Abatement as a string
    @Default([])
    @JsonKey(name: 'abatement-string')
        List<SearchParamString> abatementString,

    /// [asserter] Person who asserts this condition
    @Default([]) List<SearchParamReference> asserter,

    /// [bodySite] Anatomical location, if relevant
    @Default([]) @JsonKey(name: 'body-site') List<SearchParamToken> bodySite,

    /// [category] The category of the condition
    @Default([]) List<SearchParamToken> category,

    /// [clinicalStatus] The clinical status of the condition
    @Default([])
    @JsonKey(name: 'clinical-status')
        List<SearchParamToken> clinicalStatus,

    /// [encounter] Encounter created as part of
    @Default([]) List<SearchParamReference> encounter,

    /// [evidence] Manifestation/symptom
    @Default([]) List<SearchParamToken> evidence,

    /// [evidenceDetail] Supporting information found elsewhere
    @Default([])
    @JsonKey(name: 'evidence-detail')
        List<SearchParamReference> evidenceDetail,

    /// [onsetAge] Onsets as age or age range
    @Default([]) @JsonKey(name: 'onset-age') List<SearchParamQuantity> onsetAge,

    /// [onsetDate] Date related onsets (dateTime and Period)
    @Default([]) @JsonKey(name: 'onset-date') List<SearchParamDate> onsetDate,

    /// [onsetInfo] Onsets as a string
    @Default([]) @JsonKey(name: 'onset-info') List<SearchParamString> onsetInfo,

    /// [recordedDate] Date record was first recorded
    @Default([])
    @JsonKey(name: 'recorded-date')
        List<SearchParamDate> recordedDate,

    /// [severity] The severity of the condition
    @Default([]) List<SearchParamToken> severity,

    /// [stage] Simple summary (disease specific)
    @Default([]) List<SearchParamToken> stage,

    /// [subject] Who has the condition?
    @Default([]) List<SearchParamReference> subject,

    /// [verificationStatus] unconfirmed | provisional | differential | confirmed | refuted | entered-in-error
    @Default([])
    @JsonKey(name: 'verification-status')
        List<SearchParamToken> verificationStatus,
  }) = _ConditionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (abatementAge.isNotEmpty) {
      abatementAge.forEach((element) =>
          returnStrings.add('abatement-age${element.toRequest()}'));
    }
    if (abatementDate.isNotEmpty) {
      abatementDate.forEach((element) =>
          returnStrings.add('abatement-date${element.toRequest()}'));
    }
    if (abatementString.isNotEmpty) {
      abatementString.forEach((element) =>
          returnStrings.add('abatement-string${element.toRequest()}'));
    }
    if (asserter.isNotEmpty) {
      asserter.forEach(
          (element) => returnStrings.add('asserter${element.toRequest()}'));
    }
    if (bodySite.isNotEmpty) {
      bodySite.forEach(
          (element) => returnStrings.add('body-site${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (clinicalStatus.isNotEmpty) {
      clinicalStatus.forEach((element) =>
          returnStrings.add('clinical-status${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (evidence.isNotEmpty) {
      evidence.forEach(
          (element) => returnStrings.add('evidence${element.toRequest()}'));
    }
    if (evidenceDetail.isNotEmpty) {
      evidenceDetail.forEach((element) =>
          returnStrings.add('evidence-detail${element.toRequest()}'));
    }
    if (onsetAge.isNotEmpty) {
      onsetAge.forEach(
          (element) => returnStrings.add('onset-age${element.toRequest()}'));
    }
    if (onsetDate.isNotEmpty) {
      onsetDate.forEach(
          (element) => returnStrings.add('onset-date${element.toRequest()}'));
    }
    if (onsetInfo.isNotEmpty) {
      onsetInfo.forEach(
          (element) => returnStrings.add('onset-info${element.toRequest()}'));
    }
    if (recordedDate.isNotEmpty) {
      recordedDate.forEach((element) =>
          returnStrings.add('recorded-date${element.toRequest()}'));
    }
    if (severity.isNotEmpty) {
      severity.forEach(
          (element) => returnStrings.add('severity${element.toRequest()}'));
    }
    if (stage.isNotEmpty) {
      stage.forEach(
          (element) => returnStrings.add('stage${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    if (verificationStatus.isNotEmpty) {
      verificationStatus.forEach((element) =>
          returnStrings.add('verification-status${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class DeviceRequestSearchParams with _$DeviceRequestSearchParams {
  const DeviceRequestSearchParams._();
  const factory DeviceRequestSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [code] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Code that identifies the allergy or intolerance
    /// * [Condition](condition.html): Code for the condition
    /// * [DeviceRequest](devicerequest.html): Code for what is being requested/ordered
    /// * [DiagnosticReport](diagnosticreport.html): The code for the report, as opposed to codes for the atomic results, which are the names on the observation resource referred to from the result
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a condition code
    /// * [List](list.html): What the purpose of this list is
    /// * [Medication](medication.html): Returns medications for a specific code
    /// * [MedicationAdministration](medicationadministration.html): Return administrations of this medication code
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine code
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions of this medication code
    /// * [MedicationStatement](medicationstatement.html): Return statements of this medication code
    /// * [Observation](observation.html): The code of the observation type
    /// * [Procedure](procedure.html): A code to identify a  procedure
    /// * [ServiceRequest](servicerequest.html): What is being requested/ordered

    @Default([]) List<SearchParamToken> code,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [encounter] Multiple Resources:

    /// * [Composition](composition.html): Context of the Composition
    /// * [DeviceRequest](devicerequest.html): Encounter during which request was created
    /// * [DiagnosticReport](diagnosticreport.html): The Encounter when the order was made
    /// * [DocumentReference](documentreference.html): Context of the document  content
    /// * [Flag](flag.html): Alert relevant during encounter
    /// * [List](list.html): Context in which list created
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this encounter identifier
    /// * [Observation](observation.html): Encounter related to the observation
    /// * [Procedure](procedure.html): Encounter created as part of
    /// * [RiskAssessment](riskassessment.html): Where was assessment performed?
    /// * [ServiceRequest](servicerequest.html): An encounter in which this request is made
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this encounter identifier

    @Default([]) List<SearchParamReference> encounter,

    /// [authoredOn] When the request transitioned to being actionable
    @Default([]) @JsonKey(name: 'authored-on') List<SearchParamDate> authoredOn,

    /// [basedOn] Plan/proposal/order fulfilled by this request
    @Default([]) @JsonKey(name: 'based-on') List<SearchParamReference> basedOn,

    /// [device] Reference to resource that is being requested/ordered
    @Default([]) List<SearchParamReference> device,

    /// [eventDate] When service should occur
    @Default([]) @JsonKey(name: 'event-date') List<SearchParamDate> eventDate,

    /// [groupIdentifier] Composite request this is part of
    @Default([])
    @JsonKey(name: 'group-identifier')
        List<SearchParamToken> groupIdentifier,

    /// [instantiatesCanonical] Instantiates FHIR protocol or definition
    @Default([])
    @JsonKey(name: 'instantiates-canonical')
        List<SearchParamReference> instantiatesCanonical,

    /// [instantiatesUri] Instantiates external protocol or definition
    @Default([])
    @JsonKey(name: 'instantiates-uri')
        List<SearchParamUri> instantiatesUri,

    /// [insurance] Associated insurance coverage
    @Default([]) List<SearchParamReference> insurance,

    /// [intent] proposal | plan | original-order |reflex-order
    @Default([]) List<SearchParamToken> intent,

    /// [performer] Desired performer for service
    @Default([]) List<SearchParamReference> performer,

    /// [priorRequest] Request takes the place of referenced completed or terminated requests
    @Default([])
    @JsonKey(name: 'prior-request')
        List<SearchParamReference> priorRequest,

    /// [requester] Who/what is requesting service
    @Default([]) List<SearchParamReference> requester,

    /// [status] entered-in-error | draft | active |suspended | completed
    @Default([]) List<SearchParamToken> status,

    /// [subject] Individual the service is ordered for
    @Default([]) List<SearchParamReference> subject,
  }) = _DeviceRequestSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (authoredOn.isNotEmpty) {
      authoredOn.forEach(
          (element) => returnStrings.add('authored-on${element.toRequest()}'));
    }
    if (basedOn.isNotEmpty) {
      basedOn.forEach(
          (element) => returnStrings.add('based-on${element.toRequest()}'));
    }
    if (device.isNotEmpty) {
      device.forEach(
          (element) => returnStrings.add('device${element.toRequest()}'));
    }
    if (eventDate.isNotEmpty) {
      eventDate.forEach(
          (element) => returnStrings.add('event-date${element.toRequest()}'));
    }
    if (groupIdentifier.isNotEmpty) {
      groupIdentifier.forEach((element) =>
          returnStrings.add('group-identifier${element.toRequest()}'));
    }
    if (instantiatesCanonical.isNotEmpty) {
      instantiatesCanonical.forEach((element) =>
          returnStrings.add('instantiates-canonical${element.toRequest()}'));
    }
    if (instantiatesUri.isNotEmpty) {
      instantiatesUri.forEach((element) =>
          returnStrings.add('instantiates-uri${element.toRequest()}'));
    }
    if (insurance.isNotEmpty) {
      insurance.forEach(
          (element) => returnStrings.add('insurance${element.toRequest()}'));
    }
    if (intent.isNotEmpty) {
      intent.forEach(
          (element) => returnStrings.add('intent${element.toRequest()}'));
    }
    if (performer.isNotEmpty) {
      performer.forEach(
          (element) => returnStrings.add('performer${element.toRequest()}'));
    }
    if (priorRequest.isNotEmpty) {
      priorRequest.forEach((element) =>
          returnStrings.add('prior-request${element.toRequest()}'));
    }
    if (requester.isNotEmpty) {
      requester.forEach(
          (element) => returnStrings.add('requester${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class DiagnosticReportSearchParams with _$DiagnosticReportSearchParams {
  const DiagnosticReportSearchParams._();
  const factory DiagnosticReportSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [code] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Code that identifies the allergy or intolerance
    /// * [Condition](condition.html): Code for the condition
    /// * [DeviceRequest](devicerequest.html): Code for what is being requested/ordered
    /// * [DiagnosticReport](diagnosticreport.html): The code for the report, as opposed to codes for the atomic results, which are the names on the observation resource referred to from the result
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a condition code
    /// * [List](list.html): What the purpose of this list is
    /// * [Medication](medication.html): Returns medications for a specific code
    /// * [MedicationAdministration](medicationadministration.html): Return administrations of this medication code
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine code
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions of this medication code
    /// * [MedicationStatement](medicationstatement.html): Return statements of this medication code
    /// * [Observation](observation.html): The code of the observation type
    /// * [Procedure](procedure.html): A code to identify a  procedure
    /// * [ServiceRequest](servicerequest.html): What is being requested/ordered

    @Default([]) List<SearchParamToken> code,

    /// [date] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Date first version of the resource instance was recorded
    /// * [CarePlan](careplan.html): Time period plan covers
    /// * [CareTeam](careteam.html): Time period team covers
    /// * [ClinicalImpression](clinicalimpression.html): When the assessment was documented
    /// * [Composition](composition.html): Composition editing time
    /// * [Consent](consent.html): When this Consent was created or indexed
    /// * [DiagnosticReport](diagnosticreport.html): The clinically relevant time of the report
    /// * [Encounter](encounter.html): A date within the period the Encounter lasted
    /// * [EpisodeOfCare](episodeofcare.html): The provided date search value falls within the episode of care's period
    /// * [FamilyMemberHistory](familymemberhistory.html): When history was recorded or last updated
    /// * [Flag](flag.html): Time period when flag is active
    /// * [Immunization](immunization.html): Vaccination  (non)-Administration Date
    /// * [List](list.html): When the list was prepared
    /// * [Observation](observation.html): Obtained date/time. If the obtained element is a period, a date that falls in the period
    /// * [Procedure](procedure.html): When the procedure was performed
    /// * [RiskAssessment](riskassessment.html): When was assessment made?
    /// * [SupplyRequest](supplyrequest.html): When the request was made

    @Default([]) List<SearchParamDate> date,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [encounter] Multiple Resources:

    /// * [Composition](composition.html): Context of the Composition
    /// * [DeviceRequest](devicerequest.html): Encounter during which request was created
    /// * [DiagnosticReport](diagnosticreport.html): The Encounter when the order was made
    /// * [DocumentReference](documentreference.html): Context of the document  content
    /// * [Flag](flag.html): Alert relevant during encounter
    /// * [List](list.html): Context in which list created
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this encounter identifier
    /// * [Observation](observation.html): Encounter related to the observation
    /// * [Procedure](procedure.html): Encounter created as part of
    /// * [RiskAssessment](riskassessment.html): Where was assessment performed?
    /// * [ServiceRequest](servicerequest.html): An encounter in which this request is made
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this encounter identifier

    @Default([]) List<SearchParamReference> encounter,

    /// [basedOn] Reference to the service request.
    @Default([]) @JsonKey(name: 'based-on') List<SearchParamReference> basedOn,

    /// [category] Which diagnostic discipline/department created the report
    @Default([]) List<SearchParamToken> category,

    /// [conclusion] A coded conclusion (interpretation/impression) on the report
    @Default([]) List<SearchParamToken> conclusion,

    /// [issued] When the report was issued
    @Default([]) List<SearchParamDate> issued,

    /// [media] A reference to the image source.
    @Default([]) List<SearchParamReference> media,

    /// [performer] Who is responsible for the report
    @Default([]) List<SearchParamReference> performer,

    /// [result] Link to an atomic result (observation resource)
    @Default([]) List<SearchParamReference> result,

    /// [resultsInterpreter] Who was the source of the report
    @Default([])
    @JsonKey(name: 'results-interpreter')
        List<SearchParamReference> resultsInterpreter,

    /// [specimen] The specimen details
    @Default([]) List<SearchParamReference> specimen,

    /// [status] The status of the report
    @Default([]) List<SearchParamToken> status,

    /// [subject] The subject of the report
    @Default([]) List<SearchParamReference> subject,
  }) = _DiagnosticReportSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (basedOn.isNotEmpty) {
      basedOn.forEach(
          (element) => returnStrings.add('based-on${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (conclusion.isNotEmpty) {
      conclusion.forEach(
          (element) => returnStrings.add('conclusion${element.toRequest()}'));
    }
    if (issued.isNotEmpty) {
      issued.forEach(
          (element) => returnStrings.add('issued${element.toRequest()}'));
    }
    if (media.isNotEmpty) {
      media.forEach(
          (element) => returnStrings.add('media${element.toRequest()}'));
    }
    if (performer.isNotEmpty) {
      performer.forEach(
          (element) => returnStrings.add('performer${element.toRequest()}'));
    }
    if (result.isNotEmpty) {
      result.forEach(
          (element) => returnStrings.add('result${element.toRequest()}'));
    }
    if (resultsInterpreter.isNotEmpty) {
      resultsInterpreter.forEach((element) =>
          returnStrings.add('results-interpreter${element.toRequest()}'));
    }
    if (specimen.isNotEmpty) {
      specimen.forEach(
          (element) => returnStrings.add('specimen${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class FamilyMemberHistorySearchParams with _$FamilyMemberHistorySearchParams {
  const FamilyMemberHistorySearchParams._();
  const factory FamilyMemberHistorySearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [code] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Code that identifies the allergy or intolerance
    /// * [Condition](condition.html): Code for the condition
    /// * [DeviceRequest](devicerequest.html): Code for what is being requested/ordered
    /// * [DiagnosticReport](diagnosticreport.html): The code for the report, as opposed to codes for the atomic results, which are the names on the observation resource referred to from the result
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a condition code
    /// * [List](list.html): What the purpose of this list is
    /// * [Medication](medication.html): Returns medications for a specific code
    /// * [MedicationAdministration](medicationadministration.html): Return administrations of this medication code
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine code
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions of this medication code
    /// * [MedicationStatement](medicationstatement.html): Return statements of this medication code
    /// * [Observation](observation.html): The code of the observation type
    /// * [Procedure](procedure.html): A code to identify a  procedure
    /// * [ServiceRequest](servicerequest.html): What is being requested/ordered

    @Default([]) List<SearchParamToken> code,

    /// [date] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Date first version of the resource instance was recorded
    /// * [CarePlan](careplan.html): Time period plan covers
    /// * [CareTeam](careteam.html): Time period team covers
    /// * [ClinicalImpression](clinicalimpression.html): When the assessment was documented
    /// * [Composition](composition.html): Composition editing time
    /// * [Consent](consent.html): When this Consent was created or indexed
    /// * [DiagnosticReport](diagnosticreport.html): The clinically relevant time of the report
    /// * [Encounter](encounter.html): A date within the period the Encounter lasted
    /// * [EpisodeOfCare](episodeofcare.html): The provided date search value falls within the episode of care's period
    /// * [FamilyMemberHistory](familymemberhistory.html): When history was recorded or last updated
    /// * [Flag](flag.html): Time period when flag is active
    /// * [Immunization](immunization.html): Vaccination  (non)-Administration Date
    /// * [List](list.html): When the list was prepared
    /// * [Observation](observation.html): Obtained date/time. If the obtained element is a period, a date that falls in the period
    /// * [Procedure](procedure.html): When the procedure was performed
    /// * [RiskAssessment](riskassessment.html): When was assessment made?
    /// * [SupplyRequest](supplyrequest.html): When the request was made

    @Default([]) List<SearchParamDate> date,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [instantiatesCanonical] Instantiates FHIR protocol or definition
    @Default([])
    @JsonKey(name: 'instantiates-canonical')
        List<SearchParamReference> instantiatesCanonical,

    /// [instantiatesUri] Instantiates external protocol or definition
    @Default([])
    @JsonKey(name: 'instantiates-uri')
        List<SearchParamUri> instantiatesUri,

    /// [relationship] A search by a relationship type
    @Default([]) List<SearchParamToken> relationship,

    /// [sex] A search by a sex code of a family member
    @Default([]) List<SearchParamToken> sex,

    /// [status] partial | completed | entered-in-error | health-unknown
    @Default([]) List<SearchParamToken> status,
  }) = _FamilyMemberHistorySearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (instantiatesCanonical.isNotEmpty) {
      instantiatesCanonical.forEach((element) =>
          returnStrings.add('instantiates-canonical${element.toRequest()}'));
    }
    if (instantiatesUri.isNotEmpty) {
      instantiatesUri.forEach((element) =>
          returnStrings.add('instantiates-uri${element.toRequest()}'));
    }
    if (relationship.isNotEmpty) {
      relationship.forEach(
          (element) => returnStrings.add('relationship${element.toRequest()}'));
    }
    if (sex.isNotEmpty) {
      sex.forEach((element) => returnStrings.add('sex${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ListSearchParams with _$ListSearchParams {
  const ListSearchParams._();
  const factory ListSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [code] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Code that identifies the allergy or intolerance
    /// * [Condition](condition.html): Code for the condition
    /// * [DeviceRequest](devicerequest.html): Code for what is being requested/ordered
    /// * [DiagnosticReport](diagnosticreport.html): The code for the report, as opposed to codes for the atomic results, which are the names on the observation resource referred to from the result
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a condition code
    /// * [List](list.html): What the purpose of this list is
    /// * [Medication](medication.html): Returns medications for a specific code
    /// * [MedicationAdministration](medicationadministration.html): Return administrations of this medication code
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine code
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions of this medication code
    /// * [MedicationStatement](medicationstatement.html): Return statements of this medication code
    /// * [Observation](observation.html): The code of the observation type
    /// * [Procedure](procedure.html): A code to identify a  procedure
    /// * [ServiceRequest](servicerequest.html): What is being requested/ordered

    @Default([]) List<SearchParamToken> code,

    /// [date] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Date first version of the resource instance was recorded
    /// * [CarePlan](careplan.html): Time period plan covers
    /// * [CareTeam](careteam.html): Time period team covers
    /// * [ClinicalImpression](clinicalimpression.html): When the assessment was documented
    /// * [Composition](composition.html): Composition editing time
    /// * [Consent](consent.html): When this Consent was created or indexed
    /// * [DiagnosticReport](diagnosticreport.html): The clinically relevant time of the report
    /// * [Encounter](encounter.html): A date within the period the Encounter lasted
    /// * [EpisodeOfCare](episodeofcare.html): The provided date search value falls within the episode of care's period
    /// * [FamilyMemberHistory](familymemberhistory.html): When history was recorded or last updated
    /// * [Flag](flag.html): Time period when flag is active
    /// * [Immunization](immunization.html): Vaccination  (non)-Administration Date
    /// * [List](list.html): When the list was prepared
    /// * [Observation](observation.html): Obtained date/time. If the obtained element is a period, a date that falls in the period
    /// * [Procedure](procedure.html): When the procedure was performed
    /// * [RiskAssessment](riskassessment.html): When was assessment made?
    /// * [SupplyRequest](supplyrequest.html): When the request was made

    @Default([]) List<SearchParamDate> date,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [encounter] Multiple Resources:

    /// * [Composition](composition.html): Context of the Composition
    /// * [DeviceRequest](devicerequest.html): Encounter during which request was created
    /// * [DiagnosticReport](diagnosticreport.html): The Encounter when the order was made
    /// * [DocumentReference](documentreference.html): Context of the document  content
    /// * [Flag](flag.html): Alert relevant during encounter
    /// * [List](list.html): Context in which list created
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this encounter identifier
    /// * [Observation](observation.html): Encounter related to the observation
    /// * [Procedure](procedure.html): Encounter created as part of
    /// * [RiskAssessment](riskassessment.html): Where was assessment performed?
    /// * [ServiceRequest](servicerequest.html): An encounter in which this request is made
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this encounter identifier

    @Default([]) List<SearchParamReference> encounter,

    /// [emptyReason] Why list is empty
    @Default([])
    @JsonKey(name: 'empty-reason')
        List<SearchParamToken> emptyReason,

    /// [item] Actual entry
    @Default([]) List<SearchParamReference> item,

    /// [notes] The annotation  - text content (as markdown)
    @Default([]) List<SearchParamString> notes,

    /// [source] Who and/or what defined the list contents (aka Author)
    @Default([]) List<SearchParamReference> source,

    /// [status] current | retired | entered-in-error
    @Default([]) List<SearchParamToken> status,

    /// [subject] If all resources have the same subject
    @Default([]) List<SearchParamReference> subject,

    /// [title] Descriptive name for the list
    @Default([]) List<SearchParamString> title,
  }) = _ListSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (emptyReason.isNotEmpty) {
      emptyReason.forEach(
          (element) => returnStrings.add('empty-reason${element.toRequest()}'));
    }
    if (item.isNotEmpty) {
      item.forEach(
          (element) => returnStrings.add('item${element.toRequest()}'));
    }
    if (notes.isNotEmpty) {
      notes.forEach(
          (element) => returnStrings.add('notes${element.toRequest()}'));
    }
    if (source.isNotEmpty) {
      source.forEach(
          (element) => returnStrings.add('source${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class MedicationSearchParams with _$MedicationSearchParams {
  const MedicationSearchParams._();
  const factory MedicationSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [code] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Code that identifies the allergy or intolerance
    /// * [Condition](condition.html): Code for the condition
    /// * [DeviceRequest](devicerequest.html): Code for what is being requested/ordered
    /// * [DiagnosticReport](diagnosticreport.html): The code for the report, as opposed to codes for the atomic results, which are the names on the observation resource referred to from the result
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a condition code
    /// * [List](list.html): What the purpose of this list is
    /// * [Medication](medication.html): Returns medications for a specific code
    /// * [MedicationAdministration](medicationadministration.html): Return administrations of this medication code
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine code
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions of this medication code
    /// * [MedicationStatement](medicationstatement.html): Return statements of this medication code
    /// * [Observation](observation.html): The code of the observation type
    /// * [Procedure](procedure.html): A code to identify a  procedure
    /// * [ServiceRequest](servicerequest.html): What is being requested/ordered

    @Default([]) List<SearchParamToken> code,

    /// [expirationDate] Returns medications in a batch with this expiration date
    @Default([])
    @JsonKey(name: 'expiration-date')
        List<SearchParamDate> expirationDate,

    /// [form] Returns medications for a specific dose form
    @Default([]) List<SearchParamToken> form,

    /// [identifier] Returns medications with this external identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [ingredient] Returns medications for this ingredient reference
    @Default([]) List<SearchParamReference> ingredient,

    /// [ingredientCode] Returns medications for this ingredient code
    @Default([])
    @JsonKey(name: 'ingredient-code')
        List<SearchParamToken> ingredientCode,

    /// [lotNumber] Returns medications in a batch with this lot number
    @Default([]) @JsonKey(name: 'lot-number') List<SearchParamToken> lotNumber,

    /// [manufacturer] Returns medications made or sold for this manufacturer
    @Default([]) List<SearchParamReference> manufacturer,

    /// [status] Returns medications for this status
    @Default([]) List<SearchParamToken> status,
  }) = _MedicationSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (expirationDate.isNotEmpty) {
      expirationDate.forEach((element) =>
          returnStrings.add('expiration-date${element.toRequest()}'));
    }
    if (form.isNotEmpty) {
      form.forEach(
          (element) => returnStrings.add('form${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (ingredient.isNotEmpty) {
      ingredient.forEach(
          (element) => returnStrings.add('ingredient${element.toRequest()}'));
    }
    if (ingredientCode.isNotEmpty) {
      ingredientCode.forEach((element) =>
          returnStrings.add('ingredient-code${element.toRequest()}'));
    }
    if (lotNumber.isNotEmpty) {
      lotNumber.forEach(
          (element) => returnStrings.add('lot-number${element.toRequest()}'));
    }
    if (manufacturer.isNotEmpty) {
      manufacturer.forEach(
          (element) => returnStrings.add('manufacturer${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class MedicationAdministrationSearchParams
    with _$MedicationAdministrationSearchParams {
  const MedicationAdministrationSearchParams._();
  const factory MedicationAdministrationSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [code] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Code that identifies the allergy or intolerance
    /// * [Condition](condition.html): Code for the condition
    /// * [DeviceRequest](devicerequest.html): Code for what is being requested/ordered
    /// * [DiagnosticReport](diagnosticreport.html): The code for the report, as opposed to codes for the atomic results, which are the names on the observation resource referred to from the result
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a condition code
    /// * [List](list.html): What the purpose of this list is
    /// * [Medication](medication.html): Returns medications for a specific code
    /// * [MedicationAdministration](medicationadministration.html): Return administrations of this medication code
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine code
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions of this medication code
    /// * [MedicationStatement](medicationstatement.html): Return statements of this medication code
    /// * [Observation](observation.html): The code of the observation type
    /// * [Procedure](procedure.html): A code to identify a  procedure
    /// * [ServiceRequest](servicerequest.html): What is being requested/ordered

    @Default([]) List<SearchParamToken> code,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [context] Return administrations that share this encounter or episode of care
    @Default([]) List<SearchParamReference> context,

    /// [device] Return administrations with this administration device identity
    @Default([]) List<SearchParamReference> device,

    /// [effectiveTime] Date administration happened (or did not happen)
    @Default([])
    @JsonKey(name: 'effective-time')
        List<SearchParamDate> effectiveTime,

    /// [medication] Multiple Resources:

    /// * [MedicationAdministration](medicationadministration.html): Return administrations of this medication resource
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine resource
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions for this medication reference
    /// * [MedicationStatement](medicationstatement.html): Return statements of this medication reference

    @Default([]) List<SearchParamReference> medication,

    /// [performer] The identity of the individual who administered the medication
    @Default([]) List<SearchParamReference> performer,

    /// [reasonGiven] Reasons for administering the medication
    @Default([])
    @JsonKey(name: 'reason-given')
        List<SearchParamToken> reasonGiven,

    /// [reasonNotGiven] Reasons for not administering the medication
    @Default([])
    @JsonKey(name: 'reason-not-given')
        List<SearchParamToken> reasonNotGiven,

    /// [request] The identity of a request to list administrations from
    @Default([]) List<SearchParamReference> request,

    /// [status] Multiple Resources:

    /// * [MedicationAdministration](medicationadministration.html): MedicationAdministration event status (for example one of active/paused/completed/nullified)
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with a specified dispense status
    /// * [MedicationRequest](medicationrequest.html): Status of the prescription
    /// * [MedicationStatement](medicationstatement.html): Return statements that match the given status

    @Default([]) List<SearchParamToken> status,

    /// [subject] The identity of the individual or group to list administrations for
    @Default([]) List<SearchParamReference> subject,
  }) = _MedicationAdministrationSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (device.isNotEmpty) {
      device.forEach(
          (element) => returnStrings.add('device${element.toRequest()}'));
    }
    if (effectiveTime.isNotEmpty) {
      effectiveTime.forEach((element) =>
          returnStrings.add('effective-time${element.toRequest()}'));
    }
    if (medication.isNotEmpty) {
      medication.forEach(
          (element) => returnStrings.add('medication${element.toRequest()}'));
    }
    if (performer.isNotEmpty) {
      performer.forEach(
          (element) => returnStrings.add('performer${element.toRequest()}'));
    }
    if (reasonGiven.isNotEmpty) {
      reasonGiven.forEach(
          (element) => returnStrings.add('reason-given${element.toRequest()}'));
    }
    if (reasonNotGiven.isNotEmpty) {
      reasonNotGiven.forEach((element) =>
          returnStrings.add('reason-not-given${element.toRequest()}'));
    }
    if (request.isNotEmpty) {
      request.forEach(
          (element) => returnStrings.add('request${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class MedicationDispenseSearchParams with _$MedicationDispenseSearchParams {
  const MedicationDispenseSearchParams._();
  const factory MedicationDispenseSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [code] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Code that identifies the allergy or intolerance
    /// * [Condition](condition.html): Code for the condition
    /// * [DeviceRequest](devicerequest.html): Code for what is being requested/ordered
    /// * [DiagnosticReport](diagnosticreport.html): The code for the report, as opposed to codes for the atomic results, which are the names on the observation resource referred to from the result
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a condition code
    /// * [List](list.html): What the purpose of this list is
    /// * [Medication](medication.html): Returns medications for a specific code
    /// * [MedicationAdministration](medicationadministration.html): Return administrations of this medication code
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine code
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions of this medication code
    /// * [MedicationStatement](medicationstatement.html): Return statements of this medication code
    /// * [Observation](observation.html): The code of the observation type
    /// * [Procedure](procedure.html): A code to identify a  procedure
    /// * [ServiceRequest](servicerequest.html): What is being requested/ordered

    @Default([]) List<SearchParamToken> code,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [medication] Multiple Resources:

    /// * [MedicationAdministration](medicationadministration.html): Return administrations of this medication resource
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine resource
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions for this medication reference
    /// * [MedicationStatement](medicationstatement.html): Return statements of this medication reference

    @Default([]) List<SearchParamReference> medication,

    /// [status] Multiple Resources:

    /// * [MedicationAdministration](medicationadministration.html): MedicationAdministration event status (for example one of active/paused/completed/nullified)
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with a specified dispense status
    /// * [MedicationRequest](medicationrequest.html): Status of the prescription
    /// * [MedicationStatement](medicationstatement.html): Return statements that match the given status

    @Default([]) List<SearchParamToken> status,

    /// [context] Returns dispenses with a specific context (episode or episode of care)
    @Default([]) List<SearchParamReference> context,

    /// [destination] Returns dispenses that should be sent to a specific destination
    @Default([]) List<SearchParamReference> destination,

    /// [performer] Returns dispenses performed by a specific individual
    @Default([]) List<SearchParamReference> performer,

    /// [prescription] Multiple Resources:

    /// * [MedicationDispense](medicationdispense.html): The identity of a prescription to list dispenses from

    @Default([]) List<SearchParamReference> prescription,

    /// [receiver] The identity of a receiver to list dispenses for
    @Default([]) List<SearchParamReference> receiver,

    /// [responsibleparty] Returns dispenses with the specified responsible party
    @Default([]) List<SearchParamReference> responsibleparty,

    /// [subject] The identity of a patient for whom to list dispenses
    @Default([]) List<SearchParamReference> subject,

    /// [type] Returns dispenses of a specific type
    @Default([]) List<SearchParamToken> type,

    /// [whenhandedover] Returns dispenses handed over on this date
    @Default([]) List<SearchParamDate> whenhandedover,

    /// [whenprepared] Returns dispenses prepared on this date
    @Default([]) List<SearchParamDate> whenprepared,
  }) = _MedicationDispenseSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (medication.isNotEmpty) {
      medication.forEach(
          (element) => returnStrings.add('medication${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (destination.isNotEmpty) {
      destination.forEach(
          (element) => returnStrings.add('destination${element.toRequest()}'));
    }
    if (performer.isNotEmpty) {
      performer.forEach(
          (element) => returnStrings.add('performer${element.toRequest()}'));
    }
    if (prescription.isNotEmpty) {
      prescription.forEach(
          (element) => returnStrings.add('prescription${element.toRequest()}'));
    }
    if (receiver.isNotEmpty) {
      receiver.forEach(
          (element) => returnStrings.add('receiver${element.toRequest()}'));
    }
    if (responsibleparty.isNotEmpty) {
      responsibleparty.forEach((element) =>
          returnStrings.add('responsibleparty${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    if (whenhandedover.isNotEmpty) {
      whenhandedover.forEach((element) =>
          returnStrings.add('whenhandedover${element.toRequest()}'));
    }
    if (whenprepared.isNotEmpty) {
      whenprepared.forEach(
          (element) => returnStrings.add('whenprepared${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class MedicationRequestSearchParams with _$MedicationRequestSearchParams {
  const MedicationRequestSearchParams._();
  const factory MedicationRequestSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [code] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Code that identifies the allergy or intolerance
    /// * [Condition](condition.html): Code for the condition
    /// * [DeviceRequest](devicerequest.html): Code for what is being requested/ordered
    /// * [DiagnosticReport](diagnosticreport.html): The code for the report, as opposed to codes for the atomic results, which are the names on the observation resource referred to from the result
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a condition code
    /// * [List](list.html): What the purpose of this list is
    /// * [Medication](medication.html): Returns medications for a specific code
    /// * [MedicationAdministration](medicationadministration.html): Return administrations of this medication code
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine code
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions of this medication code
    /// * [MedicationStatement](medicationstatement.html): Return statements of this medication code
    /// * [Observation](observation.html): The code of the observation type
    /// * [Procedure](procedure.html): A code to identify a  procedure
    /// * [ServiceRequest](servicerequest.html): What is being requested/ordered

    @Default([]) List<SearchParamToken> code,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [medication] Multiple Resources:

    /// * [MedicationAdministration](medicationadministration.html): Return administrations of this medication resource
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine resource
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions for this medication reference
    /// * [MedicationStatement](medicationstatement.html): Return statements of this medication reference

    @Default([]) List<SearchParamReference> medication,

    /// [status] Multiple Resources:

    /// * [MedicationAdministration](medicationadministration.html): MedicationAdministration event status (for example one of active/paused/completed/nullified)
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with a specified dispense status
    /// * [MedicationRequest](medicationrequest.html): Status of the prescription
    /// * [MedicationStatement](medicationstatement.html): Return statements that match the given status

    @Default([]) List<SearchParamToken> status,

    /// [authoredon] Return prescriptions written on this date
    @Default([]) List<SearchParamDate> authoredon,

    /// [category] Returns prescriptions with different categories
    @Default([]) List<SearchParamToken> category,

    /// [date] Multiple Resources:

    /// * [MedicationRequest](medicationrequest.html): Returns medication request to be administered on a specific date

    @Default([]) List<SearchParamDate> date,

    /// [encounter] Multiple Resources:

    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this encounter identifier

    @Default([]) List<SearchParamReference> encounter,

    /// [intendedDispenser] Returns prescriptions intended to be dispensed by this Organization
    @Default([])
    @JsonKey(name: 'intended-dispenser')
        List<SearchParamReference> intendedDispenser,

    /// [intendedPerformer] Returns the intended performer of the administration of the medication request
    @Default([])
    @JsonKey(name: 'intended-performer')
        List<SearchParamReference> intendedPerformer,

    /// [intendedPerformertype] Returns requests for a specific type of performer
    @Default([])
    @JsonKey(name: 'intended-performertype')
        List<SearchParamToken> intendedPerformertype,

    /// [intent] Returns prescriptions with different intents
    @Default([]) List<SearchParamToken> intent,

    /// [priority] Returns prescriptions with different priorities
    @Default([]) List<SearchParamToken> priority,

    /// [requester] Returns prescriptions prescribed by this prescriber
    @Default([]) List<SearchParamReference> requester,

    /// [subject] The identity of a patient to list orders  for
    @Default([]) List<SearchParamReference> subject,
  }) = _MedicationRequestSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (medication.isNotEmpty) {
      medication.forEach(
          (element) => returnStrings.add('medication${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (authoredon.isNotEmpty) {
      authoredon.forEach(
          (element) => returnStrings.add('authoredon${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (intendedDispenser.isNotEmpty) {
      intendedDispenser.forEach((element) =>
          returnStrings.add('intended-dispenser${element.toRequest()}'));
    }
    if (intendedPerformer.isNotEmpty) {
      intendedPerformer.forEach((element) =>
          returnStrings.add('intended-performer${element.toRequest()}'));
    }
    if (intendedPerformertype.isNotEmpty) {
      intendedPerformertype.forEach((element) =>
          returnStrings.add('intended-performertype${element.toRequest()}'));
    }
    if (intent.isNotEmpty) {
      intent.forEach(
          (element) => returnStrings.add('intent${element.toRequest()}'));
    }
    if (priority.isNotEmpty) {
      priority.forEach(
          (element) => returnStrings.add('priority${element.toRequest()}'));
    }
    if (requester.isNotEmpty) {
      requester.forEach(
          (element) => returnStrings.add('requester${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class MedicationStatementSearchParams with _$MedicationStatementSearchParams {
  const MedicationStatementSearchParams._();
  const factory MedicationStatementSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [code] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Code that identifies the allergy or intolerance
    /// * [Condition](condition.html): Code for the condition
    /// * [DeviceRequest](devicerequest.html): Code for what is being requested/ordered
    /// * [DiagnosticReport](diagnosticreport.html): The code for the report, as opposed to codes for the atomic results, which are the names on the observation resource referred to from the result
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a condition code
    /// * [List](list.html): What the purpose of this list is
    /// * [Medication](medication.html): Returns medications for a specific code
    /// * [MedicationAdministration](medicationadministration.html): Return administrations of this medication code
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine code
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions of this medication code
    /// * [MedicationStatement](medicationstatement.html): Return statements of this medication code
    /// * [Observation](observation.html): The code of the observation type
    /// * [Procedure](procedure.html): A code to identify a  procedure
    /// * [ServiceRequest](servicerequest.html): What is being requested/ordered

    @Default([]) List<SearchParamToken> code,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [medication] Multiple Resources:

    /// * [MedicationAdministration](medicationadministration.html): Return administrations of this medication resource
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine resource
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions for this medication reference
    /// * [MedicationStatement](medicationstatement.html): Return statements of this medication reference

    @Default([]) List<SearchParamReference> medication,

    /// [status] Multiple Resources:

    /// * [MedicationAdministration](medicationadministration.html): MedicationAdministration event status (for example one of active/paused/completed/nullified)
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with a specified dispense status
    /// * [MedicationRequest](medicationrequest.html): Status of the prescription
    /// * [MedicationStatement](medicationstatement.html): Return statements that match the given status

    @Default([]) List<SearchParamToken> status,

    /// [category] Returns statements of this category of medicationstatement
    @Default([]) List<SearchParamToken> category,

    /// [context] Returns statements for a specific context (episode or episode of Care).
    @Default([]) List<SearchParamReference> context,

    /// [effective] Date when patient was taking (or not taking) the medication
    @Default([]) List<SearchParamDate> effective,

    /// [partOf] Returns statements that are part of another event.
    @Default([]) @JsonKey(name: 'part-of') List<SearchParamReference> partOf,

    /// [source] Who or where the information in the statement came from
    @Default([]) List<SearchParamReference> source,

    /// [subject] The identity of a patient, animal or group to list statements for
    @Default([]) List<SearchParamReference> subject,
  }) = _MedicationStatementSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (medication.isNotEmpty) {
      medication.forEach(
          (element) => returnStrings.add('medication${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (effective.isNotEmpty) {
      effective.forEach(
          (element) => returnStrings.add('effective${element.toRequest()}'));
    }
    if (partOf.isNotEmpty) {
      partOf.forEach(
          (element) => returnStrings.add('part-of${element.toRequest()}'));
    }
    if (source.isNotEmpty) {
      source.forEach(
          (element) => returnStrings.add('source${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ObservationSearchParams with _$ObservationSearchParams {
  const ObservationSearchParams._();
  const factory ObservationSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [code] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Code that identifies the allergy or intolerance
    /// * [Condition](condition.html): Code for the condition
    /// * [DeviceRequest](devicerequest.html): Code for what is being requested/ordered
    /// * [DiagnosticReport](diagnosticreport.html): The code for the report, as opposed to codes for the atomic results, which are the names on the observation resource referred to from the result
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a condition code
    /// * [List](list.html): What the purpose of this list is
    /// * [Medication](medication.html): Returns medications for a specific code
    /// * [MedicationAdministration](medicationadministration.html): Return administrations of this medication code
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine code
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions of this medication code
    /// * [MedicationStatement](medicationstatement.html): Return statements of this medication code
    /// * [Observation](observation.html): The code of the observation type
    /// * [Procedure](procedure.html): A code to identify a  procedure
    /// * [ServiceRequest](servicerequest.html): What is being requested/ordered

    @Default([]) List<SearchParamToken> code,

    /// [date] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Date first version of the resource instance was recorded
    /// * [CarePlan](careplan.html): Time period plan covers
    /// * [CareTeam](careteam.html): Time period team covers
    /// * [ClinicalImpression](clinicalimpression.html): When the assessment was documented
    /// * [Composition](composition.html): Composition editing time
    /// * [Consent](consent.html): When this Consent was created or indexed
    /// * [DiagnosticReport](diagnosticreport.html): The clinically relevant time of the report
    /// * [Encounter](encounter.html): A date within the period the Encounter lasted
    /// * [EpisodeOfCare](episodeofcare.html): The provided date search value falls within the episode of care's period
    /// * [FamilyMemberHistory](familymemberhistory.html): When history was recorded or last updated
    /// * [Flag](flag.html): Time period when flag is active
    /// * [Immunization](immunization.html): Vaccination  (non)-Administration Date
    /// * [List](list.html): When the list was prepared
    /// * [Observation](observation.html): Obtained date/time. If the obtained element is a period, a date that falls in the period
    /// * [Procedure](procedure.html): When the procedure was performed
    /// * [RiskAssessment](riskassessment.html): When was assessment made?
    /// * [SupplyRequest](supplyrequest.html): When the request was made

    @Default([]) List<SearchParamDate> date,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [encounter] Multiple Resources:

    /// * [Composition](composition.html): Context of the Composition
    /// * [DeviceRequest](devicerequest.html): Encounter during which request was created
    /// * [DiagnosticReport](diagnosticreport.html): The Encounter when the order was made
    /// * [DocumentReference](documentreference.html): Context of the document  content
    /// * [Flag](flag.html): Alert relevant during encounter
    /// * [List](list.html): Context in which list created
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this encounter identifier
    /// * [Observation](observation.html): Encounter related to the observation
    /// * [Procedure](procedure.html): Encounter created as part of
    /// * [RiskAssessment](riskassessment.html): Where was assessment performed?
    /// * [ServiceRequest](servicerequest.html): An encounter in which this request is made
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this encounter identifier

    @Default([]) List<SearchParamReference> encounter,

    /// [basedOn] Reference to the service request.
    @Default([]) @JsonKey(name: 'based-on') List<SearchParamReference> basedOn,

    /// [category] The classification of the type of observation
    @Default([]) List<SearchParamToken> category,

    /// [comboCode] The code of the observation type or component type
    @Default([]) @JsonKey(name: 'combo-code') List<SearchParamToken> comboCode,

    /// [comboDataAbsentReason] The reason why the expected value in the element Observation.value[x] or Observation.component.value[x] is missing.
    @Default([])
    @JsonKey(name: 'combo-data-absent-reason')
        List<SearchParamToken> comboDataAbsentReason,

    /// [comboValueConcept] The value or component value of the observation, if the value is a CodeableConcept
    @Default([])
    @JsonKey(name: 'combo-value-concept')
        List<SearchParamToken> comboValueConcept,

    /// [comboValueQuantity] The value or component value of the observation, if the value is a Quantity, or a SampledData (just search on the bounds of the values in sampled data)
    @Default([])
    @JsonKey(name: 'combo-value-quantity')
        List<SearchParamQuantity> comboValueQuantity,

    /// [componentCode] The component code of the observation type
    @Default([])
    @JsonKey(name: 'component-code')
        List<SearchParamToken> componentCode,

    /// [componentDataAbsentReason] The reason why the expected value in the element Observation.component.value[x] is missing.
    @Default([])
    @JsonKey(name: 'component-data-absent-reason')
        List<SearchParamToken> componentDataAbsentReason,

    /// [componentValueConcept] The value of the component observation, if the value is a CodeableConcept
    @Default([])
    @JsonKey(name: 'component-value-concept')
        List<SearchParamToken> componentValueConcept,

    /// [componentValueQuantity] The value of the component observation, if the value is a Quantity, or a SampledData (just search on the bounds of the values in sampled data)
    @Default([])
    @JsonKey(name: 'component-value-quantity')
        List<SearchParamQuantity> componentValueQuantity,

    /// [dataAbsentReason] The reason why the expected value in the element Observation.value[x] is missing.
    @Default([])
    @JsonKey(name: 'data-absent-reason')
        List<SearchParamToken> dataAbsentReason,

    /// [derivedFrom] Related measurements the observation is made from
    @Default([])
    @JsonKey(name: 'derived-from')
        List<SearchParamReference> derivedFrom,

    /// [device] The Device that generated the observation data.
    @Default([]) List<SearchParamReference> device,

    /// [focus] The focus of an observation when the focus is not the patient of record.
    @Default([]) List<SearchParamReference> focus,

    /// [hasMember] Related resource that belongs to the Observation group
    @Default([])
    @JsonKey(name: 'has-member')
        List<SearchParamReference> hasMember,

    /// [method] The method used for the observation
    @Default([]) List<SearchParamToken> method,

    /// [partOf] Part of referenced event
    @Default([]) @JsonKey(name: 'part-of') List<SearchParamReference> partOf,

    /// [performer] Who performed the observation
    @Default([]) List<SearchParamReference> performer,

    /// [specimen] Specimen used for this observation
    @Default([]) List<SearchParamReference> specimen,

    /// [status] The status of the observation
    @Default([]) List<SearchParamToken> status,

    /// [subject] The subject that the observation is about
    @Default([]) List<SearchParamReference> subject,

    /// [valueConcept] The value of the observation, if the value is a CodeableConcept
    @Default([])
    @JsonKey(name: 'value-concept')
        List<SearchParamToken> valueConcept,

    /// [valueDate] The value of the observation, if the value is a date or period of time
    @Default([]) @JsonKey(name: 'value-date') List<SearchParamDate> valueDate,

    /// [valueQuantity] The value of the observation, if the value is a Quantity, or a SampledData (just search on the bounds of the values in sampled data)
    @Default([])
    @JsonKey(name: 'value-quantity')
        List<SearchParamQuantity> valueQuantity,

    /// [valueString] The value of the observation, if the value is a string, and also searches in CodeableConcept.text
    @Default([])
    @JsonKey(name: 'value-string')
        List<SearchParamString> valueString,

    /// [codeValueConcept] Code and coded value parameter pair
    @Default([])
    @JsonKey(name: 'code-value-concept')
        List<SearchParamComposite> codeValueConcept,

    /// [codeValueDate] Code and date/time value parameter pair
    @Default([])
    @JsonKey(name: 'code-value-date')
        List<SearchParamComposite> codeValueDate,

    /// [codeValueQuantity] Code and quantity value parameter pair
    @Default([])
    @JsonKey(name: 'code-value-quantity')
        List<SearchParamComposite> codeValueQuantity,

    /// [codeValueString] Code and string value parameter pair
    @Default([])
    @JsonKey(name: 'code-value-string')
        List<SearchParamComposite> codeValueString,

    /// [comboCodeValueConcept] Code and coded value parameter pair, including in components
    @Default([])
    @JsonKey(name: 'combo-code-value-concept')
        List<SearchParamComposite> comboCodeValueConcept,

    /// [comboCodeValueQuantity] Code and quantity value parameter pair, including in components
    @Default([])
    @JsonKey(name: 'combo-code-value-quantity')
        List<SearchParamComposite> comboCodeValueQuantity,

    /// [componentCodeValueConcept] Component code and component coded value parameter pair
    @Default([])
    @JsonKey(name: 'component-code-value-concept')
        List<SearchParamComposite> componentCodeValueConcept,

    /// [componentCodeValueQuantity] Component code and component quantity value parameter pair
    @Default([])
    @JsonKey(name: 'component-code-value-quantity')
        List<SearchParamComposite> componentCodeValueQuantity,
  }) = _ObservationSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (basedOn.isNotEmpty) {
      basedOn.forEach(
          (element) => returnStrings.add('based-on${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (comboCode.isNotEmpty) {
      comboCode.forEach(
          (element) => returnStrings.add('combo-code${element.toRequest()}'));
    }
    if (comboDataAbsentReason.isNotEmpty) {
      comboDataAbsentReason.forEach((element) =>
          returnStrings.add('combo-data-absent-reason${element.toRequest()}'));
    }
    if (comboValueConcept.isNotEmpty) {
      comboValueConcept.forEach((element) =>
          returnStrings.add('combo-value-concept${element.toRequest()}'));
    }
    if (comboValueQuantity.isNotEmpty) {
      comboValueQuantity.forEach((element) =>
          returnStrings.add('combo-value-quantity${element.toRequest()}'));
    }
    if (componentCode.isNotEmpty) {
      componentCode.forEach((element) =>
          returnStrings.add('component-code${element.toRequest()}'));
    }
    if (componentDataAbsentReason.isNotEmpty) {
      componentDataAbsentReason.forEach((element) => returnStrings
          .add('component-data-absent-reason${element.toRequest()}'));
    }
    if (componentValueConcept.isNotEmpty) {
      componentValueConcept.forEach((element) =>
          returnStrings.add('component-value-concept${element.toRequest()}'));
    }
    if (componentValueQuantity.isNotEmpty) {
      componentValueQuantity.forEach((element) =>
          returnStrings.add('component-value-quantity${element.toRequest()}'));
    }
    if (dataAbsentReason.isNotEmpty) {
      dataAbsentReason.forEach((element) =>
          returnStrings.add('data-absent-reason${element.toRequest()}'));
    }
    if (derivedFrom.isNotEmpty) {
      derivedFrom.forEach(
          (element) => returnStrings.add('derived-from${element.toRequest()}'));
    }
    if (device.isNotEmpty) {
      device.forEach(
          (element) => returnStrings.add('device${element.toRequest()}'));
    }
    if (focus.isNotEmpty) {
      focus.forEach(
          (element) => returnStrings.add('focus${element.toRequest()}'));
    }
    if (hasMember.isNotEmpty) {
      hasMember.forEach(
          (element) => returnStrings.add('has-member${element.toRequest()}'));
    }
    if (method.isNotEmpty) {
      method.forEach(
          (element) => returnStrings.add('method${element.toRequest()}'));
    }
    if (partOf.isNotEmpty) {
      partOf.forEach(
          (element) => returnStrings.add('part-of${element.toRequest()}'));
    }
    if (performer.isNotEmpty) {
      performer.forEach(
          (element) => returnStrings.add('performer${element.toRequest()}'));
    }
    if (specimen.isNotEmpty) {
      specimen.forEach(
          (element) => returnStrings.add('specimen${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    if (valueConcept.isNotEmpty) {
      valueConcept.forEach((element) =>
          returnStrings.add('value-concept${element.toRequest()}'));
    }
    if (valueDate.isNotEmpty) {
      valueDate.forEach(
          (element) => returnStrings.add('value-date${element.toRequest()}'));
    }
    if (valueQuantity.isNotEmpty) {
      valueQuantity.forEach((element) =>
          returnStrings.add('value-quantity${element.toRequest()}'));
    }
    if (valueString.isNotEmpty) {
      valueString.forEach(
          (element) => returnStrings.add('value-string${element.toRequest()}'));
    }
    if (codeValueConcept.isNotEmpty) {
      codeValueConcept.forEach((element) =>
          returnStrings.add('code-value-concept${element.toRequest()}'));
    }
    if (codeValueDate.isNotEmpty) {
      codeValueDate.forEach((element) =>
          returnStrings.add('code-value-date${element.toRequest()}'));
    }
    if (codeValueQuantity.isNotEmpty) {
      codeValueQuantity.forEach((element) =>
          returnStrings.add('code-value-quantity${element.toRequest()}'));
    }
    if (codeValueString.isNotEmpty) {
      codeValueString.forEach((element) =>
          returnStrings.add('code-value-string${element.toRequest()}'));
    }
    if (comboCodeValueConcept.isNotEmpty) {
      comboCodeValueConcept.forEach((element) =>
          returnStrings.add('combo-code-value-concept${element.toRequest()}'));
    }
    if (comboCodeValueQuantity.isNotEmpty) {
      comboCodeValueQuantity.forEach((element) =>
          returnStrings.add('combo-code-value-quantity${element.toRequest()}'));
    }
    if (componentCodeValueConcept.isNotEmpty) {
      componentCodeValueConcept.forEach((element) => returnStrings
          .add('component-code-value-concept${element.toRequest()}'));
    }
    if (componentCodeValueQuantity.isNotEmpty) {
      componentCodeValueQuantity.forEach((element) => returnStrings
          .add('component-code-value-quantity${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ProcedureSearchParams with _$ProcedureSearchParams {
  const ProcedureSearchParams._();
  const factory ProcedureSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [code] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Code that identifies the allergy or intolerance
    /// * [Condition](condition.html): Code for the condition
    /// * [DeviceRequest](devicerequest.html): Code for what is being requested/ordered
    /// * [DiagnosticReport](diagnosticreport.html): The code for the report, as opposed to codes for the atomic results, which are the names on the observation resource referred to from the result
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a condition code
    /// * [List](list.html): What the purpose of this list is
    /// * [Medication](medication.html): Returns medications for a specific code
    /// * [MedicationAdministration](medicationadministration.html): Return administrations of this medication code
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine code
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions of this medication code
    /// * [MedicationStatement](medicationstatement.html): Return statements of this medication code
    /// * [Observation](observation.html): The code of the observation type
    /// * [Procedure](procedure.html): A code to identify a  procedure
    /// * [ServiceRequest](servicerequest.html): What is being requested/ordered

    @Default([]) List<SearchParamToken> code,

    /// [date] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Date first version of the resource instance was recorded
    /// * [CarePlan](careplan.html): Time period plan covers
    /// * [CareTeam](careteam.html): Time period team covers
    /// * [ClinicalImpression](clinicalimpression.html): When the assessment was documented
    /// * [Composition](composition.html): Composition editing time
    /// * [Consent](consent.html): When this Consent was created or indexed
    /// * [DiagnosticReport](diagnosticreport.html): The clinically relevant time of the report
    /// * [Encounter](encounter.html): A date within the period the Encounter lasted
    /// * [EpisodeOfCare](episodeofcare.html): The provided date search value falls within the episode of care's period
    /// * [FamilyMemberHistory](familymemberhistory.html): When history was recorded or last updated
    /// * [Flag](flag.html): Time period when flag is active
    /// * [Immunization](immunization.html): Vaccination  (non)-Administration Date
    /// * [List](list.html): When the list was prepared
    /// * [Observation](observation.html): Obtained date/time. If the obtained element is a period, a date that falls in the period
    /// * [Procedure](procedure.html): When the procedure was performed
    /// * [RiskAssessment](riskassessment.html): When was assessment made?
    /// * [SupplyRequest](supplyrequest.html): When the request was made

    @Default([]) List<SearchParamDate> date,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [encounter] Multiple Resources:

    /// * [Composition](composition.html): Context of the Composition
    /// * [DeviceRequest](devicerequest.html): Encounter during which request was created
    /// * [DiagnosticReport](diagnosticreport.html): The Encounter when the order was made
    /// * [DocumentReference](documentreference.html): Context of the document  content
    /// * [Flag](flag.html): Alert relevant during encounter
    /// * [List](list.html): Context in which list created
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this encounter identifier
    /// * [Observation](observation.html): Encounter related to the observation
    /// * [Procedure](procedure.html): Encounter created as part of
    /// * [RiskAssessment](riskassessment.html): Where was assessment performed?
    /// * [ServiceRequest](servicerequest.html): An encounter in which this request is made
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this encounter identifier

    @Default([]) List<SearchParamReference> encounter,

    /// [basedOn] A request for this procedure
    @Default([]) @JsonKey(name: 'based-on') List<SearchParamReference> basedOn,

    /// [category] Classification of the procedure
    @Default([]) List<SearchParamToken> category,

    /// [instantiatesCanonical] Instantiates FHIR protocol or definition
    @Default([])
    @JsonKey(name: 'instantiates-canonical')
        List<SearchParamReference> instantiatesCanonical,

    /// [instantiatesUri] Instantiates external protocol or definition
    @Default([])
    @JsonKey(name: 'instantiates-uri')
        List<SearchParamUri> instantiatesUri,

    /// [location] Where the procedure happened
    @Default([]) List<SearchParamReference> location,

    /// [partOf] Part of referenced event
    @Default([]) @JsonKey(name: 'part-of') List<SearchParamReference> partOf,

    /// [performer] The reference to the practitioner
    @Default([]) List<SearchParamReference> performer,

    /// [reasonCode] Coded reason procedure performed
    @Default([])
    @JsonKey(name: 'reason-code')
        List<SearchParamToken> reasonCode,

    /// [reasonReference] The justification that the procedure was performed
    @Default([])
    @JsonKey(name: 'reason-reference')
        List<SearchParamReference> reasonReference,

    /// [status] preparation | in-progress | not-done | on-hold | stopped | completed | entered-in-error | unknown
    @Default([]) List<SearchParamToken> status,

    /// [subject] Search by subject
    @Default([]) List<SearchParamReference> subject,
  }) = _ProcedureSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (basedOn.isNotEmpty) {
      basedOn.forEach(
          (element) => returnStrings.add('based-on${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (instantiatesCanonical.isNotEmpty) {
      instantiatesCanonical.forEach((element) =>
          returnStrings.add('instantiates-canonical${element.toRequest()}'));
    }
    if (instantiatesUri.isNotEmpty) {
      instantiatesUri.forEach((element) =>
          returnStrings.add('instantiates-uri${element.toRequest()}'));
    }
    if (location.isNotEmpty) {
      location.forEach(
          (element) => returnStrings.add('location${element.toRequest()}'));
    }
    if (partOf.isNotEmpty) {
      partOf.forEach(
          (element) => returnStrings.add('part-of${element.toRequest()}'));
    }
    if (performer.isNotEmpty) {
      performer.forEach(
          (element) => returnStrings.add('performer${element.toRequest()}'));
    }
    if (reasonCode.isNotEmpty) {
      reasonCode.forEach(
          (element) => returnStrings.add('reason-code${element.toRequest()}'));
    }
    if (reasonReference.isNotEmpty) {
      reasonReference.forEach((element) =>
          returnStrings.add('reason-reference${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ServiceRequestSearchParams with _$ServiceRequestSearchParams {
  const ServiceRequestSearchParams._();
  const factory ServiceRequestSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [code] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Code that identifies the allergy or intolerance
    /// * [Condition](condition.html): Code for the condition
    /// * [DeviceRequest](devicerequest.html): Code for what is being requested/ordered
    /// * [DiagnosticReport](diagnosticreport.html): The code for the report, as opposed to codes for the atomic results, which are the names on the observation resource referred to from the result
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a condition code
    /// * [List](list.html): What the purpose of this list is
    /// * [Medication](medication.html): Returns medications for a specific code
    /// * [MedicationAdministration](medicationadministration.html): Return administrations of this medication code
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine code
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions of this medication code
    /// * [MedicationStatement](medicationstatement.html): Return statements of this medication code
    /// * [Observation](observation.html): The code of the observation type
    /// * [Procedure](procedure.html): A code to identify a  procedure
    /// * [ServiceRequest](servicerequest.html): What is being requested/ordered

    @Default([]) List<SearchParamToken> code,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [encounter] Multiple Resources:

    /// * [Composition](composition.html): Context of the Composition
    /// * [DeviceRequest](devicerequest.html): Encounter during which request was created
    /// * [DiagnosticReport](diagnosticreport.html): The Encounter when the order was made
    /// * [DocumentReference](documentreference.html): Context of the document  content
    /// * [Flag](flag.html): Alert relevant during encounter
    /// * [List](list.html): Context in which list created
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this encounter identifier
    /// * [Observation](observation.html): Encounter related to the observation
    /// * [Procedure](procedure.html): Encounter created as part of
    /// * [RiskAssessment](riskassessment.html): Where was assessment performed?
    /// * [ServiceRequest](servicerequest.html): An encounter in which this request is made
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this encounter identifier

    @Default([]) List<SearchParamReference> encounter,

    /// [authored] Date request signed
    @Default([]) List<SearchParamDate> authored,

    /// [basedOn] What request fulfills
    @Default([]) @JsonKey(name: 'based-on') List<SearchParamReference> basedOn,

    /// [bodySite] Where procedure is going to be done
    @Default([]) @JsonKey(name: 'body-site') List<SearchParamToken> bodySite,

    /// [category] Classification of service
    @Default([]) List<SearchParamToken> category,

    /// [instantiatesCanonical] Instantiates FHIR protocol or definition
    @Default([])
    @JsonKey(name: 'instantiates-canonical')
        List<SearchParamReference> instantiatesCanonical,

    /// [instantiatesUri] Instantiates external protocol or definition
    @Default([])
    @JsonKey(name: 'instantiates-uri')
        List<SearchParamUri> instantiatesUri,

    /// [intent] proposal | plan | directive | order | original-order | reflex-order | filler-order | instance-order | option
    @Default([]) List<SearchParamToken> intent,

    /// [occurrence] When service should occur
    @Default([]) List<SearchParamDate> occurrence,

    /// [performer] Requested performer
    @Default([]) List<SearchParamReference> performer,

    /// [performerType] Performer role
    @Default([])
    @JsonKey(name: 'performer-type')
        List<SearchParamToken> performerType,

    /// [priority] routine | urgent | asap | stat
    @Default([]) List<SearchParamToken> priority,

    /// [replaces] What request replaces
    @Default([]) List<SearchParamReference> replaces,

    /// [requester] Who/what is requesting service
    @Default([]) List<SearchParamReference> requester,

    /// [requisition] Composite Request ID
    @Default([]) List<SearchParamToken> requisition,

    /// [specimen] Specimen to be tested
    @Default([]) List<SearchParamReference> specimen,

    /// [status] draft | active | on-hold | revoked | completed | entered-in-error | unknown
    @Default([]) List<SearchParamToken> status,

    /// [subject] Search by subject
    @Default([]) List<SearchParamReference> subject,
  }) = _ServiceRequestSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (authored.isNotEmpty) {
      authored.forEach(
          (element) => returnStrings.add('authored${element.toRequest()}'));
    }
    if (basedOn.isNotEmpty) {
      basedOn.forEach(
          (element) => returnStrings.add('based-on${element.toRequest()}'));
    }
    if (bodySite.isNotEmpty) {
      bodySite.forEach(
          (element) => returnStrings.add('body-site${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (instantiatesCanonical.isNotEmpty) {
      instantiatesCanonical.forEach((element) =>
          returnStrings.add('instantiates-canonical${element.toRequest()}'));
    }
    if (instantiatesUri.isNotEmpty) {
      instantiatesUri.forEach((element) =>
          returnStrings.add('instantiates-uri${element.toRequest()}'));
    }
    if (intent.isNotEmpty) {
      intent.forEach(
          (element) => returnStrings.add('intent${element.toRequest()}'));
    }
    if (occurrence.isNotEmpty) {
      occurrence.forEach(
          (element) => returnStrings.add('occurrence${element.toRequest()}'));
    }
    if (performer.isNotEmpty) {
      performer.forEach(
          (element) => returnStrings.add('performer${element.toRequest()}'));
    }
    if (performerType.isNotEmpty) {
      performerType.forEach((element) =>
          returnStrings.add('performer-type${element.toRequest()}'));
    }
    if (priority.isNotEmpty) {
      priority.forEach(
          (element) => returnStrings.add('priority${element.toRequest()}'));
    }
    if (replaces.isNotEmpty) {
      replaces.forEach(
          (element) => returnStrings.add('replaces${element.toRequest()}'));
    }
    if (requester.isNotEmpty) {
      requester.forEach(
          (element) => returnStrings.add('requester${element.toRequest()}'));
    }
    if (requisition.isNotEmpty) {
      requisition.forEach(
          (element) => returnStrings.add('requisition${element.toRequest()}'));
    }
    if (specimen.isNotEmpty) {
      specimen.forEach(
          (element) => returnStrings.add('specimen${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class CarePlanSearchParams with _$CarePlanSearchParams {
  const CarePlanSearchParams._();
  const factory CarePlanSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [date] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Date first version of the resource instance was recorded
    /// * [CarePlan](careplan.html): Time period plan covers
    /// * [CareTeam](careteam.html): Time period team covers
    /// * [ClinicalImpression](clinicalimpression.html): When the assessment was documented
    /// * [Composition](composition.html): Composition editing time
    /// * [Consent](consent.html): When this Consent was created or indexed
    /// * [DiagnosticReport](diagnosticreport.html): The clinically relevant time of the report
    /// * [Encounter](encounter.html): A date within the period the Encounter lasted
    /// * [EpisodeOfCare](episodeofcare.html): The provided date search value falls within the episode of care's period
    /// * [FamilyMemberHistory](familymemberhistory.html): When history was recorded or last updated
    /// * [Flag](flag.html): Time period when flag is active
    /// * [Immunization](immunization.html): Vaccination  (non)-Administration Date
    /// * [List](list.html): When the list was prepared
    /// * [Observation](observation.html): Obtained date/time. If the obtained element is a period, a date that falls in the period
    /// * [Procedure](procedure.html): When the procedure was performed
    /// * [RiskAssessment](riskassessment.html): When was assessment made?
    /// * [SupplyRequest](supplyrequest.html): When the request was made

    @Default([]) List<SearchParamDate> date,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [activityCode] Detail type of activity
    @Default([])
    @JsonKey(name: 'activity-code')
        List<SearchParamToken> activityCode,

    /// [activityDate] Specified date occurs within period specified by CarePlan.activity.detail.scheduled[x]
    @Default([])
    @JsonKey(name: 'activity-date')
        List<SearchParamDate> activityDate,

    /// [activityReference] Activity details defined in specific resource
    @Default([])
    @JsonKey(name: 'activity-reference')
        List<SearchParamReference> activityReference,

    /// [basedOn] Fulfills CarePlan
    @Default([]) @JsonKey(name: 'based-on') List<SearchParamReference> basedOn,

    /// [careTeam] Who's involved in plan?
    @Default([])
    @JsonKey(name: 'care-team')
        List<SearchParamReference> careTeam,

    /// [category] Type of plan
    @Default([]) List<SearchParamToken> category,

    /// [condition] Health issues this plan addresses
    @Default([]) List<SearchParamReference> condition,

    /// [encounter] Encounter created as part of
    @Default([]) List<SearchParamReference> encounter,

    /// [goal] Desired outcome of plan
    @Default([]) List<SearchParamReference> goal,

    /// [instantiatesCanonical] Instantiates FHIR protocol or definition
    @Default([])
    @JsonKey(name: 'instantiates-canonical')
        List<SearchParamReference> instantiatesCanonical,

    /// [instantiatesUri] Instantiates external protocol or definition
    @Default([])
    @JsonKey(name: 'instantiates-uri')
        List<SearchParamUri> instantiatesUri,

    /// [intent] proposal | plan | order | option
    @Default([]) List<SearchParamToken> intent,

    /// [partOf] Part of referenced CarePlan
    @Default([]) @JsonKey(name: 'part-of') List<SearchParamReference> partOf,

    /// [performer] Matches if the practitioner is listed as a performer in any of the "simple" activities.  (For performers of the detailed activities, chain through the activitydetail search parameter.)
    @Default([]) List<SearchParamReference> performer,

    /// [replaces] CarePlan replaced by this CarePlan
    @Default([]) List<SearchParamReference> replaces,

    /// [status] draft | active | on-hold | revoked | completed | entered-in-error | unknown
    @Default([]) List<SearchParamToken> status,

    /// [subject] Who the care plan is for
    @Default([]) List<SearchParamReference> subject,
  }) = _CarePlanSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (activityCode.isNotEmpty) {
      activityCode.forEach((element) =>
          returnStrings.add('activity-code${element.toRequest()}'));
    }
    if (activityDate.isNotEmpty) {
      activityDate.forEach((element) =>
          returnStrings.add('activity-date${element.toRequest()}'));
    }
    if (activityReference.isNotEmpty) {
      activityReference.forEach((element) =>
          returnStrings.add('activity-reference${element.toRequest()}'));
    }
    if (basedOn.isNotEmpty) {
      basedOn.forEach(
          (element) => returnStrings.add('based-on${element.toRequest()}'));
    }
    if (careTeam.isNotEmpty) {
      careTeam.forEach(
          (element) => returnStrings.add('care-team${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (condition.isNotEmpty) {
      condition.forEach(
          (element) => returnStrings.add('condition${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (goal.isNotEmpty) {
      goal.forEach(
          (element) => returnStrings.add('goal${element.toRequest()}'));
    }
    if (instantiatesCanonical.isNotEmpty) {
      instantiatesCanonical.forEach((element) =>
          returnStrings.add('instantiates-canonical${element.toRequest()}'));
    }
    if (instantiatesUri.isNotEmpty) {
      instantiatesUri.forEach((element) =>
          returnStrings.add('instantiates-uri${element.toRequest()}'));
    }
    if (intent.isNotEmpty) {
      intent.forEach(
          (element) => returnStrings.add('intent${element.toRequest()}'));
    }
    if (partOf.isNotEmpty) {
      partOf.forEach(
          (element) => returnStrings.add('part-of${element.toRequest()}'));
    }
    if (performer.isNotEmpty) {
      performer.forEach(
          (element) => returnStrings.add('performer${element.toRequest()}'));
    }
    if (replaces.isNotEmpty) {
      replaces.forEach(
          (element) => returnStrings.add('replaces${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class CareTeamSearchParams with _$CareTeamSearchParams {
  const CareTeamSearchParams._();
  const factory CareTeamSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [date] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Date first version of the resource instance was recorded
    /// * [CarePlan](careplan.html): Time period plan covers
    /// * [CareTeam](careteam.html): Time period team covers
    /// * [ClinicalImpression](clinicalimpression.html): When the assessment was documented
    /// * [Composition](composition.html): Composition editing time
    /// * [Consent](consent.html): When this Consent was created or indexed
    /// * [DiagnosticReport](diagnosticreport.html): The clinically relevant time of the report
    /// * [Encounter](encounter.html): A date within the period the Encounter lasted
    /// * [EpisodeOfCare](episodeofcare.html): The provided date search value falls within the episode of care's period
    /// * [FamilyMemberHistory](familymemberhistory.html): When history was recorded or last updated
    /// * [Flag](flag.html): Time period when flag is active
    /// * [Immunization](immunization.html): Vaccination  (non)-Administration Date
    /// * [List](list.html): When the list was prepared
    /// * [Observation](observation.html): Obtained date/time. If the obtained element is a period, a date that falls in the period
    /// * [Procedure](procedure.html): When the procedure was performed
    /// * [RiskAssessment](riskassessment.html): When was assessment made?
    /// * [SupplyRequest](supplyrequest.html): When the request was made

    @Default([]) List<SearchParamDate> date,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [category] Type of team
    @Default([]) List<SearchParamToken> category,

    /// [encounter] Encounter created as part of
    @Default([]) List<SearchParamReference> encounter,

    /// [participant] Who is involved
    @Default([]) List<SearchParamReference> participant,

    /// [status] proposed | active | suspended | inactive | entered-in-error
    @Default([]) List<SearchParamToken> status,

    /// [subject] Who care team is for
    @Default([]) List<SearchParamReference> subject,
  }) = _CareTeamSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (participant.isNotEmpty) {
      participant.forEach(
          (element) => returnStrings.add('participant${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ClinicalImpressionSearchParams with _$ClinicalImpressionSearchParams {
  const ClinicalImpressionSearchParams._();
  const factory ClinicalImpressionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [date] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Date first version of the resource instance was recorded
    /// * [CarePlan](careplan.html): Time period plan covers
    /// * [CareTeam](careteam.html): Time period team covers
    /// * [ClinicalImpression](clinicalimpression.html): When the assessment was documented
    /// * [Composition](composition.html): Composition editing time
    /// * [Consent](consent.html): When this Consent was created or indexed
    /// * [DiagnosticReport](diagnosticreport.html): The clinically relevant time of the report
    /// * [Encounter](encounter.html): A date within the period the Encounter lasted
    /// * [EpisodeOfCare](episodeofcare.html): The provided date search value falls within the episode of care's period
    /// * [FamilyMemberHistory](familymemberhistory.html): When history was recorded or last updated
    /// * [Flag](flag.html): Time period when flag is active
    /// * [Immunization](immunization.html): Vaccination  (non)-Administration Date
    /// * [List](list.html): When the list was prepared
    /// * [Observation](observation.html): Obtained date/time. If the obtained element is a period, a date that falls in the period
    /// * [Procedure](procedure.html): When the procedure was performed
    /// * [RiskAssessment](riskassessment.html): When was assessment made?
    /// * [SupplyRequest](supplyrequest.html): When the request was made

    @Default([]) List<SearchParamDate> date,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [assessor] The clinician performing the assessment
    @Default([]) List<SearchParamReference> assessor,

    /// [encounter] Encounter created as part of
    @Default([]) List<SearchParamReference> encounter,

    /// [findingCode] What was found
    @Default([])
    @JsonKey(name: 'finding-code')
        List<SearchParamToken> findingCode,

    /// [findingRef] What was found
    @Default([])
    @JsonKey(name: 'finding-ref')
        List<SearchParamReference> findingRef,

    /// [identifier] Business identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [investigation] Record of a specific investigation
    @Default([]) List<SearchParamReference> investigation,

    /// [previous] Reference to last assessment
    @Default([]) List<SearchParamReference> previous,

    /// [problem] Relevant impressions of patient state
    @Default([]) List<SearchParamReference> problem,

    /// [status] in-progress | completed | entered-in-error
    @Default([]) List<SearchParamToken> status,

    /// [subject] Patient or group assessed
    @Default([]) List<SearchParamReference> subject,

    /// [supportingInfo] Information supporting the clinical impression
    @Default([])
    @JsonKey(name: 'supporting-info')
        List<SearchParamReference> supportingInfo,
  }) = _ClinicalImpressionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (assessor.isNotEmpty) {
      assessor.forEach(
          (element) => returnStrings.add('assessor${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (findingCode.isNotEmpty) {
      findingCode.forEach(
          (element) => returnStrings.add('finding-code${element.toRequest()}'));
    }
    if (findingRef.isNotEmpty) {
      findingRef.forEach(
          (element) => returnStrings.add('finding-ref${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (investigation.isNotEmpty) {
      investigation.forEach((element) =>
          returnStrings.add('investigation${element.toRequest()}'));
    }
    if (previous.isNotEmpty) {
      previous.forEach(
          (element) => returnStrings.add('previous${element.toRequest()}'));
    }
    if (problem.isNotEmpty) {
      problem.forEach(
          (element) => returnStrings.add('problem${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    if (supportingInfo.isNotEmpty) {
      supportingInfo.forEach((element) =>
          returnStrings.add('supporting-info${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class CompositionSearchParams with _$CompositionSearchParams {
  const CompositionSearchParams._();
  const factory CompositionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [date] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Date first version of the resource instance was recorded
    /// * [CarePlan](careplan.html): Time period plan covers
    /// * [CareTeam](careteam.html): Time period team covers
    /// * [ClinicalImpression](clinicalimpression.html): When the assessment was documented
    /// * [Composition](composition.html): Composition editing time
    /// * [Consent](consent.html): When this Consent was created or indexed
    /// * [DiagnosticReport](diagnosticreport.html): The clinically relevant time of the report
    /// * [Encounter](encounter.html): A date within the period the Encounter lasted
    /// * [EpisodeOfCare](episodeofcare.html): The provided date search value falls within the episode of care's period
    /// * [FamilyMemberHistory](familymemberhistory.html): When history was recorded or last updated
    /// * [Flag](flag.html): Time period when flag is active
    /// * [Immunization](immunization.html): Vaccination  (non)-Administration Date
    /// * [List](list.html): When the list was prepared
    /// * [Observation](observation.html): Obtained date/time. If the obtained element is a period, a date that falls in the period
    /// * [Procedure](procedure.html): When the procedure was performed
    /// * [RiskAssessment](riskassessment.html): When was assessment made?
    /// * [SupplyRequest](supplyrequest.html): When the request was made

    @Default([]) List<SearchParamDate> date,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [type] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): allergy | intolerance - Underlying mechanism (if known)
    /// * [Composition](composition.html): Kind of composition (LOINC if possible)
    /// * [DocumentManifest](documentmanifest.html): Kind of document set
    /// * [DocumentReference](documentreference.html): Kind of document (LOINC if possible)
    /// * [Encounter](encounter.html): Specific type of encounter
    /// * [EpisodeOfCare](episodeofcare.html): Type/class  - e.g. specialist referral, disease management

    @Default([]) List<SearchParamToken> type,

    /// [attester] Who attested the composition
    @Default([]) List<SearchParamReference> attester,

    /// [author] Who and/or what authored the composition
    @Default([]) List<SearchParamReference> author,

    /// [category] Categorization of Composition
    @Default([]) List<SearchParamToken> category,

    /// [confidentiality] As defined by affinity domain
    @Default([]) List<SearchParamToken> confidentiality,

    /// [context] Code(s) that apply to the event being documented
    @Default([]) List<SearchParamToken> context,

    /// [encounter] Multiple Resources:

    /// * [Composition](composition.html): Context of the Composition
    /// * [DeviceRequest](devicerequest.html): Encounter during which request was created
    /// * [DiagnosticReport](diagnosticreport.html): The Encounter when the order was made
    /// * [DocumentReference](documentreference.html): Context of the document  content
    /// * [Flag](flag.html): Alert relevant during encounter
    /// * [List](list.html): Context in which list created
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this encounter identifier
    /// * [Observation](observation.html): Encounter related to the observation
    /// * [Procedure](procedure.html): Encounter created as part of
    /// * [RiskAssessment](riskassessment.html): Where was assessment performed?
    /// * [ServiceRequest](servicerequest.html): An encounter in which this request is made
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this encounter identifier

    @Default([]) List<SearchParamReference> encounter,

    /// [entry] A reference to data that supports this section
    @Default([]) List<SearchParamReference> entry,

    /// [period] The period covered by the documentation
    @Default([]) List<SearchParamDate> period,

    /// [relatedId] Target of the relationship
    @Default([]) @JsonKey(name: 'related-id') List<SearchParamToken> relatedId,

    /// [relatedRef] Target of the relationship
    @Default([])
    @JsonKey(name: 'related-ref')
        List<SearchParamReference> relatedRef,

    /// [section] Classification of section (recommended)
    @Default([]) List<SearchParamToken> section,

    /// [status] preliminary | final | amended | entered-in-error
    @Default([]) List<SearchParamToken> status,

    /// [subject] Who and/or what the composition is about
    @Default([]) List<SearchParamReference> subject,

    /// [title] Human Readable name/title
    @Default([]) List<SearchParamString> title,
  }) = _CompositionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    if (attester.isNotEmpty) {
      attester.forEach(
          (element) => returnStrings.add('attester${element.toRequest()}'));
    }
    if (author.isNotEmpty) {
      author.forEach(
          (element) => returnStrings.add('author${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (confidentiality.isNotEmpty) {
      confidentiality.forEach((element) =>
          returnStrings.add('confidentiality${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (entry.isNotEmpty) {
      entry.forEach(
          (element) => returnStrings.add('entry${element.toRequest()}'));
    }
    if (period.isNotEmpty) {
      period.forEach(
          (element) => returnStrings.add('period${element.toRequest()}'));
    }
    if (relatedId.isNotEmpty) {
      relatedId.forEach(
          (element) => returnStrings.add('related-id${element.toRequest()}'));
    }
    if (relatedRef.isNotEmpty) {
      relatedRef.forEach(
          (element) => returnStrings.add('related-ref${element.toRequest()}'));
    }
    if (section.isNotEmpty) {
      section.forEach(
          (element) => returnStrings.add('section${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ConsentSearchParams with _$ConsentSearchParams {
  const ConsentSearchParams._();
  const factory ConsentSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [date] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Date first version of the resource instance was recorded
    /// * [CarePlan](careplan.html): Time period plan covers
    /// * [CareTeam](careteam.html): Time period team covers
    /// * [ClinicalImpression](clinicalimpression.html): When the assessment was documented
    /// * [Composition](composition.html): Composition editing time
    /// * [Consent](consent.html): When this Consent was created or indexed
    /// * [DiagnosticReport](diagnosticreport.html): The clinically relevant time of the report
    /// * [Encounter](encounter.html): A date within the period the Encounter lasted
    /// * [EpisodeOfCare](episodeofcare.html): The provided date search value falls within the episode of care's period
    /// * [FamilyMemberHistory](familymemberhistory.html): When history was recorded or last updated
    /// * [Flag](flag.html): Time period when flag is active
    /// * [Immunization](immunization.html): Vaccination  (non)-Administration Date
    /// * [List](list.html): When the list was prepared
    /// * [Observation](observation.html): Obtained date/time. If the obtained element is a period, a date that falls in the period
    /// * [Procedure](procedure.html): When the procedure was performed
    /// * [RiskAssessment](riskassessment.html): When was assessment made?
    /// * [SupplyRequest](supplyrequest.html): When the request was made

    @Default([]) List<SearchParamDate> date,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [action] Actions controlled by this rule
    @Default([]) List<SearchParamToken> action,

    /// [actor] Resource for the actor (or group, by role)
    @Default([]) List<SearchParamReference> actor,

    /// [category] Classification of the consent statement - for indexing/retrieval
    @Default([]) List<SearchParamToken> category,

    /// [consentor] Who is agreeing to the policy and rules
    @Default([]) List<SearchParamReference> consentor,

    /// [data] The actual data reference
    @Default([]) List<SearchParamReference> data,

    /// [organization] Custodian of the consent
    @Default([]) List<SearchParamReference> organization,

    /// [period] Timeframe for this rule
    @Default([]) List<SearchParamDate> period,

    /// [purpose] Context of activities covered by this rule
    @Default([]) List<SearchParamToken> purpose,

    /// [scope] Which of the four areas this resource covers (extensible)
    @Default([]) List<SearchParamToken> scope,

    /// [securityLabel] Security Labels that define affected resources
    @Default([])
    @JsonKey(name: 'security-label')
        List<SearchParamToken> securityLabel,

    /// [sourceReference] Search by reference to a Consent, DocumentReference, Contract  or QuestionnaireResponse
    @Default([])
    @JsonKey(name: 'source-reference')
        List<SearchParamReference> sourceReference,

    /// [status] draft | proposed | active | rejected | inactive | entered-in-error
    @Default([]) List<SearchParamToken> status,
  }) = _ConsentSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (action.isNotEmpty) {
      action.forEach(
          (element) => returnStrings.add('action${element.toRequest()}'));
    }
    if (actor.isNotEmpty) {
      actor.forEach(
          (element) => returnStrings.add('actor${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (consentor.isNotEmpty) {
      consentor.forEach(
          (element) => returnStrings.add('consentor${element.toRequest()}'));
    }
    if (data.isNotEmpty) {
      data.forEach(
          (element) => returnStrings.add('data${element.toRequest()}'));
    }
    if (organization.isNotEmpty) {
      organization.forEach(
          (element) => returnStrings.add('organization${element.toRequest()}'));
    }
    if (period.isNotEmpty) {
      period.forEach(
          (element) => returnStrings.add('period${element.toRequest()}'));
    }
    if (purpose.isNotEmpty) {
      purpose.forEach(
          (element) => returnStrings.add('purpose${element.toRequest()}'));
    }
    if (scope.isNotEmpty) {
      scope.forEach(
          (element) => returnStrings.add('scope${element.toRequest()}'));
    }
    if (securityLabel.isNotEmpty) {
      securityLabel.forEach((element) =>
          returnStrings.add('security-label${element.toRequest()}'));
    }
    if (sourceReference.isNotEmpty) {
      sourceReference.forEach((element) =>
          returnStrings.add('source-reference${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class EncounterSearchParams with _$EncounterSearchParams {
  const EncounterSearchParams._();
  const factory EncounterSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [date] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Date first version of the resource instance was recorded
    /// * [CarePlan](careplan.html): Time period plan covers
    /// * [CareTeam](careteam.html): Time period team covers
    /// * [ClinicalImpression](clinicalimpression.html): When the assessment was documented
    /// * [Composition](composition.html): Composition editing time
    /// * [Consent](consent.html): When this Consent was created or indexed
    /// * [DiagnosticReport](diagnosticreport.html): The clinically relevant time of the report
    /// * [Encounter](encounter.html): A date within the period the Encounter lasted
    /// * [EpisodeOfCare](episodeofcare.html): The provided date search value falls within the episode of care's period
    /// * [FamilyMemberHistory](familymemberhistory.html): When history was recorded or last updated
    /// * [Flag](flag.html): Time period when flag is active
    /// * [Immunization](immunization.html): Vaccination  (non)-Administration Date
    /// * [List](list.html): When the list was prepared
    /// * [Observation](observation.html): Obtained date/time. If the obtained element is a period, a date that falls in the period
    /// * [Procedure](procedure.html): When the procedure was performed
    /// * [RiskAssessment](riskassessment.html): When was assessment made?
    /// * [SupplyRequest](supplyrequest.html): When the request was made

    @Default([]) List<SearchParamDate> date,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [type] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): allergy | intolerance - Underlying mechanism (if known)
    /// * [Composition](composition.html): Kind of composition (LOINC if possible)
    /// * [DocumentManifest](documentmanifest.html): Kind of document set
    /// * [DocumentReference](documentreference.html): Kind of document (LOINC if possible)
    /// * [Encounter](encounter.html): Specific type of encounter
    /// * [EpisodeOfCare](episodeofcare.html): Type/class  - e.g. specialist referral, disease management

    @Default([]) List<SearchParamToken> type,

    /// [account] The set of accounts that may be used for billing for this Encounter
    @Default([]) List<SearchParamReference> account,

    /// [appointment] The appointment that scheduled this encounter
    @Default([]) List<SearchParamReference> appointment,

    /// [basedOn] The ServiceRequest that initiated this encounter
    @Default([]) @JsonKey(name: 'based-on') List<SearchParamReference> basedOn,

    /// [class_] Classification of patient encounter
    @Default([]) @JsonKey(name: 'class') List<SearchParamToken> class_,

    /// [diagnosis] The diagnosis or procedure relevant to the encounter
    @Default([]) List<SearchParamReference> diagnosis,

    /// [episodeOfCare] Episode(s) of care that this encounter should be recorded against
    @Default([])
    @JsonKey(name: 'episode-of-care')
        List<SearchParamReference> episodeOfCare,

    /// [length] Length of encounter in days
    @Default([]) List<SearchParamQuantity> length,

    /// [location] Location the encounter takes place
    @Default([]) List<SearchParamReference> location,

    /// [locationPeriod] Time period during which the patient was present at the location
    @Default([])
    @JsonKey(name: 'location-period')
        List<SearchParamDate> locationPeriod,

    /// [partOf] Another Encounter this encounter is part of
    @Default([]) @JsonKey(name: 'part-of') List<SearchParamReference> partOf,

    /// [participant] Persons involved in the encounter other than the patient
    @Default([]) List<SearchParamReference> participant,

    /// [participantType] Role of participant in encounter
    @Default([])
    @JsonKey(name: 'participant-type')
        List<SearchParamToken> participantType,

    /// [practitioner] Persons involved in the encounter other than the patient
    @Default([]) List<SearchParamReference> practitioner,

    /// [reasonCode] Coded reason the encounter takes place
    @Default([])
    @JsonKey(name: 'reason-code')
        List<SearchParamToken> reasonCode,

    /// [reasonReference] Reason the encounter takes place (reference)
    @Default([])
    @JsonKey(name: 'reason-reference')
        List<SearchParamReference> reasonReference,

    /// [serviceProvider] The organization (facility) responsible for this encounter
    @Default([])
    @JsonKey(name: 'service-provider')
        List<SearchParamReference> serviceProvider,

    /// [specialArrangement] Wheelchair, translator, stretcher, etc.
    @Default([])
    @JsonKey(name: 'special-arrangement')
        List<SearchParamToken> specialArrangement,

    /// [status] planned | arrived | triaged | in-progress | onleave | finished | cancelled +
    @Default([]) List<SearchParamToken> status,

    /// [subject] The patient or group present at the encounter
    @Default([]) List<SearchParamReference> subject,
  }) = _EncounterSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    if (account.isNotEmpty) {
      account.forEach(
          (element) => returnStrings.add('account${element.toRequest()}'));
    }
    if (appointment.isNotEmpty) {
      appointment.forEach(
          (element) => returnStrings.add('appointment${element.toRequest()}'));
    }
    if (basedOn.isNotEmpty) {
      basedOn.forEach(
          (element) => returnStrings.add('based-on${element.toRequest()}'));
    }
    if (class_.isNotEmpty) {
      class_.forEach(
          (element) => returnStrings.add('class${element.toRequest()}'));
    }
    if (diagnosis.isNotEmpty) {
      diagnosis.forEach(
          (element) => returnStrings.add('diagnosis${element.toRequest()}'));
    }
    if (episodeOfCare.isNotEmpty) {
      episodeOfCare.forEach((element) =>
          returnStrings.add('episode-of-care${element.toRequest()}'));
    }
    if (length.isNotEmpty) {
      length.forEach(
          (element) => returnStrings.add('length${element.toRequest()}'));
    }
    if (location.isNotEmpty) {
      location.forEach(
          (element) => returnStrings.add('location${element.toRequest()}'));
    }
    if (locationPeriod.isNotEmpty) {
      locationPeriod.forEach((element) =>
          returnStrings.add('location-period${element.toRequest()}'));
    }
    if (partOf.isNotEmpty) {
      partOf.forEach(
          (element) => returnStrings.add('part-of${element.toRequest()}'));
    }
    if (participant.isNotEmpty) {
      participant.forEach(
          (element) => returnStrings.add('participant${element.toRequest()}'));
    }
    if (participantType.isNotEmpty) {
      participantType.forEach((element) =>
          returnStrings.add('participant-type${element.toRequest()}'));
    }
    if (practitioner.isNotEmpty) {
      practitioner.forEach(
          (element) => returnStrings.add('practitioner${element.toRequest()}'));
    }
    if (reasonCode.isNotEmpty) {
      reasonCode.forEach(
          (element) => returnStrings.add('reason-code${element.toRequest()}'));
    }
    if (reasonReference.isNotEmpty) {
      reasonReference.forEach((element) =>
          returnStrings.add('reason-reference${element.toRequest()}'));
    }
    if (serviceProvider.isNotEmpty) {
      serviceProvider.forEach((element) =>
          returnStrings.add('service-provider${element.toRequest()}'));
    }
    if (specialArrangement.isNotEmpty) {
      specialArrangement.forEach((element) =>
          returnStrings.add('special-arrangement${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class EpisodeOfCareSearchParams with _$EpisodeOfCareSearchParams {
  const EpisodeOfCareSearchParams._();
  const factory EpisodeOfCareSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [date] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Date first version of the resource instance was recorded
    /// * [CarePlan](careplan.html): Time period plan covers
    /// * [CareTeam](careteam.html): Time period team covers
    /// * [ClinicalImpression](clinicalimpression.html): When the assessment was documented
    /// * [Composition](composition.html): Composition editing time
    /// * [Consent](consent.html): When this Consent was created or indexed
    /// * [DiagnosticReport](diagnosticreport.html): The clinically relevant time of the report
    /// * [Encounter](encounter.html): A date within the period the Encounter lasted
    /// * [EpisodeOfCare](episodeofcare.html): The provided date search value falls within the episode of care's period
    /// * [FamilyMemberHistory](familymemberhistory.html): When history was recorded or last updated
    /// * [Flag](flag.html): Time period when flag is active
    /// * [Immunization](immunization.html): Vaccination  (non)-Administration Date
    /// * [List](list.html): When the list was prepared
    /// * [Observation](observation.html): Obtained date/time. If the obtained element is a period, a date that falls in the period
    /// * [Procedure](procedure.html): When the procedure was performed
    /// * [RiskAssessment](riskassessment.html): When was assessment made?
    /// * [SupplyRequest](supplyrequest.html): When the request was made

    @Default([]) List<SearchParamDate> date,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [type] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): allergy | intolerance - Underlying mechanism (if known)
    /// * [Composition](composition.html): Kind of composition (LOINC if possible)
    /// * [DocumentManifest](documentmanifest.html): Kind of document set
    /// * [DocumentReference](documentreference.html): Kind of document (LOINC if possible)
    /// * [Encounter](encounter.html): Specific type of encounter
    /// * [EpisodeOfCare](episodeofcare.html): Type/class  - e.g. specialist referral, disease management

    @Default([]) List<SearchParamToken> type,

    /// [careManager] Care manager/care coordinator for the patient
    @Default([])
    @JsonKey(name: 'care-manager')
        List<SearchParamReference> careManager,

    /// [condition] Conditions/problems/diagnoses this episode of care is for
    @Default([]) List<SearchParamReference> condition,

    /// [incomingReferral] Incoming Referral Request
    @Default([])
    @JsonKey(name: 'incoming-referral')
        List<SearchParamReference> incomingReferral,

    /// [organization] The organization that has assumed the specific responsibilities of this EpisodeOfCare
    @Default([]) List<SearchParamReference> organization,

    /// [status] The current status of the Episode of Care as provided (does not check the status history collection)
    @Default([]) List<SearchParamToken> status,
  }) = _EpisodeOfCareSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    if (careManager.isNotEmpty) {
      careManager.forEach(
          (element) => returnStrings.add('care-manager${element.toRequest()}'));
    }
    if (condition.isNotEmpty) {
      condition.forEach(
          (element) => returnStrings.add('condition${element.toRequest()}'));
    }
    if (incomingReferral.isNotEmpty) {
      incomingReferral.forEach((element) =>
          returnStrings.add('incoming-referral${element.toRequest()}'));
    }
    if (organization.isNotEmpty) {
      organization.forEach(
          (element) => returnStrings.add('organization${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class FlagSearchParams with _$FlagSearchParams {
  const FlagSearchParams._();
  const factory FlagSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [date] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Date first version of the resource instance was recorded
    /// * [CarePlan](careplan.html): Time period plan covers
    /// * [CareTeam](careteam.html): Time period team covers
    /// * [ClinicalImpression](clinicalimpression.html): When the assessment was documented
    /// * [Composition](composition.html): Composition editing time
    /// * [Consent](consent.html): When this Consent was created or indexed
    /// * [DiagnosticReport](diagnosticreport.html): The clinically relevant time of the report
    /// * [Encounter](encounter.html): A date within the period the Encounter lasted
    /// * [EpisodeOfCare](episodeofcare.html): The provided date search value falls within the episode of care's period
    /// * [FamilyMemberHistory](familymemberhistory.html): When history was recorded or last updated
    /// * [Flag](flag.html): Time period when flag is active
    /// * [Immunization](immunization.html): Vaccination  (non)-Administration Date
    /// * [List](list.html): When the list was prepared
    /// * [Observation](observation.html): Obtained date/time. If the obtained element is a period, a date that falls in the period
    /// * [Procedure](procedure.html): When the procedure was performed
    /// * [RiskAssessment](riskassessment.html): When was assessment made?
    /// * [SupplyRequest](supplyrequest.html): When the request was made

    @Default([]) List<SearchParamDate> date,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [encounter] Multiple Resources:

    /// * [Composition](composition.html): Context of the Composition
    /// * [DeviceRequest](devicerequest.html): Encounter during which request was created
    /// * [DiagnosticReport](diagnosticreport.html): The Encounter when the order was made
    /// * [DocumentReference](documentreference.html): Context of the document  content
    /// * [Flag](flag.html): Alert relevant during encounter
    /// * [List](list.html): Context in which list created
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this encounter identifier
    /// * [Observation](observation.html): Encounter related to the observation
    /// * [Procedure](procedure.html): Encounter created as part of
    /// * [RiskAssessment](riskassessment.html): Where was assessment performed?
    /// * [ServiceRequest](servicerequest.html): An encounter in which this request is made
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this encounter identifier

    @Default([]) List<SearchParamReference> encounter,

    /// [author] Flag creator
    @Default([]) List<SearchParamReference> author,

    /// [identifier] Business identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [subject] The identity of a subject to list flags for
    @Default([]) List<SearchParamReference> subject,
  }) = _FlagSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (author.isNotEmpty) {
      author.forEach(
          (element) => returnStrings.add('author${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ImmunizationSearchParams with _$ImmunizationSearchParams {
  const ImmunizationSearchParams._();
  const factory ImmunizationSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [date] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Date first version of the resource instance was recorded
    /// * [CarePlan](careplan.html): Time period plan covers
    /// * [CareTeam](careteam.html): Time period team covers
    /// * [ClinicalImpression](clinicalimpression.html): When the assessment was documented
    /// * [Composition](composition.html): Composition editing time
    /// * [Consent](consent.html): When this Consent was created or indexed
    /// * [DiagnosticReport](diagnosticreport.html): The clinically relevant time of the report
    /// * [Encounter](encounter.html): A date within the period the Encounter lasted
    /// * [EpisodeOfCare](episodeofcare.html): The provided date search value falls within the episode of care's period
    /// * [FamilyMemberHistory](familymemberhistory.html): When history was recorded or last updated
    /// * [Flag](flag.html): Time period when flag is active
    /// * [Immunization](immunization.html): Vaccination  (non)-Administration Date
    /// * [List](list.html): When the list was prepared
    /// * [Observation](observation.html): Obtained date/time. If the obtained element is a period, a date that falls in the period
    /// * [Procedure](procedure.html): When the procedure was performed
    /// * [RiskAssessment](riskassessment.html): When was assessment made?
    /// * [SupplyRequest](supplyrequest.html): When the request was made

    @Default([]) List<SearchParamDate> date,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [location] The service delivery location or facility in which the vaccine was / was to be administered
    @Default([]) List<SearchParamReference> location,

    /// [lotNumber] Vaccine Lot Number
    @Default([]) @JsonKey(name: 'lot-number') List<SearchParamString> lotNumber,

    /// [manufacturer] Vaccine Manufacturer
    @Default([]) List<SearchParamReference> manufacturer,

    /// [performer] The practitioner or organization who played a role in the vaccination
    @Default([]) List<SearchParamReference> performer,

    /// [reaction] Additional information on reaction
    @Default([]) List<SearchParamReference> reaction,

    /// [reactionDate] When reaction started
    @Default([])
    @JsonKey(name: 'reaction-date')
        List<SearchParamDate> reactionDate,

    /// [reasonCode] Reason why the vaccine was administered
    @Default([])
    @JsonKey(name: 'reason-code')
        List<SearchParamToken> reasonCode,

    /// [reasonReference] Why immunization occurred
    @Default([])
    @JsonKey(name: 'reason-reference')
        List<SearchParamReference> reasonReference,

    /// [series] The series being followed by the provider
    @Default([]) List<SearchParamString> series,

    /// [status] Immunization event status
    @Default([]) List<SearchParamToken> status,

    /// [statusReason] Reason why the vaccine was not administered
    @Default([])
    @JsonKey(name: 'status-reason')
        List<SearchParamToken> statusReason,

    /// [targetDisease] The target disease the dose is being administered against
    @Default([])
    @JsonKey(name: 'target-disease')
        List<SearchParamToken> targetDisease,

    /// [vaccineCode] Vaccine Product Administered
    @Default([])
    @JsonKey(name: 'vaccine-code')
        List<SearchParamToken> vaccineCode,
  }) = _ImmunizationSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (location.isNotEmpty) {
      location.forEach(
          (element) => returnStrings.add('location${element.toRequest()}'));
    }
    if (lotNumber.isNotEmpty) {
      lotNumber.forEach(
          (element) => returnStrings.add('lot-number${element.toRequest()}'));
    }
    if (manufacturer.isNotEmpty) {
      manufacturer.forEach(
          (element) => returnStrings.add('manufacturer${element.toRequest()}'));
    }
    if (performer.isNotEmpty) {
      performer.forEach(
          (element) => returnStrings.add('performer${element.toRequest()}'));
    }
    if (reaction.isNotEmpty) {
      reaction.forEach(
          (element) => returnStrings.add('reaction${element.toRequest()}'));
    }
    if (reactionDate.isNotEmpty) {
      reactionDate.forEach((element) =>
          returnStrings.add('reaction-date${element.toRequest()}'));
    }
    if (reasonCode.isNotEmpty) {
      reasonCode.forEach(
          (element) => returnStrings.add('reason-code${element.toRequest()}'));
    }
    if (reasonReference.isNotEmpty) {
      reasonReference.forEach((element) =>
          returnStrings.add('reason-reference${element.toRequest()}'));
    }
    if (series.isNotEmpty) {
      series.forEach(
          (element) => returnStrings.add('series${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (statusReason.isNotEmpty) {
      statusReason.forEach((element) =>
          returnStrings.add('status-reason${element.toRequest()}'));
    }
    if (targetDisease.isNotEmpty) {
      targetDisease.forEach((element) =>
          returnStrings.add('target-disease${element.toRequest()}'));
    }
    if (vaccineCode.isNotEmpty) {
      vaccineCode.forEach(
          (element) => returnStrings.add('vaccine-code${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class RiskAssessmentSearchParams with _$RiskAssessmentSearchParams {
  const RiskAssessmentSearchParams._();
  const factory RiskAssessmentSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [date] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Date first version of the resource instance was recorded
    /// * [CarePlan](careplan.html): Time period plan covers
    /// * [CareTeam](careteam.html): Time period team covers
    /// * [ClinicalImpression](clinicalimpression.html): When the assessment was documented
    /// * [Composition](composition.html): Composition editing time
    /// * [Consent](consent.html): When this Consent was created or indexed
    /// * [DiagnosticReport](diagnosticreport.html): The clinically relevant time of the report
    /// * [Encounter](encounter.html): A date within the period the Encounter lasted
    /// * [EpisodeOfCare](episodeofcare.html): The provided date search value falls within the episode of care's period
    /// * [FamilyMemberHistory](familymemberhistory.html): When history was recorded or last updated
    /// * [Flag](flag.html): Time period when flag is active
    /// * [Immunization](immunization.html): Vaccination  (non)-Administration Date
    /// * [List](list.html): When the list was prepared
    /// * [Observation](observation.html): Obtained date/time. If the obtained element is a period, a date that falls in the period
    /// * [Procedure](procedure.html): When the procedure was performed
    /// * [RiskAssessment](riskassessment.html): When was assessment made?
    /// * [SupplyRequest](supplyrequest.html): When the request was made

    @Default([]) List<SearchParamDate> date,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [encounter] Multiple Resources:

    /// * [Composition](composition.html): Context of the Composition
    /// * [DeviceRequest](devicerequest.html): Encounter during which request was created
    /// * [DiagnosticReport](diagnosticreport.html): The Encounter when the order was made
    /// * [DocumentReference](documentreference.html): Context of the document  content
    /// * [Flag](flag.html): Alert relevant during encounter
    /// * [List](list.html): Context in which list created
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this encounter identifier
    /// * [Observation](observation.html): Encounter related to the observation
    /// * [Procedure](procedure.html): Encounter created as part of
    /// * [RiskAssessment](riskassessment.html): Where was assessment performed?
    /// * [ServiceRequest](servicerequest.html): An encounter in which this request is made
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this encounter identifier

    @Default([]) List<SearchParamReference> encounter,

    /// [condition] Condition assessed
    @Default([]) List<SearchParamReference> condition,

    /// [method] Evaluation mechanism
    @Default([]) List<SearchParamToken> method,

    /// [performer] Who did assessment?
    @Default([]) List<SearchParamReference> performer,

    /// [probability] Likelihood of specified outcome
    @Default([]) List<SearchParamNumber> probability,

    /// [risk] Likelihood of specified outcome as a qualitative value
    @Default([]) List<SearchParamToken> risk,

    /// [subject] Who/what does assessment apply to?
    @Default([]) List<SearchParamReference> subject,
  }) = _RiskAssessmentSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (condition.isNotEmpty) {
      condition.forEach(
          (element) => returnStrings.add('condition${element.toRequest()}'));
    }
    if (method.isNotEmpty) {
      method.forEach(
          (element) => returnStrings.add('method${element.toRequest()}'));
    }
    if (performer.isNotEmpty) {
      performer.forEach(
          (element) => returnStrings.add('performer${element.toRequest()}'));
    }
    if (probability.isNotEmpty) {
      probability.forEach(
          (element) => returnStrings.add('probability${element.toRequest()}'));
    }
    if (risk.isNotEmpty) {
      risk.forEach(
          (element) => returnStrings.add('risk${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class SupplyRequestSearchParams with _$SupplyRequestSearchParams {
  const SupplyRequestSearchParams._();
  const factory SupplyRequestSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [date] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Date first version of the resource instance was recorded
    /// * [CarePlan](careplan.html): Time period plan covers
    /// * [CareTeam](careteam.html): Time period team covers
    /// * [ClinicalImpression](clinicalimpression.html): When the assessment was documented
    /// * [Composition](composition.html): Composition editing time
    /// * [Consent](consent.html): When this Consent was created or indexed
    /// * [DiagnosticReport](diagnosticreport.html): The clinically relevant time of the report
    /// * [Encounter](encounter.html): A date within the period the Encounter lasted
    /// * [EpisodeOfCare](episodeofcare.html): The provided date search value falls within the episode of care's period
    /// * [FamilyMemberHistory](familymemberhistory.html): When history was recorded or last updated
    /// * [Flag](flag.html): Time period when flag is active
    /// * [Immunization](immunization.html): Vaccination  (non)-Administration Date
    /// * [List](list.html): When the list was prepared
    /// * [Observation](observation.html): Obtained date/time. If the obtained element is a period, a date that falls in the period
    /// * [Procedure](procedure.html): When the procedure was performed
    /// * [RiskAssessment](riskassessment.html): When was assessment made?
    /// * [SupplyRequest](supplyrequest.html): When the request was made

    @Default([]) List<SearchParamDate> date,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [category] The kind of supply (central, non-stock, etc.)
    @Default([]) List<SearchParamToken> category,

    /// [requester] Individual making the request
    @Default([]) List<SearchParamReference> requester,

    /// [status] draft | active | suspended +
    @Default([]) List<SearchParamToken> status,

    /// [subject] The destination of the supply
    @Default([]) List<SearchParamReference> subject,

    /// [supplier] Who is intended to fulfill the request
    @Default([]) List<SearchParamReference> supplier,
  }) = _SupplyRequestSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (requester.isNotEmpty) {
      requester.forEach(
          (element) => returnStrings.add('requester${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    if (supplier.isNotEmpty) {
      supplier.forEach(
          (element) => returnStrings.add('supplier${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class DetectedIssueSearchParams with _$DetectedIssueSearchParams {
  const DetectedIssueSearchParams._();
  const factory DetectedIssueSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [author] The provider or device that identified the issue
    @Default([]) List<SearchParamReference> author,

    /// [code] Issue Category, e.g. drug-drug, duplicate therapy, etc.
    @Default([]) List<SearchParamToken> code,

    /// [identified] When identified
    @Default([]) List<SearchParamDate> identified,

    /// [implicated] Problem resource
    @Default([]) List<SearchParamReference> implicated,
  }) = _DetectedIssueSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (author.isNotEmpty) {
      author.forEach(
          (element) => returnStrings.add('author${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (identified.isNotEmpty) {
      identified.forEach(
          (element) => returnStrings.add('identified${element.toRequest()}'));
    }
    if (implicated.isNotEmpty) {
      implicated.forEach(
          (element) => returnStrings.add('implicated${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class DocumentManifestSearchParams with _$DocumentManifestSearchParams {
  const DocumentManifestSearchParams._();
  const factory DocumentManifestSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [type] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): allergy | intolerance - Underlying mechanism (if known)
    /// * [Composition](composition.html): Kind of composition (LOINC if possible)
    /// * [DocumentManifest](documentmanifest.html): Kind of document set
    /// * [DocumentReference](documentreference.html): Kind of document (LOINC if possible)
    /// * [Encounter](encounter.html): Specific type of encounter
    /// * [EpisodeOfCare](episodeofcare.html): Type/class  - e.g. specialist referral, disease management

    @Default([]) List<SearchParamToken> type,

    /// [author] Who and/or what authored the DocumentManifest
    @Default([]) List<SearchParamReference> author,

    /// [created] When this document manifest created
    @Default([]) List<SearchParamDate> created,

    /// [description] Human-readable description (title)
    @Default([]) List<SearchParamString> description,

    /// [item] Items in manifest
    @Default([]) List<SearchParamReference> item,

    /// [recipient] Intended to get notified about this set of documents
    @Default([]) List<SearchParamReference> recipient,

    /// [relatedId] Identifiers of things that are related
    @Default([]) @JsonKey(name: 'related-id') List<SearchParamToken> relatedId,

    /// [relatedRef] Related Resource
    @Default([])
    @JsonKey(name: 'related-ref')
        List<SearchParamReference> relatedRef,

    /// [source] The source system/application/software
    @Default([]) List<SearchParamUri> source,

    /// [status] current | superseded | entered-in-error
    @Default([]) List<SearchParamToken> status,

    /// [subject] The subject of the set of documents
    @Default([]) List<SearchParamReference> subject,
  }) = _DocumentManifestSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    if (author.isNotEmpty) {
      author.forEach(
          (element) => returnStrings.add('author${element.toRequest()}'));
    }
    if (created.isNotEmpty) {
      created.forEach(
          (element) => returnStrings.add('created${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (item.isNotEmpty) {
      item.forEach(
          (element) => returnStrings.add('item${element.toRequest()}'));
    }
    if (recipient.isNotEmpty) {
      recipient.forEach(
          (element) => returnStrings.add('recipient${element.toRequest()}'));
    }
    if (relatedId.isNotEmpty) {
      relatedId.forEach(
          (element) => returnStrings.add('related-id${element.toRequest()}'));
    }
    if (relatedRef.isNotEmpty) {
      relatedRef.forEach(
          (element) => returnStrings.add('related-ref${element.toRequest()}'));
    }
    if (source.isNotEmpty) {
      source.forEach(
          (element) => returnStrings.add('source${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class DocumentReferenceSearchParams with _$DocumentReferenceSearchParams {
  const DocumentReferenceSearchParams._();
  const factory DocumentReferenceSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [type] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): allergy | intolerance - Underlying mechanism (if known)
    /// * [Composition](composition.html): Kind of composition (LOINC if possible)
    /// * [DocumentManifest](documentmanifest.html): Kind of document set
    /// * [DocumentReference](documentreference.html): Kind of document (LOINC if possible)
    /// * [Encounter](encounter.html): Specific type of encounter
    /// * [EpisodeOfCare](episodeofcare.html): Type/class  - e.g. specialist referral, disease management

    @Default([]) List<SearchParamToken> type,

    /// [encounter] Multiple Resources:

    /// * [Composition](composition.html): Context of the Composition
    /// * [DeviceRequest](devicerequest.html): Encounter during which request was created
    /// * [DiagnosticReport](diagnosticreport.html): The Encounter when the order was made
    /// * [DocumentReference](documentreference.html): Context of the document  content
    /// * [Flag](flag.html): Alert relevant during encounter
    /// * [List](list.html): Context in which list created
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this encounter identifier
    /// * [Observation](observation.html): Encounter related to the observation
    /// * [Procedure](procedure.html): Encounter created as part of
    /// * [RiskAssessment](riskassessment.html): Where was assessment performed?
    /// * [ServiceRequest](servicerequest.html): An encounter in which this request is made
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this encounter identifier

    @Default([]) List<SearchParamReference> encounter,

    /// [authenticator] Who/what authenticated the document
    @Default([]) List<SearchParamReference> authenticator,

    /// [author] Who and/or what authored the document
    @Default([]) List<SearchParamReference> author,

    /// [category] Categorization of document
    @Default([]) List<SearchParamToken> category,

    /// [contenttype] Mime type of the content, with charset etc.
    @Default([]) List<SearchParamToken> contenttype,

    /// [custodian] Organization which maintains the document
    @Default([]) List<SearchParamReference> custodian,

    /// [date] When this document reference was created
    @Default([]) List<SearchParamDate> date,

    /// [description] Human-readable description
    @Default([]) List<SearchParamString> description,

    /// [event] Main clinical acts documented
    @Default([]) List<SearchParamToken> event,

    /// [facility] Kind of facility where patient was seen
    @Default([]) List<SearchParamToken> facility,

    /// [format] Format/content rules for the document
    @Default([]) List<SearchParamToken> format,

    /// [language] Human language of the content (BCP-47)
    @Default([]) List<SearchParamToken> language,

    /// [location] Uri where the data can be found
    @Default([]) List<SearchParamUri> location,

    /// [period] Time of service that is being documented
    @Default([]) List<SearchParamDate> period,

    /// [related] Related identifiers or resources
    @Default([]) List<SearchParamReference> related,

    /// [relatesto] Target of the relationship
    @Default([]) List<SearchParamReference> relatesto,

    /// [relation] replaces | transforms | signs | appends
    @Default([]) List<SearchParamToken> relation,

    /// [securityLabel] Document security-tags
    @Default([])
    @JsonKey(name: 'security-label')
        List<SearchParamToken> securityLabel,

    /// [setting] Additional details about where the content was created (e.g. clinical specialty)
    @Default([]) List<SearchParamToken> setting,

    /// [status] current | superseded | entered-in-error
    @Default([]) List<SearchParamToken> status,

    /// [subject] Who/what is the subject of the document
    @Default([]) List<SearchParamReference> subject,

    /// [relationship] Combination of relation and relatesTo
    @Default([]) List<SearchParamComposite> relationship,
  }) = _DocumentReferenceSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (authenticator.isNotEmpty) {
      authenticator.forEach((element) =>
          returnStrings.add('authenticator${element.toRequest()}'));
    }
    if (author.isNotEmpty) {
      author.forEach(
          (element) => returnStrings.add('author${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (contenttype.isNotEmpty) {
      contenttype.forEach(
          (element) => returnStrings.add('contenttype${element.toRequest()}'));
    }
    if (custodian.isNotEmpty) {
      custodian.forEach(
          (element) => returnStrings.add('custodian${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (event.isNotEmpty) {
      event.forEach(
          (element) => returnStrings.add('event${element.toRequest()}'));
    }
    if (facility.isNotEmpty) {
      facility.forEach(
          (element) => returnStrings.add('facility${element.toRequest()}'));
    }
    if (format.isNotEmpty) {
      format.forEach(
          (element) => returnStrings.add('format${element.toRequest()}'));
    }
    if (language.isNotEmpty) {
      language.forEach(
          (element) => returnStrings.add('language${element.toRequest()}'));
    }
    if (location.isNotEmpty) {
      location.forEach(
          (element) => returnStrings.add('location${element.toRequest()}'));
    }
    if (period.isNotEmpty) {
      period.forEach(
          (element) => returnStrings.add('period${element.toRequest()}'));
    }
    if (related.isNotEmpty) {
      related.forEach(
          (element) => returnStrings.add('related${element.toRequest()}'));
    }
    if (relatesto.isNotEmpty) {
      relatesto.forEach(
          (element) => returnStrings.add('relatesto${element.toRequest()}'));
    }
    if (relation.isNotEmpty) {
      relation.forEach(
          (element) => returnStrings.add('relation${element.toRequest()}'));
    }
    if (securityLabel.isNotEmpty) {
      securityLabel.forEach((element) =>
          returnStrings.add('security-label${element.toRequest()}'));
    }
    if (setting.isNotEmpty) {
      setting.forEach(
          (element) => returnStrings.add('setting${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    if (relationship.isNotEmpty) {
      relationship.forEach(
          (element) => returnStrings.add('relationship${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class GoalSearchParams with _$GoalSearchParams {
  const GoalSearchParams._();
  const factory GoalSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [achievementStatus] in-progress | improving | worsening | no-change | achieved | sustaining | not-achieved | no-progress | not-attainable
    @Default([])
    @JsonKey(name: 'achievement-status')
        List<SearchParamToken> achievementStatus,

    /// [category] E.g. Treatment, dietary, behavioral, etc.
    @Default([]) List<SearchParamToken> category,

    /// [lifecycleStatus] proposed | planned | accepted | active | on-hold | completed | cancelled | entered-in-error | rejected
    @Default([])
    @JsonKey(name: 'lifecycle-status')
        List<SearchParamToken> lifecycleStatus,

    /// [startDate] When goal pursuit begins
    @Default([]) @JsonKey(name: 'start-date') List<SearchParamDate> startDate,

    /// [subject] Who this goal is intended for
    @Default([]) List<SearchParamReference> subject,

    /// [targetDate] Reach goal on or before
    @Default([]) @JsonKey(name: 'target-date') List<SearchParamDate> targetDate,
  }) = _GoalSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (achievementStatus.isNotEmpty) {
      achievementStatus.forEach((element) =>
          returnStrings.add('achievement-status${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (lifecycleStatus.isNotEmpty) {
      lifecycleStatus.forEach((element) =>
          returnStrings.add('lifecycle-status${element.toRequest()}'));
    }
    if (startDate.isNotEmpty) {
      startDate.forEach(
          (element) => returnStrings.add('start-date${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    if (targetDate.isNotEmpty) {
      targetDate.forEach(
          (element) => returnStrings.add('target-date${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ImagingStudySearchParams with _$ImagingStudySearchParams {
  const ImagingStudySearchParams._();
  const factory ImagingStudySearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [basedon] The order for the image
    @Default([]) List<SearchParamReference> basedon,

    /// [bodysite] The body site studied
    @Default([]) List<SearchParamToken> bodysite,

    /// [dicomClass] The type of the instance
    @Default([])
    @JsonKey(name: 'dicom-class')
        List<SearchParamToken> dicomClass,

    /// [encounter] The context of the study
    @Default([]) List<SearchParamReference> encounter,

    /// [endpoint] The endpoint for the study or series
    @Default([]) List<SearchParamReference> endpoint,

    /// [instance] SOP Instance UID for an instance
    @Default([]) List<SearchParamToken> instance,

    /// [interpreter] Who interpreted the images
    @Default([]) List<SearchParamReference> interpreter,

    /// [modality] The modality of the series
    @Default([]) List<SearchParamToken> modality,

    /// [performer] The person who performed the study
    @Default([]) List<SearchParamReference> performer,

    /// [reason] The reason for the study
    @Default([]) List<SearchParamToken> reason,

    /// [referrer] The referring physician
    @Default([]) List<SearchParamReference> referrer,

    /// [series] DICOM Series Instance UID for a series
    @Default([]) List<SearchParamToken> series,

    /// [started] When the study was started
    @Default([]) List<SearchParamDate> started,

    /// [status] The status of the study
    @Default([]) List<SearchParamToken> status,

    /// [subject] Who the study is about
    @Default([]) List<SearchParamReference> subject,
  }) = _ImagingStudySearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (basedon.isNotEmpty) {
      basedon.forEach(
          (element) => returnStrings.add('basedon${element.toRequest()}'));
    }
    if (bodysite.isNotEmpty) {
      bodysite.forEach(
          (element) => returnStrings.add('bodysite${element.toRequest()}'));
    }
    if (dicomClass.isNotEmpty) {
      dicomClass.forEach(
          (element) => returnStrings.add('dicom-class${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (endpoint.isNotEmpty) {
      endpoint.forEach(
          (element) => returnStrings.add('endpoint${element.toRequest()}'));
    }
    if (instance.isNotEmpty) {
      instance.forEach(
          (element) => returnStrings.add('instance${element.toRequest()}'));
    }
    if (interpreter.isNotEmpty) {
      interpreter.forEach(
          (element) => returnStrings.add('interpreter${element.toRequest()}'));
    }
    if (modality.isNotEmpty) {
      modality.forEach(
          (element) => returnStrings.add('modality${element.toRequest()}'));
    }
    if (performer.isNotEmpty) {
      performer.forEach(
          (element) => returnStrings.add('performer${element.toRequest()}'));
    }
    if (reason.isNotEmpty) {
      reason.forEach(
          (element) => returnStrings.add('reason${element.toRequest()}'));
    }
    if (referrer.isNotEmpty) {
      referrer.forEach(
          (element) => returnStrings.add('referrer${element.toRequest()}'));
    }
    if (series.isNotEmpty) {
      series.forEach(
          (element) => returnStrings.add('series${element.toRequest()}'));
    }
    if (started.isNotEmpty) {
      started.forEach(
          (element) => returnStrings.add('started${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class NutritionOrderSearchParams with _$NutritionOrderSearchParams {
  const NutritionOrderSearchParams._();
  const factory NutritionOrderSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [encounter] Multiple Resources:

    /// * [Composition](composition.html): Context of the Composition
    /// * [DeviceRequest](devicerequest.html): Encounter during which request was created
    /// * [DiagnosticReport](diagnosticreport.html): The Encounter when the order was made
    /// * [DocumentReference](documentreference.html): Context of the document  content
    /// * [Flag](flag.html): Alert relevant during encounter
    /// * [List](list.html): Context in which list created
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this encounter identifier
    /// * [Observation](observation.html): Encounter related to the observation
    /// * [Procedure](procedure.html): Encounter created as part of
    /// * [RiskAssessment](riskassessment.html): Where was assessment performed?
    /// * [ServiceRequest](servicerequest.html): An encounter in which this request is made
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this encounter identifier

    @Default([]) List<SearchParamReference> encounter,

    /// [additive] Type of module component to add to the feeding
    @Default([]) List<SearchParamToken> additive,

    /// [datetime] Return nutrition orders requested on this date
    @Default([]) List<SearchParamDate> datetime,

    /// [formula] Type of enteral or infant formula
    @Default([]) List<SearchParamToken> formula,

    /// [instantiatesCanonical] Instantiates FHIR protocol or definition
    @Default([])
    @JsonKey(name: 'instantiates-canonical')
        List<SearchParamReference> instantiatesCanonical,

    /// [instantiatesUri] Instantiates external protocol or definition
    @Default([])
    @JsonKey(name: 'instantiates-uri')
        List<SearchParamUri> instantiatesUri,

    /// [oraldiet] Type of diet that can be consumed orally (i.e., take via the mouth).
    @Default([]) List<SearchParamToken> oraldiet,

    /// [provider] The identity of the provider who placed the nutrition order
    @Default([]) List<SearchParamReference> provider,

    /// [status] Status of the nutrition order.
    @Default([]) List<SearchParamToken> status,

    /// [supplement] Type of supplement product requested
    @Default([]) List<SearchParamToken> supplement,
  }) = _NutritionOrderSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (additive.isNotEmpty) {
      additive.forEach(
          (element) => returnStrings.add('additive${element.toRequest()}'));
    }
    if (datetime.isNotEmpty) {
      datetime.forEach(
          (element) => returnStrings.add('datetime${element.toRequest()}'));
    }
    if (formula.isNotEmpty) {
      formula.forEach(
          (element) => returnStrings.add('formula${element.toRequest()}'));
    }
    if (instantiatesCanonical.isNotEmpty) {
      instantiatesCanonical.forEach((element) =>
          returnStrings.add('instantiates-canonical${element.toRequest()}'));
    }
    if (instantiatesUri.isNotEmpty) {
      instantiatesUri.forEach((element) =>
          returnStrings.add('instantiates-uri${element.toRequest()}'));
    }
    if (oraldiet.isNotEmpty) {
      oraldiet.forEach(
          (element) => returnStrings.add('oraldiet${element.toRequest()}'));
    }
    if (provider.isNotEmpty) {
      provider.forEach(
          (element) => returnStrings.add('provider${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (supplement.isNotEmpty) {
      supplement.forEach(
          (element) => returnStrings.add('supplement${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class SupplyDeliverySearchParams with _$SupplyDeliverySearchParams {
  const SupplyDeliverySearchParams._();
  const factory SupplyDeliverySearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [receiver] Who collected the Supply
    @Default([]) List<SearchParamReference> receiver,

    /// [status] in-progress | completed | abandoned | entered-in-error
    @Default([]) List<SearchParamToken> status,

    /// [supplier] Dispenser
    @Default([]) List<SearchParamReference> supplier,
  }) = _SupplyDeliverySearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (receiver.isNotEmpty) {
      receiver.forEach(
          (element) => returnStrings.add('receiver${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (supplier.isNotEmpty) {
      supplier.forEach(
          (element) => returnStrings.add('supplier${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class VisionPrescriptionSearchParams with _$VisionPrescriptionSearchParams {
  const VisionPrescriptionSearchParams._();
  const factory VisionPrescriptionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [identifier] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): External ids for this item
    /// * [CarePlan](careplan.html): External Ids for this plan
    /// * [CareTeam](careteam.html): External Ids for this team
    /// * [Composition](composition.html): Version-independent identifier for the Composition
    /// * [Condition](condition.html): A unique identifier of the condition record
    /// * [Consent](consent.html): Identifier for this record (external references)
    /// * [DetectedIssue](detectedissue.html): Unique id for the detected issue
    /// * [DeviceRequest](devicerequest.html): Business identifier for request/order
    /// * [DiagnosticReport](diagnosticreport.html): An identifier for the report
    /// * [DocumentManifest](documentmanifest.html): Unique Identifier for the set of documents
    /// * [DocumentReference](documentreference.html): Master Version Specific Identifier
    /// * [Encounter](encounter.html): Identifier(s) by which this encounter is known
    /// * [EpisodeOfCare](episodeofcare.html): Business Identifier(s) relevant for this EpisodeOfCare
    /// * [FamilyMemberHistory](familymemberhistory.html): A search by a record identifier
    /// * [Goal](goal.html): External Ids for this goal
    /// * [ImagingStudy](imagingstudy.html): Identifiers for the Study, such as DICOM Study Instance UID and Accession number
    /// * [Immunization](immunization.html): Business identifier
    /// * [List](list.html): Business identifier
    /// * [MedicationAdministration](medicationadministration.html): Return administrations with this external identifier
    /// * [MedicationDispense](medicationdispense.html): Returns dispenses with this external identifier
    /// * [MedicationRequest](medicationrequest.html): Return prescriptions with this external identifier
    /// * [MedicationStatement](medicationstatement.html): Return statements with this external identifier
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this external identifier
    /// * [Observation](observation.html): The unique id for a particular observation
    /// * [Procedure](procedure.html): A unique identifier for a procedure
    /// * [RiskAssessment](riskassessment.html): Unique identifier for the assessment
    /// * [ServiceRequest](servicerequest.html): Identifiers assigned to this order
    /// * [SupplyDelivery](supplydelivery.html): External identifier
    /// * [SupplyRequest](supplyrequest.html): Business Identifier for SupplyRequest
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this external identifier

    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [encounter] Multiple Resources:

    /// * [Composition](composition.html): Context of the Composition
    /// * [DeviceRequest](devicerequest.html): Encounter during which request was created
    /// * [DiagnosticReport](diagnosticreport.html): The Encounter when the order was made
    /// * [DocumentReference](documentreference.html): Context of the document  content
    /// * [Flag](flag.html): Alert relevant during encounter
    /// * [List](list.html): Context in which list created
    /// * [NutritionOrder](nutritionorder.html): Return nutrition orders with this encounter identifier
    /// * [Observation](observation.html): Encounter related to the observation
    /// * [Procedure](procedure.html): Encounter created as part of
    /// * [RiskAssessment](riskassessment.html): Where was assessment performed?
    /// * [ServiceRequest](servicerequest.html): An encounter in which this request is made
    /// * [VisionPrescription](visionprescription.html): Return prescriptions with this encounter identifier

    @Default([]) List<SearchParamReference> encounter,

    /// [datewritten] Return prescriptions written on this date
    @Default([]) List<SearchParamDate> datewritten,

    /// [prescriber] Who authorized the vision prescription
    @Default([]) List<SearchParamReference> prescriber,

    /// [status] The status of the vision prescription
    @Default([]) List<SearchParamToken> status,
  }) = _VisionPrescriptionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (datewritten.isNotEmpty) {
      datewritten.forEach(
          (element) => returnStrings.add('datewritten${element.toRequest()}'));
    }
    if (prescriber.isNotEmpty) {
      prescriber.forEach(
          (element) => returnStrings.add('prescriber${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class DeviceUseStatementSearchParams with _$DeviceUseStatementSearchParams {
  const DeviceUseStatementSearchParams._();
  const factory DeviceUseStatementSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [patient] Multiple Resources:

    /// * [AllergyIntolerance](allergyintolerance.html): Who the sensitivity is for
    /// * [CarePlan](careplan.html): Who the care plan is for
    /// * [CareTeam](careteam.html): Who care team is for
    /// * [ClinicalImpression](clinicalimpression.html): Patient or group assessed
    /// * [Composition](composition.html): Who and/or what the composition is about
    /// * [Condition](condition.html): Who has the condition?
    /// * [Consent](consent.html): Who the consent applies to
    /// * [DetectedIssue](detectedissue.html): Associated patient
    /// * [DeviceRequest](devicerequest.html): Individual the service is ordered for
    /// * [DeviceUseStatement](deviceusestatement.html): Search by subject - a patient
    /// * [DiagnosticReport](diagnosticreport.html): The subject of the report if a patient
    /// * [DocumentManifest](documentmanifest.html): The subject of the set of documents
    /// * [DocumentReference](documentreference.html): Who/what is the subject of the document
    /// * [Encounter](encounter.html): The patient or group present at the encounter
    /// * [EpisodeOfCare](episodeofcare.html): The patient who is the focus of this episode of care
    /// * [FamilyMemberHistory](familymemberhistory.html): The identity of a subject to list family member history items for
    /// * [Flag](flag.html): The identity of a subject to list flags for
    /// * [Goal](goal.html): Who this goal is intended for
    /// * [ImagingStudy](imagingstudy.html): Who the study is about
    /// * [Immunization](immunization.html): The patient for the vaccination record
    /// * [List](list.html): If all resources have the same subject
    /// * [MedicationAdministration](medicationadministration.html): The identity of a patient to list administrations  for
    /// * [MedicationDispense](medicationdispense.html): The identity of a patient to list dispenses  for
    /// * [MedicationRequest](medicationrequest.html): Returns prescriptions for a specific patient
    /// * [MedicationStatement](medicationstatement.html): Returns statements for a specific patient.
    /// * [NutritionOrder](nutritionorder.html): The identity of the person who requires the diet, formula or nutritional supplement
    /// * [Observation](observation.html): The subject that the observation is about (if patient)
    /// * [Procedure](procedure.html): Search by subject - a patient
    /// * [RiskAssessment](riskassessment.html): Who/what does assessment apply to?
    /// * [ServiceRequest](servicerequest.html): Search by subject - a patient
    /// * [SupplyDelivery](supplydelivery.html): Patient for whom the item is supplied
    /// * [VisionPrescription](visionprescription.html): The identity of a patient to list dispenses for

    @Default([]) List<SearchParamReference> patient,

    /// [device] Search by device
    @Default([]) List<SearchParamReference> device,

    /// [identifier] Search by identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [subject] Search by subject
    @Default([]) List<SearchParamReference> subject,
  }) = _DeviceUseStatementSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (device.isNotEmpty) {
      device.forEach(
          (element) => returnStrings.add('device${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class AppointmentSearchParams with _$AppointmentSearchParams {
  const AppointmentSearchParams._();
  const factory AppointmentSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [actor] Any one of the individuals participating in the appointment
    @Default([]) List<SearchParamReference> actor,

    /// [appointmentType] The style of appointment or patient that has been booked in the slot (not service type)
    @Default([])
    @JsonKey(name: 'appointment-type')
        List<SearchParamToken> appointmentType,

    /// [basedOn] The service request this appointment is allocated to assess
    @Default([]) @JsonKey(name: 'based-on') List<SearchParamReference> basedOn,

    /// [date] Appointment date/time.
    @Default([]) List<SearchParamDate> date,

    /// [identifier] An Identifier of the Appointment
    @Default([]) List<SearchParamToken> identifier,

    /// [location] This location is listed in the participants of the appointment
    @Default([]) List<SearchParamReference> location,

    /// [partStatus] The Participation status of the subject, or other participant on the appointment. Can be used to locate participants that have not responded to meeting requests.
    @Default([])
    @JsonKey(name: 'part-status')
        List<SearchParamToken> partStatus,

    /// [patient] One of the individuals of the appointment is this patient
    @Default([]) List<SearchParamReference> patient,

    /// [practitioner] One of the individuals of the appointment is this practitioner
    @Default([]) List<SearchParamReference> practitioner,

    /// [reasonCode] Coded reason this appointment is scheduled
    @Default([])
    @JsonKey(name: 'reason-code')
        List<SearchParamToken> reasonCode,

    /// [reasonReference] Reason the appointment is to take place (resource)
    @Default([])
    @JsonKey(name: 'reason-reference')
        List<SearchParamReference> reasonReference,

    /// [serviceCategory] A broad categorization of the service that is to be performed during this appointment
    @Default([])
    @JsonKey(name: 'service-category')
        List<SearchParamToken> serviceCategory,

    /// [serviceType] The specific service that is to be performed during this appointment
    @Default([])
    @JsonKey(name: 'service-type')
        List<SearchParamToken> serviceType,

    /// [slot] The slots that this appointment is filling
    @Default([]) List<SearchParamReference> slot,

    /// [specialty] The specialty of a practitioner that would be required to perform the service requested in this appointment
    @Default([]) List<SearchParamToken> specialty,

    /// [status] The overall status of the appointment
    @Default([]) List<SearchParamToken> status,

    /// [supportingInfo] Additional information to support the appointment
    @Default([])
    @JsonKey(name: 'supporting-info')
        List<SearchParamReference> supportingInfo,
  }) = _AppointmentSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (actor.isNotEmpty) {
      actor.forEach(
          (element) => returnStrings.add('actor${element.toRequest()}'));
    }
    if (appointmentType.isNotEmpty) {
      appointmentType.forEach((element) =>
          returnStrings.add('appointment-type${element.toRequest()}'));
    }
    if (basedOn.isNotEmpty) {
      basedOn.forEach(
          (element) => returnStrings.add('based-on${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (location.isNotEmpty) {
      location.forEach(
          (element) => returnStrings.add('location${element.toRequest()}'));
    }
    if (partStatus.isNotEmpty) {
      partStatus.forEach(
          (element) => returnStrings.add('part-status${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (practitioner.isNotEmpty) {
      practitioner.forEach(
          (element) => returnStrings.add('practitioner${element.toRequest()}'));
    }
    if (reasonCode.isNotEmpty) {
      reasonCode.forEach(
          (element) => returnStrings.add('reason-code${element.toRequest()}'));
    }
    if (reasonReference.isNotEmpty) {
      reasonReference.forEach((element) =>
          returnStrings.add('reason-reference${element.toRequest()}'));
    }
    if (serviceCategory.isNotEmpty) {
      serviceCategory.forEach((element) =>
          returnStrings.add('service-category${element.toRequest()}'));
    }
    if (serviceType.isNotEmpty) {
      serviceType.forEach(
          (element) => returnStrings.add('service-type${element.toRequest()}'));
    }
    if (slot.isNotEmpty) {
      slot.forEach(
          (element) => returnStrings.add('slot${element.toRequest()}'));
    }
    if (specialty.isNotEmpty) {
      specialty.forEach(
          (element) => returnStrings.add('specialty${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (supportingInfo.isNotEmpty) {
      supportingInfo.forEach((element) =>
          returnStrings.add('supporting-info${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class AppointmentResponseSearchParams with _$AppointmentResponseSearchParams {
  const AppointmentResponseSearchParams._();
  const factory AppointmentResponseSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [actor] The Person, Location/HealthcareService or Device that this appointment response replies for
    @Default([]) List<SearchParamReference> actor,

    /// [appointment] The appointment that the response is attached to
    @Default([]) List<SearchParamReference> appointment,

    /// [identifier] An Identifier in this appointment response
    @Default([]) List<SearchParamToken> identifier,

    /// [location] This Response is for this Location
    @Default([]) List<SearchParamReference> location,

    /// [partStatus] The participants acceptance status for this appointment
    @Default([])
    @JsonKey(name: 'part-status')
        List<SearchParamToken> partStatus,

    /// [patient] This Response is for this Patient
    @Default([]) List<SearchParamReference> patient,

    /// [practitioner] This Response is for this Practitioner
    @Default([]) List<SearchParamReference> practitioner,
  }) = _AppointmentResponseSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (actor.isNotEmpty) {
      actor.forEach(
          (element) => returnStrings.add('actor${element.toRequest()}'));
    }
    if (appointment.isNotEmpty) {
      appointment.forEach(
          (element) => returnStrings.add('appointment${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (location.isNotEmpty) {
      location.forEach(
          (element) => returnStrings.add('location${element.toRequest()}'));
    }
    if (partStatus.isNotEmpty) {
      partStatus.forEach(
          (element) => returnStrings.add('part-status${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (practitioner.isNotEmpty) {
      practitioner.forEach(
          (element) => returnStrings.add('practitioner${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class AuditEventSearchParams with _$AuditEventSearchParams {
  const AuditEventSearchParams._();
  const factory AuditEventSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [action] Type of action performed during the event
    @Default([]) List<SearchParamToken> action,

    /// [address] Identifier for the network access point of the user device
    @Default([]) List<SearchParamString> address,

    /// [agent] Identifier of who
    @Default([]) List<SearchParamReference> agent,

    /// [agentName] Human friendly name for the agent
    @Default([]) @JsonKey(name: 'agent-name') List<SearchParamString> agentName,

    /// [agentRole] Agent role in the event
    @Default([]) @JsonKey(name: 'agent-role') List<SearchParamToken> agentRole,

    /// [altid] Alternative User identity
    @Default([]) List<SearchParamToken> altid,

    /// [date] Time when the event was recorded
    @Default([]) List<SearchParamDate> date,

    /// [entity] Specific instance of resource
    @Default([]) List<SearchParamReference> entity,

    /// [entityName] Descriptor for entity
    @Default([])
    @JsonKey(name: 'entity-name')
        List<SearchParamString> entityName,

    /// [entityRole] What role the entity played
    @Default([])
    @JsonKey(name: 'entity-role')
        List<SearchParamToken> entityRole,

    /// [entityType] Type of entity involved
    @Default([])
    @JsonKey(name: 'entity-type')
        List<SearchParamToken> entityType,

    /// [outcome] Whether the event succeeded or failed
    @Default([]) List<SearchParamToken> outcome,

    /// [patient] Identifier of who
    @Default([]) List<SearchParamReference> patient,

    /// [policy] Policy that authorized event
    @Default([]) List<SearchParamUri> policy,

    /// [site] Logical source location within the enterprise
    @Default([]) List<SearchParamToken> site,

    /// [source] The identity of source detecting the event
    @Default([]) List<SearchParamReference> source,

    /// [subtype] More specific type/id for the event
    @Default([]) List<SearchParamToken> subtype,

    /// [type] Type/identifier of event
    @Default([]) List<SearchParamToken> type,
  }) = _AuditEventSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (action.isNotEmpty) {
      action.forEach(
          (element) => returnStrings.add('action${element.toRequest()}'));
    }
    if (address.isNotEmpty) {
      address.forEach(
          (element) => returnStrings.add('address${element.toRequest()}'));
    }
    if (agent.isNotEmpty) {
      agent.forEach(
          (element) => returnStrings.add('agent${element.toRequest()}'));
    }
    if (agentName.isNotEmpty) {
      agentName.forEach(
          (element) => returnStrings.add('agent-name${element.toRequest()}'));
    }
    if (agentRole.isNotEmpty) {
      agentRole.forEach(
          (element) => returnStrings.add('agent-role${element.toRequest()}'));
    }
    if (altid.isNotEmpty) {
      altid.forEach(
          (element) => returnStrings.add('altid${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (entity.isNotEmpty) {
      entity.forEach(
          (element) => returnStrings.add('entity${element.toRequest()}'));
    }
    if (entityName.isNotEmpty) {
      entityName.forEach(
          (element) => returnStrings.add('entity-name${element.toRequest()}'));
    }
    if (entityRole.isNotEmpty) {
      entityRole.forEach(
          (element) => returnStrings.add('entity-role${element.toRequest()}'));
    }
    if (entityType.isNotEmpty) {
      entityType.forEach(
          (element) => returnStrings.add('entity-type${element.toRequest()}'));
    }
    if (outcome.isNotEmpty) {
      outcome.forEach(
          (element) => returnStrings.add('outcome${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (policy.isNotEmpty) {
      policy.forEach(
          (element) => returnStrings.add('policy${element.toRequest()}'));
    }
    if (site.isNotEmpty) {
      site.forEach(
          (element) => returnStrings.add('site${element.toRequest()}'));
    }
    if (source.isNotEmpty) {
      source.forEach(
          (element) => returnStrings.add('source${element.toRequest()}'));
    }
    if (subtype.isNotEmpty) {
      subtype.forEach(
          (element) => returnStrings.add('subtype${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class BasicSearchParams with _$BasicSearchParams {
  const BasicSearchParams._();
  const factory BasicSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [author] Who created
    @Default([]) List<SearchParamReference> author,

    /// [code] Kind of Resource
    @Default([]) List<SearchParamToken> code,

    /// [created] When created
    @Default([]) List<SearchParamDate> created,

    /// [identifier] Business identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Identifies the focus of this resource
    @Default([]) List<SearchParamReference> patient,

    /// [subject] Identifies the focus of this resource
    @Default([]) List<SearchParamReference> subject,
  }) = _BasicSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (author.isNotEmpty) {
      author.forEach(
          (element) => returnStrings.add('author${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (created.isNotEmpty) {
      created.forEach(
          (element) => returnStrings.add('created${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class BodyStructureSearchParams with _$BodyStructureSearchParams {
  const BodyStructureSearchParams._();
  const factory BodyStructureSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [identifier] Bodystructure identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [location] Body site
    @Default([]) List<SearchParamToken> location,

    /// [morphology] Kind of Structure
    @Default([]) List<SearchParamToken> morphology,

    /// [patient] Who this is about
    @Default([]) List<SearchParamReference> patient,
  }) = _BodyStructureSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (location.isNotEmpty) {
      location.forEach(
          (element) => returnStrings.add('location${element.toRequest()}'));
    }
    if (morphology.isNotEmpty) {
      morphology.forEach(
          (element) => returnStrings.add('morphology${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class BundleSearchParams with _$BundleSearchParams {
  const BundleSearchParams._();
  const factory BundleSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [composition] The first resource in the bundle, if the bundle type is "document" - this is a composition, and this parameter provides access to search its contents
    @Default([]) List<SearchParamReference> composition,

    /// [identifier] Persistent identifier for the bundle
    @Default([]) List<SearchParamToken> identifier,

    /// [message] The first resource in the bundle, if the bundle type is "message" - this is a message header, and this parameter provides access to search its contents
    @Default([]) List<SearchParamReference> message,

    /// [timestamp] When the bundle was assembled
    @Default([]) List<SearchParamDate> timestamp,

    /// [type] document | message | transaction | transaction-response | batch | batch-response | history | searchset | collection
    @Default([]) List<SearchParamToken> type,
  }) = _BundleSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (composition.isNotEmpty) {
      composition.forEach(
          (element) => returnStrings.add('composition${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (message.isNotEmpty) {
      message.forEach(
          (element) => returnStrings.add('message${element.toRequest()}'));
    }
    if (timestamp.isNotEmpty) {
      timestamp.forEach(
          (element) => returnStrings.add('timestamp${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class CapabilityStatementSearchParams with _$CapabilityStatementSearchParams {
  const CapabilityStatementSearchParams._();
  const factory CapabilityStatementSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context assigned to the value set

    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A quantity- or range-valued use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A quantity- or range-valued use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A quantity- or range-valued use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A quantity- or range-valued use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A quantity- or range-valued use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A quantity- or range-valued use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A quantity- or range-valued use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A quantity- or range-valued use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A quantity- or range-valued use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A quantity- or range-valued use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A quantity- or range-valued use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A quantity- or range-valued use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A quantity- or range-valued use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A quantity- or range-valued use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A type of use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A type of use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A type of use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A type of use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A type of use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A type of use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A type of use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A type of use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A type of use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A type of use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A type of use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A type of use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A type of use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A type of use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The capability statement publication date
    /// * [CodeSystem](codesystem.html): The code system publication date
    /// * [CompartmentDefinition](compartmentdefinition.html): The compartment definition publication date
    /// * [ConceptMap](conceptmap.html): The concept map publication date
    /// * [GraphDefinition](graphdefinition.html): The graph definition publication date
    /// * [ImplementationGuide](implementationguide.html): The implementation guide publication date
    /// * [MessageDefinition](messagedefinition.html): The message definition publication date
    /// * [NamingSystem](namingsystem.html): The naming system publication date
    /// * [OperationDefinition](operationdefinition.html): The operation definition publication date
    /// * [SearchParameter](searchparameter.html): The search parameter publication date
    /// * [StructureDefinition](structuredefinition.html): The structure definition publication date
    /// * [StructureMap](structuremap.html): The structure map publication date
    /// * [TerminologyCapabilities](terminologycapabilities.html): The terminology capabilities publication date
    /// * [ValueSet](valueset.html): The value set publication date

    @Default([]) List<SearchParamDate> date,

    /// [description] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The description of the capability statement
    /// * [CodeSystem](codesystem.html): The description of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The description of the compartment definition
    /// * [ConceptMap](conceptmap.html): The description of the concept map
    /// * [GraphDefinition](graphdefinition.html): The description of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The description of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The description of the message definition
    /// * [NamingSystem](namingsystem.html): The description of the naming system
    /// * [OperationDefinition](operationdefinition.html): The description of the operation definition
    /// * [SearchParameter](searchparameter.html): The description of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The description of the structure definition
    /// * [StructureMap](structuremap.html): The description of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The description of the terminology capabilities
    /// * [ValueSet](valueset.html): The description of the value set

    @Default([]) List<SearchParamString> description,

    /// [fhirversion] The version of FHIR
    @Default([]) List<SearchParamToken> fhirversion,

    /// [format] formats supported (xml | json | ttl | mime type)
    @Default([]) List<SearchParamToken> format,

    /// [guide] Implementation guides supported
    @Default([]) List<SearchParamReference> guide,

    /// [jurisdiction] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Intended jurisdiction for the capability statement
    /// * [CodeSystem](codesystem.html): Intended jurisdiction for the code system
    /// * [ConceptMap](conceptmap.html): Intended jurisdiction for the concept map
    /// * [GraphDefinition](graphdefinition.html): Intended jurisdiction for the graph definition
    /// * [ImplementationGuide](implementationguide.html): Intended jurisdiction for the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Intended jurisdiction for the message definition
    /// * [NamingSystem](namingsystem.html): Intended jurisdiction for the naming system
    /// * [OperationDefinition](operationdefinition.html): Intended jurisdiction for the operation definition
    /// * [SearchParameter](searchparameter.html): Intended jurisdiction for the search parameter
    /// * [StructureDefinition](structuredefinition.html): Intended jurisdiction for the structure definition
    /// * [StructureMap](structuremap.html): Intended jurisdiction for the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Intended jurisdiction for the terminology capabilities
    /// * [ValueSet](valueset.html): Intended jurisdiction for the value set

    @Default([]) List<SearchParamToken> jurisdiction,

    /// [mode] Mode - restful (server/client) or messaging (sender/receiver)
    @Default([]) List<SearchParamToken> mode,

    /// [name] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Computationally friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): Computationally friendly name of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Computationally friendly name of the compartment definition
    /// * [ConceptMap](conceptmap.html): Computationally friendly name of the concept map
    /// * [GraphDefinition](graphdefinition.html): Computationally friendly name of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Computationally friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Computationally friendly name of the message definition
    /// * [NamingSystem](namingsystem.html): Computationally friendly name of the naming system
    /// * [OperationDefinition](operationdefinition.html): Computationally friendly name of the operation definition
    /// * [SearchParameter](searchparameter.html): Computationally friendly name of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Computationally friendly name of the structure definition
    /// * [StructureMap](structuremap.html): Computationally friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Computationally friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): Computationally friendly name of the value set

    @Default([]) List<SearchParamString> name,

    /// [publisher] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Name of the publisher of the capability statement
    /// * [CodeSystem](codesystem.html): Name of the publisher of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Name of the publisher of the compartment definition
    /// * [ConceptMap](conceptmap.html): Name of the publisher of the concept map
    /// * [GraphDefinition](graphdefinition.html): Name of the publisher of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Name of the publisher of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Name of the publisher of the message definition
    /// * [NamingSystem](namingsystem.html): Name of the publisher of the naming system
    /// * [OperationDefinition](operationdefinition.html): Name of the publisher of the operation definition
    /// * [SearchParameter](searchparameter.html): Name of the publisher of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Name of the publisher of the structure definition
    /// * [StructureMap](structuremap.html): Name of the publisher of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Name of the publisher of the terminology capabilities
    /// * [ValueSet](valueset.html): Name of the publisher of the value set

    @Default([]) List<SearchParamString> publisher,

    /// [resource] Name of a resource mentioned in a capability statement
    @Default([]) List<SearchParamToken> resource,

    /// [resourceProfile] A profile id invoked in a capability statement
    @Default([])
    @JsonKey(name: 'resource-profile')
        List<SearchParamReference> resourceProfile_,

    /// [securityService] OAuth | SMART-on-FHIR | NTLM | Basic | Kerberos | Certificates
    @Default([])
    @JsonKey(name: 'security-service')
        List<SearchParamToken> securityService,

    /// [software] Part of the name of a software application
    @Default([]) List<SearchParamString> software,

    /// [status] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The current status of the capability statement
    /// * [CodeSystem](codesystem.html): The current status of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The current status of the compartment definition
    /// * [ConceptMap](conceptmap.html): The current status of the concept map
    /// * [GraphDefinition](graphdefinition.html): The current status of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The current status of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The current status of the message definition
    /// * [NamingSystem](namingsystem.html): The current status of the naming system
    /// * [OperationDefinition](operationdefinition.html): The current status of the operation definition
    /// * [SearchParameter](searchparameter.html): The current status of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The current status of the structure definition
    /// * [StructureMap](structuremap.html): The current status of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The current status of the terminology capabilities
    /// * [ValueSet](valueset.html): The current status of the value set

    @Default([]) List<SearchParamToken> status,

    /// [supportedProfile] Profiles for use cases supported
    @Default([])
    @JsonKey(name: 'supported-profile')
        List<SearchParamReference> supportedProfile,

    /// [title] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The human-friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): The human-friendly name of the code system
    /// * [ConceptMap](conceptmap.html): The human-friendly name of the concept map
    /// * [ImplementationGuide](implementationguide.html): The human-friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The human-friendly name of the message definition
    /// * [OperationDefinition](operationdefinition.html): The human-friendly name of the operation definition
    /// * [StructureDefinition](structuredefinition.html): The human-friendly name of the structure definition
    /// * [StructureMap](structuremap.html): The human-friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The human-friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): The human-friendly name of the value set

    @Default([]) List<SearchParamString> title,

    /// [url] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The uri that identifies the capability statement
    /// * [CodeSystem](codesystem.html): The uri that identifies the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The uri that identifies the compartment definition
    /// * [ConceptMap](conceptmap.html): The uri that identifies the concept map
    /// * [GraphDefinition](graphdefinition.html): The uri that identifies the graph definition
    /// * [ImplementationGuide](implementationguide.html): The uri that identifies the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The uri that identifies the message definition
    /// * [OperationDefinition](operationdefinition.html): The uri that identifies the operation definition
    /// * [SearchParameter](searchparameter.html): The uri that identifies the search parameter
    /// * [StructureDefinition](structuredefinition.html): The uri that identifies the structure definition
    /// * [StructureMap](structuremap.html): The uri that identifies the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The uri that identifies the terminology capabilities
    /// * [ValueSet](valueset.html): The uri that identifies the value set

    @Default([]) List<SearchParamUri> url,

    /// [version] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The business version of the capability statement
    /// * [CodeSystem](codesystem.html): The business version of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The business version of the compartment definition
    /// * [ConceptMap](conceptmap.html): The business version of the concept map
    /// * [GraphDefinition](graphdefinition.html): The business version of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The business version of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The business version of the message definition
    /// * [OperationDefinition](operationdefinition.html): The business version of the operation definition
    /// * [SearchParameter](searchparameter.html): The business version of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The business version of the structure definition
    /// * [StructureMap](structuremap.html): The business version of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The business version of the terminology capabilities
    /// * [ValueSet](valueset.html): The business version of the value set

    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and quantity- or range-based value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and quantity- or range-based value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and quantity- or range-based value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and quantity- or range-based value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and quantity- or range-based value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and quantity- or range-based value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and quantity- or range-based value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and quantity- or range-based value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and quantity- or range-based value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and quantity- or range-based value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and quantity- or range-based value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and quantity- or range-based value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and quantity- or range-based value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and quantity- or range-based value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,
  }) = _CapabilityStatementSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (fhirversion.isNotEmpty) {
      fhirversion.forEach(
          (element) => returnStrings.add('fhirversion${element.toRequest()}'));
    }
    if (format.isNotEmpty) {
      format.forEach(
          (element) => returnStrings.add('format${element.toRequest()}'));
    }
    if (guide.isNotEmpty) {
      guide.forEach(
          (element) => returnStrings.add('guide${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (mode.isNotEmpty) {
      mode.forEach(
          (element) => returnStrings.add('mode${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (resource.isNotEmpty) {
      resource.forEach(
          (element) => returnStrings.add('resource${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach((element) =>
          returnStrings.add('resource-profile${element.toRequest()}'));
    }
    if (securityService.isNotEmpty) {
      securityService.forEach((element) =>
          returnStrings.add('security-service${element.toRequest()}'));
    }
    if (software.isNotEmpty) {
      software.forEach(
          (element) => returnStrings.add('software${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (supportedProfile.isNotEmpty) {
      supportedProfile.forEach((element) =>
          returnStrings.add('supported-profile${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class CodeSystemSearchParams with _$CodeSystemSearchParams {
  const CodeSystemSearchParams._();
  const factory CodeSystemSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context assigned to the value set

    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A quantity- or range-valued use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A quantity- or range-valued use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A quantity- or range-valued use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A quantity- or range-valued use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A quantity- or range-valued use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A quantity- or range-valued use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A quantity- or range-valued use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A quantity- or range-valued use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A quantity- or range-valued use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A quantity- or range-valued use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A quantity- or range-valued use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A quantity- or range-valued use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A quantity- or range-valued use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A quantity- or range-valued use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A type of use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A type of use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A type of use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A type of use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A type of use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A type of use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A type of use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A type of use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A type of use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A type of use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A type of use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A type of use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A type of use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A type of use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The capability statement publication date
    /// * [CodeSystem](codesystem.html): The code system publication date
    /// * [CompartmentDefinition](compartmentdefinition.html): The compartment definition publication date
    /// * [ConceptMap](conceptmap.html): The concept map publication date
    /// * [GraphDefinition](graphdefinition.html): The graph definition publication date
    /// * [ImplementationGuide](implementationguide.html): The implementation guide publication date
    /// * [MessageDefinition](messagedefinition.html): The message definition publication date
    /// * [NamingSystem](namingsystem.html): The naming system publication date
    /// * [OperationDefinition](operationdefinition.html): The operation definition publication date
    /// * [SearchParameter](searchparameter.html): The search parameter publication date
    /// * [StructureDefinition](structuredefinition.html): The structure definition publication date
    /// * [StructureMap](structuremap.html): The structure map publication date
    /// * [TerminologyCapabilities](terminologycapabilities.html): The terminology capabilities publication date
    /// * [ValueSet](valueset.html): The value set publication date

    @Default([]) List<SearchParamDate> date,

    /// [description] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The description of the capability statement
    /// * [CodeSystem](codesystem.html): The description of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The description of the compartment definition
    /// * [ConceptMap](conceptmap.html): The description of the concept map
    /// * [GraphDefinition](graphdefinition.html): The description of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The description of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The description of the message definition
    /// * [NamingSystem](namingsystem.html): The description of the naming system
    /// * [OperationDefinition](operationdefinition.html): The description of the operation definition
    /// * [SearchParameter](searchparameter.html): The description of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The description of the structure definition
    /// * [StructureMap](structuremap.html): The description of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The description of the terminology capabilities
    /// * [ValueSet](valueset.html): The description of the value set

    @Default([]) List<SearchParamString> description,

    /// [jurisdiction] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Intended jurisdiction for the capability statement
    /// * [CodeSystem](codesystem.html): Intended jurisdiction for the code system
    /// * [ConceptMap](conceptmap.html): Intended jurisdiction for the concept map
    /// * [GraphDefinition](graphdefinition.html): Intended jurisdiction for the graph definition
    /// * [ImplementationGuide](implementationguide.html): Intended jurisdiction for the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Intended jurisdiction for the message definition
    /// * [NamingSystem](namingsystem.html): Intended jurisdiction for the naming system
    /// * [OperationDefinition](operationdefinition.html): Intended jurisdiction for the operation definition
    /// * [SearchParameter](searchparameter.html): Intended jurisdiction for the search parameter
    /// * [StructureDefinition](structuredefinition.html): Intended jurisdiction for the structure definition
    /// * [StructureMap](structuremap.html): Intended jurisdiction for the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Intended jurisdiction for the terminology capabilities
    /// * [ValueSet](valueset.html): Intended jurisdiction for the value set

    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Computationally friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): Computationally friendly name of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Computationally friendly name of the compartment definition
    /// * [ConceptMap](conceptmap.html): Computationally friendly name of the concept map
    /// * [GraphDefinition](graphdefinition.html): Computationally friendly name of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Computationally friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Computationally friendly name of the message definition
    /// * [NamingSystem](namingsystem.html): Computationally friendly name of the naming system
    /// * [OperationDefinition](operationdefinition.html): Computationally friendly name of the operation definition
    /// * [SearchParameter](searchparameter.html): Computationally friendly name of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Computationally friendly name of the structure definition
    /// * [StructureMap](structuremap.html): Computationally friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Computationally friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): Computationally friendly name of the value set

    @Default([]) List<SearchParamString> name,

    /// [publisher] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Name of the publisher of the capability statement
    /// * [CodeSystem](codesystem.html): Name of the publisher of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Name of the publisher of the compartment definition
    /// * [ConceptMap](conceptmap.html): Name of the publisher of the concept map
    /// * [GraphDefinition](graphdefinition.html): Name of the publisher of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Name of the publisher of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Name of the publisher of the message definition
    /// * [NamingSystem](namingsystem.html): Name of the publisher of the naming system
    /// * [OperationDefinition](operationdefinition.html): Name of the publisher of the operation definition
    /// * [SearchParameter](searchparameter.html): Name of the publisher of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Name of the publisher of the structure definition
    /// * [StructureMap](structuremap.html): Name of the publisher of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Name of the publisher of the terminology capabilities
    /// * [ValueSet](valueset.html): Name of the publisher of the value set

    @Default([]) List<SearchParamString> publisher,

    /// [status] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The current status of the capability statement
    /// * [CodeSystem](codesystem.html): The current status of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The current status of the compartment definition
    /// * [ConceptMap](conceptmap.html): The current status of the concept map
    /// * [GraphDefinition](graphdefinition.html): The current status of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The current status of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The current status of the message definition
    /// * [NamingSystem](namingsystem.html): The current status of the naming system
    /// * [OperationDefinition](operationdefinition.html): The current status of the operation definition
    /// * [SearchParameter](searchparameter.html): The current status of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The current status of the structure definition
    /// * [StructureMap](structuremap.html): The current status of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The current status of the terminology capabilities
    /// * [ValueSet](valueset.html): The current status of the value set

    @Default([]) List<SearchParamToken> status,

    /// [title] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The human-friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): The human-friendly name of the code system
    /// * [ConceptMap](conceptmap.html): The human-friendly name of the concept map
    /// * [ImplementationGuide](implementationguide.html): The human-friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The human-friendly name of the message definition
    /// * [OperationDefinition](operationdefinition.html): The human-friendly name of the operation definition
    /// * [StructureDefinition](structuredefinition.html): The human-friendly name of the structure definition
    /// * [StructureMap](structuremap.html): The human-friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The human-friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): The human-friendly name of the value set

    @Default([]) List<SearchParamString> title,

    /// [url] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The uri that identifies the capability statement
    /// * [CodeSystem](codesystem.html): The uri that identifies the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The uri that identifies the compartment definition
    /// * [ConceptMap](conceptmap.html): The uri that identifies the concept map
    /// * [GraphDefinition](graphdefinition.html): The uri that identifies the graph definition
    /// * [ImplementationGuide](implementationguide.html): The uri that identifies the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The uri that identifies the message definition
    /// * [OperationDefinition](operationdefinition.html): The uri that identifies the operation definition
    /// * [SearchParameter](searchparameter.html): The uri that identifies the search parameter
    /// * [StructureDefinition](structuredefinition.html): The uri that identifies the structure definition
    /// * [StructureMap](structuremap.html): The uri that identifies the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The uri that identifies the terminology capabilities
    /// * [ValueSet](valueset.html): The uri that identifies the value set

    @Default([]) List<SearchParamUri> url,

    /// [version] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The business version of the capability statement
    /// * [CodeSystem](codesystem.html): The business version of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The business version of the compartment definition
    /// * [ConceptMap](conceptmap.html): The business version of the concept map
    /// * [GraphDefinition](graphdefinition.html): The business version of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The business version of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The business version of the message definition
    /// * [OperationDefinition](operationdefinition.html): The business version of the operation definition
    /// * [SearchParameter](searchparameter.html): The business version of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The business version of the structure definition
    /// * [StructureMap](structuremap.html): The business version of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The business version of the terminology capabilities
    /// * [ValueSet](valueset.html): The business version of the value set

    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and quantity- or range-based value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and quantity- or range-based value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and quantity- or range-based value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and quantity- or range-based value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and quantity- or range-based value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and quantity- or range-based value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and quantity- or range-based value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and quantity- or range-based value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and quantity- or range-based value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and quantity- or range-based value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and quantity- or range-based value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and quantity- or range-based value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and quantity- or range-based value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and quantity- or range-based value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,

    /// [code] A code defined in the code system
    @Default([]) List<SearchParamToken> code,

    /// [contentMode] not-present | example | fragment | complete | supplement
    @Default([])
    @JsonKey(name: 'content-mode')
        List<SearchParamToken> contentMode,

    /// [identifier] Multiple Resources:

    /// * [CodeSystem](codesystem.html): External identifier for the code system
    /// * [ConceptMap](conceptmap.html): External identifier for the concept map
    /// * [MessageDefinition](messagedefinition.html): External identifier for the message definition
    /// * [StructureDefinition](structuredefinition.html): External identifier for the structure definition
    /// * [StructureMap](structuremap.html): External identifier for the structure map
    /// * [ValueSet](valueset.html): External identifier for the value set

    @Default([]) List<SearchParamToken> identifier,

    /// [language] A language in which a designation is provided
    @Default([]) List<SearchParamToken> language,

    /// [supplements] Find code system supplements for the referenced code system
    @Default([]) List<SearchParamReference> supplements,

    /// [system] The system for any codes defined by this code system (same as 'url')
    @Default([]) List<SearchParamUri> system,
  }) = _CodeSystemSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (contentMode.isNotEmpty) {
      contentMode.forEach(
          (element) => returnStrings.add('content-mode${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (language.isNotEmpty) {
      language.forEach(
          (element) => returnStrings.add('language${element.toRequest()}'));
    }
    if (supplements.isNotEmpty) {
      supplements.forEach(
          (element) => returnStrings.add('supplements${element.toRequest()}'));
    }
    if (system.isNotEmpty) {
      system.forEach(
          (element) => returnStrings.add('system${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class CompartmentDefinitionSearchParams
    with _$CompartmentDefinitionSearchParams {
  const CompartmentDefinitionSearchParams._();
  const factory CompartmentDefinitionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context assigned to the value set

    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A quantity- or range-valued use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A quantity- or range-valued use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A quantity- or range-valued use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A quantity- or range-valued use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A quantity- or range-valued use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A quantity- or range-valued use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A quantity- or range-valued use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A quantity- or range-valued use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A quantity- or range-valued use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A quantity- or range-valued use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A quantity- or range-valued use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A quantity- or range-valued use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A quantity- or range-valued use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A quantity- or range-valued use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A type of use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A type of use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A type of use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A type of use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A type of use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A type of use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A type of use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A type of use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A type of use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A type of use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A type of use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A type of use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A type of use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A type of use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The capability statement publication date
    /// * [CodeSystem](codesystem.html): The code system publication date
    /// * [CompartmentDefinition](compartmentdefinition.html): The compartment definition publication date
    /// * [ConceptMap](conceptmap.html): The concept map publication date
    /// * [GraphDefinition](graphdefinition.html): The graph definition publication date
    /// * [ImplementationGuide](implementationguide.html): The implementation guide publication date
    /// * [MessageDefinition](messagedefinition.html): The message definition publication date
    /// * [NamingSystem](namingsystem.html): The naming system publication date
    /// * [OperationDefinition](operationdefinition.html): The operation definition publication date
    /// * [SearchParameter](searchparameter.html): The search parameter publication date
    /// * [StructureDefinition](structuredefinition.html): The structure definition publication date
    /// * [StructureMap](structuremap.html): The structure map publication date
    /// * [TerminologyCapabilities](terminologycapabilities.html): The terminology capabilities publication date
    /// * [ValueSet](valueset.html): The value set publication date

    @Default([]) List<SearchParamDate> date,

    /// [description] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The description of the capability statement
    /// * [CodeSystem](codesystem.html): The description of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The description of the compartment definition
    /// * [ConceptMap](conceptmap.html): The description of the concept map
    /// * [GraphDefinition](graphdefinition.html): The description of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The description of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The description of the message definition
    /// * [NamingSystem](namingsystem.html): The description of the naming system
    /// * [OperationDefinition](operationdefinition.html): The description of the operation definition
    /// * [SearchParameter](searchparameter.html): The description of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The description of the structure definition
    /// * [StructureMap](structuremap.html): The description of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The description of the terminology capabilities
    /// * [ValueSet](valueset.html): The description of the value set

    @Default([]) List<SearchParamString> description,

    /// [name] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Computationally friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): Computationally friendly name of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Computationally friendly name of the compartment definition
    /// * [ConceptMap](conceptmap.html): Computationally friendly name of the concept map
    /// * [GraphDefinition](graphdefinition.html): Computationally friendly name of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Computationally friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Computationally friendly name of the message definition
    /// * [NamingSystem](namingsystem.html): Computationally friendly name of the naming system
    /// * [OperationDefinition](operationdefinition.html): Computationally friendly name of the operation definition
    /// * [SearchParameter](searchparameter.html): Computationally friendly name of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Computationally friendly name of the structure definition
    /// * [StructureMap](structuremap.html): Computationally friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Computationally friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): Computationally friendly name of the value set

    @Default([]) List<SearchParamString> name,

    /// [publisher] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Name of the publisher of the capability statement
    /// * [CodeSystem](codesystem.html): Name of the publisher of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Name of the publisher of the compartment definition
    /// * [ConceptMap](conceptmap.html): Name of the publisher of the concept map
    /// * [GraphDefinition](graphdefinition.html): Name of the publisher of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Name of the publisher of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Name of the publisher of the message definition
    /// * [NamingSystem](namingsystem.html): Name of the publisher of the naming system
    /// * [OperationDefinition](operationdefinition.html): Name of the publisher of the operation definition
    /// * [SearchParameter](searchparameter.html): Name of the publisher of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Name of the publisher of the structure definition
    /// * [StructureMap](structuremap.html): Name of the publisher of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Name of the publisher of the terminology capabilities
    /// * [ValueSet](valueset.html): Name of the publisher of the value set

    @Default([]) List<SearchParamString> publisher,

    /// [status] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The current status of the capability statement
    /// * [CodeSystem](codesystem.html): The current status of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The current status of the compartment definition
    /// * [ConceptMap](conceptmap.html): The current status of the concept map
    /// * [GraphDefinition](graphdefinition.html): The current status of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The current status of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The current status of the message definition
    /// * [NamingSystem](namingsystem.html): The current status of the naming system
    /// * [OperationDefinition](operationdefinition.html): The current status of the operation definition
    /// * [SearchParameter](searchparameter.html): The current status of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The current status of the structure definition
    /// * [StructureMap](structuremap.html): The current status of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The current status of the terminology capabilities
    /// * [ValueSet](valueset.html): The current status of the value set

    @Default([]) List<SearchParamToken> status,

    /// [url] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The uri that identifies the capability statement
    /// * [CodeSystem](codesystem.html): The uri that identifies the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The uri that identifies the compartment definition
    /// * [ConceptMap](conceptmap.html): The uri that identifies the concept map
    /// * [GraphDefinition](graphdefinition.html): The uri that identifies the graph definition
    /// * [ImplementationGuide](implementationguide.html): The uri that identifies the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The uri that identifies the message definition
    /// * [OperationDefinition](operationdefinition.html): The uri that identifies the operation definition
    /// * [SearchParameter](searchparameter.html): The uri that identifies the search parameter
    /// * [StructureDefinition](structuredefinition.html): The uri that identifies the structure definition
    /// * [StructureMap](structuremap.html): The uri that identifies the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The uri that identifies the terminology capabilities
    /// * [ValueSet](valueset.html): The uri that identifies the value set

    @Default([]) List<SearchParamUri> url,

    /// [version] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The business version of the capability statement
    /// * [CodeSystem](codesystem.html): The business version of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The business version of the compartment definition
    /// * [ConceptMap](conceptmap.html): The business version of the concept map
    /// * [GraphDefinition](graphdefinition.html): The business version of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The business version of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The business version of the message definition
    /// * [OperationDefinition](operationdefinition.html): The business version of the operation definition
    /// * [SearchParameter](searchparameter.html): The business version of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The business version of the structure definition
    /// * [StructureMap](structuremap.html): The business version of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The business version of the terminology capabilities
    /// * [ValueSet](valueset.html): The business version of the value set

    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and quantity- or range-based value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and quantity- or range-based value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and quantity- or range-based value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and quantity- or range-based value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and quantity- or range-based value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and quantity- or range-based value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and quantity- or range-based value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and quantity- or range-based value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and quantity- or range-based value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and quantity- or range-based value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and quantity- or range-based value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and quantity- or range-based value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and quantity- or range-based value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and quantity- or range-based value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,

    /// [code] Patient | Encounter | RelatedPerson | Practitioner | Device
    @Default([]) List<SearchParamToken> code,

    /// [resource] Name of resource type
    @Default([]) List<SearchParamToken> resource,
  }) = _CompartmentDefinitionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (resource.isNotEmpty) {
      resource.forEach(
          (element) => returnStrings.add('resource${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ConceptMapSearchParams with _$ConceptMapSearchParams {
  const ConceptMapSearchParams._();
  const factory ConceptMapSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context assigned to the value set

    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A quantity- or range-valued use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A quantity- or range-valued use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A quantity- or range-valued use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A quantity- or range-valued use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A quantity- or range-valued use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A quantity- or range-valued use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A quantity- or range-valued use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A quantity- or range-valued use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A quantity- or range-valued use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A quantity- or range-valued use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A quantity- or range-valued use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A quantity- or range-valued use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A quantity- or range-valued use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A quantity- or range-valued use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A type of use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A type of use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A type of use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A type of use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A type of use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A type of use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A type of use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A type of use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A type of use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A type of use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A type of use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A type of use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A type of use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A type of use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The capability statement publication date
    /// * [CodeSystem](codesystem.html): The code system publication date
    /// * [CompartmentDefinition](compartmentdefinition.html): The compartment definition publication date
    /// * [ConceptMap](conceptmap.html): The concept map publication date
    /// * [GraphDefinition](graphdefinition.html): The graph definition publication date
    /// * [ImplementationGuide](implementationguide.html): The implementation guide publication date
    /// * [MessageDefinition](messagedefinition.html): The message definition publication date
    /// * [NamingSystem](namingsystem.html): The naming system publication date
    /// * [OperationDefinition](operationdefinition.html): The operation definition publication date
    /// * [SearchParameter](searchparameter.html): The search parameter publication date
    /// * [StructureDefinition](structuredefinition.html): The structure definition publication date
    /// * [StructureMap](structuremap.html): The structure map publication date
    /// * [TerminologyCapabilities](terminologycapabilities.html): The terminology capabilities publication date
    /// * [ValueSet](valueset.html): The value set publication date

    @Default([]) List<SearchParamDate> date,

    /// [description] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The description of the capability statement
    /// * [CodeSystem](codesystem.html): The description of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The description of the compartment definition
    /// * [ConceptMap](conceptmap.html): The description of the concept map
    /// * [GraphDefinition](graphdefinition.html): The description of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The description of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The description of the message definition
    /// * [NamingSystem](namingsystem.html): The description of the naming system
    /// * [OperationDefinition](operationdefinition.html): The description of the operation definition
    /// * [SearchParameter](searchparameter.html): The description of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The description of the structure definition
    /// * [StructureMap](structuremap.html): The description of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The description of the terminology capabilities
    /// * [ValueSet](valueset.html): The description of the value set

    @Default([]) List<SearchParamString> description,

    /// [jurisdiction] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Intended jurisdiction for the capability statement
    /// * [CodeSystem](codesystem.html): Intended jurisdiction for the code system
    /// * [ConceptMap](conceptmap.html): Intended jurisdiction for the concept map
    /// * [GraphDefinition](graphdefinition.html): Intended jurisdiction for the graph definition
    /// * [ImplementationGuide](implementationguide.html): Intended jurisdiction for the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Intended jurisdiction for the message definition
    /// * [NamingSystem](namingsystem.html): Intended jurisdiction for the naming system
    /// * [OperationDefinition](operationdefinition.html): Intended jurisdiction for the operation definition
    /// * [SearchParameter](searchparameter.html): Intended jurisdiction for the search parameter
    /// * [StructureDefinition](structuredefinition.html): Intended jurisdiction for the structure definition
    /// * [StructureMap](structuremap.html): Intended jurisdiction for the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Intended jurisdiction for the terminology capabilities
    /// * [ValueSet](valueset.html): Intended jurisdiction for the value set

    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Computationally friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): Computationally friendly name of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Computationally friendly name of the compartment definition
    /// * [ConceptMap](conceptmap.html): Computationally friendly name of the concept map
    /// * [GraphDefinition](graphdefinition.html): Computationally friendly name of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Computationally friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Computationally friendly name of the message definition
    /// * [NamingSystem](namingsystem.html): Computationally friendly name of the naming system
    /// * [OperationDefinition](operationdefinition.html): Computationally friendly name of the operation definition
    /// * [SearchParameter](searchparameter.html): Computationally friendly name of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Computationally friendly name of the structure definition
    /// * [StructureMap](structuremap.html): Computationally friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Computationally friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): Computationally friendly name of the value set

    @Default([]) List<SearchParamString> name,

    /// [publisher] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Name of the publisher of the capability statement
    /// * [CodeSystem](codesystem.html): Name of the publisher of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Name of the publisher of the compartment definition
    /// * [ConceptMap](conceptmap.html): Name of the publisher of the concept map
    /// * [GraphDefinition](graphdefinition.html): Name of the publisher of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Name of the publisher of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Name of the publisher of the message definition
    /// * [NamingSystem](namingsystem.html): Name of the publisher of the naming system
    /// * [OperationDefinition](operationdefinition.html): Name of the publisher of the operation definition
    /// * [SearchParameter](searchparameter.html): Name of the publisher of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Name of the publisher of the structure definition
    /// * [StructureMap](structuremap.html): Name of the publisher of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Name of the publisher of the terminology capabilities
    /// * [ValueSet](valueset.html): Name of the publisher of the value set

    @Default([]) List<SearchParamString> publisher,

    /// [status] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The current status of the capability statement
    /// * [CodeSystem](codesystem.html): The current status of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The current status of the compartment definition
    /// * [ConceptMap](conceptmap.html): The current status of the concept map
    /// * [GraphDefinition](graphdefinition.html): The current status of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The current status of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The current status of the message definition
    /// * [NamingSystem](namingsystem.html): The current status of the naming system
    /// * [OperationDefinition](operationdefinition.html): The current status of the operation definition
    /// * [SearchParameter](searchparameter.html): The current status of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The current status of the structure definition
    /// * [StructureMap](structuremap.html): The current status of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The current status of the terminology capabilities
    /// * [ValueSet](valueset.html): The current status of the value set

    @Default([]) List<SearchParamToken> status,

    /// [title] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The human-friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): The human-friendly name of the code system
    /// * [ConceptMap](conceptmap.html): The human-friendly name of the concept map
    /// * [ImplementationGuide](implementationguide.html): The human-friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The human-friendly name of the message definition
    /// * [OperationDefinition](operationdefinition.html): The human-friendly name of the operation definition
    /// * [StructureDefinition](structuredefinition.html): The human-friendly name of the structure definition
    /// * [StructureMap](structuremap.html): The human-friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The human-friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): The human-friendly name of the value set

    @Default([]) List<SearchParamString> title,

    /// [url] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The uri that identifies the capability statement
    /// * [CodeSystem](codesystem.html): The uri that identifies the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The uri that identifies the compartment definition
    /// * [ConceptMap](conceptmap.html): The uri that identifies the concept map
    /// * [GraphDefinition](graphdefinition.html): The uri that identifies the graph definition
    /// * [ImplementationGuide](implementationguide.html): The uri that identifies the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The uri that identifies the message definition
    /// * [OperationDefinition](operationdefinition.html): The uri that identifies the operation definition
    /// * [SearchParameter](searchparameter.html): The uri that identifies the search parameter
    /// * [StructureDefinition](structuredefinition.html): The uri that identifies the structure definition
    /// * [StructureMap](structuremap.html): The uri that identifies the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The uri that identifies the terminology capabilities
    /// * [ValueSet](valueset.html): The uri that identifies the value set

    @Default([]) List<SearchParamUri> url,

    /// [version] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The business version of the capability statement
    /// * [CodeSystem](codesystem.html): The business version of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The business version of the compartment definition
    /// * [ConceptMap](conceptmap.html): The business version of the concept map
    /// * [GraphDefinition](graphdefinition.html): The business version of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The business version of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The business version of the message definition
    /// * [OperationDefinition](operationdefinition.html): The business version of the operation definition
    /// * [SearchParameter](searchparameter.html): The business version of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The business version of the structure definition
    /// * [StructureMap](structuremap.html): The business version of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The business version of the terminology capabilities
    /// * [ValueSet](valueset.html): The business version of the value set

    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and quantity- or range-based value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and quantity- or range-based value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and quantity- or range-based value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and quantity- or range-based value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and quantity- or range-based value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and quantity- or range-based value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and quantity- or range-based value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and quantity- or range-based value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and quantity- or range-based value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and quantity- or range-based value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and quantity- or range-based value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and quantity- or range-based value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and quantity- or range-based value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and quantity- or range-based value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,

    /// [identifier] Multiple Resources:

    /// * [CodeSystem](codesystem.html): External identifier for the code system
    /// * [ConceptMap](conceptmap.html): External identifier for the concept map
    /// * [MessageDefinition](messagedefinition.html): External identifier for the message definition
    /// * [StructureDefinition](structuredefinition.html): External identifier for the structure definition
    /// * [StructureMap](structuremap.html): External identifier for the structure map
    /// * [ValueSet](valueset.html): External identifier for the value set

    @Default([]) List<SearchParamToken> identifier,

    /// [dependson] Reference to property mapping depends on
    @Default([]) List<SearchParamUri> dependson,

    /// [other] canonical reference to an additional ConceptMap to use for mapping if the source concept is unmapped
    @Default([]) List<SearchParamReference> other,

    /// [product] Reference to property mapping depends on
    @Default([]) List<SearchParamUri> product,

    /// [source] The source value set that contains the concepts that are being mapped
    @Default([]) List<SearchParamReference> source,

    /// [sourceCode] Identifies element being mapped
    @Default([])
    @JsonKey(name: 'source-code')
        List<SearchParamToken> sourceCode,

    /// [sourceSystem] Source system where concepts to be mapped are defined
    @Default([])
    @JsonKey(name: 'source-system')
        List<SearchParamUri> sourceSystem,

    /// [sourceUri] The source value set that contains the concepts that are being mapped
    @Default([])
    @JsonKey(name: 'source-uri')
        List<SearchParamReference> sourceUri,

    /// [target] The target value set which provides context for the mappings
    @Default([]) List<SearchParamReference> target,

    /// [targetCode] Code that identifies the target element
    @Default([])
    @JsonKey(name: 'target-code')
        List<SearchParamToken> targetCode,

    /// [targetSystem] Target system that the concepts are to be mapped to
    @Default([])
    @JsonKey(name: 'target-system')
        List<SearchParamUri> targetSystem,

    /// [targetUri] The target value set which provides context for the mappings
    @Default([])
    @JsonKey(name: 'target-uri')
        List<SearchParamReference> targetUri,
  }) = _ConceptMapSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (dependson.isNotEmpty) {
      dependson.forEach(
          (element) => returnStrings.add('dependson${element.toRequest()}'));
    }
    if (other.isNotEmpty) {
      other.forEach(
          (element) => returnStrings.add('other${element.toRequest()}'));
    }
    if (product.isNotEmpty) {
      product.forEach(
          (element) => returnStrings.add('product${element.toRequest()}'));
    }
    if (source.isNotEmpty) {
      source.forEach(
          (element) => returnStrings.add('source${element.toRequest()}'));
    }
    if (sourceCode.isNotEmpty) {
      sourceCode.forEach(
          (element) => returnStrings.add('source-code${element.toRequest()}'));
    }
    if (sourceSystem.isNotEmpty) {
      sourceSystem.forEach((element) =>
          returnStrings.add('source-system${element.toRequest()}'));
    }
    if (sourceUri.isNotEmpty) {
      sourceUri.forEach(
          (element) => returnStrings.add('source-uri${element.toRequest()}'));
    }
    if (target.isNotEmpty) {
      target.forEach(
          (element) => returnStrings.add('target${element.toRequest()}'));
    }
    if (targetCode.isNotEmpty) {
      targetCode.forEach(
          (element) => returnStrings.add('target-code${element.toRequest()}'));
    }
    if (targetSystem.isNotEmpty) {
      targetSystem.forEach((element) =>
          returnStrings.add('target-system${element.toRequest()}'));
    }
    if (targetUri.isNotEmpty) {
      targetUri.forEach(
          (element) => returnStrings.add('target-uri${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class GraphDefinitionSearchParams with _$GraphDefinitionSearchParams {
  const GraphDefinitionSearchParams._();
  const factory GraphDefinitionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context assigned to the value set

    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A quantity- or range-valued use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A quantity- or range-valued use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A quantity- or range-valued use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A quantity- or range-valued use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A quantity- or range-valued use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A quantity- or range-valued use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A quantity- or range-valued use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A quantity- or range-valued use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A quantity- or range-valued use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A quantity- or range-valued use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A quantity- or range-valued use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A quantity- or range-valued use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A quantity- or range-valued use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A quantity- or range-valued use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A type of use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A type of use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A type of use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A type of use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A type of use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A type of use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A type of use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A type of use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A type of use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A type of use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A type of use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A type of use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A type of use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A type of use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The capability statement publication date
    /// * [CodeSystem](codesystem.html): The code system publication date
    /// * [CompartmentDefinition](compartmentdefinition.html): The compartment definition publication date
    /// * [ConceptMap](conceptmap.html): The concept map publication date
    /// * [GraphDefinition](graphdefinition.html): The graph definition publication date
    /// * [ImplementationGuide](implementationguide.html): The implementation guide publication date
    /// * [MessageDefinition](messagedefinition.html): The message definition publication date
    /// * [NamingSystem](namingsystem.html): The naming system publication date
    /// * [OperationDefinition](operationdefinition.html): The operation definition publication date
    /// * [SearchParameter](searchparameter.html): The search parameter publication date
    /// * [StructureDefinition](structuredefinition.html): The structure definition publication date
    /// * [StructureMap](structuremap.html): The structure map publication date
    /// * [TerminologyCapabilities](terminologycapabilities.html): The terminology capabilities publication date
    /// * [ValueSet](valueset.html): The value set publication date

    @Default([]) List<SearchParamDate> date,

    /// [description] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The description of the capability statement
    /// * [CodeSystem](codesystem.html): The description of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The description of the compartment definition
    /// * [ConceptMap](conceptmap.html): The description of the concept map
    /// * [GraphDefinition](graphdefinition.html): The description of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The description of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The description of the message definition
    /// * [NamingSystem](namingsystem.html): The description of the naming system
    /// * [OperationDefinition](operationdefinition.html): The description of the operation definition
    /// * [SearchParameter](searchparameter.html): The description of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The description of the structure definition
    /// * [StructureMap](structuremap.html): The description of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The description of the terminology capabilities
    /// * [ValueSet](valueset.html): The description of the value set

    @Default([]) List<SearchParamString> description,

    /// [jurisdiction] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Intended jurisdiction for the capability statement
    /// * [CodeSystem](codesystem.html): Intended jurisdiction for the code system
    /// * [ConceptMap](conceptmap.html): Intended jurisdiction for the concept map
    /// * [GraphDefinition](graphdefinition.html): Intended jurisdiction for the graph definition
    /// * [ImplementationGuide](implementationguide.html): Intended jurisdiction for the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Intended jurisdiction for the message definition
    /// * [NamingSystem](namingsystem.html): Intended jurisdiction for the naming system
    /// * [OperationDefinition](operationdefinition.html): Intended jurisdiction for the operation definition
    /// * [SearchParameter](searchparameter.html): Intended jurisdiction for the search parameter
    /// * [StructureDefinition](structuredefinition.html): Intended jurisdiction for the structure definition
    /// * [StructureMap](structuremap.html): Intended jurisdiction for the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Intended jurisdiction for the terminology capabilities
    /// * [ValueSet](valueset.html): Intended jurisdiction for the value set

    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Computationally friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): Computationally friendly name of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Computationally friendly name of the compartment definition
    /// * [ConceptMap](conceptmap.html): Computationally friendly name of the concept map
    /// * [GraphDefinition](graphdefinition.html): Computationally friendly name of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Computationally friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Computationally friendly name of the message definition
    /// * [NamingSystem](namingsystem.html): Computationally friendly name of the naming system
    /// * [OperationDefinition](operationdefinition.html): Computationally friendly name of the operation definition
    /// * [SearchParameter](searchparameter.html): Computationally friendly name of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Computationally friendly name of the structure definition
    /// * [StructureMap](structuremap.html): Computationally friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Computationally friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): Computationally friendly name of the value set

    @Default([]) List<SearchParamString> name,

    /// [publisher] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Name of the publisher of the capability statement
    /// * [CodeSystem](codesystem.html): Name of the publisher of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Name of the publisher of the compartment definition
    /// * [ConceptMap](conceptmap.html): Name of the publisher of the concept map
    /// * [GraphDefinition](graphdefinition.html): Name of the publisher of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Name of the publisher of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Name of the publisher of the message definition
    /// * [NamingSystem](namingsystem.html): Name of the publisher of the naming system
    /// * [OperationDefinition](operationdefinition.html): Name of the publisher of the operation definition
    /// * [SearchParameter](searchparameter.html): Name of the publisher of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Name of the publisher of the structure definition
    /// * [StructureMap](structuremap.html): Name of the publisher of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Name of the publisher of the terminology capabilities
    /// * [ValueSet](valueset.html): Name of the publisher of the value set

    @Default([]) List<SearchParamString> publisher,

    /// [status] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The current status of the capability statement
    /// * [CodeSystem](codesystem.html): The current status of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The current status of the compartment definition
    /// * [ConceptMap](conceptmap.html): The current status of the concept map
    /// * [GraphDefinition](graphdefinition.html): The current status of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The current status of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The current status of the message definition
    /// * [NamingSystem](namingsystem.html): The current status of the naming system
    /// * [OperationDefinition](operationdefinition.html): The current status of the operation definition
    /// * [SearchParameter](searchparameter.html): The current status of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The current status of the structure definition
    /// * [StructureMap](structuremap.html): The current status of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The current status of the terminology capabilities
    /// * [ValueSet](valueset.html): The current status of the value set

    @Default([]) List<SearchParamToken> status,

    /// [url] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The uri that identifies the capability statement
    /// * [CodeSystem](codesystem.html): The uri that identifies the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The uri that identifies the compartment definition
    /// * [ConceptMap](conceptmap.html): The uri that identifies the concept map
    /// * [GraphDefinition](graphdefinition.html): The uri that identifies the graph definition
    /// * [ImplementationGuide](implementationguide.html): The uri that identifies the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The uri that identifies the message definition
    /// * [OperationDefinition](operationdefinition.html): The uri that identifies the operation definition
    /// * [SearchParameter](searchparameter.html): The uri that identifies the search parameter
    /// * [StructureDefinition](structuredefinition.html): The uri that identifies the structure definition
    /// * [StructureMap](structuremap.html): The uri that identifies the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The uri that identifies the terminology capabilities
    /// * [ValueSet](valueset.html): The uri that identifies the value set

    @Default([]) List<SearchParamUri> url,

    /// [version] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The business version of the capability statement
    /// * [CodeSystem](codesystem.html): The business version of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The business version of the compartment definition
    /// * [ConceptMap](conceptmap.html): The business version of the concept map
    /// * [GraphDefinition](graphdefinition.html): The business version of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The business version of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The business version of the message definition
    /// * [OperationDefinition](operationdefinition.html): The business version of the operation definition
    /// * [SearchParameter](searchparameter.html): The business version of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The business version of the structure definition
    /// * [StructureMap](structuremap.html): The business version of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The business version of the terminology capabilities
    /// * [ValueSet](valueset.html): The business version of the value set

    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and quantity- or range-based value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and quantity- or range-based value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and quantity- or range-based value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and quantity- or range-based value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and quantity- or range-based value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and quantity- or range-based value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and quantity- or range-based value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and quantity- or range-based value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and quantity- or range-based value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and quantity- or range-based value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and quantity- or range-based value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and quantity- or range-based value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and quantity- or range-based value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and quantity- or range-based value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,

    /// [start] Type of resource at which the graph starts
    @Default([]) List<SearchParamToken> start,
  }) = _GraphDefinitionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    if (start.isNotEmpty) {
      start.forEach(
          (element) => returnStrings.add('start${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ImplementationGuideSearchParams with _$ImplementationGuideSearchParams {
  const ImplementationGuideSearchParams._();
  const factory ImplementationGuideSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context assigned to the value set

    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A quantity- or range-valued use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A quantity- or range-valued use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A quantity- or range-valued use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A quantity- or range-valued use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A quantity- or range-valued use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A quantity- or range-valued use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A quantity- or range-valued use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A quantity- or range-valued use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A quantity- or range-valued use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A quantity- or range-valued use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A quantity- or range-valued use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A quantity- or range-valued use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A quantity- or range-valued use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A quantity- or range-valued use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A type of use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A type of use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A type of use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A type of use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A type of use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A type of use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A type of use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A type of use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A type of use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A type of use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A type of use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A type of use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A type of use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A type of use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The capability statement publication date
    /// * [CodeSystem](codesystem.html): The code system publication date
    /// * [CompartmentDefinition](compartmentdefinition.html): The compartment definition publication date
    /// * [ConceptMap](conceptmap.html): The concept map publication date
    /// * [GraphDefinition](graphdefinition.html): The graph definition publication date
    /// * [ImplementationGuide](implementationguide.html): The implementation guide publication date
    /// * [MessageDefinition](messagedefinition.html): The message definition publication date
    /// * [NamingSystem](namingsystem.html): The naming system publication date
    /// * [OperationDefinition](operationdefinition.html): The operation definition publication date
    /// * [SearchParameter](searchparameter.html): The search parameter publication date
    /// * [StructureDefinition](structuredefinition.html): The structure definition publication date
    /// * [StructureMap](structuremap.html): The structure map publication date
    /// * [TerminologyCapabilities](terminologycapabilities.html): The terminology capabilities publication date
    /// * [ValueSet](valueset.html): The value set publication date

    @Default([]) List<SearchParamDate> date,

    /// [description] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The description of the capability statement
    /// * [CodeSystem](codesystem.html): The description of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The description of the compartment definition
    /// * [ConceptMap](conceptmap.html): The description of the concept map
    /// * [GraphDefinition](graphdefinition.html): The description of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The description of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The description of the message definition
    /// * [NamingSystem](namingsystem.html): The description of the naming system
    /// * [OperationDefinition](operationdefinition.html): The description of the operation definition
    /// * [SearchParameter](searchparameter.html): The description of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The description of the structure definition
    /// * [StructureMap](structuremap.html): The description of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The description of the terminology capabilities
    /// * [ValueSet](valueset.html): The description of the value set

    @Default([]) List<SearchParamString> description,

    /// [jurisdiction] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Intended jurisdiction for the capability statement
    /// * [CodeSystem](codesystem.html): Intended jurisdiction for the code system
    /// * [ConceptMap](conceptmap.html): Intended jurisdiction for the concept map
    /// * [GraphDefinition](graphdefinition.html): Intended jurisdiction for the graph definition
    /// * [ImplementationGuide](implementationguide.html): Intended jurisdiction for the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Intended jurisdiction for the message definition
    /// * [NamingSystem](namingsystem.html): Intended jurisdiction for the naming system
    /// * [OperationDefinition](operationdefinition.html): Intended jurisdiction for the operation definition
    /// * [SearchParameter](searchparameter.html): Intended jurisdiction for the search parameter
    /// * [StructureDefinition](structuredefinition.html): Intended jurisdiction for the structure definition
    /// * [StructureMap](structuremap.html): Intended jurisdiction for the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Intended jurisdiction for the terminology capabilities
    /// * [ValueSet](valueset.html): Intended jurisdiction for the value set

    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Computationally friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): Computationally friendly name of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Computationally friendly name of the compartment definition
    /// * [ConceptMap](conceptmap.html): Computationally friendly name of the concept map
    /// * [GraphDefinition](graphdefinition.html): Computationally friendly name of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Computationally friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Computationally friendly name of the message definition
    /// * [NamingSystem](namingsystem.html): Computationally friendly name of the naming system
    /// * [OperationDefinition](operationdefinition.html): Computationally friendly name of the operation definition
    /// * [SearchParameter](searchparameter.html): Computationally friendly name of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Computationally friendly name of the structure definition
    /// * [StructureMap](structuremap.html): Computationally friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Computationally friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): Computationally friendly name of the value set

    @Default([]) List<SearchParamString> name,

    /// [publisher] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Name of the publisher of the capability statement
    /// * [CodeSystem](codesystem.html): Name of the publisher of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Name of the publisher of the compartment definition
    /// * [ConceptMap](conceptmap.html): Name of the publisher of the concept map
    /// * [GraphDefinition](graphdefinition.html): Name of the publisher of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Name of the publisher of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Name of the publisher of the message definition
    /// * [NamingSystem](namingsystem.html): Name of the publisher of the naming system
    /// * [OperationDefinition](operationdefinition.html): Name of the publisher of the operation definition
    /// * [SearchParameter](searchparameter.html): Name of the publisher of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Name of the publisher of the structure definition
    /// * [StructureMap](structuremap.html): Name of the publisher of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Name of the publisher of the terminology capabilities
    /// * [ValueSet](valueset.html): Name of the publisher of the value set

    @Default([]) List<SearchParamString> publisher,

    /// [status] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The current status of the capability statement
    /// * [CodeSystem](codesystem.html): The current status of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The current status of the compartment definition
    /// * [ConceptMap](conceptmap.html): The current status of the concept map
    /// * [GraphDefinition](graphdefinition.html): The current status of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The current status of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The current status of the message definition
    /// * [NamingSystem](namingsystem.html): The current status of the naming system
    /// * [OperationDefinition](operationdefinition.html): The current status of the operation definition
    /// * [SearchParameter](searchparameter.html): The current status of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The current status of the structure definition
    /// * [StructureMap](structuremap.html): The current status of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The current status of the terminology capabilities
    /// * [ValueSet](valueset.html): The current status of the value set

    @Default([]) List<SearchParamToken> status,

    /// [title] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The human-friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): The human-friendly name of the code system
    /// * [ConceptMap](conceptmap.html): The human-friendly name of the concept map
    /// * [ImplementationGuide](implementationguide.html): The human-friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The human-friendly name of the message definition
    /// * [OperationDefinition](operationdefinition.html): The human-friendly name of the operation definition
    /// * [StructureDefinition](structuredefinition.html): The human-friendly name of the structure definition
    /// * [StructureMap](structuremap.html): The human-friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The human-friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): The human-friendly name of the value set

    @Default([]) List<SearchParamString> title,

    /// [url] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The uri that identifies the capability statement
    /// * [CodeSystem](codesystem.html): The uri that identifies the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The uri that identifies the compartment definition
    /// * [ConceptMap](conceptmap.html): The uri that identifies the concept map
    /// * [GraphDefinition](graphdefinition.html): The uri that identifies the graph definition
    /// * [ImplementationGuide](implementationguide.html): The uri that identifies the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The uri that identifies the message definition
    /// * [OperationDefinition](operationdefinition.html): The uri that identifies the operation definition
    /// * [SearchParameter](searchparameter.html): The uri that identifies the search parameter
    /// * [StructureDefinition](structuredefinition.html): The uri that identifies the structure definition
    /// * [StructureMap](structuremap.html): The uri that identifies the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The uri that identifies the terminology capabilities
    /// * [ValueSet](valueset.html): The uri that identifies the value set

    @Default([]) List<SearchParamUri> url,

    /// [version] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The business version of the capability statement
    /// * [CodeSystem](codesystem.html): The business version of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The business version of the compartment definition
    /// * [ConceptMap](conceptmap.html): The business version of the concept map
    /// * [GraphDefinition](graphdefinition.html): The business version of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The business version of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The business version of the message definition
    /// * [OperationDefinition](operationdefinition.html): The business version of the operation definition
    /// * [SearchParameter](searchparameter.html): The business version of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The business version of the structure definition
    /// * [StructureMap](structuremap.html): The business version of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The business version of the terminology capabilities
    /// * [ValueSet](valueset.html): The business version of the value set

    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and quantity- or range-based value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and quantity- or range-based value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and quantity- or range-based value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and quantity- or range-based value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and quantity- or range-based value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and quantity- or range-based value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and quantity- or range-based value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and quantity- or range-based value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and quantity- or range-based value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and quantity- or range-based value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and quantity- or range-based value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and quantity- or range-based value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and quantity- or range-based value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and quantity- or range-based value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,

    /// [dependsOn] Identity of the IG that this depends on
    @Default([])
    @JsonKey(name: 'depends-on')
        List<SearchParamReference> dependsOn,

    /// [experimental] For testing purposes, not real usage
    @Default([]) List<SearchParamToken> experimental,

    /// [global] Profile that all resources must conform to
    @Default([]) List<SearchParamReference> global,

    /// [resource] Location of the resource
    @Default([]) List<SearchParamReference> resource,
  }) = _ImplementationGuideSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    if (dependsOn.isNotEmpty) {
      dependsOn.forEach(
          (element) => returnStrings.add('depends-on${element.toRequest()}'));
    }
    if (experimental.isNotEmpty) {
      experimental.forEach(
          (element) => returnStrings.add('experimental${element.toRequest()}'));
    }
    if (global.isNotEmpty) {
      global.forEach(
          (element) => returnStrings.add('global${element.toRequest()}'));
    }
    if (resource.isNotEmpty) {
      resource.forEach(
          (element) => returnStrings.add('resource${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class MessageDefinitionSearchParams with _$MessageDefinitionSearchParams {
  const MessageDefinitionSearchParams._();
  const factory MessageDefinitionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context assigned to the value set

    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A quantity- or range-valued use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A quantity- or range-valued use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A quantity- or range-valued use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A quantity- or range-valued use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A quantity- or range-valued use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A quantity- or range-valued use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A quantity- or range-valued use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A quantity- or range-valued use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A quantity- or range-valued use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A quantity- or range-valued use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A quantity- or range-valued use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A quantity- or range-valued use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A quantity- or range-valued use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A quantity- or range-valued use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A type of use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A type of use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A type of use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A type of use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A type of use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A type of use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A type of use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A type of use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A type of use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A type of use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A type of use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A type of use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A type of use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A type of use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The capability statement publication date
    /// * [CodeSystem](codesystem.html): The code system publication date
    /// * [CompartmentDefinition](compartmentdefinition.html): The compartment definition publication date
    /// * [ConceptMap](conceptmap.html): The concept map publication date
    /// * [GraphDefinition](graphdefinition.html): The graph definition publication date
    /// * [ImplementationGuide](implementationguide.html): The implementation guide publication date
    /// * [MessageDefinition](messagedefinition.html): The message definition publication date
    /// * [NamingSystem](namingsystem.html): The naming system publication date
    /// * [OperationDefinition](operationdefinition.html): The operation definition publication date
    /// * [SearchParameter](searchparameter.html): The search parameter publication date
    /// * [StructureDefinition](structuredefinition.html): The structure definition publication date
    /// * [StructureMap](structuremap.html): The structure map publication date
    /// * [TerminologyCapabilities](terminologycapabilities.html): The terminology capabilities publication date
    /// * [ValueSet](valueset.html): The value set publication date

    @Default([]) List<SearchParamDate> date,

    /// [description] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The description of the capability statement
    /// * [CodeSystem](codesystem.html): The description of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The description of the compartment definition
    /// * [ConceptMap](conceptmap.html): The description of the concept map
    /// * [GraphDefinition](graphdefinition.html): The description of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The description of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The description of the message definition
    /// * [NamingSystem](namingsystem.html): The description of the naming system
    /// * [OperationDefinition](operationdefinition.html): The description of the operation definition
    /// * [SearchParameter](searchparameter.html): The description of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The description of the structure definition
    /// * [StructureMap](structuremap.html): The description of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The description of the terminology capabilities
    /// * [ValueSet](valueset.html): The description of the value set

    @Default([]) List<SearchParamString> description,

    /// [jurisdiction] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Intended jurisdiction for the capability statement
    /// * [CodeSystem](codesystem.html): Intended jurisdiction for the code system
    /// * [ConceptMap](conceptmap.html): Intended jurisdiction for the concept map
    /// * [GraphDefinition](graphdefinition.html): Intended jurisdiction for the graph definition
    /// * [ImplementationGuide](implementationguide.html): Intended jurisdiction for the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Intended jurisdiction for the message definition
    /// * [NamingSystem](namingsystem.html): Intended jurisdiction for the naming system
    /// * [OperationDefinition](operationdefinition.html): Intended jurisdiction for the operation definition
    /// * [SearchParameter](searchparameter.html): Intended jurisdiction for the search parameter
    /// * [StructureDefinition](structuredefinition.html): Intended jurisdiction for the structure definition
    /// * [StructureMap](structuremap.html): Intended jurisdiction for the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Intended jurisdiction for the terminology capabilities
    /// * [ValueSet](valueset.html): Intended jurisdiction for the value set

    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Computationally friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): Computationally friendly name of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Computationally friendly name of the compartment definition
    /// * [ConceptMap](conceptmap.html): Computationally friendly name of the concept map
    /// * [GraphDefinition](graphdefinition.html): Computationally friendly name of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Computationally friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Computationally friendly name of the message definition
    /// * [NamingSystem](namingsystem.html): Computationally friendly name of the naming system
    /// * [OperationDefinition](operationdefinition.html): Computationally friendly name of the operation definition
    /// * [SearchParameter](searchparameter.html): Computationally friendly name of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Computationally friendly name of the structure definition
    /// * [StructureMap](structuremap.html): Computationally friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Computationally friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): Computationally friendly name of the value set

    @Default([]) List<SearchParamString> name,

    /// [publisher] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Name of the publisher of the capability statement
    /// * [CodeSystem](codesystem.html): Name of the publisher of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Name of the publisher of the compartment definition
    /// * [ConceptMap](conceptmap.html): Name of the publisher of the concept map
    /// * [GraphDefinition](graphdefinition.html): Name of the publisher of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Name of the publisher of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Name of the publisher of the message definition
    /// * [NamingSystem](namingsystem.html): Name of the publisher of the naming system
    /// * [OperationDefinition](operationdefinition.html): Name of the publisher of the operation definition
    /// * [SearchParameter](searchparameter.html): Name of the publisher of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Name of the publisher of the structure definition
    /// * [StructureMap](structuremap.html): Name of the publisher of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Name of the publisher of the terminology capabilities
    /// * [ValueSet](valueset.html): Name of the publisher of the value set

    @Default([]) List<SearchParamString> publisher,

    /// [status] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The current status of the capability statement
    /// * [CodeSystem](codesystem.html): The current status of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The current status of the compartment definition
    /// * [ConceptMap](conceptmap.html): The current status of the concept map
    /// * [GraphDefinition](graphdefinition.html): The current status of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The current status of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The current status of the message definition
    /// * [NamingSystem](namingsystem.html): The current status of the naming system
    /// * [OperationDefinition](operationdefinition.html): The current status of the operation definition
    /// * [SearchParameter](searchparameter.html): The current status of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The current status of the structure definition
    /// * [StructureMap](structuremap.html): The current status of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The current status of the terminology capabilities
    /// * [ValueSet](valueset.html): The current status of the value set

    @Default([]) List<SearchParamToken> status,

    /// [title] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The human-friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): The human-friendly name of the code system
    /// * [ConceptMap](conceptmap.html): The human-friendly name of the concept map
    /// * [ImplementationGuide](implementationguide.html): The human-friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The human-friendly name of the message definition
    /// * [OperationDefinition](operationdefinition.html): The human-friendly name of the operation definition
    /// * [StructureDefinition](structuredefinition.html): The human-friendly name of the structure definition
    /// * [StructureMap](structuremap.html): The human-friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The human-friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): The human-friendly name of the value set

    @Default([]) List<SearchParamString> title,

    /// [url] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The uri that identifies the capability statement
    /// * [CodeSystem](codesystem.html): The uri that identifies the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The uri that identifies the compartment definition
    /// * [ConceptMap](conceptmap.html): The uri that identifies the concept map
    /// * [GraphDefinition](graphdefinition.html): The uri that identifies the graph definition
    /// * [ImplementationGuide](implementationguide.html): The uri that identifies the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The uri that identifies the message definition
    /// * [OperationDefinition](operationdefinition.html): The uri that identifies the operation definition
    /// * [SearchParameter](searchparameter.html): The uri that identifies the search parameter
    /// * [StructureDefinition](structuredefinition.html): The uri that identifies the structure definition
    /// * [StructureMap](structuremap.html): The uri that identifies the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The uri that identifies the terminology capabilities
    /// * [ValueSet](valueset.html): The uri that identifies the value set

    @Default([]) List<SearchParamUri> url,

    /// [version] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The business version of the capability statement
    /// * [CodeSystem](codesystem.html): The business version of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The business version of the compartment definition
    /// * [ConceptMap](conceptmap.html): The business version of the concept map
    /// * [GraphDefinition](graphdefinition.html): The business version of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The business version of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The business version of the message definition
    /// * [OperationDefinition](operationdefinition.html): The business version of the operation definition
    /// * [SearchParameter](searchparameter.html): The business version of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The business version of the structure definition
    /// * [StructureMap](structuremap.html): The business version of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The business version of the terminology capabilities
    /// * [ValueSet](valueset.html): The business version of the value set

    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and quantity- or range-based value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and quantity- or range-based value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and quantity- or range-based value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and quantity- or range-based value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and quantity- or range-based value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and quantity- or range-based value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and quantity- or range-based value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and quantity- or range-based value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and quantity- or range-based value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and quantity- or range-based value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and quantity- or range-based value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and quantity- or range-based value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and quantity- or range-based value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and quantity- or range-based value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,

    /// [identifier] Multiple Resources:

    /// * [CodeSystem](codesystem.html): External identifier for the code system
    /// * [ConceptMap](conceptmap.html): External identifier for the concept map
    /// * [MessageDefinition](messagedefinition.html): External identifier for the message definition
    /// * [StructureDefinition](structuredefinition.html): External identifier for the structure definition
    /// * [StructureMap](structuremap.html): External identifier for the structure map
    /// * [ValueSet](valueset.html): External identifier for the value set

    @Default([]) List<SearchParamToken> identifier,

    /// [category] The behavior associated with the message
    @Default([]) List<SearchParamToken> category,

    /// [event] The event that triggers the message or link to the event definition.
    @Default([]) List<SearchParamToken> event,

    /// [focus] A resource that is a permitted focus of the message
    @Default([]) List<SearchParamToken> focus,

    /// [parent] A resource that is the parent of the definition
    @Default([]) List<SearchParamReference> parent,
  }) = _MessageDefinitionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (event.isNotEmpty) {
      event.forEach(
          (element) => returnStrings.add('event${element.toRequest()}'));
    }
    if (focus.isNotEmpty) {
      focus.forEach(
          (element) => returnStrings.add('focus${element.toRequest()}'));
    }
    if (parent.isNotEmpty) {
      parent.forEach(
          (element) => returnStrings.add('parent${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class NamingSystemSearchParams with _$NamingSystemSearchParams {
  const NamingSystemSearchParams._();
  const factory NamingSystemSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context assigned to the value set

    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A quantity- or range-valued use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A quantity- or range-valued use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A quantity- or range-valued use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A quantity- or range-valued use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A quantity- or range-valued use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A quantity- or range-valued use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A quantity- or range-valued use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A quantity- or range-valued use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A quantity- or range-valued use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A quantity- or range-valued use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A quantity- or range-valued use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A quantity- or range-valued use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A quantity- or range-valued use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A quantity- or range-valued use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A type of use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A type of use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A type of use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A type of use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A type of use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A type of use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A type of use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A type of use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A type of use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A type of use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A type of use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A type of use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A type of use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A type of use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The capability statement publication date
    /// * [CodeSystem](codesystem.html): The code system publication date
    /// * [CompartmentDefinition](compartmentdefinition.html): The compartment definition publication date
    /// * [ConceptMap](conceptmap.html): The concept map publication date
    /// * [GraphDefinition](graphdefinition.html): The graph definition publication date
    /// * [ImplementationGuide](implementationguide.html): The implementation guide publication date
    /// * [MessageDefinition](messagedefinition.html): The message definition publication date
    /// * [NamingSystem](namingsystem.html): The naming system publication date
    /// * [OperationDefinition](operationdefinition.html): The operation definition publication date
    /// * [SearchParameter](searchparameter.html): The search parameter publication date
    /// * [StructureDefinition](structuredefinition.html): The structure definition publication date
    /// * [StructureMap](structuremap.html): The structure map publication date
    /// * [TerminologyCapabilities](terminologycapabilities.html): The terminology capabilities publication date
    /// * [ValueSet](valueset.html): The value set publication date

    @Default([]) List<SearchParamDate> date,

    /// [description] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The description of the capability statement
    /// * [CodeSystem](codesystem.html): The description of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The description of the compartment definition
    /// * [ConceptMap](conceptmap.html): The description of the concept map
    /// * [GraphDefinition](graphdefinition.html): The description of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The description of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The description of the message definition
    /// * [NamingSystem](namingsystem.html): The description of the naming system
    /// * [OperationDefinition](operationdefinition.html): The description of the operation definition
    /// * [SearchParameter](searchparameter.html): The description of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The description of the structure definition
    /// * [StructureMap](structuremap.html): The description of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The description of the terminology capabilities
    /// * [ValueSet](valueset.html): The description of the value set

    @Default([]) List<SearchParamString> description,

    /// [jurisdiction] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Intended jurisdiction for the capability statement
    /// * [CodeSystem](codesystem.html): Intended jurisdiction for the code system
    /// * [ConceptMap](conceptmap.html): Intended jurisdiction for the concept map
    /// * [GraphDefinition](graphdefinition.html): Intended jurisdiction for the graph definition
    /// * [ImplementationGuide](implementationguide.html): Intended jurisdiction for the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Intended jurisdiction for the message definition
    /// * [NamingSystem](namingsystem.html): Intended jurisdiction for the naming system
    /// * [OperationDefinition](operationdefinition.html): Intended jurisdiction for the operation definition
    /// * [SearchParameter](searchparameter.html): Intended jurisdiction for the search parameter
    /// * [StructureDefinition](structuredefinition.html): Intended jurisdiction for the structure definition
    /// * [StructureMap](structuremap.html): Intended jurisdiction for the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Intended jurisdiction for the terminology capabilities
    /// * [ValueSet](valueset.html): Intended jurisdiction for the value set

    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Computationally friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): Computationally friendly name of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Computationally friendly name of the compartment definition
    /// * [ConceptMap](conceptmap.html): Computationally friendly name of the concept map
    /// * [GraphDefinition](graphdefinition.html): Computationally friendly name of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Computationally friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Computationally friendly name of the message definition
    /// * [NamingSystem](namingsystem.html): Computationally friendly name of the naming system
    /// * [OperationDefinition](operationdefinition.html): Computationally friendly name of the operation definition
    /// * [SearchParameter](searchparameter.html): Computationally friendly name of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Computationally friendly name of the structure definition
    /// * [StructureMap](structuremap.html): Computationally friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Computationally friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): Computationally friendly name of the value set

    @Default([]) List<SearchParamString> name,

    /// [publisher] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Name of the publisher of the capability statement
    /// * [CodeSystem](codesystem.html): Name of the publisher of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Name of the publisher of the compartment definition
    /// * [ConceptMap](conceptmap.html): Name of the publisher of the concept map
    /// * [GraphDefinition](graphdefinition.html): Name of the publisher of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Name of the publisher of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Name of the publisher of the message definition
    /// * [NamingSystem](namingsystem.html): Name of the publisher of the naming system
    /// * [OperationDefinition](operationdefinition.html): Name of the publisher of the operation definition
    /// * [SearchParameter](searchparameter.html): Name of the publisher of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Name of the publisher of the structure definition
    /// * [StructureMap](structuremap.html): Name of the publisher of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Name of the publisher of the terminology capabilities
    /// * [ValueSet](valueset.html): Name of the publisher of the value set

    @Default([]) List<SearchParamString> publisher,

    /// [status] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The current status of the capability statement
    /// * [CodeSystem](codesystem.html): The current status of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The current status of the compartment definition
    /// * [ConceptMap](conceptmap.html): The current status of the concept map
    /// * [GraphDefinition](graphdefinition.html): The current status of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The current status of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The current status of the message definition
    /// * [NamingSystem](namingsystem.html): The current status of the naming system
    /// * [OperationDefinition](operationdefinition.html): The current status of the operation definition
    /// * [SearchParameter](searchparameter.html): The current status of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The current status of the structure definition
    /// * [StructureMap](structuremap.html): The current status of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The current status of the terminology capabilities
    /// * [ValueSet](valueset.html): The current status of the value set

    @Default([]) List<SearchParamToken> status,

    /// [contextTypeQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and quantity- or range-based value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and quantity- or range-based value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and quantity- or range-based value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and quantity- or range-based value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and quantity- or range-based value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and quantity- or range-based value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and quantity- or range-based value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and quantity- or range-based value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and quantity- or range-based value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and quantity- or range-based value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and quantity- or range-based value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and quantity- or range-based value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and quantity- or range-based value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and quantity- or range-based value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,

    /// [contact] Name of an individual to contact
    @Default([]) List<SearchParamString> contact,

    /// [idType] oid | uuid | uri | other
    @Default([]) @JsonKey(name: 'id-type') List<SearchParamToken> idType,

    /// [kind] codesystem | identifier | root
    @Default([]) List<SearchParamToken> kind,

    /// [period] When is identifier valid?
    @Default([]) List<SearchParamDate> period,

    /// [responsible] Who maintains system namespace?
    @Default([]) List<SearchParamString> responsible,

    /// [telecom] Contact details for individual or organization
    @Default([]) List<SearchParamToken> telecom,

    /// [type] e.g. driver,  provider,  patient, bank etc.
    @Default([]) List<SearchParamToken> type,

    /// [value] The unique identifier
    @Default([]) List<SearchParamString> value,
  }) = _NamingSystemSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    if (contact.isNotEmpty) {
      contact.forEach(
          (element) => returnStrings.add('contact${element.toRequest()}'));
    }
    if (idType.isNotEmpty) {
      idType.forEach(
          (element) => returnStrings.add('id-type${element.toRequest()}'));
    }
    if (kind.isNotEmpty) {
      kind.forEach(
          (element) => returnStrings.add('kind${element.toRequest()}'));
    }
    if (period.isNotEmpty) {
      period.forEach(
          (element) => returnStrings.add('period${element.toRequest()}'));
    }
    if (responsible.isNotEmpty) {
      responsible.forEach(
          (element) => returnStrings.add('responsible${element.toRequest()}'));
    }
    if (telecom.isNotEmpty) {
      telecom.forEach(
          (element) => returnStrings.add('telecom${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    if (value.isNotEmpty) {
      value.forEach(
          (element) => returnStrings.add('value${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class OperationDefinitionSearchParams with _$OperationDefinitionSearchParams {
  const OperationDefinitionSearchParams._();
  const factory OperationDefinitionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context assigned to the value set

    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A quantity- or range-valued use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A quantity- or range-valued use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A quantity- or range-valued use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A quantity- or range-valued use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A quantity- or range-valued use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A quantity- or range-valued use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A quantity- or range-valued use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A quantity- or range-valued use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A quantity- or range-valued use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A quantity- or range-valued use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A quantity- or range-valued use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A quantity- or range-valued use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A quantity- or range-valued use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A quantity- or range-valued use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A type of use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A type of use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A type of use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A type of use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A type of use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A type of use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A type of use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A type of use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A type of use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A type of use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A type of use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A type of use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A type of use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A type of use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The capability statement publication date
    /// * [CodeSystem](codesystem.html): The code system publication date
    /// * [CompartmentDefinition](compartmentdefinition.html): The compartment definition publication date
    /// * [ConceptMap](conceptmap.html): The concept map publication date
    /// * [GraphDefinition](graphdefinition.html): The graph definition publication date
    /// * [ImplementationGuide](implementationguide.html): The implementation guide publication date
    /// * [MessageDefinition](messagedefinition.html): The message definition publication date
    /// * [NamingSystem](namingsystem.html): The naming system publication date
    /// * [OperationDefinition](operationdefinition.html): The operation definition publication date
    /// * [SearchParameter](searchparameter.html): The search parameter publication date
    /// * [StructureDefinition](structuredefinition.html): The structure definition publication date
    /// * [StructureMap](structuremap.html): The structure map publication date
    /// * [TerminologyCapabilities](terminologycapabilities.html): The terminology capabilities publication date
    /// * [ValueSet](valueset.html): The value set publication date

    @Default([]) List<SearchParamDate> date,

    /// [description] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The description of the capability statement
    /// * [CodeSystem](codesystem.html): The description of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The description of the compartment definition
    /// * [ConceptMap](conceptmap.html): The description of the concept map
    /// * [GraphDefinition](graphdefinition.html): The description of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The description of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The description of the message definition
    /// * [NamingSystem](namingsystem.html): The description of the naming system
    /// * [OperationDefinition](operationdefinition.html): The description of the operation definition
    /// * [SearchParameter](searchparameter.html): The description of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The description of the structure definition
    /// * [StructureMap](structuremap.html): The description of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The description of the terminology capabilities
    /// * [ValueSet](valueset.html): The description of the value set

    @Default([]) List<SearchParamString> description,

    /// [jurisdiction] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Intended jurisdiction for the capability statement
    /// * [CodeSystem](codesystem.html): Intended jurisdiction for the code system
    /// * [ConceptMap](conceptmap.html): Intended jurisdiction for the concept map
    /// * [GraphDefinition](graphdefinition.html): Intended jurisdiction for the graph definition
    /// * [ImplementationGuide](implementationguide.html): Intended jurisdiction for the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Intended jurisdiction for the message definition
    /// * [NamingSystem](namingsystem.html): Intended jurisdiction for the naming system
    /// * [OperationDefinition](operationdefinition.html): Intended jurisdiction for the operation definition
    /// * [SearchParameter](searchparameter.html): Intended jurisdiction for the search parameter
    /// * [StructureDefinition](structuredefinition.html): Intended jurisdiction for the structure definition
    /// * [StructureMap](structuremap.html): Intended jurisdiction for the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Intended jurisdiction for the terminology capabilities
    /// * [ValueSet](valueset.html): Intended jurisdiction for the value set

    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Computationally friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): Computationally friendly name of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Computationally friendly name of the compartment definition
    /// * [ConceptMap](conceptmap.html): Computationally friendly name of the concept map
    /// * [GraphDefinition](graphdefinition.html): Computationally friendly name of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Computationally friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Computationally friendly name of the message definition
    /// * [NamingSystem](namingsystem.html): Computationally friendly name of the naming system
    /// * [OperationDefinition](operationdefinition.html): Computationally friendly name of the operation definition
    /// * [SearchParameter](searchparameter.html): Computationally friendly name of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Computationally friendly name of the structure definition
    /// * [StructureMap](structuremap.html): Computationally friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Computationally friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): Computationally friendly name of the value set

    @Default([]) List<SearchParamString> name,

    /// [publisher] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Name of the publisher of the capability statement
    /// * [CodeSystem](codesystem.html): Name of the publisher of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Name of the publisher of the compartment definition
    /// * [ConceptMap](conceptmap.html): Name of the publisher of the concept map
    /// * [GraphDefinition](graphdefinition.html): Name of the publisher of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Name of the publisher of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Name of the publisher of the message definition
    /// * [NamingSystem](namingsystem.html): Name of the publisher of the naming system
    /// * [OperationDefinition](operationdefinition.html): Name of the publisher of the operation definition
    /// * [SearchParameter](searchparameter.html): Name of the publisher of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Name of the publisher of the structure definition
    /// * [StructureMap](structuremap.html): Name of the publisher of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Name of the publisher of the terminology capabilities
    /// * [ValueSet](valueset.html): Name of the publisher of the value set

    @Default([]) List<SearchParamString> publisher,

    /// [status] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The current status of the capability statement
    /// * [CodeSystem](codesystem.html): The current status of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The current status of the compartment definition
    /// * [ConceptMap](conceptmap.html): The current status of the concept map
    /// * [GraphDefinition](graphdefinition.html): The current status of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The current status of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The current status of the message definition
    /// * [NamingSystem](namingsystem.html): The current status of the naming system
    /// * [OperationDefinition](operationdefinition.html): The current status of the operation definition
    /// * [SearchParameter](searchparameter.html): The current status of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The current status of the structure definition
    /// * [StructureMap](structuremap.html): The current status of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The current status of the terminology capabilities
    /// * [ValueSet](valueset.html): The current status of the value set

    @Default([]) List<SearchParamToken> status,

    /// [title] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The human-friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): The human-friendly name of the code system
    /// * [ConceptMap](conceptmap.html): The human-friendly name of the concept map
    /// * [ImplementationGuide](implementationguide.html): The human-friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The human-friendly name of the message definition
    /// * [OperationDefinition](operationdefinition.html): The human-friendly name of the operation definition
    /// * [StructureDefinition](structuredefinition.html): The human-friendly name of the structure definition
    /// * [StructureMap](structuremap.html): The human-friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The human-friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): The human-friendly name of the value set

    @Default([]) List<SearchParamString> title,

    /// [url] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The uri that identifies the capability statement
    /// * [CodeSystem](codesystem.html): The uri that identifies the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The uri that identifies the compartment definition
    /// * [ConceptMap](conceptmap.html): The uri that identifies the concept map
    /// * [GraphDefinition](graphdefinition.html): The uri that identifies the graph definition
    /// * [ImplementationGuide](implementationguide.html): The uri that identifies the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The uri that identifies the message definition
    /// * [OperationDefinition](operationdefinition.html): The uri that identifies the operation definition
    /// * [SearchParameter](searchparameter.html): The uri that identifies the search parameter
    /// * [StructureDefinition](structuredefinition.html): The uri that identifies the structure definition
    /// * [StructureMap](structuremap.html): The uri that identifies the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The uri that identifies the terminology capabilities
    /// * [ValueSet](valueset.html): The uri that identifies the value set

    @Default([]) List<SearchParamUri> url,

    /// [version] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The business version of the capability statement
    /// * [CodeSystem](codesystem.html): The business version of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The business version of the compartment definition
    /// * [ConceptMap](conceptmap.html): The business version of the concept map
    /// * [GraphDefinition](graphdefinition.html): The business version of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The business version of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The business version of the message definition
    /// * [OperationDefinition](operationdefinition.html): The business version of the operation definition
    /// * [SearchParameter](searchparameter.html): The business version of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The business version of the structure definition
    /// * [StructureMap](structuremap.html): The business version of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The business version of the terminology capabilities
    /// * [ValueSet](valueset.html): The business version of the value set

    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and quantity- or range-based value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and quantity- or range-based value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and quantity- or range-based value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and quantity- or range-based value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and quantity- or range-based value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and quantity- or range-based value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and quantity- or range-based value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and quantity- or range-based value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and quantity- or range-based value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and quantity- or range-based value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and quantity- or range-based value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and quantity- or range-based value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and quantity- or range-based value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and quantity- or range-based value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,

    /// [base] Marks this as a profile of the base
    @Default([]) List<SearchParamReference> base,

    /// [code] Name used to invoke the operation
    @Default([]) List<SearchParamToken> code,

    /// [inputProfile] Validation information for in parameters
    @Default([])
    @JsonKey(name: 'input-profile')
        List<SearchParamReference> inputProfile,

    /// [instance] Invoke on an instance?
    @Default([]) List<SearchParamToken> instance,

    /// [kind] operation | query
    @Default([]) List<SearchParamToken> kind,

    /// [outputProfile] Validation information for out parameters
    @Default([])
    @JsonKey(name: 'output-profile')
        List<SearchParamReference> outputProfile,

    /// [system] Invoke at the system level?
    @Default([]) List<SearchParamToken> system,

    /// [type] Invoke at the type level?
    @Default([]) List<SearchParamToken> type,
  }) = _OperationDefinitionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    if (base.isNotEmpty) {
      base.forEach(
          (element) => returnStrings.add('base${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (inputProfile.isNotEmpty) {
      inputProfile.forEach((element) =>
          returnStrings.add('input-profile${element.toRequest()}'));
    }
    if (instance.isNotEmpty) {
      instance.forEach(
          (element) => returnStrings.add('instance${element.toRequest()}'));
    }
    if (kind.isNotEmpty) {
      kind.forEach(
          (element) => returnStrings.add('kind${element.toRequest()}'));
    }
    if (outputProfile.isNotEmpty) {
      outputProfile.forEach((element) =>
          returnStrings.add('output-profile${element.toRequest()}'));
    }
    if (system.isNotEmpty) {
      system.forEach(
          (element) => returnStrings.add('system${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class SearchParameterSearchParams with _$SearchParameterSearchParams {
  const SearchParameterSearchParams._();
  const factory SearchParameterSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context assigned to the value set

    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A quantity- or range-valued use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A quantity- or range-valued use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A quantity- or range-valued use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A quantity- or range-valued use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A quantity- or range-valued use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A quantity- or range-valued use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A quantity- or range-valued use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A quantity- or range-valued use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A quantity- or range-valued use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A quantity- or range-valued use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A quantity- or range-valued use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A quantity- or range-valued use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A quantity- or range-valued use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A quantity- or range-valued use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A type of use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A type of use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A type of use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A type of use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A type of use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A type of use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A type of use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A type of use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A type of use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A type of use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A type of use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A type of use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A type of use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A type of use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The capability statement publication date
    /// * [CodeSystem](codesystem.html): The code system publication date
    /// * [CompartmentDefinition](compartmentdefinition.html): The compartment definition publication date
    /// * [ConceptMap](conceptmap.html): The concept map publication date
    /// * [GraphDefinition](graphdefinition.html): The graph definition publication date
    /// * [ImplementationGuide](implementationguide.html): The implementation guide publication date
    /// * [MessageDefinition](messagedefinition.html): The message definition publication date
    /// * [NamingSystem](namingsystem.html): The naming system publication date
    /// * [OperationDefinition](operationdefinition.html): The operation definition publication date
    /// * [SearchParameter](searchparameter.html): The search parameter publication date
    /// * [StructureDefinition](structuredefinition.html): The structure definition publication date
    /// * [StructureMap](structuremap.html): The structure map publication date
    /// * [TerminologyCapabilities](terminologycapabilities.html): The terminology capabilities publication date
    /// * [ValueSet](valueset.html): The value set publication date

    @Default([]) List<SearchParamDate> date,

    /// [description] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The description of the capability statement
    /// * [CodeSystem](codesystem.html): The description of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The description of the compartment definition
    /// * [ConceptMap](conceptmap.html): The description of the concept map
    /// * [GraphDefinition](graphdefinition.html): The description of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The description of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The description of the message definition
    /// * [NamingSystem](namingsystem.html): The description of the naming system
    /// * [OperationDefinition](operationdefinition.html): The description of the operation definition
    /// * [SearchParameter](searchparameter.html): The description of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The description of the structure definition
    /// * [StructureMap](structuremap.html): The description of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The description of the terminology capabilities
    /// * [ValueSet](valueset.html): The description of the value set

    @Default([]) List<SearchParamString> description,

    /// [jurisdiction] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Intended jurisdiction for the capability statement
    /// * [CodeSystem](codesystem.html): Intended jurisdiction for the code system
    /// * [ConceptMap](conceptmap.html): Intended jurisdiction for the concept map
    /// * [GraphDefinition](graphdefinition.html): Intended jurisdiction for the graph definition
    /// * [ImplementationGuide](implementationguide.html): Intended jurisdiction for the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Intended jurisdiction for the message definition
    /// * [NamingSystem](namingsystem.html): Intended jurisdiction for the naming system
    /// * [OperationDefinition](operationdefinition.html): Intended jurisdiction for the operation definition
    /// * [SearchParameter](searchparameter.html): Intended jurisdiction for the search parameter
    /// * [StructureDefinition](structuredefinition.html): Intended jurisdiction for the structure definition
    /// * [StructureMap](structuremap.html): Intended jurisdiction for the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Intended jurisdiction for the terminology capabilities
    /// * [ValueSet](valueset.html): Intended jurisdiction for the value set

    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Computationally friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): Computationally friendly name of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Computationally friendly name of the compartment definition
    /// * [ConceptMap](conceptmap.html): Computationally friendly name of the concept map
    /// * [GraphDefinition](graphdefinition.html): Computationally friendly name of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Computationally friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Computationally friendly name of the message definition
    /// * [NamingSystem](namingsystem.html): Computationally friendly name of the naming system
    /// * [OperationDefinition](operationdefinition.html): Computationally friendly name of the operation definition
    /// * [SearchParameter](searchparameter.html): Computationally friendly name of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Computationally friendly name of the structure definition
    /// * [StructureMap](structuremap.html): Computationally friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Computationally friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): Computationally friendly name of the value set

    @Default([]) List<SearchParamString> name,

    /// [publisher] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Name of the publisher of the capability statement
    /// * [CodeSystem](codesystem.html): Name of the publisher of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Name of the publisher of the compartment definition
    /// * [ConceptMap](conceptmap.html): Name of the publisher of the concept map
    /// * [GraphDefinition](graphdefinition.html): Name of the publisher of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Name of the publisher of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Name of the publisher of the message definition
    /// * [NamingSystem](namingsystem.html): Name of the publisher of the naming system
    /// * [OperationDefinition](operationdefinition.html): Name of the publisher of the operation definition
    /// * [SearchParameter](searchparameter.html): Name of the publisher of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Name of the publisher of the structure definition
    /// * [StructureMap](structuremap.html): Name of the publisher of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Name of the publisher of the terminology capabilities
    /// * [ValueSet](valueset.html): Name of the publisher of the value set

    @Default([]) List<SearchParamString> publisher,

    /// [status] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The current status of the capability statement
    /// * [CodeSystem](codesystem.html): The current status of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The current status of the compartment definition
    /// * [ConceptMap](conceptmap.html): The current status of the concept map
    /// * [GraphDefinition](graphdefinition.html): The current status of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The current status of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The current status of the message definition
    /// * [NamingSystem](namingsystem.html): The current status of the naming system
    /// * [OperationDefinition](operationdefinition.html): The current status of the operation definition
    /// * [SearchParameter](searchparameter.html): The current status of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The current status of the structure definition
    /// * [StructureMap](structuremap.html): The current status of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The current status of the terminology capabilities
    /// * [ValueSet](valueset.html): The current status of the value set

    @Default([]) List<SearchParamToken> status,

    /// [url] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The uri that identifies the capability statement
    /// * [CodeSystem](codesystem.html): The uri that identifies the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The uri that identifies the compartment definition
    /// * [ConceptMap](conceptmap.html): The uri that identifies the concept map
    /// * [GraphDefinition](graphdefinition.html): The uri that identifies the graph definition
    /// * [ImplementationGuide](implementationguide.html): The uri that identifies the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The uri that identifies the message definition
    /// * [OperationDefinition](operationdefinition.html): The uri that identifies the operation definition
    /// * [SearchParameter](searchparameter.html): The uri that identifies the search parameter
    /// * [StructureDefinition](structuredefinition.html): The uri that identifies the structure definition
    /// * [StructureMap](structuremap.html): The uri that identifies the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The uri that identifies the terminology capabilities
    /// * [ValueSet](valueset.html): The uri that identifies the value set

    @Default([]) List<SearchParamUri> url,

    /// [version] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The business version of the capability statement
    /// * [CodeSystem](codesystem.html): The business version of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The business version of the compartment definition
    /// * [ConceptMap](conceptmap.html): The business version of the concept map
    /// * [GraphDefinition](graphdefinition.html): The business version of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The business version of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The business version of the message definition
    /// * [OperationDefinition](operationdefinition.html): The business version of the operation definition
    /// * [SearchParameter](searchparameter.html): The business version of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The business version of the structure definition
    /// * [StructureMap](structuremap.html): The business version of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The business version of the terminology capabilities
    /// * [ValueSet](valueset.html): The business version of the value set

    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and quantity- or range-based value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and quantity- or range-based value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and quantity- or range-based value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and quantity- or range-based value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and quantity- or range-based value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and quantity- or range-based value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and quantity- or range-based value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and quantity- or range-based value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and quantity- or range-based value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and quantity- or range-based value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and quantity- or range-based value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and quantity- or range-based value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and quantity- or range-based value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and quantity- or range-based value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,

    /// [base] The resource type(s) this search parameter applies to
    @Default([]) List<SearchParamToken> base,

    /// [code] Code used in URL
    @Default([]) List<SearchParamToken> code,

    /// [component] Defines how the part works
    @Default([]) List<SearchParamReference> component,

    /// [derivedFrom] Original definition for the search parameter
    @Default([])
    @JsonKey(name: 'derived-from')
        List<SearchParamReference> derivedFrom,

    /// [target] Types of resource (if a resource reference)
    @Default([]) List<SearchParamToken> target,

    /// [type] number | date | string | token | reference | composite | quantity | uri | special
    @Default([]) List<SearchParamToken> type,
  }) = _SearchParameterSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    if (base.isNotEmpty) {
      base.forEach(
          (element) => returnStrings.add('base${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (component.isNotEmpty) {
      component.forEach(
          (element) => returnStrings.add('component${element.toRequest()}'));
    }
    if (derivedFrom.isNotEmpty) {
      derivedFrom.forEach(
          (element) => returnStrings.add('derived-from${element.toRequest()}'));
    }
    if (target.isNotEmpty) {
      target.forEach(
          (element) => returnStrings.add('target${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class StructureDefinitionSearchParams with _$StructureDefinitionSearchParams {
  const StructureDefinitionSearchParams._();
  const factory StructureDefinitionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context assigned to the value set

    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A quantity- or range-valued use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A quantity- or range-valued use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A quantity- or range-valued use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A quantity- or range-valued use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A quantity- or range-valued use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A quantity- or range-valued use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A quantity- or range-valued use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A quantity- or range-valued use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A quantity- or range-valued use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A quantity- or range-valued use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A quantity- or range-valued use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A quantity- or range-valued use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A quantity- or range-valued use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A quantity- or range-valued use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A type of use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A type of use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A type of use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A type of use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A type of use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A type of use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A type of use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A type of use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A type of use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A type of use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A type of use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A type of use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A type of use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A type of use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The capability statement publication date
    /// * [CodeSystem](codesystem.html): The code system publication date
    /// * [CompartmentDefinition](compartmentdefinition.html): The compartment definition publication date
    /// * [ConceptMap](conceptmap.html): The concept map publication date
    /// * [GraphDefinition](graphdefinition.html): The graph definition publication date
    /// * [ImplementationGuide](implementationguide.html): The implementation guide publication date
    /// * [MessageDefinition](messagedefinition.html): The message definition publication date
    /// * [NamingSystem](namingsystem.html): The naming system publication date
    /// * [OperationDefinition](operationdefinition.html): The operation definition publication date
    /// * [SearchParameter](searchparameter.html): The search parameter publication date
    /// * [StructureDefinition](structuredefinition.html): The structure definition publication date
    /// * [StructureMap](structuremap.html): The structure map publication date
    /// * [TerminologyCapabilities](terminologycapabilities.html): The terminology capabilities publication date
    /// * [ValueSet](valueset.html): The value set publication date

    @Default([]) List<SearchParamDate> date,

    /// [description] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The description of the capability statement
    /// * [CodeSystem](codesystem.html): The description of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The description of the compartment definition
    /// * [ConceptMap](conceptmap.html): The description of the concept map
    /// * [GraphDefinition](graphdefinition.html): The description of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The description of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The description of the message definition
    /// * [NamingSystem](namingsystem.html): The description of the naming system
    /// * [OperationDefinition](operationdefinition.html): The description of the operation definition
    /// * [SearchParameter](searchparameter.html): The description of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The description of the structure definition
    /// * [StructureMap](structuremap.html): The description of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The description of the terminology capabilities
    /// * [ValueSet](valueset.html): The description of the value set

    @Default([]) List<SearchParamString> description,

    /// [jurisdiction] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Intended jurisdiction for the capability statement
    /// * [CodeSystem](codesystem.html): Intended jurisdiction for the code system
    /// * [ConceptMap](conceptmap.html): Intended jurisdiction for the concept map
    /// * [GraphDefinition](graphdefinition.html): Intended jurisdiction for the graph definition
    /// * [ImplementationGuide](implementationguide.html): Intended jurisdiction for the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Intended jurisdiction for the message definition
    /// * [NamingSystem](namingsystem.html): Intended jurisdiction for the naming system
    /// * [OperationDefinition](operationdefinition.html): Intended jurisdiction for the operation definition
    /// * [SearchParameter](searchparameter.html): Intended jurisdiction for the search parameter
    /// * [StructureDefinition](structuredefinition.html): Intended jurisdiction for the structure definition
    /// * [StructureMap](structuremap.html): Intended jurisdiction for the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Intended jurisdiction for the terminology capabilities
    /// * [ValueSet](valueset.html): Intended jurisdiction for the value set

    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Computationally friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): Computationally friendly name of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Computationally friendly name of the compartment definition
    /// * [ConceptMap](conceptmap.html): Computationally friendly name of the concept map
    /// * [GraphDefinition](graphdefinition.html): Computationally friendly name of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Computationally friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Computationally friendly name of the message definition
    /// * [NamingSystem](namingsystem.html): Computationally friendly name of the naming system
    /// * [OperationDefinition](operationdefinition.html): Computationally friendly name of the operation definition
    /// * [SearchParameter](searchparameter.html): Computationally friendly name of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Computationally friendly name of the structure definition
    /// * [StructureMap](structuremap.html): Computationally friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Computationally friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): Computationally friendly name of the value set

    @Default([]) List<SearchParamString> name,

    /// [publisher] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Name of the publisher of the capability statement
    /// * [CodeSystem](codesystem.html): Name of the publisher of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Name of the publisher of the compartment definition
    /// * [ConceptMap](conceptmap.html): Name of the publisher of the concept map
    /// * [GraphDefinition](graphdefinition.html): Name of the publisher of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Name of the publisher of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Name of the publisher of the message definition
    /// * [NamingSystem](namingsystem.html): Name of the publisher of the naming system
    /// * [OperationDefinition](operationdefinition.html): Name of the publisher of the operation definition
    /// * [SearchParameter](searchparameter.html): Name of the publisher of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Name of the publisher of the structure definition
    /// * [StructureMap](structuremap.html): Name of the publisher of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Name of the publisher of the terminology capabilities
    /// * [ValueSet](valueset.html): Name of the publisher of the value set

    @Default([]) List<SearchParamString> publisher,

    /// [status] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The current status of the capability statement
    /// * [CodeSystem](codesystem.html): The current status of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The current status of the compartment definition
    /// * [ConceptMap](conceptmap.html): The current status of the concept map
    /// * [GraphDefinition](graphdefinition.html): The current status of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The current status of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The current status of the message definition
    /// * [NamingSystem](namingsystem.html): The current status of the naming system
    /// * [OperationDefinition](operationdefinition.html): The current status of the operation definition
    /// * [SearchParameter](searchparameter.html): The current status of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The current status of the structure definition
    /// * [StructureMap](structuremap.html): The current status of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The current status of the terminology capabilities
    /// * [ValueSet](valueset.html): The current status of the value set

    @Default([]) List<SearchParamToken> status,

    /// [title] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The human-friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): The human-friendly name of the code system
    /// * [ConceptMap](conceptmap.html): The human-friendly name of the concept map
    /// * [ImplementationGuide](implementationguide.html): The human-friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The human-friendly name of the message definition
    /// * [OperationDefinition](operationdefinition.html): The human-friendly name of the operation definition
    /// * [StructureDefinition](structuredefinition.html): The human-friendly name of the structure definition
    /// * [StructureMap](structuremap.html): The human-friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The human-friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): The human-friendly name of the value set

    @Default([]) List<SearchParamString> title,

    /// [url] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The uri that identifies the capability statement
    /// * [CodeSystem](codesystem.html): The uri that identifies the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The uri that identifies the compartment definition
    /// * [ConceptMap](conceptmap.html): The uri that identifies the concept map
    /// * [GraphDefinition](graphdefinition.html): The uri that identifies the graph definition
    /// * [ImplementationGuide](implementationguide.html): The uri that identifies the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The uri that identifies the message definition
    /// * [OperationDefinition](operationdefinition.html): The uri that identifies the operation definition
    /// * [SearchParameter](searchparameter.html): The uri that identifies the search parameter
    /// * [StructureDefinition](structuredefinition.html): The uri that identifies the structure definition
    /// * [StructureMap](structuremap.html): The uri that identifies the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The uri that identifies the terminology capabilities
    /// * [ValueSet](valueset.html): The uri that identifies the value set

    @Default([]) List<SearchParamUri> url,

    /// [version] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The business version of the capability statement
    /// * [CodeSystem](codesystem.html): The business version of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The business version of the compartment definition
    /// * [ConceptMap](conceptmap.html): The business version of the concept map
    /// * [GraphDefinition](graphdefinition.html): The business version of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The business version of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The business version of the message definition
    /// * [OperationDefinition](operationdefinition.html): The business version of the operation definition
    /// * [SearchParameter](searchparameter.html): The business version of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The business version of the structure definition
    /// * [StructureMap](structuremap.html): The business version of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The business version of the terminology capabilities
    /// * [ValueSet](valueset.html): The business version of the value set

    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and quantity- or range-based value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and quantity- or range-based value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and quantity- or range-based value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and quantity- or range-based value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and quantity- or range-based value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and quantity- or range-based value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and quantity- or range-based value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and quantity- or range-based value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and quantity- or range-based value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and quantity- or range-based value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and quantity- or range-based value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and quantity- or range-based value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and quantity- or range-based value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and quantity- or range-based value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,

    /// [identifier] Multiple Resources:

    /// * [CodeSystem](codesystem.html): External identifier for the code system
    /// * [ConceptMap](conceptmap.html): External identifier for the concept map
    /// * [MessageDefinition](messagedefinition.html): External identifier for the message definition
    /// * [StructureDefinition](structuredefinition.html): External identifier for the structure definition
    /// * [StructureMap](structuremap.html): External identifier for the structure map
    /// * [ValueSet](valueset.html): External identifier for the value set

    @Default([]) List<SearchParamToken> identifier,

    /// [abstract_] Whether the structure is abstract
    @Default([]) @JsonKey(name: 'abstract') List<SearchParamToken> abstract_,

    /// [base] Definition that this type is constrained/specialized from
    @Default([]) List<SearchParamReference> base,

    /// [basePath] Path that identifies the base element
    @Default([]) @JsonKey(name: 'base-path') List<SearchParamToken> basePath,

    /// [derivation] specialization | constraint - How relates to base definition
    @Default([]) List<SearchParamToken> derivation,

    /// [experimental] For testing purposes, not real usage
    @Default([]) List<SearchParamToken> experimental,

    /// [extContext] The system is the URL for the context-type: e.g. http://hl7.org/fhir/extension-context-type#element|CodeableConcept.text
    @Default([])
    @JsonKey(name: 'ext-context')
        List<SearchParamToken> extContext,

    /// [keyword] A code for the StructureDefinition
    @Default([]) List<SearchParamToken> keyword,

    /// [kind] primitive-type | complex-type | resource | logical
    @Default([]) List<SearchParamToken> kind,

    /// [path] A path that is constrained in the StructureDefinition
    @Default([]) List<SearchParamToken> path,

    /// [type] Type defined or constrained by this structure
    @Default([]) List<SearchParamUri> type,

    /// [valueset] A vocabulary binding reference
    @Default([]) List<SearchParamReference> valueset,
  }) = _StructureDefinitionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (abstract_.isNotEmpty) {
      abstract_.forEach(
          (element) => returnStrings.add('abstract${element.toRequest()}'));
    }
    if (base.isNotEmpty) {
      base.forEach(
          (element) => returnStrings.add('base${element.toRequest()}'));
    }
    if (basePath.isNotEmpty) {
      basePath.forEach(
          (element) => returnStrings.add('base-path${element.toRequest()}'));
    }
    if (derivation.isNotEmpty) {
      derivation.forEach(
          (element) => returnStrings.add('derivation${element.toRequest()}'));
    }
    if (experimental.isNotEmpty) {
      experimental.forEach(
          (element) => returnStrings.add('experimental${element.toRequest()}'));
    }
    if (extContext.isNotEmpty) {
      extContext.forEach(
          (element) => returnStrings.add('ext-context${element.toRequest()}'));
    }
    if (keyword.isNotEmpty) {
      keyword.forEach(
          (element) => returnStrings.add('keyword${element.toRequest()}'));
    }
    if (kind.isNotEmpty) {
      kind.forEach(
          (element) => returnStrings.add('kind${element.toRequest()}'));
    }
    if (path.isNotEmpty) {
      path.forEach(
          (element) => returnStrings.add('path${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    if (valueset.isNotEmpty) {
      valueset.forEach(
          (element) => returnStrings.add('valueset${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class StructureMapSearchParams with _$StructureMapSearchParams {
  const StructureMapSearchParams._();
  const factory StructureMapSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context assigned to the value set

    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A quantity- or range-valued use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A quantity- or range-valued use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A quantity- or range-valued use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A quantity- or range-valued use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A quantity- or range-valued use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A quantity- or range-valued use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A quantity- or range-valued use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A quantity- or range-valued use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A quantity- or range-valued use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A quantity- or range-valued use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A quantity- or range-valued use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A quantity- or range-valued use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A quantity- or range-valued use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A quantity- or range-valued use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A type of use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A type of use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A type of use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A type of use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A type of use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A type of use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A type of use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A type of use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A type of use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A type of use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A type of use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A type of use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A type of use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A type of use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The capability statement publication date
    /// * [CodeSystem](codesystem.html): The code system publication date
    /// * [CompartmentDefinition](compartmentdefinition.html): The compartment definition publication date
    /// * [ConceptMap](conceptmap.html): The concept map publication date
    /// * [GraphDefinition](graphdefinition.html): The graph definition publication date
    /// * [ImplementationGuide](implementationguide.html): The implementation guide publication date
    /// * [MessageDefinition](messagedefinition.html): The message definition publication date
    /// * [NamingSystem](namingsystem.html): The naming system publication date
    /// * [OperationDefinition](operationdefinition.html): The operation definition publication date
    /// * [SearchParameter](searchparameter.html): The search parameter publication date
    /// * [StructureDefinition](structuredefinition.html): The structure definition publication date
    /// * [StructureMap](structuremap.html): The structure map publication date
    /// * [TerminologyCapabilities](terminologycapabilities.html): The terminology capabilities publication date
    /// * [ValueSet](valueset.html): The value set publication date

    @Default([]) List<SearchParamDate> date,

    /// [description] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The description of the capability statement
    /// * [CodeSystem](codesystem.html): The description of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The description of the compartment definition
    /// * [ConceptMap](conceptmap.html): The description of the concept map
    /// * [GraphDefinition](graphdefinition.html): The description of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The description of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The description of the message definition
    /// * [NamingSystem](namingsystem.html): The description of the naming system
    /// * [OperationDefinition](operationdefinition.html): The description of the operation definition
    /// * [SearchParameter](searchparameter.html): The description of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The description of the structure definition
    /// * [StructureMap](structuremap.html): The description of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The description of the terminology capabilities
    /// * [ValueSet](valueset.html): The description of the value set

    @Default([]) List<SearchParamString> description,

    /// [jurisdiction] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Intended jurisdiction for the capability statement
    /// * [CodeSystem](codesystem.html): Intended jurisdiction for the code system
    /// * [ConceptMap](conceptmap.html): Intended jurisdiction for the concept map
    /// * [GraphDefinition](graphdefinition.html): Intended jurisdiction for the graph definition
    /// * [ImplementationGuide](implementationguide.html): Intended jurisdiction for the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Intended jurisdiction for the message definition
    /// * [NamingSystem](namingsystem.html): Intended jurisdiction for the naming system
    /// * [OperationDefinition](operationdefinition.html): Intended jurisdiction for the operation definition
    /// * [SearchParameter](searchparameter.html): Intended jurisdiction for the search parameter
    /// * [StructureDefinition](structuredefinition.html): Intended jurisdiction for the structure definition
    /// * [StructureMap](structuremap.html): Intended jurisdiction for the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Intended jurisdiction for the terminology capabilities
    /// * [ValueSet](valueset.html): Intended jurisdiction for the value set

    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Computationally friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): Computationally friendly name of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Computationally friendly name of the compartment definition
    /// * [ConceptMap](conceptmap.html): Computationally friendly name of the concept map
    /// * [GraphDefinition](graphdefinition.html): Computationally friendly name of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Computationally friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Computationally friendly name of the message definition
    /// * [NamingSystem](namingsystem.html): Computationally friendly name of the naming system
    /// * [OperationDefinition](operationdefinition.html): Computationally friendly name of the operation definition
    /// * [SearchParameter](searchparameter.html): Computationally friendly name of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Computationally friendly name of the structure definition
    /// * [StructureMap](structuremap.html): Computationally friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Computationally friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): Computationally friendly name of the value set

    @Default([]) List<SearchParamString> name,

    /// [publisher] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Name of the publisher of the capability statement
    /// * [CodeSystem](codesystem.html): Name of the publisher of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Name of the publisher of the compartment definition
    /// * [ConceptMap](conceptmap.html): Name of the publisher of the concept map
    /// * [GraphDefinition](graphdefinition.html): Name of the publisher of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Name of the publisher of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Name of the publisher of the message definition
    /// * [NamingSystem](namingsystem.html): Name of the publisher of the naming system
    /// * [OperationDefinition](operationdefinition.html): Name of the publisher of the operation definition
    /// * [SearchParameter](searchparameter.html): Name of the publisher of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Name of the publisher of the structure definition
    /// * [StructureMap](structuremap.html): Name of the publisher of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Name of the publisher of the terminology capabilities
    /// * [ValueSet](valueset.html): Name of the publisher of the value set

    @Default([]) List<SearchParamString> publisher,

    /// [status] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The current status of the capability statement
    /// * [CodeSystem](codesystem.html): The current status of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The current status of the compartment definition
    /// * [ConceptMap](conceptmap.html): The current status of the concept map
    /// * [GraphDefinition](graphdefinition.html): The current status of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The current status of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The current status of the message definition
    /// * [NamingSystem](namingsystem.html): The current status of the naming system
    /// * [OperationDefinition](operationdefinition.html): The current status of the operation definition
    /// * [SearchParameter](searchparameter.html): The current status of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The current status of the structure definition
    /// * [StructureMap](structuremap.html): The current status of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The current status of the terminology capabilities
    /// * [ValueSet](valueset.html): The current status of the value set

    @Default([]) List<SearchParamToken> status,

    /// [title] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The human-friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): The human-friendly name of the code system
    /// * [ConceptMap](conceptmap.html): The human-friendly name of the concept map
    /// * [ImplementationGuide](implementationguide.html): The human-friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The human-friendly name of the message definition
    /// * [OperationDefinition](operationdefinition.html): The human-friendly name of the operation definition
    /// * [StructureDefinition](structuredefinition.html): The human-friendly name of the structure definition
    /// * [StructureMap](structuremap.html): The human-friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The human-friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): The human-friendly name of the value set

    @Default([]) List<SearchParamString> title,

    /// [url] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The uri that identifies the capability statement
    /// * [CodeSystem](codesystem.html): The uri that identifies the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The uri that identifies the compartment definition
    /// * [ConceptMap](conceptmap.html): The uri that identifies the concept map
    /// * [GraphDefinition](graphdefinition.html): The uri that identifies the graph definition
    /// * [ImplementationGuide](implementationguide.html): The uri that identifies the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The uri that identifies the message definition
    /// * [OperationDefinition](operationdefinition.html): The uri that identifies the operation definition
    /// * [SearchParameter](searchparameter.html): The uri that identifies the search parameter
    /// * [StructureDefinition](structuredefinition.html): The uri that identifies the structure definition
    /// * [StructureMap](structuremap.html): The uri that identifies the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The uri that identifies the terminology capabilities
    /// * [ValueSet](valueset.html): The uri that identifies the value set

    @Default([]) List<SearchParamUri> url,

    /// [version] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The business version of the capability statement
    /// * [CodeSystem](codesystem.html): The business version of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The business version of the compartment definition
    /// * [ConceptMap](conceptmap.html): The business version of the concept map
    /// * [GraphDefinition](graphdefinition.html): The business version of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The business version of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The business version of the message definition
    /// * [OperationDefinition](operationdefinition.html): The business version of the operation definition
    /// * [SearchParameter](searchparameter.html): The business version of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The business version of the structure definition
    /// * [StructureMap](structuremap.html): The business version of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The business version of the terminology capabilities
    /// * [ValueSet](valueset.html): The business version of the value set

    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and quantity- or range-based value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and quantity- or range-based value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and quantity- or range-based value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and quantity- or range-based value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and quantity- or range-based value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and quantity- or range-based value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and quantity- or range-based value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and quantity- or range-based value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and quantity- or range-based value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and quantity- or range-based value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and quantity- or range-based value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and quantity- or range-based value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and quantity- or range-based value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and quantity- or range-based value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,

    /// [identifier] Multiple Resources:

    /// * [CodeSystem](codesystem.html): External identifier for the code system
    /// * [ConceptMap](conceptmap.html): External identifier for the concept map
    /// * [MessageDefinition](messagedefinition.html): External identifier for the message definition
    /// * [StructureDefinition](structuredefinition.html): External identifier for the structure definition
    /// * [StructureMap](structuremap.html): External identifier for the structure map
    /// * [ValueSet](valueset.html): External identifier for the value set

    @Default([]) List<SearchParamToken> identifier,
  }) = _StructureMapSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class TerminologyCapabilitiesSearchParams
    with _$TerminologyCapabilitiesSearchParams {
  const TerminologyCapabilitiesSearchParams._();
  const factory TerminologyCapabilitiesSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context assigned to the value set

    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A quantity- or range-valued use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A quantity- or range-valued use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A quantity- or range-valued use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A quantity- or range-valued use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A quantity- or range-valued use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A quantity- or range-valued use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A quantity- or range-valued use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A quantity- or range-valued use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A quantity- or range-valued use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A quantity- or range-valued use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A quantity- or range-valued use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A quantity- or range-valued use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A quantity- or range-valued use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A quantity- or range-valued use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A type of use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A type of use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A type of use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A type of use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A type of use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A type of use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A type of use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A type of use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A type of use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A type of use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A type of use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A type of use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A type of use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A type of use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The capability statement publication date
    /// * [CodeSystem](codesystem.html): The code system publication date
    /// * [CompartmentDefinition](compartmentdefinition.html): The compartment definition publication date
    /// * [ConceptMap](conceptmap.html): The concept map publication date
    /// * [GraphDefinition](graphdefinition.html): The graph definition publication date
    /// * [ImplementationGuide](implementationguide.html): The implementation guide publication date
    /// * [MessageDefinition](messagedefinition.html): The message definition publication date
    /// * [NamingSystem](namingsystem.html): The naming system publication date
    /// * [OperationDefinition](operationdefinition.html): The operation definition publication date
    /// * [SearchParameter](searchparameter.html): The search parameter publication date
    /// * [StructureDefinition](structuredefinition.html): The structure definition publication date
    /// * [StructureMap](structuremap.html): The structure map publication date
    /// * [TerminologyCapabilities](terminologycapabilities.html): The terminology capabilities publication date
    /// * [ValueSet](valueset.html): The value set publication date

    @Default([]) List<SearchParamDate> date,

    /// [description] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The description of the capability statement
    /// * [CodeSystem](codesystem.html): The description of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The description of the compartment definition
    /// * [ConceptMap](conceptmap.html): The description of the concept map
    /// * [GraphDefinition](graphdefinition.html): The description of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The description of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The description of the message definition
    /// * [NamingSystem](namingsystem.html): The description of the naming system
    /// * [OperationDefinition](operationdefinition.html): The description of the operation definition
    /// * [SearchParameter](searchparameter.html): The description of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The description of the structure definition
    /// * [StructureMap](structuremap.html): The description of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The description of the terminology capabilities
    /// * [ValueSet](valueset.html): The description of the value set

    @Default([]) List<SearchParamString> description,

    /// [jurisdiction] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Intended jurisdiction for the capability statement
    /// * [CodeSystem](codesystem.html): Intended jurisdiction for the code system
    /// * [ConceptMap](conceptmap.html): Intended jurisdiction for the concept map
    /// * [GraphDefinition](graphdefinition.html): Intended jurisdiction for the graph definition
    /// * [ImplementationGuide](implementationguide.html): Intended jurisdiction for the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Intended jurisdiction for the message definition
    /// * [NamingSystem](namingsystem.html): Intended jurisdiction for the naming system
    /// * [OperationDefinition](operationdefinition.html): Intended jurisdiction for the operation definition
    /// * [SearchParameter](searchparameter.html): Intended jurisdiction for the search parameter
    /// * [StructureDefinition](structuredefinition.html): Intended jurisdiction for the structure definition
    /// * [StructureMap](structuremap.html): Intended jurisdiction for the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Intended jurisdiction for the terminology capabilities
    /// * [ValueSet](valueset.html): Intended jurisdiction for the value set

    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Computationally friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): Computationally friendly name of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Computationally friendly name of the compartment definition
    /// * [ConceptMap](conceptmap.html): Computationally friendly name of the concept map
    /// * [GraphDefinition](graphdefinition.html): Computationally friendly name of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Computationally friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Computationally friendly name of the message definition
    /// * [NamingSystem](namingsystem.html): Computationally friendly name of the naming system
    /// * [OperationDefinition](operationdefinition.html): Computationally friendly name of the operation definition
    /// * [SearchParameter](searchparameter.html): Computationally friendly name of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Computationally friendly name of the structure definition
    /// * [StructureMap](structuremap.html): Computationally friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Computationally friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): Computationally friendly name of the value set

    @Default([]) List<SearchParamString> name,

    /// [publisher] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Name of the publisher of the capability statement
    /// * [CodeSystem](codesystem.html): Name of the publisher of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Name of the publisher of the compartment definition
    /// * [ConceptMap](conceptmap.html): Name of the publisher of the concept map
    /// * [GraphDefinition](graphdefinition.html): Name of the publisher of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Name of the publisher of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Name of the publisher of the message definition
    /// * [NamingSystem](namingsystem.html): Name of the publisher of the naming system
    /// * [OperationDefinition](operationdefinition.html): Name of the publisher of the operation definition
    /// * [SearchParameter](searchparameter.html): Name of the publisher of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Name of the publisher of the structure definition
    /// * [StructureMap](structuremap.html): Name of the publisher of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Name of the publisher of the terminology capabilities
    /// * [ValueSet](valueset.html): Name of the publisher of the value set

    @Default([]) List<SearchParamString> publisher,

    /// [status] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The current status of the capability statement
    /// * [CodeSystem](codesystem.html): The current status of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The current status of the compartment definition
    /// * [ConceptMap](conceptmap.html): The current status of the concept map
    /// * [GraphDefinition](graphdefinition.html): The current status of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The current status of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The current status of the message definition
    /// * [NamingSystem](namingsystem.html): The current status of the naming system
    /// * [OperationDefinition](operationdefinition.html): The current status of the operation definition
    /// * [SearchParameter](searchparameter.html): The current status of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The current status of the structure definition
    /// * [StructureMap](structuremap.html): The current status of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The current status of the terminology capabilities
    /// * [ValueSet](valueset.html): The current status of the value set

    @Default([]) List<SearchParamToken> status,

    /// [title] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The human-friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): The human-friendly name of the code system
    /// * [ConceptMap](conceptmap.html): The human-friendly name of the concept map
    /// * [ImplementationGuide](implementationguide.html): The human-friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The human-friendly name of the message definition
    /// * [OperationDefinition](operationdefinition.html): The human-friendly name of the operation definition
    /// * [StructureDefinition](structuredefinition.html): The human-friendly name of the structure definition
    /// * [StructureMap](structuremap.html): The human-friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The human-friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): The human-friendly name of the value set

    @Default([]) List<SearchParamString> title,

    /// [url] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The uri that identifies the capability statement
    /// * [CodeSystem](codesystem.html): The uri that identifies the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The uri that identifies the compartment definition
    /// * [ConceptMap](conceptmap.html): The uri that identifies the concept map
    /// * [GraphDefinition](graphdefinition.html): The uri that identifies the graph definition
    /// * [ImplementationGuide](implementationguide.html): The uri that identifies the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The uri that identifies the message definition
    /// * [OperationDefinition](operationdefinition.html): The uri that identifies the operation definition
    /// * [SearchParameter](searchparameter.html): The uri that identifies the search parameter
    /// * [StructureDefinition](structuredefinition.html): The uri that identifies the structure definition
    /// * [StructureMap](structuremap.html): The uri that identifies the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The uri that identifies the terminology capabilities
    /// * [ValueSet](valueset.html): The uri that identifies the value set

    @Default([]) List<SearchParamUri> url,

    /// [version] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The business version of the capability statement
    /// * [CodeSystem](codesystem.html): The business version of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The business version of the compartment definition
    /// * [ConceptMap](conceptmap.html): The business version of the concept map
    /// * [GraphDefinition](graphdefinition.html): The business version of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The business version of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The business version of the message definition
    /// * [OperationDefinition](operationdefinition.html): The business version of the operation definition
    /// * [SearchParameter](searchparameter.html): The business version of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The business version of the structure definition
    /// * [StructureMap](structuremap.html): The business version of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The business version of the terminology capabilities
    /// * [ValueSet](valueset.html): The business version of the value set

    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and quantity- or range-based value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and quantity- or range-based value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and quantity- or range-based value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and quantity- or range-based value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and quantity- or range-based value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and quantity- or range-based value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and quantity- or range-based value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and quantity- or range-based value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and quantity- or range-based value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and quantity- or range-based value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and quantity- or range-based value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and quantity- or range-based value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and quantity- or range-based value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and quantity- or range-based value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,
  }) = _TerminologyCapabilitiesSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ValueSetSearchParams with _$ValueSetSearchParams {
  const ValueSetSearchParams._();
  const factory ValueSetSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context assigned to the value set

    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A quantity- or range-valued use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A quantity- or range-valued use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A quantity- or range-valued use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A quantity- or range-valued use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A quantity- or range-valued use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A quantity- or range-valued use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A quantity- or range-valued use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A quantity- or range-valued use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A quantity- or range-valued use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A quantity- or range-valued use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A quantity- or range-valued use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A quantity- or range-valued use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A quantity- or range-valued use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A quantity- or range-valued use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A type of use context assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A type of use context assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A type of use context assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A type of use context assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A type of use context assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A type of use context assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A type of use context assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A type of use context assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A type of use context assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A type of use context assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A type of use context assigned to the structure definition
    /// * [StructureMap](structuremap.html): A type of use context assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A type of use context assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A type of use context assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The capability statement publication date
    /// * [CodeSystem](codesystem.html): The code system publication date
    /// * [CompartmentDefinition](compartmentdefinition.html): The compartment definition publication date
    /// * [ConceptMap](conceptmap.html): The concept map publication date
    /// * [GraphDefinition](graphdefinition.html): The graph definition publication date
    /// * [ImplementationGuide](implementationguide.html): The implementation guide publication date
    /// * [MessageDefinition](messagedefinition.html): The message definition publication date
    /// * [NamingSystem](namingsystem.html): The naming system publication date
    /// * [OperationDefinition](operationdefinition.html): The operation definition publication date
    /// * [SearchParameter](searchparameter.html): The search parameter publication date
    /// * [StructureDefinition](structuredefinition.html): The structure definition publication date
    /// * [StructureMap](structuremap.html): The structure map publication date
    /// * [TerminologyCapabilities](terminologycapabilities.html): The terminology capabilities publication date
    /// * [ValueSet](valueset.html): The value set publication date

    @Default([]) List<SearchParamDate> date,

    /// [description] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The description of the capability statement
    /// * [CodeSystem](codesystem.html): The description of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The description of the compartment definition
    /// * [ConceptMap](conceptmap.html): The description of the concept map
    /// * [GraphDefinition](graphdefinition.html): The description of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The description of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The description of the message definition
    /// * [NamingSystem](namingsystem.html): The description of the naming system
    /// * [OperationDefinition](operationdefinition.html): The description of the operation definition
    /// * [SearchParameter](searchparameter.html): The description of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The description of the structure definition
    /// * [StructureMap](structuremap.html): The description of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The description of the terminology capabilities
    /// * [ValueSet](valueset.html): The description of the value set

    @Default([]) List<SearchParamString> description,

    /// [jurisdiction] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Intended jurisdiction for the capability statement
    /// * [CodeSystem](codesystem.html): Intended jurisdiction for the code system
    /// * [ConceptMap](conceptmap.html): Intended jurisdiction for the concept map
    /// * [GraphDefinition](graphdefinition.html): Intended jurisdiction for the graph definition
    /// * [ImplementationGuide](implementationguide.html): Intended jurisdiction for the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Intended jurisdiction for the message definition
    /// * [NamingSystem](namingsystem.html): Intended jurisdiction for the naming system
    /// * [OperationDefinition](operationdefinition.html): Intended jurisdiction for the operation definition
    /// * [SearchParameter](searchparameter.html): Intended jurisdiction for the search parameter
    /// * [StructureDefinition](structuredefinition.html): Intended jurisdiction for the structure definition
    /// * [StructureMap](structuremap.html): Intended jurisdiction for the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Intended jurisdiction for the terminology capabilities
    /// * [ValueSet](valueset.html): Intended jurisdiction for the value set

    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Computationally friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): Computationally friendly name of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Computationally friendly name of the compartment definition
    /// * [ConceptMap](conceptmap.html): Computationally friendly name of the concept map
    /// * [GraphDefinition](graphdefinition.html): Computationally friendly name of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Computationally friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Computationally friendly name of the message definition
    /// * [NamingSystem](namingsystem.html): Computationally friendly name of the naming system
    /// * [OperationDefinition](operationdefinition.html): Computationally friendly name of the operation definition
    /// * [SearchParameter](searchparameter.html): Computationally friendly name of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Computationally friendly name of the structure definition
    /// * [StructureMap](structuremap.html): Computationally friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Computationally friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): Computationally friendly name of the value set

    @Default([]) List<SearchParamString> name,

    /// [publisher] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): Name of the publisher of the capability statement
    /// * [CodeSystem](codesystem.html): Name of the publisher of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): Name of the publisher of the compartment definition
    /// * [ConceptMap](conceptmap.html): Name of the publisher of the concept map
    /// * [GraphDefinition](graphdefinition.html): Name of the publisher of the graph definition
    /// * [ImplementationGuide](implementationguide.html): Name of the publisher of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): Name of the publisher of the message definition
    /// * [NamingSystem](namingsystem.html): Name of the publisher of the naming system
    /// * [OperationDefinition](operationdefinition.html): Name of the publisher of the operation definition
    /// * [SearchParameter](searchparameter.html): Name of the publisher of the search parameter
    /// * [StructureDefinition](structuredefinition.html): Name of the publisher of the structure definition
    /// * [StructureMap](structuremap.html): Name of the publisher of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): Name of the publisher of the terminology capabilities
    /// * [ValueSet](valueset.html): Name of the publisher of the value set

    @Default([]) List<SearchParamString> publisher,

    /// [status] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The current status of the capability statement
    /// * [CodeSystem](codesystem.html): The current status of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The current status of the compartment definition
    /// * [ConceptMap](conceptmap.html): The current status of the concept map
    /// * [GraphDefinition](graphdefinition.html): The current status of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The current status of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The current status of the message definition
    /// * [NamingSystem](namingsystem.html): The current status of the naming system
    /// * [OperationDefinition](operationdefinition.html): The current status of the operation definition
    /// * [SearchParameter](searchparameter.html): The current status of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The current status of the structure definition
    /// * [StructureMap](structuremap.html): The current status of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The current status of the terminology capabilities
    /// * [ValueSet](valueset.html): The current status of the value set

    @Default([]) List<SearchParamToken> status,

    /// [title] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The human-friendly name of the capability statement
    /// * [CodeSystem](codesystem.html): The human-friendly name of the code system
    /// * [ConceptMap](conceptmap.html): The human-friendly name of the concept map
    /// * [ImplementationGuide](implementationguide.html): The human-friendly name of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The human-friendly name of the message definition
    /// * [OperationDefinition](operationdefinition.html): The human-friendly name of the operation definition
    /// * [StructureDefinition](structuredefinition.html): The human-friendly name of the structure definition
    /// * [StructureMap](structuremap.html): The human-friendly name of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The human-friendly name of the terminology capabilities
    /// * [ValueSet](valueset.html): The human-friendly name of the value set

    @Default([]) List<SearchParamString> title,

    /// [url] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The uri that identifies the capability statement
    /// * [CodeSystem](codesystem.html): The uri that identifies the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The uri that identifies the compartment definition
    /// * [ConceptMap](conceptmap.html): The uri that identifies the concept map
    /// * [GraphDefinition](graphdefinition.html): The uri that identifies the graph definition
    /// * [ImplementationGuide](implementationguide.html): The uri that identifies the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The uri that identifies the message definition
    /// * [OperationDefinition](operationdefinition.html): The uri that identifies the operation definition
    /// * [SearchParameter](searchparameter.html): The uri that identifies the search parameter
    /// * [StructureDefinition](structuredefinition.html): The uri that identifies the structure definition
    /// * [StructureMap](structuremap.html): The uri that identifies the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The uri that identifies the terminology capabilities
    /// * [ValueSet](valueset.html): The uri that identifies the value set

    @Default([]) List<SearchParamUri> url,

    /// [version] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): The business version of the capability statement
    /// * [CodeSystem](codesystem.html): The business version of the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): The business version of the compartment definition
    /// * [ConceptMap](conceptmap.html): The business version of the concept map
    /// * [GraphDefinition](graphdefinition.html): The business version of the graph definition
    /// * [ImplementationGuide](implementationguide.html): The business version of the implementation guide
    /// * [MessageDefinition](messagedefinition.html): The business version of the message definition
    /// * [OperationDefinition](operationdefinition.html): The business version of the operation definition
    /// * [SearchParameter](searchparameter.html): The business version of the search parameter
    /// * [StructureDefinition](structuredefinition.html): The business version of the structure definition
    /// * [StructureMap](structuremap.html): The business version of the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): The business version of the terminology capabilities
    /// * [ValueSet](valueset.html): The business version of the value set

    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and quantity- or range-based value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and quantity- or range-based value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and quantity- or range-based value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and quantity- or range-based value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and quantity- or range-based value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and quantity- or range-based value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and quantity- or range-based value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and quantity- or range-based value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and quantity- or range-based value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and quantity- or range-based value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and quantity- or range-based value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and quantity- or range-based value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and quantity- or range-based value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and quantity- or range-based value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] Multiple Resources:

    /// * [CapabilityStatement](capabilitystatement.html): A use context type and value assigned to the capability statement
    /// * [CodeSystem](codesystem.html): A use context type and value assigned to the code system
    /// * [CompartmentDefinition](compartmentdefinition.html): A use context type and value assigned to the compartment definition
    /// * [ConceptMap](conceptmap.html): A use context type and value assigned to the concept map
    /// * [GraphDefinition](graphdefinition.html): A use context type and value assigned to the graph definition
    /// * [ImplementationGuide](implementationguide.html): A use context type and value assigned to the implementation guide
    /// * [MessageDefinition](messagedefinition.html): A use context type and value assigned to the message definition
    /// * [NamingSystem](namingsystem.html): A use context type and value assigned to the naming system
    /// * [OperationDefinition](operationdefinition.html): A use context type and value assigned to the operation definition
    /// * [SearchParameter](searchparameter.html): A use context type and value assigned to the search parameter
    /// * [StructureDefinition](structuredefinition.html): A use context type and value assigned to the structure definition
    /// * [StructureMap](structuremap.html): A use context type and value assigned to the structure map
    /// * [TerminologyCapabilities](terminologycapabilities.html): A use context type and value assigned to the terminology capabilities
    /// * [ValueSet](valueset.html): A use context type and value assigned to the value set

    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,

    /// [identifier] Multiple Resources:

    /// * [CodeSystem](codesystem.html): External identifier for the code system
    /// * [ConceptMap](conceptmap.html): External identifier for the concept map
    /// * [MessageDefinition](messagedefinition.html): External identifier for the message definition
    /// * [StructureDefinition](structuredefinition.html): External identifier for the structure definition
    /// * [StructureMap](structuremap.html): External identifier for the structure map
    /// * [ValueSet](valueset.html): External identifier for the value set

    @Default([]) List<SearchParamToken> identifier,

    /// [code] This special parameter searches for codes in the value set. See additional notes on the ValueSet resource
    @Default([]) List<SearchParamToken> code,

    /// [expansion] Identifies the value set expansion (business identifier)
    @Default([]) List<SearchParamUri> expansion,

    /// [reference] A code system included or excluded in the value set or an imported value set
    @Default([]) List<SearchParamUri> reference,
  }) = _ValueSetSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (expansion.isNotEmpty) {
      expansion.forEach(
          (element) => returnStrings.add('expansion${element.toRequest()}'));
    }
    if (reference.isNotEmpty) {
      reference.forEach(
          (element) => returnStrings.add('reference${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ChargeItemSearchParams with _$ChargeItemSearchParams {
  const ChargeItemSearchParams._();
  const factory ChargeItemSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [account] Account to place this charge
    @Default([]) List<SearchParamReference> account,

    /// [code] A code that identifies the charge, like a billing code
    @Default([]) List<SearchParamToken> code,

    /// [context] Encounter / Episode associated with event
    @Default([]) List<SearchParamReference> context,

    /// [enteredDate] Date the charge item was entered
    @Default([])
    @JsonKey(name: 'entered-date')
        List<SearchParamDate> enteredDate,

    /// [enterer] Individual who was entering
    @Default([]) List<SearchParamReference> enterer,

    /// [factorOverride] Factor overriding the associated rules
    @Default([])
    @JsonKey(name: 'factor-override')
        List<SearchParamNumber> factorOverride,

    /// [identifier] Business Identifier for item
    @Default([]) List<SearchParamToken> identifier,

    /// [occurrence] When the charged service was applied
    @Default([]) List<SearchParamDate> occurrence,

    /// [patient] Individual service was done for/to
    @Default([]) List<SearchParamReference> patient,

    /// [performerActor] Individual who was performing
    @Default([])
    @JsonKey(name: 'performer-actor')
        List<SearchParamReference> performerActor,

    /// [performerFunction] What type of performance was done
    @Default([])
    @JsonKey(name: 'performer-function')
        List<SearchParamToken> performerFunction,

    /// [performingOrganization] Organization providing the charged service
    @Default([])
    @JsonKey(name: 'performing-organization')
        List<SearchParamReference> performingOrganization,

    /// [priceOverride] Price overriding the associated rules
    @Default([])
    @JsonKey(name: 'price-override')
        List<SearchParamQuantity> priceOverride,

    /// [quantity] Quantity of which the charge item has been serviced
    @Default([]) List<SearchParamQuantity> quantity,

    /// [requestingOrganization] Organization requesting the charged service
    @Default([])
    @JsonKey(name: 'requesting-organization')
        List<SearchParamReference> requestingOrganization,

    /// [service] Which rendered service is being charged?
    @Default([]) List<SearchParamReference> service,

    /// [subject] Individual service was done for/to
    @Default([]) List<SearchParamReference> subject,
  }) = _ChargeItemSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (account.isNotEmpty) {
      account.forEach(
          (element) => returnStrings.add('account${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (enteredDate.isNotEmpty) {
      enteredDate.forEach(
          (element) => returnStrings.add('entered-date${element.toRequest()}'));
    }
    if (enterer.isNotEmpty) {
      enterer.forEach(
          (element) => returnStrings.add('enterer${element.toRequest()}'));
    }
    if (factorOverride.isNotEmpty) {
      factorOverride.forEach((element) =>
          returnStrings.add('factor-override${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (occurrence.isNotEmpty) {
      occurrence.forEach(
          (element) => returnStrings.add('occurrence${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (performerActor.isNotEmpty) {
      performerActor.forEach((element) =>
          returnStrings.add('performer-actor${element.toRequest()}'));
    }
    if (performerFunction.isNotEmpty) {
      performerFunction.forEach((element) =>
          returnStrings.add('performer-function${element.toRequest()}'));
    }
    if (performingOrganization.isNotEmpty) {
      performingOrganization.forEach((element) =>
          returnStrings.add('performing-organization${element.toRequest()}'));
    }
    if (priceOverride.isNotEmpty) {
      priceOverride.forEach((element) =>
          returnStrings.add('price-override${element.toRequest()}'));
    }
    if (quantity.isNotEmpty) {
      quantity.forEach(
          (element) => returnStrings.add('quantity${element.toRequest()}'));
    }
    if (requestingOrganization.isNotEmpty) {
      requestingOrganization.forEach((element) =>
          returnStrings.add('requesting-organization${element.toRequest()}'));
    }
    if (service.isNotEmpty) {
      service.forEach(
          (element) => returnStrings.add('service${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ChargeItemDefinitionSearchParams with _$ChargeItemDefinitionSearchParams {
  const ChargeItemDefinitionSearchParams._();
  const factory ChargeItemDefinitionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] A use context assigned to the charge item definition
    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] A quantity- or range-valued use context assigned to the charge item definition
    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] A type of use context assigned to the charge item definition
    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] The charge item definition publication date
    @Default([]) List<SearchParamDate> date,

    /// [description] The description of the charge item definition
    @Default([]) List<SearchParamString> description,

    /// [effective] The time during which the charge item definition is intended to be in use
    @Default([]) List<SearchParamDate> effective,

    /// [identifier] External identifier for the charge item definition
    @Default([]) List<SearchParamToken> identifier,

    /// [jurisdiction] Intended jurisdiction for the charge item definition
    @Default([]) List<SearchParamToken> jurisdiction,

    /// [publisher] Name of the publisher of the charge item definition
    @Default([]) List<SearchParamString> publisher,

    /// [status] The current status of the charge item definition
    @Default([]) List<SearchParamToken> status,

    /// [title] The human-friendly name of the charge item definition
    @Default([]) List<SearchParamString> title,

    /// [url] The uri that identifies the charge item definition
    @Default([]) List<SearchParamUri> url,

    /// [version] The business version of the charge item definition
    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] A use context type and quantity- or range-based value assigned to the charge item definition
    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] A use context type and value assigned to the charge item definition
    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,
  }) = _ChargeItemDefinitionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (effective.isNotEmpty) {
      effective.forEach(
          (element) => returnStrings.add('effective${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class CitationSearchParams with _$CitationSearchParams {
  const CitationSearchParams._();
  const factory CitationSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] A use context assigned to the citation
    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] A quantity- or range-valued use context assigned to the citation
    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] A type of use context assigned to the citation
    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] The citation publication date
    @Default([]) List<SearchParamDate> date,

    /// [description] The description of the citation
    @Default([]) List<SearchParamString> description,

    /// [effective] The time during which the citation is intended to be in use
    @Default([]) List<SearchParamDate> effective,

    /// [identifier] External identifier for the citation
    @Default([]) List<SearchParamToken> identifier,

    /// [jurisdiction] Intended jurisdiction for the citation
    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Computationally friendly name of the citation
    @Default([]) List<SearchParamString> name,

    /// [publisher] Name of the publisher of the citation
    @Default([]) List<SearchParamString> publisher,

    /// [status] The current status of the citation
    @Default([]) List<SearchParamToken> status,

    /// [title] The human-friendly name of the citation
    @Default([]) List<SearchParamString> title,

    /// [url] The uri that identifies the citation
    @Default([]) List<SearchParamUri> url,

    /// [version] The business version of the citation
    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] A use context type and quantity- or range-based value assigned to the citation
    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] A use context type and value assigned to the citation
    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,
  }) = _CitationSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (effective.isNotEmpty) {
      effective.forEach(
          (element) => returnStrings.add('effective${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ClaimSearchParams with _$ClaimSearchParams {
  const ClaimSearchParams._();
  const factory ClaimSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [careTeam] Member of the CareTeam
    @Default([])
    @JsonKey(name: 'care-team')
        List<SearchParamReference> careTeam,

    /// [created] The creation date for the Claim
    @Default([]) List<SearchParamDate> created,

    /// [detailUdi] UDI associated with a line item, detail product or service
    @Default([])
    @JsonKey(name: 'detail-udi')
        List<SearchParamReference> detailUdi,

    /// [encounter] Encounters associated with a billed line item
    @Default([]) List<SearchParamReference> encounter,

    /// [enterer] The party responsible for the entry of the Claim
    @Default([]) List<SearchParamReference> enterer,

    /// [facility] Facility where the products or services have been or will be provided
    @Default([]) List<SearchParamReference> facility,

    /// [identifier] The primary identifier of the financial resource
    @Default([]) List<SearchParamToken> identifier,

    /// [insurer] The target payor/insurer for the Claim
    @Default([]) List<SearchParamReference> insurer,

    /// [itemUdi] UDI associated with a line item product or service
    @Default([]) @JsonKey(name: 'item-udi') List<SearchParamReference> itemUdi,

    /// [patient] Patient receiving the products or services
    @Default([]) List<SearchParamReference> patient,

    /// [payee] The party receiving any payment for the Claim
    @Default([]) List<SearchParamReference> payee,

    /// [priority] Processing priority requested
    @Default([]) List<SearchParamToken> priority,

    /// [procedureUdi] UDI associated with a procedure
    @Default([])
    @JsonKey(name: 'procedure-udi')
        List<SearchParamReference> procedureUdi,

    /// [provider] Provider responsible for the Claim
    @Default([]) List<SearchParamReference> provider,

    /// [status] The status of the Claim instance.
    @Default([]) List<SearchParamToken> status,

    /// [subdetailUdi] UDI associated with a line item, detail, subdetail product or service
    @Default([])
    @JsonKey(name: 'subdetail-udi')
        List<SearchParamReference> subdetailUdi,

    /// [use] The kind of financial resource
    @Default([]) List<SearchParamToken> use,
  }) = _ClaimSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (careTeam.isNotEmpty) {
      careTeam.forEach(
          (element) => returnStrings.add('care-team${element.toRequest()}'));
    }
    if (created.isNotEmpty) {
      created.forEach(
          (element) => returnStrings.add('created${element.toRequest()}'));
    }
    if (detailUdi.isNotEmpty) {
      detailUdi.forEach(
          (element) => returnStrings.add('detail-udi${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (enterer.isNotEmpty) {
      enterer.forEach(
          (element) => returnStrings.add('enterer${element.toRequest()}'));
    }
    if (facility.isNotEmpty) {
      facility.forEach(
          (element) => returnStrings.add('facility${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (insurer.isNotEmpty) {
      insurer.forEach(
          (element) => returnStrings.add('insurer${element.toRequest()}'));
    }
    if (itemUdi.isNotEmpty) {
      itemUdi.forEach(
          (element) => returnStrings.add('item-udi${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (payee.isNotEmpty) {
      payee.forEach(
          (element) => returnStrings.add('payee${element.toRequest()}'));
    }
    if (priority.isNotEmpty) {
      priority.forEach(
          (element) => returnStrings.add('priority${element.toRequest()}'));
    }
    if (procedureUdi.isNotEmpty) {
      procedureUdi.forEach((element) =>
          returnStrings.add('procedure-udi${element.toRequest()}'));
    }
    if (provider.isNotEmpty) {
      provider.forEach(
          (element) => returnStrings.add('provider${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subdetailUdi.isNotEmpty) {
      subdetailUdi.forEach((element) =>
          returnStrings.add('subdetail-udi${element.toRequest()}'));
    }
    if (use.isNotEmpty) {
      use.forEach((element) => returnStrings.add('use${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ClaimResponseSearchParams with _$ClaimResponseSearchParams {
  const ClaimResponseSearchParams._();
  const factory ClaimResponseSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [created] The creation date
    @Default([]) List<SearchParamDate> created,

    /// [disposition] The contents of the disposition message
    @Default([]) List<SearchParamString> disposition,

    /// [identifier] The identity of the ClaimResponse
    @Default([]) List<SearchParamToken> identifier,

    /// [insurer] The organization which generated this resource
    @Default([]) List<SearchParamReference> insurer,

    /// [outcome] The processing outcome
    @Default([]) List<SearchParamToken> outcome,

    /// [patient] The subject of care
    @Default([]) List<SearchParamReference> patient,

    /// [paymentDate] The expected payment date
    @Default([])
    @JsonKey(name: 'payment-date')
        List<SearchParamDate> paymentDate,

    /// [request] The claim reference
    @Default([]) List<SearchParamReference> request,

    /// [requestor] The Provider of the claim
    @Default([]) List<SearchParamReference> requestor,

    /// [status] The status of the ClaimResponse
    @Default([]) List<SearchParamToken> status,

    /// [use] The type of claim
    @Default([]) List<SearchParamToken> use,
  }) = _ClaimResponseSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (created.isNotEmpty) {
      created.forEach(
          (element) => returnStrings.add('created${element.toRequest()}'));
    }
    if (disposition.isNotEmpty) {
      disposition.forEach(
          (element) => returnStrings.add('disposition${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (insurer.isNotEmpty) {
      insurer.forEach(
          (element) => returnStrings.add('insurer${element.toRequest()}'));
    }
    if (outcome.isNotEmpty) {
      outcome.forEach(
          (element) => returnStrings.add('outcome${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (paymentDate.isNotEmpty) {
      paymentDate.forEach(
          (element) => returnStrings.add('payment-date${element.toRequest()}'));
    }
    if (request.isNotEmpty) {
      request.forEach(
          (element) => returnStrings.add('request${element.toRequest()}'));
    }
    if (requestor.isNotEmpty) {
      requestor.forEach(
          (element) => returnStrings.add('requestor${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (use.isNotEmpty) {
      use.forEach((element) => returnStrings.add('use${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ClinicalUseDefinitionSearchParams
    with _$ClinicalUseDefinitionSearchParams {
  const ClinicalUseDefinitionSearchParams._();
  const factory ClinicalUseDefinitionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [contraindication] The situation that is being documented as contraindicating against this item, as a code
    @Default([]) List<SearchParamToken> contraindication,

    /// [contraindicationReference] The situation that is being documented as contraindicating against this item, as a reference
    @Default([])
    @JsonKey(name: 'contraindication-reference')
        List<SearchParamReference> contraindicationReference,

    /// [effect] The situation in which the undesirable effect may manifest, as a code
    @Default([]) List<SearchParamToken> effect,

    /// [effectReference] The situation in which the undesirable effect may manifest, as a reference
    @Default([])
    @JsonKey(name: 'effect-reference')
        List<SearchParamReference> effectReference,

    /// [identifier] Business identifier for this issue
    @Default([]) List<SearchParamToken> identifier,

    /// [indication] The situation that is being documented as an indicaton for this item, as a code
    @Default([]) List<SearchParamToken> indication,

    /// [indicationReference] The situation that is being documented as an indicaton for this item, as a reference
    @Default([])
    @JsonKey(name: 'indication-reference')
        List<SearchParamReference> indicationReference,

    /// [interaction] The type of the interaction e.g. drug-drug interaction, drug-food interaction, drug-lab test interaction
    @Default([]) List<SearchParamToken> interaction,

    /// [product] The medicinal product for which this is a clinical usage issue
    @Default([]) List<SearchParamReference> product,

    /// [subject] The resource for which this is a clinical usage issue
    @Default([]) List<SearchParamReference> subject,

    /// [type] indication | contraindication | interaction | undesirable-effect | warning
    @Default([]) List<SearchParamToken> type,
  }) = _ClinicalUseDefinitionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (contraindication.isNotEmpty) {
      contraindication.forEach((element) =>
          returnStrings.add('contraindication${element.toRequest()}'));
    }
    if (contraindicationReference.isNotEmpty) {
      contraindicationReference.forEach((element) => returnStrings
          .add('contraindication-reference${element.toRequest()}'));
    }
    if (effect.isNotEmpty) {
      effect.forEach(
          (element) => returnStrings.add('effect${element.toRequest()}'));
    }
    if (effectReference.isNotEmpty) {
      effectReference.forEach((element) =>
          returnStrings.add('effect-reference${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (indication.isNotEmpty) {
      indication.forEach(
          (element) => returnStrings.add('indication${element.toRequest()}'));
    }
    if (indicationReference.isNotEmpty) {
      indicationReference.forEach((element) =>
          returnStrings.add('indication-reference${element.toRequest()}'));
    }
    if (interaction.isNotEmpty) {
      interaction.forEach(
          (element) => returnStrings.add('interaction${element.toRequest()}'));
    }
    if (product.isNotEmpty) {
      product.forEach(
          (element) => returnStrings.add('product${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class CommunicationSearchParams with _$CommunicationSearchParams {
  const CommunicationSearchParams._();
  const factory CommunicationSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [basedOn] Request fulfilled by this communication
    @Default([]) @JsonKey(name: 'based-on') List<SearchParamReference> basedOn,

    /// [category] Message category
    @Default([]) List<SearchParamToken> category,

    /// [encounter] Encounter created as part of
    @Default([]) List<SearchParamReference> encounter,

    /// [identifier] Unique identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [instantiatesCanonical] Instantiates FHIR protocol or definition
    @Default([])
    @JsonKey(name: 'instantiates-canonical')
        List<SearchParamReference> instantiatesCanonical,

    /// [instantiatesUri] Instantiates external protocol or definition
    @Default([])
    @JsonKey(name: 'instantiates-uri')
        List<SearchParamUri> instantiatesUri,

    /// [medium] A channel of communication
    @Default([]) List<SearchParamToken> medium,

    /// [partOf] Part of this action
    @Default([]) @JsonKey(name: 'part-of') List<SearchParamReference> partOf,

    /// [patient] Focus of message
    @Default([]) List<SearchParamReference> patient,

    /// [received] When received
    @Default([]) List<SearchParamDate> received,

    /// [recipient] Message recipient
    @Default([]) List<SearchParamReference> recipient,

    /// [sender] Message sender
    @Default([]) List<SearchParamReference> sender,

    /// [sent] When sent
    @Default([]) List<SearchParamDate> sent,

    /// [status] preparation | in-progress | not-done | on-hold | stopped | completed | entered-in-error | unknown
    @Default([]) List<SearchParamToken> status,

    /// [subject] Focus of message
    @Default([]) List<SearchParamReference> subject,
  }) = _CommunicationSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (basedOn.isNotEmpty) {
      basedOn.forEach(
          (element) => returnStrings.add('based-on${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (instantiatesCanonical.isNotEmpty) {
      instantiatesCanonical.forEach((element) =>
          returnStrings.add('instantiates-canonical${element.toRequest()}'));
    }
    if (instantiatesUri.isNotEmpty) {
      instantiatesUri.forEach((element) =>
          returnStrings.add('instantiates-uri${element.toRequest()}'));
    }
    if (medium.isNotEmpty) {
      medium.forEach(
          (element) => returnStrings.add('medium${element.toRequest()}'));
    }
    if (partOf.isNotEmpty) {
      partOf.forEach(
          (element) => returnStrings.add('part-of${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (received.isNotEmpty) {
      received.forEach(
          (element) => returnStrings.add('received${element.toRequest()}'));
    }
    if (recipient.isNotEmpty) {
      recipient.forEach(
          (element) => returnStrings.add('recipient${element.toRequest()}'));
    }
    if (sender.isNotEmpty) {
      sender.forEach(
          (element) => returnStrings.add('sender${element.toRequest()}'));
    }
    if (sent.isNotEmpty) {
      sent.forEach(
          (element) => returnStrings.add('sent${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class CommunicationRequestSearchParams with _$CommunicationRequestSearchParams {
  const CommunicationRequestSearchParams._();
  const factory CommunicationRequestSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [authored] When request transitioned to being actionable
    @Default([]) List<SearchParamDate> authored,

    /// [basedOn] Fulfills plan or proposal
    @Default([]) @JsonKey(name: 'based-on') List<SearchParamReference> basedOn,

    /// [category] Message category
    @Default([]) List<SearchParamToken> category,

    /// [encounter] Encounter created as part of
    @Default([]) List<SearchParamReference> encounter,

    /// [groupIdentifier] Composite request this is part of
    @Default([])
    @JsonKey(name: 'group-identifier')
        List<SearchParamToken> groupIdentifier,

    /// [identifier] Unique identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [medium] A channel of communication
    @Default([]) List<SearchParamToken> medium,

    /// [occurrence] When scheduled
    @Default([]) List<SearchParamDate> occurrence,

    /// [patient] Focus of message
    @Default([]) List<SearchParamReference> patient,

    /// [priority] routine | urgent | asap | stat
    @Default([]) List<SearchParamToken> priority,

    /// [recipient] Message recipient
    @Default([]) List<SearchParamReference> recipient,

    /// [replaces] Request(s) replaced by this request
    @Default([]) List<SearchParamReference> replaces,

    /// [requester] Who/what is requesting service
    @Default([]) List<SearchParamReference> requester,

    /// [sender] Message sender
    @Default([]) List<SearchParamReference> sender,

    /// [status] draft | active | on-hold | revoked | completed | entered-in-error | unknown
    @Default([]) List<SearchParamToken> status,

    /// [subject] Focus of message
    @Default([]) List<SearchParamReference> subject,
  }) = _CommunicationRequestSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (authored.isNotEmpty) {
      authored.forEach(
          (element) => returnStrings.add('authored${element.toRequest()}'));
    }
    if (basedOn.isNotEmpty) {
      basedOn.forEach(
          (element) => returnStrings.add('based-on${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (groupIdentifier.isNotEmpty) {
      groupIdentifier.forEach((element) =>
          returnStrings.add('group-identifier${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (medium.isNotEmpty) {
      medium.forEach(
          (element) => returnStrings.add('medium${element.toRequest()}'));
    }
    if (occurrence.isNotEmpty) {
      occurrence.forEach(
          (element) => returnStrings.add('occurrence${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (priority.isNotEmpty) {
      priority.forEach(
          (element) => returnStrings.add('priority${element.toRequest()}'));
    }
    if (recipient.isNotEmpty) {
      recipient.forEach(
          (element) => returnStrings.add('recipient${element.toRequest()}'));
    }
    if (replaces.isNotEmpty) {
      replaces.forEach(
          (element) => returnStrings.add('replaces${element.toRequest()}'));
    }
    if (requester.isNotEmpty) {
      requester.forEach(
          (element) => returnStrings.add('requester${element.toRequest()}'));
    }
    if (sender.isNotEmpty) {
      sender.forEach(
          (element) => returnStrings.add('sender${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ContractSearchParams with _$ContractSearchParams {
  const ContractSearchParams._();
  const factory ContractSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [authority] The authority of the contract
    @Default([]) List<SearchParamReference> authority,

    /// [domain] The domain of the contract
    @Default([]) List<SearchParamReference> domain,

    /// [identifier] The identity of the contract
    @Default([]) List<SearchParamToken> identifier,

    /// [instantiates] A source definition of the contract
    @Default([]) List<SearchParamUri> instantiates,

    /// [issued] The date/time the contract was issued
    @Default([]) List<SearchParamDate> issued,

    /// [patient] The identity of the subject of the contract (if a patient)
    @Default([]) List<SearchParamReference> patient,

    /// [signer] Contract Signatory Party
    @Default([]) List<SearchParamReference> signer,

    /// [status] The status of the contract
    @Default([]) List<SearchParamToken> status,

    /// [subject] The identity of the subject of the contract
    @Default([]) List<SearchParamReference> subject,

    /// [url] The basal contract definition
    @Default([]) List<SearchParamUri> url,
  }) = _ContractSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (authority.isNotEmpty) {
      authority.forEach(
          (element) => returnStrings.add('authority${element.toRequest()}'));
    }
    if (domain.isNotEmpty) {
      domain.forEach(
          (element) => returnStrings.add('domain${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (instantiates.isNotEmpty) {
      instantiates.forEach(
          (element) => returnStrings.add('instantiates${element.toRequest()}'));
    }
    if (issued.isNotEmpty) {
      issued.forEach(
          (element) => returnStrings.add('issued${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (signer.isNotEmpty) {
      signer.forEach(
          (element) => returnStrings.add('signer${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class CoverageSearchParams with _$CoverageSearchParams {
  const CoverageSearchParams._();
  const factory CoverageSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [beneficiary] Covered party
    @Default([]) List<SearchParamReference> beneficiary,

    /// [classType] Coverage class (eg. plan, group)
    @Default([]) @JsonKey(name: 'class-type') List<SearchParamToken> classType,

    /// [classValue] Value of the class (eg. Plan number, group number)
    @Default([])
    @JsonKey(name: 'class-value')
        List<SearchParamString> classValue,

    /// [dependent] Dependent number
    @Default([]) List<SearchParamString> dependent,

    /// [identifier] The primary identifier of the insured and the coverage
    @Default([]) List<SearchParamToken> identifier,

    /// [patient] Retrieve coverages for a patient
    @Default([]) List<SearchParamReference> patient,

    /// [payor] The identity of the insurer or party paying for services
    @Default([]) List<SearchParamReference> payor,

    /// [policyHolder] Reference to the policyholder
    @Default([])
    @JsonKey(name: 'policy-holder')
        List<SearchParamReference> policyHolder,

    /// [status] The status of the Coverage
    @Default([]) List<SearchParamToken> status,

    /// [subscriber] Reference to the subscriber
    @Default([]) List<SearchParamReference> subscriber,

    /// [type] The kind of coverage (health plan, auto, Workers Compensation)
    @Default([]) List<SearchParamToken> type,
  }) = _CoverageSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (beneficiary.isNotEmpty) {
      beneficiary.forEach(
          (element) => returnStrings.add('beneficiary${element.toRequest()}'));
    }
    if (classType.isNotEmpty) {
      classType.forEach(
          (element) => returnStrings.add('class-type${element.toRequest()}'));
    }
    if (classValue.isNotEmpty) {
      classValue.forEach(
          (element) => returnStrings.add('class-value${element.toRequest()}'));
    }
    if (dependent.isNotEmpty) {
      dependent.forEach(
          (element) => returnStrings.add('dependent${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (payor.isNotEmpty) {
      payor.forEach(
          (element) => returnStrings.add('payor${element.toRequest()}'));
    }
    if (policyHolder.isNotEmpty) {
      policyHolder.forEach((element) =>
          returnStrings.add('policy-holder${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subscriber.isNotEmpty) {
      subscriber.forEach(
          (element) => returnStrings.add('subscriber${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class CoverageEligibilityRequestSearchParams
    with _$CoverageEligibilityRequestSearchParams {
  const CoverageEligibilityRequestSearchParams._();
  const factory CoverageEligibilityRequestSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [created] The creation date for the EOB
    @Default([]) List<SearchParamDate> created,

    /// [enterer] The party who is responsible for the request
    @Default([]) List<SearchParamReference> enterer,

    /// [facility] Facility responsible for the goods and services
    @Default([]) List<SearchParamReference> facility,

    /// [identifier] The business identifier of the Eligibility
    @Default([]) List<SearchParamToken> identifier,

    /// [patient] The reference to the patient
    @Default([]) List<SearchParamReference> patient,

    /// [provider] The reference to the provider
    @Default([]) List<SearchParamReference> provider,

    /// [status] The status of the EligibilityRequest
    @Default([]) List<SearchParamToken> status,
  }) = _CoverageEligibilityRequestSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (created.isNotEmpty) {
      created.forEach(
          (element) => returnStrings.add('created${element.toRequest()}'));
    }
    if (enterer.isNotEmpty) {
      enterer.forEach(
          (element) => returnStrings.add('enterer${element.toRequest()}'));
    }
    if (facility.isNotEmpty) {
      facility.forEach(
          (element) => returnStrings.add('facility${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (provider.isNotEmpty) {
      provider.forEach(
          (element) => returnStrings.add('provider${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class CoverageEligibilityResponseSearchParams
    with _$CoverageEligibilityResponseSearchParams {
  const CoverageEligibilityResponseSearchParams._();
  const factory CoverageEligibilityResponseSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [created] The creation date
    @Default([]) List<SearchParamDate> created,

    /// [disposition] The contents of the disposition message
    @Default([]) List<SearchParamString> disposition,

    /// [identifier] The business identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [insurer] The organization which generated this resource
    @Default([]) List<SearchParamReference> insurer,

    /// [outcome] The processing outcome
    @Default([]) List<SearchParamToken> outcome,

    /// [patient] The reference to the patient
    @Default([]) List<SearchParamReference> patient,

    /// [request] The EligibilityRequest reference
    @Default([]) List<SearchParamReference> request,

    /// [requestor] The EligibilityRequest provider
    @Default([]) List<SearchParamReference> requestor,

    /// [status] The EligibilityRequest status
    @Default([]) List<SearchParamToken> status,
  }) = _CoverageEligibilityResponseSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (created.isNotEmpty) {
      created.forEach(
          (element) => returnStrings.add('created${element.toRequest()}'));
    }
    if (disposition.isNotEmpty) {
      disposition.forEach(
          (element) => returnStrings.add('disposition${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (insurer.isNotEmpty) {
      insurer.forEach(
          (element) => returnStrings.add('insurer${element.toRequest()}'));
    }
    if (outcome.isNotEmpty) {
      outcome.forEach(
          (element) => returnStrings.add('outcome${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (request.isNotEmpty) {
      request.forEach(
          (element) => returnStrings.add('request${element.toRequest()}'));
    }
    if (requestor.isNotEmpty) {
      requestor.forEach(
          (element) => returnStrings.add('requestor${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class DeviceSearchParams with _$DeviceSearchParams {
  const DeviceSearchParams._();
  const factory DeviceSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [deviceName] A server defined search that may match any of the string fields in Device.deviceName or Device.type.
    @Default([])
    @JsonKey(name: 'device-name')
        List<SearchParamString> deviceName,

    /// [identifier] Instance id from manufacturer, owner, and others
    @Default([]) List<SearchParamToken> identifier,

    /// [location] A location, where the resource is found
    @Default([]) List<SearchParamReference> location,

    /// [manufacturer] The manufacturer of the device
    @Default([]) List<SearchParamString> manufacturer,

    /// [model] The model of the device
    @Default([]) List<SearchParamString> model,

    /// [organization] The organization responsible for the device
    @Default([]) List<SearchParamReference> organization,

    /// [patient] Patient information, if the resource is affixed to a person
    @Default([]) List<SearchParamReference> patient,

    /// [status] active | inactive | entered-in-error | unknown
    @Default([]) List<SearchParamToken> status,

    /// [type] The type of the device
    @Default([]) List<SearchParamToken> type,

    /// [udiCarrier] UDI Barcode (RFID or other technology) string in *HRF* format.
    @Default([])
    @JsonKey(name: 'udi-carrier')
        List<SearchParamString> udiCarrier,

    /// [udiDi] The udi Device Identifier (DI)
    @Default([]) @JsonKey(name: 'udi-di') List<SearchParamString> udiDi,

    /// [url] Network address to contact device
    @Default([]) List<SearchParamUri> url,
  }) = _DeviceSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (deviceName.isNotEmpty) {
      deviceName.forEach(
          (element) => returnStrings.add('device-name${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (location.isNotEmpty) {
      location.forEach(
          (element) => returnStrings.add('location${element.toRequest()}'));
    }
    if (manufacturer.isNotEmpty) {
      manufacturer.forEach(
          (element) => returnStrings.add('manufacturer${element.toRequest()}'));
    }
    if (model.isNotEmpty) {
      model.forEach(
          (element) => returnStrings.add('model${element.toRequest()}'));
    }
    if (organization.isNotEmpty) {
      organization.forEach(
          (element) => returnStrings.add('organization${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    if (udiCarrier.isNotEmpty) {
      udiCarrier.forEach(
          (element) => returnStrings.add('udi-carrier${element.toRequest()}'));
    }
    if (udiDi.isNotEmpty) {
      udiDi.forEach(
          (element) => returnStrings.add('udi-di${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class DeviceDefinitionSearchParams with _$DeviceDefinitionSearchParams {
  const DeviceDefinitionSearchParams._();
  const factory DeviceDefinitionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [identifier] The identifier of the component
    @Default([]) List<SearchParamToken> identifier,

    /// [parent] The parent DeviceDefinition resource
    @Default([]) List<SearchParamReference> parent,

    /// [type] The device component type
    @Default([]) List<SearchParamToken> type,
  }) = _DeviceDefinitionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (parent.isNotEmpty) {
      parent.forEach(
          (element) => returnStrings.add('parent${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class DeviceMetricSearchParams with _$DeviceMetricSearchParams {
  const DeviceMetricSearchParams._();
  const factory DeviceMetricSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [category] The category of the metric
    @Default([]) List<SearchParamToken> category,

    /// [identifier] The identifier of the metric
    @Default([]) List<SearchParamToken> identifier,

    /// [parent] The parent DeviceMetric resource
    @Default([]) List<SearchParamReference> parent,

    /// [source] The device resource
    @Default([]) List<SearchParamReference> source,

    /// [type] The component type
    @Default([]) List<SearchParamToken> type,
  }) = _DeviceMetricSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (parent.isNotEmpty) {
      parent.forEach(
          (element) => returnStrings.add('parent${element.toRequest()}'));
    }
    if (source.isNotEmpty) {
      source.forEach(
          (element) => returnStrings.add('source${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class EndpointSearchParams with _$EndpointSearchParams {
  const EndpointSearchParams._();
  const factory EndpointSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [connectionType] Protocol/Profile/Standard to be used with this endpoint connection
    @Default([])
    @JsonKey(name: 'connection-type')
        List<SearchParamToken> connectionType,

    /// [identifier] Identifies this endpoint across multiple systems
    @Default([]) List<SearchParamToken> identifier,

    /// [name] A name that this endpoint can be identified by
    @Default([]) List<SearchParamString> name,

    /// [organization] The organization that is managing the endpoint
    @Default([]) List<SearchParamReference> organization,

    /// [payloadType] The type of content that may be used at this endpoint (e.g. XDS Discharge summaries)
    @Default([])
    @JsonKey(name: 'payload-type')
        List<SearchParamToken> payloadType,

    /// [status] The current status of the Endpoint (usually expected to be active)
    @Default([]) List<SearchParamToken> status,
  }) = _EndpointSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (connectionType.isNotEmpty) {
      connectionType.forEach((element) =>
          returnStrings.add('connection-type${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (organization.isNotEmpty) {
      organization.forEach(
          (element) => returnStrings.add('organization${element.toRequest()}'));
    }
    if (payloadType.isNotEmpty) {
      payloadType.forEach(
          (element) => returnStrings.add('payload-type${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class EnrollmentRequestSearchParams with _$EnrollmentRequestSearchParams {
  const EnrollmentRequestSearchParams._();
  const factory EnrollmentRequestSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [identifier] The business identifier of the Enrollment
    @Default([]) List<SearchParamToken> identifier,

    /// [patient] The party to be enrolled
    @Default([]) List<SearchParamReference> patient,

    /// [status] The status of the enrollment
    @Default([]) List<SearchParamToken> status,

    /// [subject] The party to be enrolled
    @Default([]) List<SearchParamReference> subject,
  }) = _EnrollmentRequestSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class EnrollmentResponseSearchParams with _$EnrollmentResponseSearchParams {
  const EnrollmentResponseSearchParams._();
  const factory EnrollmentResponseSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [identifier] The business identifier of the EnrollmentResponse
    @Default([]) List<SearchParamToken> identifier,

    /// [request] The reference to the claim
    @Default([]) List<SearchParamReference> request,

    /// [status] The status of the enrollment response
    @Default([]) List<SearchParamToken> status,
  }) = _EnrollmentResponseSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (request.isNotEmpty) {
      request.forEach(
          (element) => returnStrings.add('request${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class EventDefinitionSearchParams with _$EventDefinitionSearchParams {
  const EventDefinitionSearchParams._();
  const factory EventDefinitionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [composedOf] What resource is being referenced
    @Default([])
    @JsonKey(name: 'composed-of')
        List<SearchParamReference> composedOf,

    /// [context] A use context assigned to the event definition
    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] A quantity- or range-valued use context assigned to the event definition
    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] A type of use context assigned to the event definition
    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] The event definition publication date
    @Default([]) List<SearchParamDate> date,

    /// [dependsOn] What resource is being referenced
    @Default([])
    @JsonKey(name: 'depends-on')
        List<SearchParamReference> dependsOn,

    /// [derivedFrom] What resource is being referenced
    @Default([])
    @JsonKey(name: 'derived-from')
        List<SearchParamReference> derivedFrom,

    /// [description] The description of the event definition
    @Default([]) List<SearchParamString> description,

    /// [effective] The time during which the event definition is intended to be in use
    @Default([]) List<SearchParamDate> effective,

    /// [identifier] External identifier for the event definition
    @Default([]) List<SearchParamToken> identifier,

    /// [jurisdiction] Intended jurisdiction for the event definition
    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Computationally friendly name of the event definition
    @Default([]) List<SearchParamString> name,

    /// [predecessor] What resource is being referenced
    @Default([]) List<SearchParamReference> predecessor,

    /// [publisher] Name of the publisher of the event definition
    @Default([]) List<SearchParamString> publisher,

    /// [status] The current status of the event definition
    @Default([]) List<SearchParamToken> status,

    /// [successor] What resource is being referenced
    @Default([]) List<SearchParamReference> successor,

    /// [title] The human-friendly name of the event definition
    @Default([]) List<SearchParamString> title,

    /// [topic] Topics associated with the module
    @Default([]) List<SearchParamToken> topic,

    /// [url] The uri that identifies the event definition
    @Default([]) List<SearchParamUri> url,

    /// [version] The business version of the event definition
    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] A use context type and quantity- or range-based value assigned to the event definition
    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] A use context type and value assigned to the event definition
    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,
  }) = _EventDefinitionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (composedOf.isNotEmpty) {
      composedOf.forEach(
          (element) => returnStrings.add('composed-of${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (dependsOn.isNotEmpty) {
      dependsOn.forEach(
          (element) => returnStrings.add('depends-on${element.toRequest()}'));
    }
    if (derivedFrom.isNotEmpty) {
      derivedFrom.forEach(
          (element) => returnStrings.add('derived-from${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (effective.isNotEmpty) {
      effective.forEach(
          (element) => returnStrings.add('effective${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (predecessor.isNotEmpty) {
      predecessor.forEach(
          (element) => returnStrings.add('predecessor${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (successor.isNotEmpty) {
      successor.forEach(
          (element) => returnStrings.add('successor${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (topic.isNotEmpty) {
      topic.forEach(
          (element) => returnStrings.add('topic${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class EvidenceSearchParams with _$EvidenceSearchParams {
  const EvidenceSearchParams._();
  const factory EvidenceSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] A use context assigned to the evidence
    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] A quantity- or range-valued use context assigned to the evidence
    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] A type of use context assigned to the evidence
    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] The evidence publication date
    @Default([]) List<SearchParamDate> date,

    /// [description] The description of the evidence
    @Default([]) List<SearchParamString> description,

    /// [identifier] External identifier for the evidence
    @Default([]) List<SearchParamToken> identifier,

    /// [publisher] Name of the publisher of the evidence
    @Default([]) List<SearchParamString> publisher,

    /// [status] The current status of the evidence
    @Default([]) List<SearchParamToken> status,

    /// [title] The human-friendly name of the evidence
    @Default([]) List<SearchParamString> title,

    /// [url] The uri that identifies the evidence
    @Default([]) List<SearchParamUri> url,

    /// [version] The business version of the evidence
    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] A use context type and quantity- or range-based value assigned to the evidence
    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] A use context type and value assigned to the evidence
    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,
  }) = _EvidenceSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class EvidenceReportSearchParams with _$EvidenceReportSearchParams {
  const EvidenceReportSearchParams._();
  const factory EvidenceReportSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] A use context assigned to the evidence report
    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] A quantity- or range-valued use context assigned to the evidence report
    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] A type of use context assigned to the evidence report
    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [identifier] External identifier for the evidence report
    @Default([]) List<SearchParamToken> identifier,

    /// [publisher] Name of the publisher of the evidence report
    @Default([]) List<SearchParamString> publisher,

    /// [status] The current status of the evidence report
    @Default([]) List<SearchParamToken> status,

    /// [url] The uri that identifies the evidence report
    @Default([]) List<SearchParamUri> url,

    /// [contextTypeQuantity] A use context type and quantity- or range-based value assigned to the evidence report
    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] A use context type and value assigned to the evidence report
    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,
  }) = _EvidenceReportSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class EvidenceVariableSearchParams with _$EvidenceVariableSearchParams {
  const EvidenceVariableSearchParams._();
  const factory EvidenceVariableSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] A use context assigned to the evidence variable
    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] A quantity- or range-valued use context assigned to the evidence variable
    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] A type of use context assigned to the evidence variable
    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] The evidence variable publication date
    @Default([]) List<SearchParamDate> date,

    /// [description] The description of the evidence variable
    @Default([]) List<SearchParamString> description,

    /// [identifier] External identifier for the evidence variable
    @Default([]) List<SearchParamToken> identifier,

    /// [name] Computationally friendly name of the evidence variable
    @Default([]) List<SearchParamString> name,

    /// [publisher] Name of the publisher of the evidence variable
    @Default([]) List<SearchParamString> publisher,

    /// [status] The current status of the evidence variable
    @Default([]) List<SearchParamToken> status,

    /// [title] The human-friendly name of the evidence variable
    @Default([]) List<SearchParamString> title,

    /// [url] The uri that identifies the evidence variable
    @Default([]) List<SearchParamUri> url,

    /// [version] The business version of the evidence variable
    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] A use context type and quantity- or range-based value assigned to the evidence variable
    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] A use context type and value assigned to the evidence variable
    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,
  }) = _EvidenceVariableSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ExampleScenarioSearchParams with _$ExampleScenarioSearchParams {
  const ExampleScenarioSearchParams._();
  const factory ExampleScenarioSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] A use context assigned to the example scenario
    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] A quantity- or range-valued use context assigned to the example scenario
    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] A type of use context assigned to the example scenario
    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] The example scenario publication date
    @Default([]) List<SearchParamDate> date,

    /// [identifier] External identifier for the example scenario
    @Default([]) List<SearchParamToken> identifier,

    /// [jurisdiction] Intended jurisdiction for the example scenario
    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Computationally friendly name of the example scenario
    @Default([]) List<SearchParamString> name,

    /// [publisher] Name of the publisher of the example scenario
    @Default([]) List<SearchParamString> publisher,

    /// [status] The current status of the example scenario
    @Default([]) List<SearchParamToken> status,

    /// [url] The uri that identifies the example scenario
    @Default([]) List<SearchParamUri> url,

    /// [version] The business version of the example scenario
    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] A use context type and quantity- or range-based value assigned to the example scenario
    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] A use context type and value assigned to the example scenario
    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,
  }) = _ExampleScenarioSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ExplanationOfBenefitSearchParams with _$ExplanationOfBenefitSearchParams {
  const ExplanationOfBenefitSearchParams._();
  const factory ExplanationOfBenefitSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [careTeam] Member of the CareTeam
    @Default([])
    @JsonKey(name: 'care-team')
        List<SearchParamReference> careTeam,

    /// [claim] The reference to the claim
    @Default([]) List<SearchParamReference> claim,

    /// [coverage] The plan under which the claim was adjudicated
    @Default([]) List<SearchParamReference> coverage,

    /// [created] The creation date for the EOB
    @Default([]) List<SearchParamDate> created,

    /// [detailUdi] UDI associated with a line item detail product or service
    @Default([])
    @JsonKey(name: 'detail-udi')
        List<SearchParamReference> detailUdi,

    /// [disposition] The contents of the disposition message
    @Default([]) List<SearchParamString> disposition,

    /// [encounter] Encounters associated with a billed line item
    @Default([]) List<SearchParamReference> encounter,

    /// [enterer] The party responsible for the entry of the Claim
    @Default([]) List<SearchParamReference> enterer,

    /// [facility] Facility responsible for the goods and services
    @Default([]) List<SearchParamReference> facility,

    /// [identifier] The business identifier of the Explanation of Benefit
    @Default([]) List<SearchParamToken> identifier,

    /// [itemUdi] UDI associated with a line item product or service
    @Default([]) @JsonKey(name: 'item-udi') List<SearchParamReference> itemUdi,

    /// [patient] The reference to the patient
    @Default([]) List<SearchParamReference> patient,

    /// [payee] The party receiving any payment for the Claim
    @Default([]) List<SearchParamReference> payee,

    /// [procedureUdi] UDI associated with a procedure
    @Default([])
    @JsonKey(name: 'procedure-udi')
        List<SearchParamReference> procedureUdi,

    /// [provider] The reference to the provider
    @Default([]) List<SearchParamReference> provider,

    /// [status] Status of the instance
    @Default([]) List<SearchParamToken> status,

    /// [subdetailUdi] UDI associated with a line item detail subdetail product or service
    @Default([])
    @JsonKey(name: 'subdetail-udi')
        List<SearchParamReference> subdetailUdi,
  }) = _ExplanationOfBenefitSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (careTeam.isNotEmpty) {
      careTeam.forEach(
          (element) => returnStrings.add('care-team${element.toRequest()}'));
    }
    if (claim.isNotEmpty) {
      claim.forEach(
          (element) => returnStrings.add('claim${element.toRequest()}'));
    }
    if (coverage.isNotEmpty) {
      coverage.forEach(
          (element) => returnStrings.add('coverage${element.toRequest()}'));
    }
    if (created.isNotEmpty) {
      created.forEach(
          (element) => returnStrings.add('created${element.toRequest()}'));
    }
    if (detailUdi.isNotEmpty) {
      detailUdi.forEach(
          (element) => returnStrings.add('detail-udi${element.toRequest()}'));
    }
    if (disposition.isNotEmpty) {
      disposition.forEach(
          (element) => returnStrings.add('disposition${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (enterer.isNotEmpty) {
      enterer.forEach(
          (element) => returnStrings.add('enterer${element.toRequest()}'));
    }
    if (facility.isNotEmpty) {
      facility.forEach(
          (element) => returnStrings.add('facility${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (itemUdi.isNotEmpty) {
      itemUdi.forEach(
          (element) => returnStrings.add('item-udi${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (payee.isNotEmpty) {
      payee.forEach(
          (element) => returnStrings.add('payee${element.toRequest()}'));
    }
    if (procedureUdi.isNotEmpty) {
      procedureUdi.forEach((element) =>
          returnStrings.add('procedure-udi${element.toRequest()}'));
    }
    if (provider.isNotEmpty) {
      provider.forEach(
          (element) => returnStrings.add('provider${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subdetailUdi.isNotEmpty) {
      subdetailUdi.forEach((element) =>
          returnStrings.add('subdetail-udi${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class GroupSearchParams with _$GroupSearchParams {
  const GroupSearchParams._();
  const factory GroupSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [actual] Descriptive or actual
    @Default([]) List<SearchParamToken> actual,

    /// [characteristic] Kind of characteristic
    @Default([]) List<SearchParamToken> characteristic,

    /// [code] The kind of resources contained
    @Default([]) List<SearchParamToken> code,

    /// [exclude] Group includes or excludes
    @Default([]) List<SearchParamToken> exclude,

    /// [identifier] Unique id
    @Default([]) List<SearchParamToken> identifier,

    /// [managingEntity] Entity that is the custodian of the Group's definition
    @Default([])
    @JsonKey(name: 'managing-entity')
        List<SearchParamReference> managingEntity,

    /// [member] Reference to the group member
    @Default([]) List<SearchParamReference> member,

    /// [type] The type of resources the group contains
    @Default([]) List<SearchParamToken> type,

    /// [value] Value held by characteristic
    @Default([]) List<SearchParamToken> value,

    /// [characteristicValue] A composite of both characteristic and value
    @Default([])
    @JsonKey(name: 'characteristic-value')
        List<SearchParamComposite> characteristicValue,
  }) = _GroupSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (actual.isNotEmpty) {
      actual.forEach(
          (element) => returnStrings.add('actual${element.toRequest()}'));
    }
    if (characteristic.isNotEmpty) {
      characteristic.forEach((element) =>
          returnStrings.add('characteristic${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (exclude.isNotEmpty) {
      exclude.forEach(
          (element) => returnStrings.add('exclude${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (managingEntity.isNotEmpty) {
      managingEntity.forEach((element) =>
          returnStrings.add('managing-entity${element.toRequest()}'));
    }
    if (member.isNotEmpty) {
      member.forEach(
          (element) => returnStrings.add('member${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    if (value.isNotEmpty) {
      value.forEach(
          (element) => returnStrings.add('value${element.toRequest()}'));
    }
    if (characteristicValue.isNotEmpty) {
      characteristicValue.forEach((element) =>
          returnStrings.add('characteristic-value${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class GuidanceResponseSearchParams with _$GuidanceResponseSearchParams {
  const GuidanceResponseSearchParams._();
  const factory GuidanceResponseSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [identifier] The identifier of the guidance response
    @Default([]) List<SearchParamToken> identifier,

    /// [patient] The identity of a patient to search for guidance response results
    @Default([]) List<SearchParamReference> patient,

    /// [request] The identifier of the request associated with the response
    @Default([]) List<SearchParamToken> request,

    /// [subject] The subject that the guidance response is about
    @Default([]) List<SearchParamReference> subject,
  }) = _GuidanceResponseSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (request.isNotEmpty) {
      request.forEach(
          (element) => returnStrings.add('request${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class HealthcareServiceSearchParams with _$HealthcareServiceSearchParams {
  const HealthcareServiceSearchParams._();
  const factory HealthcareServiceSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [active] The Healthcare Service is currently marked as active
    @Default([]) List<SearchParamToken> active,

    /// [characteristic] One of the HealthcareService's characteristics
    @Default([]) List<SearchParamToken> characteristic,

    /// [coverageArea] Location(s) service is intended for/available to
    @Default([])
    @JsonKey(name: 'coverage-area')
        List<SearchParamReference> coverageArea,

    /// [endpoint] Technical endpoints providing access to electronic services operated for the healthcare service
    @Default([]) List<SearchParamReference> endpoint,

    /// [identifier] External identifiers for this item
    @Default([]) List<SearchParamToken> identifier,

    /// [location] The location of the Healthcare Service
    @Default([]) List<SearchParamReference> location,

    /// [name] A portion of the Healthcare service name
    @Default([]) List<SearchParamString> name,

    /// [organization] The organization that provides this Healthcare Service
    @Default([]) List<SearchParamReference> organization,

    /// [program] One of the Programs supported by this HealthcareService
    @Default([]) List<SearchParamToken> program,

    /// [serviceCategory] Service Category of the Healthcare Service
    @Default([])
    @JsonKey(name: 'service-category')
        List<SearchParamToken> serviceCategory,

    /// [serviceType] The type of service provided by this healthcare service
    @Default([])
    @JsonKey(name: 'service-type')
        List<SearchParamToken> serviceType,

    /// [specialty] The specialty of the service provided by this healthcare service
    @Default([]) List<SearchParamToken> specialty,
  }) = _HealthcareServiceSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (active.isNotEmpty) {
      active.forEach(
          (element) => returnStrings.add('active${element.toRequest()}'));
    }
    if (characteristic.isNotEmpty) {
      characteristic.forEach((element) =>
          returnStrings.add('characteristic${element.toRequest()}'));
    }
    if (coverageArea.isNotEmpty) {
      coverageArea.forEach((element) =>
          returnStrings.add('coverage-area${element.toRequest()}'));
    }
    if (endpoint.isNotEmpty) {
      endpoint.forEach(
          (element) => returnStrings.add('endpoint${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (location.isNotEmpty) {
      location.forEach(
          (element) => returnStrings.add('location${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (organization.isNotEmpty) {
      organization.forEach(
          (element) => returnStrings.add('organization${element.toRequest()}'));
    }
    if (program.isNotEmpty) {
      program.forEach(
          (element) => returnStrings.add('program${element.toRequest()}'));
    }
    if (serviceCategory.isNotEmpty) {
      serviceCategory.forEach((element) =>
          returnStrings.add('service-category${element.toRequest()}'));
    }
    if (serviceType.isNotEmpty) {
      serviceType.forEach(
          (element) => returnStrings.add('service-type${element.toRequest()}'));
    }
    if (specialty.isNotEmpty) {
      specialty.forEach(
          (element) => returnStrings.add('specialty${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ImmunizationEvaluationSearchParams
    with _$ImmunizationEvaluationSearchParams {
  const ImmunizationEvaluationSearchParams._();
  const factory ImmunizationEvaluationSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [date] Date the evaluation was generated
    @Default([]) List<SearchParamDate> date,

    /// [doseStatus] The status of the dose relative to published recommendations
    @Default([])
    @JsonKey(name: 'dose-status')
        List<SearchParamToken> doseStatus,

    /// [identifier] ID of the evaluation
    @Default([]) List<SearchParamToken> identifier,

    /// [immunizationEvent] The vaccine administration event being evaluated
    @Default([])
    @JsonKey(name: 'immunization-event')
        List<SearchParamReference> immunizationEvent,

    /// [patient] The patient being evaluated
    @Default([]) List<SearchParamReference> patient,

    /// [status] Immunization evaluation status
    @Default([]) List<SearchParamToken> status,

    /// [targetDisease] The vaccine preventable disease being evaluated against
    @Default([])
    @JsonKey(name: 'target-disease')
        List<SearchParamToken> targetDisease,
  }) = _ImmunizationEvaluationSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (doseStatus.isNotEmpty) {
      doseStatus.forEach(
          (element) => returnStrings.add('dose-status${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (immunizationEvent.isNotEmpty) {
      immunizationEvent.forEach((element) =>
          returnStrings.add('immunization-event${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (targetDisease.isNotEmpty) {
      targetDisease.forEach((element) =>
          returnStrings.add('target-disease${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ImmunizationRecommendationSearchParams
    with _$ImmunizationRecommendationSearchParams {
  const ImmunizationRecommendationSearchParams._();
  const factory ImmunizationRecommendationSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [date] Date recommendation(s) created
    @Default([]) List<SearchParamDate> date,

    /// [identifier] Business identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [information] Patient observations supporting recommendation
    @Default([]) List<SearchParamReference> information,

    /// [patient] Who this profile is for
    @Default([]) List<SearchParamReference> patient,

    /// [status] Vaccine recommendation status
    @Default([]) List<SearchParamToken> status,

    /// [support] Past immunizations supporting recommendation
    @Default([]) List<SearchParamReference> support,

    /// [targetDisease] Disease to be immunized against
    @Default([])
    @JsonKey(name: 'target-disease')
        List<SearchParamToken> targetDisease,

    /// [vaccineType] Vaccine  or vaccine group recommendation applies to
    @Default([])
    @JsonKey(name: 'vaccine-type')
        List<SearchParamToken> vaccineType,
  }) = _ImmunizationRecommendationSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (information.isNotEmpty) {
      information.forEach(
          (element) => returnStrings.add('information${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (support.isNotEmpty) {
      support.forEach(
          (element) => returnStrings.add('support${element.toRequest()}'));
    }
    if (targetDisease.isNotEmpty) {
      targetDisease.forEach((element) =>
          returnStrings.add('target-disease${element.toRequest()}'));
    }
    if (vaccineType.isNotEmpty) {
      vaccineType.forEach(
          (element) => returnStrings.add('vaccine-type${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class IngredientSearchParams with _$IngredientSearchParams {
  const IngredientSearchParams._();
  const factory IngredientSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [for_] The product which this ingredient is a constituent part of
    @Default([]) @JsonKey(name: 'for') List<SearchParamReference> for_,

    /// [function_] A classification of the ingredient identifying its precise purpose(s) in the drug product. This extends the Ingredient.role to add more detail. Example: Antioxidant, Alkalizing Agent
    @Default([]) @JsonKey(name: 'function') List<SearchParamToken> function_,

    /// [identifier] An identifier or code by which the ingredient can be referenced
    @Default([]) List<SearchParamToken> identifier,

    /// [manufacturer] The organization that manufactures this ingredient
    @Default([]) List<SearchParamReference> manufacturer,

    /// [role] A classification of the ingredient identifying its purpose within the product, e.g. active, inactive
    @Default([]) List<SearchParamToken> role,

    /// [substance] Reference to a resource (by instance)
    @Default([]) List<SearchParamReference> substance,

    /// [substanceCode] Reference to a concept (by class)
    @Default([])
    @JsonKey(name: 'substance-code')
        List<SearchParamToken> substanceCode,

    /// [substanceDefinition] Reference to a resource (by instance)
    @Default([])
    @JsonKey(name: 'substance-definition')
        List<SearchParamReference> substanceDefinition,
  }) = _IngredientSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (for_.isNotEmpty) {
      for_.forEach((element) => returnStrings.add('for${element.toRequest()}'));
    }
    if (function_.isNotEmpty) {
      function_.forEach(
          (element) => returnStrings.add('function${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (manufacturer.isNotEmpty) {
      manufacturer.forEach(
          (element) => returnStrings.add('manufacturer${element.toRequest()}'));
    }
    if (role.isNotEmpty) {
      role.forEach(
          (element) => returnStrings.add('role${element.toRequest()}'));
    }
    if (substance.isNotEmpty) {
      substance.forEach(
          (element) => returnStrings.add('substance${element.toRequest()}'));
    }
    if (substanceCode.isNotEmpty) {
      substanceCode.forEach((element) =>
          returnStrings.add('substance-code${element.toRequest()}'));
    }
    if (substanceDefinition.isNotEmpty) {
      substanceDefinition.forEach((element) =>
          returnStrings.add('substance-definition${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class InsurancePlanSearchParams with _$InsurancePlanSearchParams {
  const InsurancePlanSearchParams._();
  const factory InsurancePlanSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [address] A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text
    @Default([]) List<SearchParamString> address,

    /// [addressCity] A city specified in an address
    @Default([])
    @JsonKey(name: 'address-city')
        List<SearchParamString> addressCity,

    /// [addressCountry] A country specified in an address
    @Default([])
    @JsonKey(name: 'address-country')
        List<SearchParamString> addressCountry,

    /// [addressPostalcode] A postal code specified in an address
    @Default([])
    @JsonKey(name: 'address-postalcode')
        List<SearchParamString> addressPostalcode,

    /// [addressState] A state specified in an address
    @Default([])
    @JsonKey(name: 'address-state')
        List<SearchParamString> addressState,

    /// [addressUse] A use code specified in an address
    @Default([])
    @JsonKey(name: 'address-use')
        List<SearchParamToken> addressUse,

    /// [administeredBy] Product administrator
    @Default([])
    @JsonKey(name: 'administered-by')
        List<SearchParamReference> administeredBy,

    /// [endpoint] Technical endpoint
    @Default([]) List<SearchParamReference> endpoint,

    /// [identifier] Any identifier for the organization (not the accreditation issuer's identifier)
    @Default([]) List<SearchParamToken> identifier,

    /// [name] A portion of the organization's name or alias
    @Default([]) List<SearchParamString> name,

    /// [ownedBy] An organization of which this organization forms a part
    @Default([]) @JsonKey(name: 'owned-by') List<SearchParamReference> ownedBy,

    /// [phonetic] A portion of the organization's name using some kind of phonetic matching algorithm
    @Default([]) List<SearchParamString> phonetic,

    /// [status] Is the Organization record active
    @Default([]) List<SearchParamToken> status,

    /// [type] A code for the type of organization
    @Default([]) List<SearchParamToken> type,
  }) = _InsurancePlanSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (address.isNotEmpty) {
      address.forEach(
          (element) => returnStrings.add('address${element.toRequest()}'));
    }
    if (addressCity.isNotEmpty) {
      addressCity.forEach(
          (element) => returnStrings.add('address-city${element.toRequest()}'));
    }
    if (addressCountry.isNotEmpty) {
      addressCountry.forEach((element) =>
          returnStrings.add('address-country${element.toRequest()}'));
    }
    if (addressPostalcode.isNotEmpty) {
      addressPostalcode.forEach((element) =>
          returnStrings.add('address-postalcode${element.toRequest()}'));
    }
    if (addressState.isNotEmpty) {
      addressState.forEach((element) =>
          returnStrings.add('address-state${element.toRequest()}'));
    }
    if (addressUse.isNotEmpty) {
      addressUse.forEach(
          (element) => returnStrings.add('address-use${element.toRequest()}'));
    }
    if (administeredBy.isNotEmpty) {
      administeredBy.forEach((element) =>
          returnStrings.add('administered-by${element.toRequest()}'));
    }
    if (endpoint.isNotEmpty) {
      endpoint.forEach(
          (element) => returnStrings.add('endpoint${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (ownedBy.isNotEmpty) {
      ownedBy.forEach(
          (element) => returnStrings.add('owned-by${element.toRequest()}'));
    }
    if (phonetic.isNotEmpty) {
      phonetic.forEach(
          (element) => returnStrings.add('phonetic${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class InvoiceSearchParams with _$InvoiceSearchParams {
  const InvoiceSearchParams._();
  const factory InvoiceSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [account] Account that is being balanced
    @Default([]) List<SearchParamReference> account,

    /// [date] Invoice date / posting date
    @Default([]) List<SearchParamDate> date,

    /// [identifier] Business Identifier for item
    @Default([]) List<SearchParamToken> identifier,

    /// [issuer] Issuing Organization of Invoice
    @Default([]) List<SearchParamReference> issuer,

    /// [participant] Individual who was involved
    @Default([]) List<SearchParamReference> participant,

    /// [participantRole] Type of involvement in creation of this Invoice
    @Default([])
    @JsonKey(name: 'participant-role')
        List<SearchParamToken> participantRole,

    /// [patient] Recipient(s) of goods and services
    @Default([]) List<SearchParamReference> patient,

    /// [recipient] Recipient of this invoice
    @Default([]) List<SearchParamReference> recipient,

    /// [status] draft | issued | balanced | cancelled | entered-in-error
    @Default([]) List<SearchParamToken> status,

    /// [subject] Recipient(s) of goods and services
    @Default([]) List<SearchParamReference> subject,

    /// [totalgross] Gross total of this Invoice
    @Default([]) List<SearchParamQuantity> totalgross,

    /// [totalnet] Net total of this Invoice
    @Default([]) List<SearchParamQuantity> totalnet,

    /// [type] Type of Invoice
    @Default([]) List<SearchParamToken> type,
  }) = _InvoiceSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (account.isNotEmpty) {
      account.forEach(
          (element) => returnStrings.add('account${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (issuer.isNotEmpty) {
      issuer.forEach(
          (element) => returnStrings.add('issuer${element.toRequest()}'));
    }
    if (participant.isNotEmpty) {
      participant.forEach(
          (element) => returnStrings.add('participant${element.toRequest()}'));
    }
    if (participantRole.isNotEmpty) {
      participantRole.forEach((element) =>
          returnStrings.add('participant-role${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (recipient.isNotEmpty) {
      recipient.forEach(
          (element) => returnStrings.add('recipient${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    if (totalgross.isNotEmpty) {
      totalgross.forEach(
          (element) => returnStrings.add('totalgross${element.toRequest()}'));
    }
    if (totalnet.isNotEmpty) {
      totalnet.forEach(
          (element) => returnStrings.add('totalnet${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class LibrarySearchParams with _$LibrarySearchParams {
  const LibrarySearchParams._();
  const factory LibrarySearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [composedOf] What resource is being referenced
    @Default([])
    @JsonKey(name: 'composed-of')
        List<SearchParamReference> composedOf,

    /// [contentType] The type of content in the library (e.g. text/cql)
    @Default([])
    @JsonKey(name: 'content-type')
        List<SearchParamToken> contentType,

    /// [context] A use context assigned to the library
    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] A quantity- or range-valued use context assigned to the library
    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] A type of use context assigned to the library
    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] The library publication date
    @Default([]) List<SearchParamDate> date,

    /// [dependsOn] What resource is being referenced
    @Default([])
    @JsonKey(name: 'depends-on')
        List<SearchParamReference> dependsOn,

    /// [derivedFrom] What resource is being referenced
    @Default([])
    @JsonKey(name: 'derived-from')
        List<SearchParamReference> derivedFrom,

    /// [description] The description of the library
    @Default([]) List<SearchParamString> description,

    /// [effective] The time during which the library is intended to be in use
    @Default([]) List<SearchParamDate> effective,

    /// [identifier] External identifier for the library
    @Default([]) List<SearchParamToken> identifier,

    /// [jurisdiction] Intended jurisdiction for the library
    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Computationally friendly name of the library
    @Default([]) List<SearchParamString> name,

    /// [predecessor] What resource is being referenced
    @Default([]) List<SearchParamReference> predecessor,

    /// [publisher] Name of the publisher of the library
    @Default([]) List<SearchParamString> publisher,

    /// [status] The current status of the library
    @Default([]) List<SearchParamToken> status,

    /// [successor] What resource is being referenced
    @Default([]) List<SearchParamReference> successor,

    /// [title] The human-friendly name of the library
    @Default([]) List<SearchParamString> title,

    /// [topic] Topics associated with the module
    @Default([]) List<SearchParamToken> topic,

    /// [type] The type of the library (e.g. logic-library, model-definition, asset-collection, module-definition)
    @Default([]) List<SearchParamToken> type,

    /// [url] The uri that identifies the library
    @Default([]) List<SearchParamUri> url,

    /// [version] The business version of the library
    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] A use context type and quantity- or range-based value assigned to the library
    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] A use context type and value assigned to the library
    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,
  }) = _LibrarySearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (composedOf.isNotEmpty) {
      composedOf.forEach(
          (element) => returnStrings.add('composed-of${element.toRequest()}'));
    }
    if (contentType.isNotEmpty) {
      contentType.forEach(
          (element) => returnStrings.add('content-type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (dependsOn.isNotEmpty) {
      dependsOn.forEach(
          (element) => returnStrings.add('depends-on${element.toRequest()}'));
    }
    if (derivedFrom.isNotEmpty) {
      derivedFrom.forEach(
          (element) => returnStrings.add('derived-from${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (effective.isNotEmpty) {
      effective.forEach(
          (element) => returnStrings.add('effective${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (predecessor.isNotEmpty) {
      predecessor.forEach(
          (element) => returnStrings.add('predecessor${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (successor.isNotEmpty) {
      successor.forEach(
          (element) => returnStrings.add('successor${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (topic.isNotEmpty) {
      topic.forEach(
          (element) => returnStrings.add('topic${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class LinkageSearchParams with _$LinkageSearchParams {
  const LinkageSearchParams._();
  const factory LinkageSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [author] Author of the Linkage
    @Default([]) List<SearchParamReference> author,

    /// [item] Matches on any item in the Linkage
    @Default([]) List<SearchParamReference> item,

    /// [source] Matches on any item in the Linkage with a type of 'source'
    @Default([]) List<SearchParamReference> source,
  }) = _LinkageSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (author.isNotEmpty) {
      author.forEach(
          (element) => returnStrings.add('author${element.toRequest()}'));
    }
    if (item.isNotEmpty) {
      item.forEach(
          (element) => returnStrings.add('item${element.toRequest()}'));
    }
    if (source.isNotEmpty) {
      source.forEach(
          (element) => returnStrings.add('source${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class LocationSearchParams with _$LocationSearchParams {
  const LocationSearchParams._();
  const factory LocationSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [address] A (part of the) address of the location
    @Default([]) List<SearchParamString> address,

    /// [addressCity] A city specified in an address
    @Default([])
    @JsonKey(name: 'address-city')
        List<SearchParamString> addressCity,

    /// [addressCountry] A country specified in an address
    @Default([])
    @JsonKey(name: 'address-country')
        List<SearchParamString> addressCountry,

    /// [addressPostalcode] A postal code specified in an address
    @Default([])
    @JsonKey(name: 'address-postalcode')
        List<SearchParamString> addressPostalcode,

    /// [addressState] A state specified in an address
    @Default([])
    @JsonKey(name: 'address-state')
        List<SearchParamString> addressState,

    /// [addressUse] A use code specified in an address
    @Default([])
    @JsonKey(name: 'address-use')
        List<SearchParamToken> addressUse,

    /// [endpoint] Technical endpoints providing access to services operated for the location
    @Default([]) List<SearchParamReference> endpoint,

    /// [identifier] An identifier for the location
    @Default([]) List<SearchParamToken> identifier,

    /// [name] A portion of the location's name or alias
    @Default([]) List<SearchParamString> name,

    /// [near] Search for locations where the location.position is near to, or
    /// within a specified distance of, the provided coordinates expressed as
    /// [latitude]|[longitude]|[distance]|[units] (using the WGS84 datum, see notes).
    /// If the units are omitted, then kms should be assumed. If the distance is
    /// omitted, then the server can use its own discretion as to what distances
    /// should be considered near (and units are irrelevant)
    /// Servers may search using various techniques that might have differing
    /// accuracies, depending on implementation efficiency.
    /// Requires the near-distance parameter to be provided also
    @Default([]) List<SearchParamSpecial> near,

    /// [operationalStatus] Searches for locations (typically bed/room) that have an operational status (e.g. contaminated, housekeeping)
    @Default([])
    @JsonKey(name: 'operational-status')
        List<SearchParamToken> operationalStatus,

    /// [organization] Searches for locations that are managed by the provided organization
    @Default([]) List<SearchParamReference> organization,

    /// [partof] A location of which this location is a part
    @Default([]) List<SearchParamReference> partof,

    /// [status] Searches for locations with a specific kind of status
    @Default([]) List<SearchParamToken> status,

    /// [type] A code for the type of location
    @Default([]) List<SearchParamToken> type,
  }) = _LocationSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (address.isNotEmpty) {
      address.forEach(
          (element) => returnStrings.add('address${element.toRequest()}'));
    }
    if (addressCity.isNotEmpty) {
      addressCity.forEach(
          (element) => returnStrings.add('address-city${element.toRequest()}'));
    }
    if (addressCountry.isNotEmpty) {
      addressCountry.forEach((element) =>
          returnStrings.add('address-country${element.toRequest()}'));
    }
    if (addressPostalcode.isNotEmpty) {
      addressPostalcode.forEach((element) =>
          returnStrings.add('address-postalcode${element.toRequest()}'));
    }
    if (addressState.isNotEmpty) {
      addressState.forEach((element) =>
          returnStrings.add('address-state${element.toRequest()}'));
    }
    if (addressUse.isNotEmpty) {
      addressUse.forEach(
          (element) => returnStrings.add('address-use${element.toRequest()}'));
    }
    if (endpoint.isNotEmpty) {
      endpoint.forEach(
          (element) => returnStrings.add('endpoint${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (near.isNotEmpty) {
      near.forEach(
          (element) => returnStrings.add('near${element.toRequest()}'));
    }
    if (operationalStatus.isNotEmpty) {
      operationalStatus.forEach((element) =>
          returnStrings.add('operational-status${element.toRequest()}'));
    }
    if (organization.isNotEmpty) {
      organization.forEach(
          (element) => returnStrings.add('organization${element.toRequest()}'));
    }
    if (partof.isNotEmpty) {
      partof.forEach(
          (element) => returnStrings.add('partof${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ManufacturedItemDefinitionSearchParams
    with _$ManufacturedItemDefinitionSearchParams {
  const ManufacturedItemDefinitionSearchParams._();
  const factory ManufacturedItemDefinitionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [doseForm] Dose form as manufactured and before any transformation into the pharmaceutical product
    @Default([]) @JsonKey(name: 'dose-form') List<SearchParamToken> doseForm,

    /// [identifier] Unique identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [ingredient] An ingredient of this item
    @Default([]) List<SearchParamToken> ingredient,
  }) = _ManufacturedItemDefinitionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (doseForm.isNotEmpty) {
      doseForm.forEach(
          (element) => returnStrings.add('dose-form${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (ingredient.isNotEmpty) {
      ingredient.forEach(
          (element) => returnStrings.add('ingredient${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class MeasureSearchParams with _$MeasureSearchParams {
  const MeasureSearchParams._();
  const factory MeasureSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [composedOf] What resource is being referenced
    @Default([])
    @JsonKey(name: 'composed-of')
        List<SearchParamReference> composedOf,

    /// [context] A use context assigned to the measure
    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] A quantity- or range-valued use context assigned to the measure
    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] A type of use context assigned to the measure
    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] The measure publication date
    @Default([]) List<SearchParamDate> date,

    /// [dependsOn] What resource is being referenced
    @Default([])
    @JsonKey(name: 'depends-on')
        List<SearchParamReference> dependsOn,

    /// [derivedFrom] What resource is being referenced
    @Default([])
    @JsonKey(name: 'derived-from')
        List<SearchParamReference> derivedFrom,

    /// [description] The description of the measure
    @Default([]) List<SearchParamString> description,

    /// [effective] The time during which the measure is intended to be in use
    @Default([]) List<SearchParamDate> effective,

    /// [identifier] External identifier for the measure
    @Default([]) List<SearchParamToken> identifier,

    /// [jurisdiction] Intended jurisdiction for the measure
    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Computationally friendly name of the measure
    @Default([]) List<SearchParamString> name,

    /// [predecessor] What resource is being referenced
    @Default([]) List<SearchParamReference> predecessor,

    /// [publisher] Name of the publisher of the measure
    @Default([]) List<SearchParamString> publisher,

    /// [status] The current status of the measure
    @Default([]) List<SearchParamToken> status,

    /// [successor] What resource is being referenced
    @Default([]) List<SearchParamReference> successor,

    /// [title] The human-friendly name of the measure
    @Default([]) List<SearchParamString> title,

    /// [topic] Topics associated with the measure
    @Default([]) List<SearchParamToken> topic,

    /// [url] The uri that identifies the measure
    @Default([]) List<SearchParamUri> url,

    /// [version] The business version of the measure
    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] A use context type and quantity- or range-based value assigned to the measure
    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] A use context type and value assigned to the measure
    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,
  }) = _MeasureSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (composedOf.isNotEmpty) {
      composedOf.forEach(
          (element) => returnStrings.add('composed-of${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (dependsOn.isNotEmpty) {
      dependsOn.forEach(
          (element) => returnStrings.add('depends-on${element.toRequest()}'));
    }
    if (derivedFrom.isNotEmpty) {
      derivedFrom.forEach(
          (element) => returnStrings.add('derived-from${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (effective.isNotEmpty) {
      effective.forEach(
          (element) => returnStrings.add('effective${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (predecessor.isNotEmpty) {
      predecessor.forEach(
          (element) => returnStrings.add('predecessor${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (successor.isNotEmpty) {
      successor.forEach(
          (element) => returnStrings.add('successor${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (topic.isNotEmpty) {
      topic.forEach(
          (element) => returnStrings.add('topic${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class MeasureReportSearchParams with _$MeasureReportSearchParams {
  const MeasureReportSearchParams._();
  const factory MeasureReportSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [date] The date of the measure report
    @Default([]) List<SearchParamDate> date,

    /// [evaluatedResource] An evaluated resource referenced by the measure report
    @Default([])
    @JsonKey(name: 'evaluated-resource')
        List<SearchParamReference> evaluatedResource,

    /// [identifier] External identifier of the measure report to be returned
    @Default([]) List<SearchParamToken> identifier,

    /// [measure] The measure to return measure report results for
    @Default([]) List<SearchParamReference> measure,

    /// [patient] The identity of a patient to search for individual measure report results for
    @Default([]) List<SearchParamReference> patient,

    /// [period] The period of the measure report
    @Default([]) List<SearchParamDate> period,

    /// [reporter] The reporter to return measure report results for
    @Default([]) List<SearchParamReference> reporter,

    /// [status] The status of the measure report
    @Default([]) List<SearchParamToken> status,

    /// [subject] The identity of a subject to search for individual measure report results for
    @Default([]) List<SearchParamReference> subject,
  }) = _MeasureReportSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (evaluatedResource.isNotEmpty) {
      evaluatedResource.forEach((element) =>
          returnStrings.add('evaluated-resource${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (measure.isNotEmpty) {
      measure.forEach(
          (element) => returnStrings.add('measure${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (period.isNotEmpty) {
      period.forEach(
          (element) => returnStrings.add('period${element.toRequest()}'));
    }
    if (reporter.isNotEmpty) {
      reporter.forEach(
          (element) => returnStrings.add('reporter${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class MediaSearchParams with _$MediaSearchParams {
  const MediaSearchParams._();
  const factory MediaSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [basedOn] Procedure that caused this media to be created
    @Default([]) @JsonKey(name: 'based-on') List<SearchParamReference> basedOn,

    /// [created] When Media was collected
    @Default([]) List<SearchParamDate> created,

    /// [device] Observing Device
    @Default([]) List<SearchParamReference> device,

    /// [encounter] Encounter associated with media
    @Default([]) List<SearchParamReference> encounter,

    /// [identifier] Identifier(s) for the image
    @Default([]) List<SearchParamToken> identifier,

    /// [modality] The type of acquisition equipment/process
    @Default([]) List<SearchParamToken> modality,

    /// [operator_] The person who generated the image
    @Default([])
    @JsonKey(name: 'operator')
        List<SearchParamReference> operator_,

    /// [patient] Who/What this Media is a record of
    @Default([]) List<SearchParamReference> patient,

    /// [site] Observed body part
    @Default([]) List<SearchParamToken> site,

    /// [status] preparation | in-progress | not-done | on-hold | stopped | completed | entered-in-error | unknown
    @Default([]) List<SearchParamToken> status,

    /// [subject] Who/What this Media is a record of
    @Default([]) List<SearchParamReference> subject,

    /// [type] Classification of media as image, video, or audio
    @Default([]) List<SearchParamToken> type,

    /// [view] Imaging view, e.g. Lateral or Antero-posterior
    @Default([]) List<SearchParamToken> view,
  }) = _MediaSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (basedOn.isNotEmpty) {
      basedOn.forEach(
          (element) => returnStrings.add('based-on${element.toRequest()}'));
    }
    if (created.isNotEmpty) {
      created.forEach(
          (element) => returnStrings.add('created${element.toRequest()}'));
    }
    if (device.isNotEmpty) {
      device.forEach(
          (element) => returnStrings.add('device${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (modality.isNotEmpty) {
      modality.forEach(
          (element) => returnStrings.add('modality${element.toRequest()}'));
    }
    if (operator_.isNotEmpty) {
      operator_.forEach(
          (element) => returnStrings.add('operator${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (site.isNotEmpty) {
      site.forEach(
          (element) => returnStrings.add('site${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    if (view.isNotEmpty) {
      view.forEach(
          (element) => returnStrings.add('view${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class MedicationKnowledgeSearchParams with _$MedicationKnowledgeSearchParams {
  const MedicationKnowledgeSearchParams._();
  const factory MedicationKnowledgeSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [classification] Specific category assigned to the medication
    @Default([]) List<SearchParamToken> classification,

    /// [classificationType] The type of category for the medication (for example, therapeutic classification, therapeutic sub-classification)
    @Default([])
    @JsonKey(name: 'classification-type')
        List<SearchParamToken> classificationType,

    /// [code] Code that identifies this medication
    @Default([]) List<SearchParamToken> code,

    /// [doseform] powder | tablets | capsule +
    @Default([]) List<SearchParamToken> doseform,

    /// [ingredient] Medication(s) or substance(s) contained in the medication
    @Default([]) List<SearchParamReference> ingredient,

    /// [ingredientCode] Medication(s) or substance(s) contained in the medication
    @Default([])
    @JsonKey(name: 'ingredient-code')
        List<SearchParamToken> ingredientCode,

    /// [manufacturer] Manufacturer of the item
    @Default([]) List<SearchParamReference> manufacturer,

    /// [monitoringProgramName] Name of the reviewing program
    @Default([])
    @JsonKey(name: 'monitoring-program-name')
        List<SearchParamToken> monitoringProgramName,

    /// [monitoringProgramType] Type of program under which the medication is monitored
    @Default([])
    @JsonKey(name: 'monitoring-program-type')
        List<SearchParamToken> monitoringProgramType,

    /// [monograph] Associated documentation about the medication
    @Default([]) List<SearchParamReference> monograph,

    /// [monographType] The category of medication document
    @Default([])
    @JsonKey(name: 'monograph-type')
        List<SearchParamToken> monographType,

    /// [sourceCost] The source or owner for the price information
    @Default([])
    @JsonKey(name: 'source-cost')
        List<SearchParamToken> sourceCost,

    /// [status] active | inactive | entered-in-error
    @Default([]) List<SearchParamToken> status,
  }) = _MedicationKnowledgeSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (classification.isNotEmpty) {
      classification.forEach((element) =>
          returnStrings.add('classification${element.toRequest()}'));
    }
    if (classificationType.isNotEmpty) {
      classificationType.forEach((element) =>
          returnStrings.add('classification-type${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (doseform.isNotEmpty) {
      doseform.forEach(
          (element) => returnStrings.add('doseform${element.toRequest()}'));
    }
    if (ingredient.isNotEmpty) {
      ingredient.forEach(
          (element) => returnStrings.add('ingredient${element.toRequest()}'));
    }
    if (ingredientCode.isNotEmpty) {
      ingredientCode.forEach((element) =>
          returnStrings.add('ingredient-code${element.toRequest()}'));
    }
    if (manufacturer.isNotEmpty) {
      manufacturer.forEach(
          (element) => returnStrings.add('manufacturer${element.toRequest()}'));
    }
    if (monitoringProgramName.isNotEmpty) {
      monitoringProgramName.forEach((element) =>
          returnStrings.add('monitoring-program-name${element.toRequest()}'));
    }
    if (monitoringProgramType.isNotEmpty) {
      monitoringProgramType.forEach((element) =>
          returnStrings.add('monitoring-program-type${element.toRequest()}'));
    }
    if (monograph.isNotEmpty) {
      monograph.forEach(
          (element) => returnStrings.add('monograph${element.toRequest()}'));
    }
    if (monographType.isNotEmpty) {
      monographType.forEach((element) =>
          returnStrings.add('monograph-type${element.toRequest()}'));
    }
    if (sourceCost.isNotEmpty) {
      sourceCost.forEach(
          (element) => returnStrings.add('source-cost${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class MedicinalProductDefinitionSearchParams
    with _$MedicinalProductDefinitionSearchParams {
  const MedicinalProductDefinitionSearchParams._();
  const factory MedicinalProductDefinitionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [characteristic] Allows the key product features to be recorded, such as "sugar free", "modified release", "parallel import"
    @Default([]) List<SearchParamToken> characteristic,

    /// [characteristicType] A category for the characteristic
    @Default([])
    @JsonKey(name: 'characteristic-type')
        List<SearchParamToken> characteristicType,

    /// [contact] A product specific contact, person (in a role), or an organization
    @Default([]) List<SearchParamReference> contact,

    /// [domain] If this medicine applies to human or veterinary uses
    @Default([]) List<SearchParamToken> domain,

    /// [identifier] Business identifier for this product. Could be an MPID
    @Default([]) List<SearchParamToken> identifier,

    /// [ingredient] An ingredient of this product
    @Default([]) List<SearchParamToken> ingredient,

    /// [masterFile] A master file for to the medicinal product (e.g. Pharmacovigilance System Master File)
    @Default([])
    @JsonKey(name: 'master-file')
        List<SearchParamReference> masterFile,

    /// [name] The full product name
    @Default([]) List<SearchParamString> name,

    /// [nameLanguage] Language code for this name
    @Default([])
    @JsonKey(name: 'name-language')
        List<SearchParamToken> nameLanguage,

    /// [productClassification] Allows the product to be classified by various systems
    @Default([])
    @JsonKey(name: 'product-classification')
        List<SearchParamToken> productClassification,

    /// [status] The status within the lifecycle of this product record. A high-level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization status
    @Default([]) List<SearchParamToken> status,

    /// [type] Regulatory type, e.g. Investigational or Authorized
    @Default([]) List<SearchParamToken> type,
  }) = _MedicinalProductDefinitionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (characteristic.isNotEmpty) {
      characteristic.forEach((element) =>
          returnStrings.add('characteristic${element.toRequest()}'));
    }
    if (characteristicType.isNotEmpty) {
      characteristicType.forEach((element) =>
          returnStrings.add('characteristic-type${element.toRequest()}'));
    }
    if (contact.isNotEmpty) {
      contact.forEach(
          (element) => returnStrings.add('contact${element.toRequest()}'));
    }
    if (domain.isNotEmpty) {
      domain.forEach(
          (element) => returnStrings.add('domain${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (ingredient.isNotEmpty) {
      ingredient.forEach(
          (element) => returnStrings.add('ingredient${element.toRequest()}'));
    }
    if (masterFile.isNotEmpty) {
      masterFile.forEach(
          (element) => returnStrings.add('master-file${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (nameLanguage.isNotEmpty) {
      nameLanguage.forEach((element) =>
          returnStrings.add('name-language${element.toRequest()}'));
    }
    if (productClassification.isNotEmpty) {
      productClassification.forEach((element) =>
          returnStrings.add('product-classification${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class MessageHeaderSearchParams with _$MessageHeaderSearchParams {
  const MessageHeaderSearchParams._();
  const factory MessageHeaderSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [author] The source of the decision
    @Default([]) List<SearchParamReference> author,

    /// [code] ok | transient-error | fatal-error
    @Default([]) List<SearchParamToken> code,

    /// [destination] Name of system
    @Default([]) List<SearchParamString> destination,

    /// [destinationUri] Actual destination address or id
    @Default([])
    @JsonKey(name: 'destination-uri')
        List<SearchParamUri> destinationUri,

    /// [enterer] The source of the data entry
    @Default([]) List<SearchParamReference> enterer,

    /// [event] Code for the event this message represents or link to event definition
    @Default([]) List<SearchParamToken> event,

    /// [focus] The actual content of the message
    @Default([]) List<SearchParamReference> focus,

    /// [receiver] Intended "real-world" recipient for the data
    @Default([]) List<SearchParamReference> receiver,

    /// [responseId] Id of original message
    @Default([])
    @JsonKey(name: 'response-id')
        List<SearchParamToken> responseId,

    /// [responsible] Final responsibility for event
    @Default([]) List<SearchParamReference> responsible,

    /// [sender] Real world sender of the message
    @Default([]) List<SearchParamReference> sender,

    /// [source] Name of system
    @Default([]) List<SearchParamString> source,

    /// [sourceUri] Actual message source address or id
    @Default([]) @JsonKey(name: 'source-uri') List<SearchParamUri> sourceUri,

    /// [target] Particular delivery destination within the destination
    @Default([]) List<SearchParamReference> target,
  }) = _MessageHeaderSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (author.isNotEmpty) {
      author.forEach(
          (element) => returnStrings.add('author${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (destination.isNotEmpty) {
      destination.forEach(
          (element) => returnStrings.add('destination${element.toRequest()}'));
    }
    if (destinationUri.isNotEmpty) {
      destinationUri.forEach((element) =>
          returnStrings.add('destination-uri${element.toRequest()}'));
    }
    if (enterer.isNotEmpty) {
      enterer.forEach(
          (element) => returnStrings.add('enterer${element.toRequest()}'));
    }
    if (event.isNotEmpty) {
      event.forEach(
          (element) => returnStrings.add('event${element.toRequest()}'));
    }
    if (focus.isNotEmpty) {
      focus.forEach(
          (element) => returnStrings.add('focus${element.toRequest()}'));
    }
    if (receiver.isNotEmpty) {
      receiver.forEach(
          (element) => returnStrings.add('receiver${element.toRequest()}'));
    }
    if (responseId.isNotEmpty) {
      responseId.forEach(
          (element) => returnStrings.add('response-id${element.toRequest()}'));
    }
    if (responsible.isNotEmpty) {
      responsible.forEach(
          (element) => returnStrings.add('responsible${element.toRequest()}'));
    }
    if (sender.isNotEmpty) {
      sender.forEach(
          (element) => returnStrings.add('sender${element.toRequest()}'));
    }
    if (source.isNotEmpty) {
      source.forEach(
          (element) => returnStrings.add('source${element.toRequest()}'));
    }
    if (sourceUri.isNotEmpty) {
      sourceUri.forEach(
          (element) => returnStrings.add('source-uri${element.toRequest()}'));
    }
    if (target.isNotEmpty) {
      target.forEach(
          (element) => returnStrings.add('target${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class MolecularSequenceSearchParams with _$MolecularSequenceSearchParams {
  const MolecularSequenceSearchParams._();
  const factory MolecularSequenceSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [chromosome] Chromosome number of the reference sequence
    @Default([]) List<SearchParamToken> chromosome,

    /// [identifier] The unique identity for a particular sequence
    @Default([]) List<SearchParamToken> identifier,

    /// [patient] The subject that the observation is about
    @Default([]) List<SearchParamReference> patient,

    /// [referenceseqid] Reference Sequence of the sequence
    @Default([]) List<SearchParamToken> referenceseqid,

    /// [type] Amino Acid Sequence/ DNA Sequence / RNA Sequence
    @Default([]) List<SearchParamToken> type,

    /// [variantEnd] End position (0-based exclusive, which menas the acid at this position will not be included, 1-based inclusive, which means the acid at this position will be included) of the variant.
    @Default([])
    @JsonKey(name: 'variant-end')
        List<SearchParamNumber> variantEnd,

    /// [variantStart] Start position (0-based inclusive, 1-based inclusive, that means the nucleic acid or amino acid at this position will be included) of the variant.
    @Default([])
    @JsonKey(name: 'variant-start')
        List<SearchParamNumber> variantStart,

    /// [windowEnd] End position (0-based exclusive, which menas the acid at this position will not be included, 1-based inclusive, which means the acid at this position will be included) of the reference sequence.
    @Default([]) @JsonKey(name: 'window-end') List<SearchParamNumber> windowEnd,

    /// [windowStart] Start position (0-based inclusive, 1-based inclusive, that means the nucleic acid or amino acid at this position will be included) of the reference sequence.
    @Default([])
    @JsonKey(name: 'window-start')
        List<SearchParamNumber> windowStart,

    /// [chromosomeVariantCoordinate] Search parameter by chromosome and variant coordinate. This will refer to part of a locus or part of a gene where search region will be represented in 1-based system. Since the coordinateSystem can either be 0-based or 1-based, this search query will include the result of both coordinateSystem that contains the equivalent segment of the gene or whole genome sequence. For example, a search for sequence can be represented as `chromosome-variant-coordinate=1$lt345$gt123`, this means it will search for the MolecularSequence resource with variants on chromosome 1 and with position >123 and <345, where in 1-based system resource, all strings within region 1:124-344 will be revealed, while in 0-based system resource, all strings within region 1:123-344 will be revealed. You may want to check detail about 0-based v.s. 1-based above.
    @Default([])
    @JsonKey(name: 'chromosome-variant-coordinate')
        List<SearchParamComposite> chromosomeVariantCoordinate,

    /// [chromosomeWindowCoordinate] Search parameter by chromosome and window. This will refer to part of a locus or part of a gene where search region will be represented in 1-based system. Since the coordinateSystem can either be 0-based or 1-based, this search query will include the result of both coordinateSystem that contains the equivalent segment of the gene or whole genome sequence. For example, a search for sequence can be represented as `chromosome-window-coordinate=1$lt345$gt123`, this means it will search for the MolecularSequence resource with a window on chromosome 1 and with position >123 and <345, where in 1-based system resource, all strings within region 1:124-344 will be revealed, while in 0-based system resource, all strings within region 1:123-344 will be revealed. You may want to check detail about 0-based v.s. 1-based above.
    @Default([])
    @JsonKey(name: 'chromosome-window-coordinate')
        List<SearchParamComposite> chromosomeWindowCoordinate,

    /// [referenceseqidVariantCoordinate] Search parameter by reference sequence and variant coordinate. This will refer to part of a locus or part of a gene where search region will be represented in 1-based system. Since the coordinateSystem can either be 0-based or 1-based, this search query will include the result of both coordinateSystem that contains the equivalent segment of the gene or whole genome sequence. For example, a search for sequence can be represented as `referenceSeqId-variant-coordinate=NC_000001.11$lt345$gt123`, this means it will search for the MolecularSequence resource with variants on NC_000001.11 and with position >123 and <345, where in 1-based system resource, all strings within region NC_000001.11:124-344 will be revealed, while in 0-based system resource, all strings within region NC_000001.11:123-344 will be revealed. You may want to check detail about 0-based v.s. 1-based above.
    @Default([])
    @JsonKey(name: 'referenceseqid-variant-coordinate')
        List<SearchParamComposite> referenceseqidVariantCoordinate,

    /// [referenceseqidWindowCoordinate] Search parameter by reference sequence and window. This will refer to part of a locus or part of a gene where search region will be represented in 1-based system. Since the coordinateSystem can either be 0-based or 1-based, this search query will include the result of both coordinateSystem that contains the equivalent segment of the gene or whole genome sequence. For example, a search for sequence can be represented as `referenceSeqId-window-coordinate=NC_000001.11$lt345$gt123`, this means it will search for the MolecularSequence resource with a window on NC_000001.11 and with position >123 and <345, where in 1-based system resource, all strings within region NC_000001.11:124-344 will be revealed, while in 0-based system resource, all strings within region NC_000001.11:123-344 will be revealed. You may want to check detail about 0-based v.s. 1-based above.
    @Default([])
    @JsonKey(name: 'referenceseqid-window-coordinate')
        List<SearchParamComposite> referenceseqidWindowCoordinate,
  }) = _MolecularSequenceSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (chromosome.isNotEmpty) {
      chromosome.forEach(
          (element) => returnStrings.add('chromosome${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (referenceseqid.isNotEmpty) {
      referenceseqid.forEach((element) =>
          returnStrings.add('referenceseqid${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    if (variantEnd.isNotEmpty) {
      variantEnd.forEach(
          (element) => returnStrings.add('variant-end${element.toRequest()}'));
    }
    if (variantStart.isNotEmpty) {
      variantStart.forEach((element) =>
          returnStrings.add('variant-start${element.toRequest()}'));
    }
    if (windowEnd.isNotEmpty) {
      windowEnd.forEach(
          (element) => returnStrings.add('window-end${element.toRequest()}'));
    }
    if (windowStart.isNotEmpty) {
      windowStart.forEach(
          (element) => returnStrings.add('window-start${element.toRequest()}'));
    }
    if (chromosomeVariantCoordinate.isNotEmpty) {
      chromosomeVariantCoordinate.forEach((element) => returnStrings
          .add('chromosome-variant-coordinate${element.toRequest()}'));
    }
    if (chromosomeWindowCoordinate.isNotEmpty) {
      chromosomeWindowCoordinate.forEach((element) => returnStrings
          .add('chromosome-window-coordinate${element.toRequest()}'));
    }
    if (referenceseqidVariantCoordinate.isNotEmpty) {
      referenceseqidVariantCoordinate.forEach((element) => returnStrings
          .add('referenceseqid-variant-coordinate${element.toRequest()}'));
    }
    if (referenceseqidWindowCoordinate.isNotEmpty) {
      referenceseqidWindowCoordinate.forEach((element) => returnStrings
          .add('referenceseqid-window-coordinate${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class NutritionProductSearchParams with _$NutritionProductSearchParams {
  const NutritionProductSearchParams._();
  const factory NutritionProductSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [identifier] The identifier for the physical instance, typically a serial number
    @Default([]) List<SearchParamToken> identifier,

    /// [status] active | inactive | entered-in-error
    @Default([]) List<SearchParamToken> status,
  }) = _NutritionProductSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class OrganizationSearchParams with _$OrganizationSearchParams {
  const OrganizationSearchParams._();
  const factory OrganizationSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [active] Is the Organization record active
    @Default([]) List<SearchParamToken> active,

    /// [address] A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text
    @Default([]) List<SearchParamString> address,

    /// [addressCity] A city specified in an address
    @Default([])
    @JsonKey(name: 'address-city')
        List<SearchParamString> addressCity,

    /// [addressCountry] A country specified in an address
    @Default([])
    @JsonKey(name: 'address-country')
        List<SearchParamString> addressCountry,

    /// [addressPostalcode] A postal code specified in an address
    @Default([])
    @JsonKey(name: 'address-postalcode')
        List<SearchParamString> addressPostalcode,

    /// [addressState] A state specified in an address
    @Default([])
    @JsonKey(name: 'address-state')
        List<SearchParamString> addressState,

    /// [addressUse] A use code specified in an address
    @Default([])
    @JsonKey(name: 'address-use')
        List<SearchParamToken> addressUse,

    /// [endpoint] Technical endpoints providing access to services operated for the organization
    @Default([]) List<SearchParamReference> endpoint,

    /// [identifier] Any identifier for the organization (not the accreditation issuer's identifier)
    @Default([]) List<SearchParamToken> identifier,

    /// [name] A portion of the organization's name or alias
    @Default([]) List<SearchParamString> name,

    /// [partof] An organization of which this organization forms a part
    @Default([]) List<SearchParamReference> partof,

    /// [phonetic] A portion of the organization's name using some kind of phonetic matching algorithm
    @Default([]) List<SearchParamString> phonetic,

    /// [type] A code for the type of organization
    @Default([]) List<SearchParamToken> type,
  }) = _OrganizationSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (active.isNotEmpty) {
      active.forEach(
          (element) => returnStrings.add('active${element.toRequest()}'));
    }
    if (address.isNotEmpty) {
      address.forEach(
          (element) => returnStrings.add('address${element.toRequest()}'));
    }
    if (addressCity.isNotEmpty) {
      addressCity.forEach(
          (element) => returnStrings.add('address-city${element.toRequest()}'));
    }
    if (addressCountry.isNotEmpty) {
      addressCountry.forEach((element) =>
          returnStrings.add('address-country${element.toRequest()}'));
    }
    if (addressPostalcode.isNotEmpty) {
      addressPostalcode.forEach((element) =>
          returnStrings.add('address-postalcode${element.toRequest()}'));
    }
    if (addressState.isNotEmpty) {
      addressState.forEach((element) =>
          returnStrings.add('address-state${element.toRequest()}'));
    }
    if (addressUse.isNotEmpty) {
      addressUse.forEach(
          (element) => returnStrings.add('address-use${element.toRequest()}'));
    }
    if (endpoint.isNotEmpty) {
      endpoint.forEach(
          (element) => returnStrings.add('endpoint${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (partof.isNotEmpty) {
      partof.forEach(
          (element) => returnStrings.add('partof${element.toRequest()}'));
    }
    if (phonetic.isNotEmpty) {
      phonetic.forEach(
          (element) => returnStrings.add('phonetic${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class OrganizationAffiliationSearchParams
    with _$OrganizationAffiliationSearchParams {
  const OrganizationAffiliationSearchParams._();
  const factory OrganizationAffiliationSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [active] Whether this organization affiliation record is in active use
    @Default([]) List<SearchParamToken> active,

    /// [date] The period during which the participatingOrganization is affiliated with the primary organization
    @Default([]) List<SearchParamDate> date,

    /// [email] A value in an email contact
    @Default([]) List<SearchParamToken> email,

    /// [endpoint] Technical endpoints providing access to services operated for this role
    @Default([]) List<SearchParamReference> endpoint,

    /// [identifier] An organization affiliation's Identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [location] The location(s) at which the role occurs
    @Default([]) List<SearchParamReference> location,

    /// [network] Health insurance provider network in which the participatingOrganization provides the role's services (if defined) at the indicated locations (if defined)
    @Default([]) List<SearchParamReference> network,

    /// [participatingOrganization] The organization that provides services to the primary organization
    @Default([])
    @JsonKey(name: 'participating-organization')
        List<SearchParamReference> participatingOrganization,

    /// [phone] A value in a phone contact
    @Default([]) List<SearchParamToken> phone,

    /// [primaryOrganization] The organization that receives the services from the participating organization
    @Default([])
    @JsonKey(name: 'primary-organization')
        List<SearchParamReference> primaryOrganization,

    /// [role] Definition of the role the participatingOrganization plays
    @Default([]) List<SearchParamToken> role,

    /// [service] Healthcare services provided through the role
    @Default([]) List<SearchParamReference> service,

    /// [specialty] Specific specialty of the participatingOrganization in the context of the role
    @Default([]) List<SearchParamToken> specialty,

    /// [telecom] The value in any kind of contact
    @Default([]) List<SearchParamToken> telecom,
  }) = _OrganizationAffiliationSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (active.isNotEmpty) {
      active.forEach(
          (element) => returnStrings.add('active${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (email.isNotEmpty) {
      email.forEach(
          (element) => returnStrings.add('email${element.toRequest()}'));
    }
    if (endpoint.isNotEmpty) {
      endpoint.forEach(
          (element) => returnStrings.add('endpoint${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (location.isNotEmpty) {
      location.forEach(
          (element) => returnStrings.add('location${element.toRequest()}'));
    }
    if (network.isNotEmpty) {
      network.forEach(
          (element) => returnStrings.add('network${element.toRequest()}'));
    }
    if (participatingOrganization.isNotEmpty) {
      participatingOrganization.forEach((element) => returnStrings
          .add('participating-organization${element.toRequest()}'));
    }
    if (phone.isNotEmpty) {
      phone.forEach(
          (element) => returnStrings.add('phone${element.toRequest()}'));
    }
    if (primaryOrganization.isNotEmpty) {
      primaryOrganization.forEach((element) =>
          returnStrings.add('primary-organization${element.toRequest()}'));
    }
    if (role.isNotEmpty) {
      role.forEach(
          (element) => returnStrings.add('role${element.toRequest()}'));
    }
    if (service.isNotEmpty) {
      service.forEach(
          (element) => returnStrings.add('service${element.toRequest()}'));
    }
    if (specialty.isNotEmpty) {
      specialty.forEach(
          (element) => returnStrings.add('specialty${element.toRequest()}'));
    }
    if (telecom.isNotEmpty) {
      telecom.forEach(
          (element) => returnStrings.add('telecom${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class PackagedProductDefinitionSearchParams
    with _$PackagedProductDefinitionSearchParams {
  const PackagedProductDefinitionSearchParams._();
  const factory PackagedProductDefinitionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [biological] A biologically derived product within this packaged product
    @Default([]) List<SearchParamReference> biological,

    /// [containedItem] Any of the contained items within this packaged product
    @Default([])
    @JsonKey(name: 'contained-item')
        List<SearchParamReference> containedItem,

    /// [device] A device within this packaged product
    @Default([]) List<SearchParamReference> device,

    /// [identifier] Unique identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [manufacturedItem] A manufactured item of medication within this packaged product
    @Default([])
    @JsonKey(name: 'manufactured-item')
        List<SearchParamReference> manufacturedItem,

    /// [medication] A manufactured item of medication within this packaged product
    @Default([]) List<SearchParamReference> medication,

    /// [name] A name for this package. Typically what it would be listed as in a drug formulary or catalogue, inventory etc
    @Default([]) List<SearchParamToken> name,

    /// [nutrition] A nutrition product within this packaged product
    @Default([]) List<SearchParamReference> nutrition,

    /// [package] A complete packaged product within this packaged product
    @Default([]) List<SearchParamReference> package,

    /// [packageFor] The product that this is a pack for
    @Default([])
    @JsonKey(name: 'package-for')
        List<SearchParamReference> packageFor,

    /// [status] The status within the lifecycle of this item. A high level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization or marketing status
    @Default([]) List<SearchParamToken> status,
  }) = _PackagedProductDefinitionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (biological.isNotEmpty) {
      biological.forEach(
          (element) => returnStrings.add('biological${element.toRequest()}'));
    }
    if (containedItem.isNotEmpty) {
      containedItem.forEach((element) =>
          returnStrings.add('contained-item${element.toRequest()}'));
    }
    if (device.isNotEmpty) {
      device.forEach(
          (element) => returnStrings.add('device${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (manufacturedItem.isNotEmpty) {
      manufacturedItem.forEach((element) =>
          returnStrings.add('manufactured-item${element.toRequest()}'));
    }
    if (medication.isNotEmpty) {
      medication.forEach(
          (element) => returnStrings.add('medication${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (nutrition.isNotEmpty) {
      nutrition.forEach(
          (element) => returnStrings.add('nutrition${element.toRequest()}'));
    }
    if (package.isNotEmpty) {
      package.forEach(
          (element) => returnStrings.add('package${element.toRequest()}'));
    }
    if (packageFor.isNotEmpty) {
      packageFor.forEach(
          (element) => returnStrings.add('package-for${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class PatientSearchParams with _$PatientSearchParams {
  const PatientSearchParams._();
  const factory PatientSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [active] Whether the patient record is active
    @Default([]) List<SearchParamToken> active,

    /// [address] Multiple Resources:

    /// * [Patient](patient.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text
    /// * [Person](person.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text
    /// * [Practitioner](practitioner.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text
    /// * [RelatedPerson](relatedperson.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text

    @Default([]) List<SearchParamString> address,

    /// [addressCity] Multiple Resources:

    /// * [Patient](patient.html): A city specified in an address
    /// * [Person](person.html): A city specified in an address
    /// * [Practitioner](practitioner.html): A city specified in an address
    /// * [RelatedPerson](relatedperson.html): A city specified in an address

    @Default([])
    @JsonKey(name: 'address-city')
        List<SearchParamString> addressCity,

    /// [addressCountry] Multiple Resources:

    /// * [Patient](patient.html): A country specified in an address
    /// * [Person](person.html): A country specified in an address
    /// * [Practitioner](practitioner.html): A country specified in an address
    /// * [RelatedPerson](relatedperson.html): A country specified in an address

    @Default([])
    @JsonKey(name: 'address-country')
        List<SearchParamString> addressCountry,

    /// [addressPostalcode] Multiple Resources:

    /// * [Patient](patient.html): A postalCode specified in an address
    /// * [Person](person.html): A postal code specified in an address
    /// * [Practitioner](practitioner.html): A postalCode specified in an address
    /// * [RelatedPerson](relatedperson.html): A postal code specified in an address

    @Default([])
    @JsonKey(name: 'address-postalcode')
        List<SearchParamString> addressPostalcode,

    /// [addressState] Multiple Resources:

    /// * [Patient](patient.html): A state specified in an address
    /// * [Person](person.html): A state specified in an address
    /// * [Practitioner](practitioner.html): A state specified in an address
    /// * [RelatedPerson](relatedperson.html): A state specified in an address

    @Default([])
    @JsonKey(name: 'address-state')
        List<SearchParamString> addressState,

    /// [addressUse] Multiple Resources:

    /// * [Patient](patient.html): A use code specified in an address
    /// * [Person](person.html): A use code specified in an address
    /// * [Practitioner](practitioner.html): A use code specified in an address
    /// * [RelatedPerson](relatedperson.html): A use code specified in an address

    @Default([])
    @JsonKey(name: 'address-use')
        List<SearchParamToken> addressUse,

    /// [birthdate] Multiple Resources:

    /// * [Patient](patient.html): The patient's date of birth
    /// * [Person](person.html): The person's date of birth
    /// * [RelatedPerson](relatedperson.html): The Related Person's date of birth

    @Default([]) List<SearchParamDate> birthdate,

    /// [deathDate] The date of death has been provided and satisfies this search value
    @Default([]) @JsonKey(name: 'death-date') List<SearchParamDate> deathDate,

    /// [deceased] This patient has been marked as deceased, or has a death date entered
    @Default([]) List<SearchParamToken> deceased,

    /// [email] Multiple Resources:

    /// * [Patient](patient.html): A value in an email contact
    /// * [Person](person.html): A value in an email contact
    /// * [Practitioner](practitioner.html): A value in an email contact
    /// * [PractitionerRole](practitionerrole.html): A value in an email contact
    /// * [RelatedPerson](relatedperson.html): A value in an email contact

    @Default([]) List<SearchParamToken> email,

    /// [family] Multiple Resources:

    /// * [Patient](patient.html): A portion of the family name of the patient
    /// * [Practitioner](practitioner.html): A portion of the family name

    @Default([]) List<SearchParamString> family,

    /// [gender] Multiple Resources:

    /// * [Patient](patient.html): Gender of the patient
    /// * [Person](person.html): The gender of the person
    /// * [Practitioner](practitioner.html): Gender of the practitioner
    /// * [RelatedPerson](relatedperson.html): Gender of the related person

    @Default([]) List<SearchParamToken> gender,

    /// [generalPractitioner] Patient's nominated general practitioner, not the organization that manages the record
    @Default([])
    @JsonKey(name: 'general-practitioner')
        List<SearchParamReference> generalPractitioner,

    /// [given] Multiple Resources:

    /// * [Patient](patient.html): A portion of the given name of the patient
    /// * [Practitioner](practitioner.html): A portion of the given name

    @Default([]) List<SearchParamString> given,

    /// [identifier] A patient identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [language] Language code (irrespective of use value)
    @Default([]) List<SearchParamToken> language,

    /// [link] All patients linked to the given patient
    @Default([]) List<SearchParamReference> link,

    /// [name] A server defined search that may match any of the string fields in the HumanName, including family, give, prefix, suffix, suffix, and/or text
    @Default([]) List<SearchParamString> name,

    /// [organization] The organization that is the custodian of the patient record
    @Default([]) List<SearchParamReference> organization,

    /// [phone] Multiple Resources:

    /// * [Patient](patient.html): A value in a phone contact
    /// * [Person](person.html): A value in a phone contact
    /// * [Practitioner](practitioner.html): A value in a phone contact
    /// * [PractitionerRole](practitionerrole.html): A value in a phone contact
    /// * [RelatedPerson](relatedperson.html): A value in a phone contact

    @Default([]) List<SearchParamToken> phone,

    /// [phonetic] Multiple Resources:

    /// * [Patient](patient.html): A portion of either family or given name using some kind of phonetic matching algorithm
    /// * [Person](person.html): A portion of name using some kind of phonetic matching algorithm
    /// * [Practitioner](practitioner.html): A portion of either family or given name using some kind of phonetic matching algorithm
    /// * [RelatedPerson](relatedperson.html): A portion of name using some kind of phonetic matching algorithm

    @Default([]) List<SearchParamString> phonetic,

    /// [telecom] Multiple Resources:

    /// * [Patient](patient.html): The value in any kind of telecom details of the patient
    /// * [Person](person.html): The value in any kind of contact
    /// * [Practitioner](practitioner.html): The value in any kind of contact
    /// * [PractitionerRole](practitionerrole.html): The value in any kind of contact
    /// * [RelatedPerson](relatedperson.html): The value in any kind of contact

    @Default([]) List<SearchParamToken> telecom,
  }) = _PatientSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (active.isNotEmpty) {
      active.forEach(
          (element) => returnStrings.add('active${element.toRequest()}'));
    }
    if (address.isNotEmpty) {
      address.forEach(
          (element) => returnStrings.add('address${element.toRequest()}'));
    }
    if (addressCity.isNotEmpty) {
      addressCity.forEach(
          (element) => returnStrings.add('address-city${element.toRequest()}'));
    }
    if (addressCountry.isNotEmpty) {
      addressCountry.forEach((element) =>
          returnStrings.add('address-country${element.toRequest()}'));
    }
    if (addressPostalcode.isNotEmpty) {
      addressPostalcode.forEach((element) =>
          returnStrings.add('address-postalcode${element.toRequest()}'));
    }
    if (addressState.isNotEmpty) {
      addressState.forEach((element) =>
          returnStrings.add('address-state${element.toRequest()}'));
    }
    if (addressUse.isNotEmpty) {
      addressUse.forEach(
          (element) => returnStrings.add('address-use${element.toRequest()}'));
    }
    if (birthdate.isNotEmpty) {
      birthdate.forEach(
          (element) => returnStrings.add('birthdate${element.toRequest()}'));
    }
    if (deathDate.isNotEmpty) {
      deathDate.forEach(
          (element) => returnStrings.add('death-date${element.toRequest()}'));
    }
    if (deceased.isNotEmpty) {
      deceased.forEach(
          (element) => returnStrings.add('deceased${element.toRequest()}'));
    }
    if (email.isNotEmpty) {
      email.forEach(
          (element) => returnStrings.add('email${element.toRequest()}'));
    }
    if (family.isNotEmpty) {
      family.forEach(
          (element) => returnStrings.add('family${element.toRequest()}'));
    }
    if (gender.isNotEmpty) {
      gender.forEach(
          (element) => returnStrings.add('gender${element.toRequest()}'));
    }
    if (generalPractitioner.isNotEmpty) {
      generalPractitioner.forEach((element) =>
          returnStrings.add('general-practitioner${element.toRequest()}'));
    }
    if (given.isNotEmpty) {
      given.forEach(
          (element) => returnStrings.add('given${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (language.isNotEmpty) {
      language.forEach(
          (element) => returnStrings.add('language${element.toRequest()}'));
    }
    if (link.isNotEmpty) {
      link.forEach(
          (element) => returnStrings.add('link${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (organization.isNotEmpty) {
      organization.forEach(
          (element) => returnStrings.add('organization${element.toRequest()}'));
    }
    if (phone.isNotEmpty) {
      phone.forEach(
          (element) => returnStrings.add('phone${element.toRequest()}'));
    }
    if (phonetic.isNotEmpty) {
      phonetic.forEach(
          (element) => returnStrings.add('phonetic${element.toRequest()}'));
    }
    if (telecom.isNotEmpty) {
      telecom.forEach(
          (element) => returnStrings.add('telecom${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class PersonSearchParams with _$PersonSearchParams {
  const PersonSearchParams._();
  const factory PersonSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [address] Multiple Resources:

    /// * [Patient](patient.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text
    /// * [Person](person.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text
    /// * [Practitioner](practitioner.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text
    /// * [RelatedPerson](relatedperson.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text

    @Default([]) List<SearchParamString> address,

    /// [addressCity] Multiple Resources:

    /// * [Patient](patient.html): A city specified in an address
    /// * [Person](person.html): A city specified in an address
    /// * [Practitioner](practitioner.html): A city specified in an address
    /// * [RelatedPerson](relatedperson.html): A city specified in an address

    @Default([])
    @JsonKey(name: 'address-city')
        List<SearchParamString> addressCity,

    /// [addressCountry] Multiple Resources:

    /// * [Patient](patient.html): A country specified in an address
    /// * [Person](person.html): A country specified in an address
    /// * [Practitioner](practitioner.html): A country specified in an address
    /// * [RelatedPerson](relatedperson.html): A country specified in an address

    @Default([])
    @JsonKey(name: 'address-country')
        List<SearchParamString> addressCountry,

    /// [addressPostalcode] Multiple Resources:

    /// * [Patient](patient.html): A postalCode specified in an address
    /// * [Person](person.html): A postal code specified in an address
    /// * [Practitioner](practitioner.html): A postalCode specified in an address
    /// * [RelatedPerson](relatedperson.html): A postal code specified in an address

    @Default([])
    @JsonKey(name: 'address-postalcode')
        List<SearchParamString> addressPostalcode,

    /// [addressState] Multiple Resources:

    /// * [Patient](patient.html): A state specified in an address
    /// * [Person](person.html): A state specified in an address
    /// * [Practitioner](practitioner.html): A state specified in an address
    /// * [RelatedPerson](relatedperson.html): A state specified in an address

    @Default([])
    @JsonKey(name: 'address-state')
        List<SearchParamString> addressState,

    /// [addressUse] Multiple Resources:

    /// * [Patient](patient.html): A use code specified in an address
    /// * [Person](person.html): A use code specified in an address
    /// * [Practitioner](practitioner.html): A use code specified in an address
    /// * [RelatedPerson](relatedperson.html): A use code specified in an address

    @Default([])
    @JsonKey(name: 'address-use')
        List<SearchParamToken> addressUse,

    /// [birthdate] Multiple Resources:

    /// * [Patient](patient.html): The patient's date of birth
    /// * [Person](person.html): The person's date of birth
    /// * [RelatedPerson](relatedperson.html): The Related Person's date of birth

    @Default([]) List<SearchParamDate> birthdate,

    /// [email] Multiple Resources:

    /// * [Patient](patient.html): A value in an email contact
    /// * [Person](person.html): A value in an email contact
    /// * [Practitioner](practitioner.html): A value in an email contact
    /// * [PractitionerRole](practitionerrole.html): A value in an email contact
    /// * [RelatedPerson](relatedperson.html): A value in an email contact

    @Default([]) List<SearchParamToken> email,

    /// [gender] Multiple Resources:

    /// * [Patient](patient.html): Gender of the patient
    /// * [Person](person.html): The gender of the person
    /// * [Practitioner](practitioner.html): Gender of the practitioner
    /// * [RelatedPerson](relatedperson.html): Gender of the related person

    @Default([]) List<SearchParamToken> gender,

    /// [phone] Multiple Resources:

    /// * [Patient](patient.html): A value in a phone contact
    /// * [Person](person.html): A value in a phone contact
    /// * [Practitioner](practitioner.html): A value in a phone contact
    /// * [PractitionerRole](practitionerrole.html): A value in a phone contact
    /// * [RelatedPerson](relatedperson.html): A value in a phone contact

    @Default([]) List<SearchParamToken> phone,

    /// [phonetic] Multiple Resources:

    /// * [Patient](patient.html): A portion of either family or given name using some kind of phonetic matching algorithm
    /// * [Person](person.html): A portion of name using some kind of phonetic matching algorithm
    /// * [Practitioner](practitioner.html): A portion of either family or given name using some kind of phonetic matching algorithm
    /// * [RelatedPerson](relatedperson.html): A portion of name using some kind of phonetic matching algorithm

    @Default([]) List<SearchParamString> phonetic,

    /// [telecom] Multiple Resources:

    /// * [Patient](patient.html): The value in any kind of telecom details of the patient
    /// * [Person](person.html): The value in any kind of contact
    /// * [Practitioner](practitioner.html): The value in any kind of contact
    /// * [PractitionerRole](practitionerrole.html): The value in any kind of contact
    /// * [RelatedPerson](relatedperson.html): The value in any kind of contact

    @Default([]) List<SearchParamToken> telecom,

    /// [identifier] A person Identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [link] Any link has this Patient, Person, RelatedPerson or Practitioner reference
    @Default([]) List<SearchParamReference> link,

    /// [name] A server defined search that may match any of the string fields in the HumanName, including family, give, prefix, suffix, suffix, and/or text
    @Default([]) List<SearchParamString> name,

    /// [organization] The organization at which this person record is being managed
    @Default([]) List<SearchParamReference> organization,

    /// [patient] The Person links to this Patient
    @Default([]) List<SearchParamReference> patient,

    /// [practitioner] The Person links to this Practitioner
    @Default([]) List<SearchParamReference> practitioner,

    /// [relatedperson] The Person links to this RelatedPerson
    @Default([]) List<SearchParamReference> relatedperson,
  }) = _PersonSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (address.isNotEmpty) {
      address.forEach(
          (element) => returnStrings.add('address${element.toRequest()}'));
    }
    if (addressCity.isNotEmpty) {
      addressCity.forEach(
          (element) => returnStrings.add('address-city${element.toRequest()}'));
    }
    if (addressCountry.isNotEmpty) {
      addressCountry.forEach((element) =>
          returnStrings.add('address-country${element.toRequest()}'));
    }
    if (addressPostalcode.isNotEmpty) {
      addressPostalcode.forEach((element) =>
          returnStrings.add('address-postalcode${element.toRequest()}'));
    }
    if (addressState.isNotEmpty) {
      addressState.forEach((element) =>
          returnStrings.add('address-state${element.toRequest()}'));
    }
    if (addressUse.isNotEmpty) {
      addressUse.forEach(
          (element) => returnStrings.add('address-use${element.toRequest()}'));
    }
    if (birthdate.isNotEmpty) {
      birthdate.forEach(
          (element) => returnStrings.add('birthdate${element.toRequest()}'));
    }
    if (email.isNotEmpty) {
      email.forEach(
          (element) => returnStrings.add('email${element.toRequest()}'));
    }
    if (gender.isNotEmpty) {
      gender.forEach(
          (element) => returnStrings.add('gender${element.toRequest()}'));
    }
    if (phone.isNotEmpty) {
      phone.forEach(
          (element) => returnStrings.add('phone${element.toRequest()}'));
    }
    if (phonetic.isNotEmpty) {
      phonetic.forEach(
          (element) => returnStrings.add('phonetic${element.toRequest()}'));
    }
    if (telecom.isNotEmpty) {
      telecom.forEach(
          (element) => returnStrings.add('telecom${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (link.isNotEmpty) {
      link.forEach(
          (element) => returnStrings.add('link${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (organization.isNotEmpty) {
      organization.forEach(
          (element) => returnStrings.add('organization${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (practitioner.isNotEmpty) {
      practitioner.forEach(
          (element) => returnStrings.add('practitioner${element.toRequest()}'));
    }
    if (relatedperson.isNotEmpty) {
      relatedperson.forEach((element) =>
          returnStrings.add('relatedperson${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class PractitionerSearchParams with _$PractitionerSearchParams {
  const PractitionerSearchParams._();
  const factory PractitionerSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [address] Multiple Resources:

    /// * [Patient](patient.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text
    /// * [Person](person.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text
    /// * [Practitioner](practitioner.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text
    /// * [RelatedPerson](relatedperson.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text

    @Default([]) List<SearchParamString> address,

    /// [addressCity] Multiple Resources:

    /// * [Patient](patient.html): A city specified in an address
    /// * [Person](person.html): A city specified in an address
    /// * [Practitioner](practitioner.html): A city specified in an address
    /// * [RelatedPerson](relatedperson.html): A city specified in an address

    @Default([])
    @JsonKey(name: 'address-city')
        List<SearchParamString> addressCity,

    /// [addressCountry] Multiple Resources:

    /// * [Patient](patient.html): A country specified in an address
    /// * [Person](person.html): A country specified in an address
    /// * [Practitioner](practitioner.html): A country specified in an address
    /// * [RelatedPerson](relatedperson.html): A country specified in an address

    @Default([])
    @JsonKey(name: 'address-country')
        List<SearchParamString> addressCountry,

    /// [addressPostalcode] Multiple Resources:

    /// * [Patient](patient.html): A postalCode specified in an address
    /// * [Person](person.html): A postal code specified in an address
    /// * [Practitioner](practitioner.html): A postalCode specified in an address
    /// * [RelatedPerson](relatedperson.html): A postal code specified in an address

    @Default([])
    @JsonKey(name: 'address-postalcode')
        List<SearchParamString> addressPostalcode,

    /// [addressState] Multiple Resources:

    /// * [Patient](patient.html): A state specified in an address
    /// * [Person](person.html): A state specified in an address
    /// * [Practitioner](practitioner.html): A state specified in an address
    /// * [RelatedPerson](relatedperson.html): A state specified in an address

    @Default([])
    @JsonKey(name: 'address-state')
        List<SearchParamString> addressState,

    /// [addressUse] Multiple Resources:

    /// * [Patient](patient.html): A use code specified in an address
    /// * [Person](person.html): A use code specified in an address
    /// * [Practitioner](practitioner.html): A use code specified in an address
    /// * [RelatedPerson](relatedperson.html): A use code specified in an address

    @Default([])
    @JsonKey(name: 'address-use')
        List<SearchParamToken> addressUse,

    /// [email] Multiple Resources:

    /// * [Patient](patient.html): A value in an email contact
    /// * [Person](person.html): A value in an email contact
    /// * [Practitioner](practitioner.html): A value in an email contact
    /// * [PractitionerRole](practitionerrole.html): A value in an email contact
    /// * [RelatedPerson](relatedperson.html): A value in an email contact

    @Default([]) List<SearchParamToken> email,

    /// [family] Multiple Resources:

    /// * [Patient](patient.html): A portion of the family name of the patient
    /// * [Practitioner](practitioner.html): A portion of the family name

    @Default([]) List<SearchParamString> family,

    /// [gender] Multiple Resources:

    /// * [Patient](patient.html): Gender of the patient
    /// * [Person](person.html): The gender of the person
    /// * [Practitioner](practitioner.html): Gender of the practitioner
    /// * [RelatedPerson](relatedperson.html): Gender of the related person

    @Default([]) List<SearchParamToken> gender,

    /// [given] Multiple Resources:

    /// * [Patient](patient.html): A portion of the given name of the patient
    /// * [Practitioner](practitioner.html): A portion of the given name

    @Default([]) List<SearchParamString> given,

    /// [phone] Multiple Resources:

    /// * [Patient](patient.html): A value in a phone contact
    /// * [Person](person.html): A value in a phone contact
    /// * [Practitioner](practitioner.html): A value in a phone contact
    /// * [PractitionerRole](practitionerrole.html): A value in a phone contact
    /// * [RelatedPerson](relatedperson.html): A value in a phone contact

    @Default([]) List<SearchParamToken> phone,

    /// [phonetic] Multiple Resources:

    /// * [Patient](patient.html): A portion of either family or given name using some kind of phonetic matching algorithm
    /// * [Person](person.html): A portion of name using some kind of phonetic matching algorithm
    /// * [Practitioner](practitioner.html): A portion of either family or given name using some kind of phonetic matching algorithm
    /// * [RelatedPerson](relatedperson.html): A portion of name using some kind of phonetic matching algorithm

    @Default([]) List<SearchParamString> phonetic,

    /// [telecom] Multiple Resources:

    /// * [Patient](patient.html): The value in any kind of telecom details of the patient
    /// * [Person](person.html): The value in any kind of contact
    /// * [Practitioner](practitioner.html): The value in any kind of contact
    /// * [PractitionerRole](practitionerrole.html): The value in any kind of contact
    /// * [RelatedPerson](relatedperson.html): The value in any kind of contact

    @Default([]) List<SearchParamToken> telecom,

    /// [active] Whether the practitioner record is active
    @Default([]) List<SearchParamToken> active,

    /// [communication] One of the languages that the practitioner can communicate with
    @Default([]) List<SearchParamToken> communication,

    /// [identifier] A practitioner's Identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [name] A server defined search that may match any of the string fields in the HumanName, including family, give, prefix, suffix, suffix, and/or text
    @Default([]) List<SearchParamString> name,
  }) = _PractitionerSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (address.isNotEmpty) {
      address.forEach(
          (element) => returnStrings.add('address${element.toRequest()}'));
    }
    if (addressCity.isNotEmpty) {
      addressCity.forEach(
          (element) => returnStrings.add('address-city${element.toRequest()}'));
    }
    if (addressCountry.isNotEmpty) {
      addressCountry.forEach((element) =>
          returnStrings.add('address-country${element.toRequest()}'));
    }
    if (addressPostalcode.isNotEmpty) {
      addressPostalcode.forEach((element) =>
          returnStrings.add('address-postalcode${element.toRequest()}'));
    }
    if (addressState.isNotEmpty) {
      addressState.forEach((element) =>
          returnStrings.add('address-state${element.toRequest()}'));
    }
    if (addressUse.isNotEmpty) {
      addressUse.forEach(
          (element) => returnStrings.add('address-use${element.toRequest()}'));
    }
    if (email.isNotEmpty) {
      email.forEach(
          (element) => returnStrings.add('email${element.toRequest()}'));
    }
    if (family.isNotEmpty) {
      family.forEach(
          (element) => returnStrings.add('family${element.toRequest()}'));
    }
    if (gender.isNotEmpty) {
      gender.forEach(
          (element) => returnStrings.add('gender${element.toRequest()}'));
    }
    if (given.isNotEmpty) {
      given.forEach(
          (element) => returnStrings.add('given${element.toRequest()}'));
    }
    if (phone.isNotEmpty) {
      phone.forEach(
          (element) => returnStrings.add('phone${element.toRequest()}'));
    }
    if (phonetic.isNotEmpty) {
      phonetic.forEach(
          (element) => returnStrings.add('phonetic${element.toRequest()}'));
    }
    if (telecom.isNotEmpty) {
      telecom.forEach(
          (element) => returnStrings.add('telecom${element.toRequest()}'));
    }
    if (active.isNotEmpty) {
      active.forEach(
          (element) => returnStrings.add('active${element.toRequest()}'));
    }
    if (communication.isNotEmpty) {
      communication.forEach((element) =>
          returnStrings.add('communication${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class RelatedPersonSearchParams with _$RelatedPersonSearchParams {
  const RelatedPersonSearchParams._();
  const factory RelatedPersonSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [address] Multiple Resources:

    /// * [Patient](patient.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text
    /// * [Person](person.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text
    /// * [Practitioner](practitioner.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text
    /// * [RelatedPerson](relatedperson.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text

    @Default([]) List<SearchParamString> address,

    /// [addressCity] Multiple Resources:

    /// * [Patient](patient.html): A city specified in an address
    /// * [Person](person.html): A city specified in an address
    /// * [Practitioner](practitioner.html): A city specified in an address
    /// * [RelatedPerson](relatedperson.html): A city specified in an address

    @Default([])
    @JsonKey(name: 'address-city')
        List<SearchParamString> addressCity,

    /// [addressCountry] Multiple Resources:

    /// * [Patient](patient.html): A country specified in an address
    /// * [Person](person.html): A country specified in an address
    /// * [Practitioner](practitioner.html): A country specified in an address
    /// * [RelatedPerson](relatedperson.html): A country specified in an address

    @Default([])
    @JsonKey(name: 'address-country')
        List<SearchParamString> addressCountry,

    /// [addressPostalcode] Multiple Resources:

    /// * [Patient](patient.html): A postalCode specified in an address
    /// * [Person](person.html): A postal code specified in an address
    /// * [Practitioner](practitioner.html): A postalCode specified in an address
    /// * [RelatedPerson](relatedperson.html): A postal code specified in an address

    @Default([])
    @JsonKey(name: 'address-postalcode')
        List<SearchParamString> addressPostalcode,

    /// [addressState] Multiple Resources:

    /// * [Patient](patient.html): A state specified in an address
    /// * [Person](person.html): A state specified in an address
    /// * [Practitioner](practitioner.html): A state specified in an address
    /// * [RelatedPerson](relatedperson.html): A state specified in an address

    @Default([])
    @JsonKey(name: 'address-state')
        List<SearchParamString> addressState,

    /// [addressUse] Multiple Resources:

    /// * [Patient](patient.html): A use code specified in an address
    /// * [Person](person.html): A use code specified in an address
    /// * [Practitioner](practitioner.html): A use code specified in an address
    /// * [RelatedPerson](relatedperson.html): A use code specified in an address

    @Default([])
    @JsonKey(name: 'address-use')
        List<SearchParamToken> addressUse,

    /// [birthdate] Multiple Resources:

    /// * [Patient](patient.html): The patient's date of birth
    /// * [Person](person.html): The person's date of birth
    /// * [RelatedPerson](relatedperson.html): The Related Person's date of birth

    @Default([]) List<SearchParamDate> birthdate,

    /// [email] Multiple Resources:

    /// * [Patient](patient.html): A value in an email contact
    /// * [Person](person.html): A value in an email contact
    /// * [Practitioner](practitioner.html): A value in an email contact
    /// * [PractitionerRole](practitionerrole.html): A value in an email contact
    /// * [RelatedPerson](relatedperson.html): A value in an email contact

    @Default([]) List<SearchParamToken> email,

    /// [gender] Multiple Resources:

    /// * [Patient](patient.html): Gender of the patient
    /// * [Person](person.html): The gender of the person
    /// * [Practitioner](practitioner.html): Gender of the practitioner
    /// * [RelatedPerson](relatedperson.html): Gender of the related person

    @Default([]) List<SearchParamToken> gender,

    /// [phone] Multiple Resources:

    /// * [Patient](patient.html): A value in a phone contact
    /// * [Person](person.html): A value in a phone contact
    /// * [Practitioner](practitioner.html): A value in a phone contact
    /// * [PractitionerRole](practitionerrole.html): A value in a phone contact
    /// * [RelatedPerson](relatedperson.html): A value in a phone contact

    @Default([]) List<SearchParamToken> phone,

    /// [phonetic] Multiple Resources:

    /// * [Patient](patient.html): A portion of either family or given name using some kind of phonetic matching algorithm
    /// * [Person](person.html): A portion of name using some kind of phonetic matching algorithm
    /// * [Practitioner](practitioner.html): A portion of either family or given name using some kind of phonetic matching algorithm
    /// * [RelatedPerson](relatedperson.html): A portion of name using some kind of phonetic matching algorithm

    @Default([]) List<SearchParamString> phonetic,

    /// [telecom] Multiple Resources:

    /// * [Patient](patient.html): The value in any kind of telecom details of the patient
    /// * [Person](person.html): The value in any kind of contact
    /// * [Practitioner](practitioner.html): The value in any kind of contact
    /// * [PractitionerRole](practitionerrole.html): The value in any kind of contact
    /// * [RelatedPerson](relatedperson.html): The value in any kind of contact

    @Default([]) List<SearchParamToken> telecom,

    /// [active] Indicates if the related person record is active
    @Default([]) List<SearchParamToken> active,

    /// [identifier] An Identifier of the RelatedPerson
    @Default([]) List<SearchParamToken> identifier,

    /// [name] A server defined search that may match any of the string fields in the HumanName, including family, give, prefix, suffix, suffix, and/or text
    @Default([]) List<SearchParamString> name,

    /// [patient] The patient this related person is related to
    @Default([]) List<SearchParamReference> patient,

    /// [relationship] The relationship between the patient and the relatedperson
    @Default([]) List<SearchParamToken> relationship,
  }) = _RelatedPersonSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (address.isNotEmpty) {
      address.forEach(
          (element) => returnStrings.add('address${element.toRequest()}'));
    }
    if (addressCity.isNotEmpty) {
      addressCity.forEach(
          (element) => returnStrings.add('address-city${element.toRequest()}'));
    }
    if (addressCountry.isNotEmpty) {
      addressCountry.forEach((element) =>
          returnStrings.add('address-country${element.toRequest()}'));
    }
    if (addressPostalcode.isNotEmpty) {
      addressPostalcode.forEach((element) =>
          returnStrings.add('address-postalcode${element.toRequest()}'));
    }
    if (addressState.isNotEmpty) {
      addressState.forEach((element) =>
          returnStrings.add('address-state${element.toRequest()}'));
    }
    if (addressUse.isNotEmpty) {
      addressUse.forEach(
          (element) => returnStrings.add('address-use${element.toRequest()}'));
    }
    if (birthdate.isNotEmpty) {
      birthdate.forEach(
          (element) => returnStrings.add('birthdate${element.toRequest()}'));
    }
    if (email.isNotEmpty) {
      email.forEach(
          (element) => returnStrings.add('email${element.toRequest()}'));
    }
    if (gender.isNotEmpty) {
      gender.forEach(
          (element) => returnStrings.add('gender${element.toRequest()}'));
    }
    if (phone.isNotEmpty) {
      phone.forEach(
          (element) => returnStrings.add('phone${element.toRequest()}'));
    }
    if (phonetic.isNotEmpty) {
      phonetic.forEach(
          (element) => returnStrings.add('phonetic${element.toRequest()}'));
    }
    if (telecom.isNotEmpty) {
      telecom.forEach(
          (element) => returnStrings.add('telecom${element.toRequest()}'));
    }
    if (active.isNotEmpty) {
      active.forEach(
          (element) => returnStrings.add('active${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (relationship.isNotEmpty) {
      relationship.forEach(
          (element) => returnStrings.add('relationship${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class PractitionerRoleSearchParams with _$PractitionerRoleSearchParams {
  const PractitionerRoleSearchParams._();
  const factory PractitionerRoleSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [email] Multiple Resources:

    /// * [Patient](patient.html): A value in an email contact
    /// * [Person](person.html): A value in an email contact
    /// * [Practitioner](practitioner.html): A value in an email contact
    /// * [PractitionerRole](practitionerrole.html): A value in an email contact
    /// * [RelatedPerson](relatedperson.html): A value in an email contact

    @Default([]) List<SearchParamToken> email,

    /// [phone] Multiple Resources:

    /// * [Patient](patient.html): A value in a phone contact
    /// * [Person](person.html): A value in a phone contact
    /// * [Practitioner](practitioner.html): A value in a phone contact
    /// * [PractitionerRole](practitionerrole.html): A value in a phone contact
    /// * [RelatedPerson](relatedperson.html): A value in a phone contact

    @Default([]) List<SearchParamToken> phone,

    /// [telecom] Multiple Resources:

    /// * [Patient](patient.html): The value in any kind of telecom details of the patient
    /// * [Person](person.html): The value in any kind of contact
    /// * [Practitioner](practitioner.html): The value in any kind of contact
    /// * [PractitionerRole](practitionerrole.html): The value in any kind of contact
    /// * [RelatedPerson](relatedperson.html): The value in any kind of contact

    @Default([]) List<SearchParamToken> telecom,

    /// [active] Whether this practitioner role record is in active use
    @Default([]) List<SearchParamToken> active,

    /// [date] The period during which the practitioner is authorized to perform in these role(s)
    @Default([]) List<SearchParamDate> date,

    /// [endpoint] Technical endpoints providing access to services operated for the practitioner with this role
    @Default([]) List<SearchParamReference> endpoint,

    /// [identifier] A practitioner's Identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [location] One of the locations at which this practitioner provides care
    @Default([]) List<SearchParamReference> location,

    /// [organization] The identity of the organization the practitioner represents / acts on behalf of
    @Default([]) List<SearchParamReference> organization,

    /// [practitioner] Practitioner that is able to provide the defined services for the organization
    @Default([]) List<SearchParamReference> practitioner,

    /// [role] The practitioner can perform this role at for the organization
    @Default([]) List<SearchParamToken> role,

    /// [service] The list of healthcare services that this worker provides for this role's Organization/Location(s)
    @Default([]) List<SearchParamReference> service,

    /// [specialty] The practitioner has this specialty at an organization
    @Default([]) List<SearchParamToken> specialty,
  }) = _PractitionerRoleSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (email.isNotEmpty) {
      email.forEach(
          (element) => returnStrings.add('email${element.toRequest()}'));
    }
    if (phone.isNotEmpty) {
      phone.forEach(
          (element) => returnStrings.add('phone${element.toRequest()}'));
    }
    if (telecom.isNotEmpty) {
      telecom.forEach(
          (element) => returnStrings.add('telecom${element.toRequest()}'));
    }
    if (active.isNotEmpty) {
      active.forEach(
          (element) => returnStrings.add('active${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (endpoint.isNotEmpty) {
      endpoint.forEach(
          (element) => returnStrings.add('endpoint${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (location.isNotEmpty) {
      location.forEach(
          (element) => returnStrings.add('location${element.toRequest()}'));
    }
    if (organization.isNotEmpty) {
      organization.forEach(
          (element) => returnStrings.add('organization${element.toRequest()}'));
    }
    if (practitioner.isNotEmpty) {
      practitioner.forEach(
          (element) => returnStrings.add('practitioner${element.toRequest()}'));
    }
    if (role.isNotEmpty) {
      role.forEach(
          (element) => returnStrings.add('role${element.toRequest()}'));
    }
    if (service.isNotEmpty) {
      service.forEach(
          (element) => returnStrings.add('service${element.toRequest()}'));
    }
    if (specialty.isNotEmpty) {
      specialty.forEach(
          (element) => returnStrings.add('specialty${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class PaymentNoticeSearchParams with _$PaymentNoticeSearchParams {
  const PaymentNoticeSearchParams._();
  const factory PaymentNoticeSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [created] Creation date fro the notice
    @Default([]) List<SearchParamDate> created,

    /// [identifier] The business identifier of the notice
    @Default([]) List<SearchParamToken> identifier,

    /// [paymentStatus] The type of payment notice
    @Default([])
    @JsonKey(name: 'payment-status')
        List<SearchParamToken> paymentStatus,

    /// [provider] The reference to the provider
    @Default([]) List<SearchParamReference> provider,

    /// [request] The Claim
    @Default([]) List<SearchParamReference> request,

    /// [response] The ClaimResponse
    @Default([]) List<SearchParamReference> response,

    /// [status] The status of the payment notice
    @Default([]) List<SearchParamToken> status,
  }) = _PaymentNoticeSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (created.isNotEmpty) {
      created.forEach(
          (element) => returnStrings.add('created${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (paymentStatus.isNotEmpty) {
      paymentStatus.forEach((element) =>
          returnStrings.add('payment-status${element.toRequest()}'));
    }
    if (provider.isNotEmpty) {
      provider.forEach(
          (element) => returnStrings.add('provider${element.toRequest()}'));
    }
    if (request.isNotEmpty) {
      request.forEach(
          (element) => returnStrings.add('request${element.toRequest()}'));
    }
    if (response.isNotEmpty) {
      response.forEach(
          (element) => returnStrings.add('response${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class PaymentReconciliationSearchParams
    with _$PaymentReconciliationSearchParams {
  const PaymentReconciliationSearchParams._();
  const factory PaymentReconciliationSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [created] The creation date
    @Default([]) List<SearchParamDate> created,

    /// [disposition] The contents of the disposition message
    @Default([]) List<SearchParamString> disposition,

    /// [identifier] The business identifier of the ExplanationOfBenefit
    @Default([]) List<SearchParamToken> identifier,

    /// [outcome] The processing outcome
    @Default([]) List<SearchParamToken> outcome,

    /// [paymentIssuer] The organization which generated this resource
    @Default([])
    @JsonKey(name: 'payment-issuer')
        List<SearchParamReference> paymentIssuer,

    /// [request] The reference to the claim
    @Default([]) List<SearchParamReference> request,

    /// [requestor] The reference to the provider who submitted the claim
    @Default([]) List<SearchParamReference> requestor,

    /// [status] The status of the payment reconciliation
    @Default([]) List<SearchParamToken> status,
  }) = _PaymentReconciliationSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (created.isNotEmpty) {
      created.forEach(
          (element) => returnStrings.add('created${element.toRequest()}'));
    }
    if (disposition.isNotEmpty) {
      disposition.forEach(
          (element) => returnStrings.add('disposition${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (outcome.isNotEmpty) {
      outcome.forEach(
          (element) => returnStrings.add('outcome${element.toRequest()}'));
    }
    if (paymentIssuer.isNotEmpty) {
      paymentIssuer.forEach((element) =>
          returnStrings.add('payment-issuer${element.toRequest()}'));
    }
    if (request.isNotEmpty) {
      request.forEach(
          (element) => returnStrings.add('request${element.toRequest()}'));
    }
    if (requestor.isNotEmpty) {
      requestor.forEach(
          (element) => returnStrings.add('requestor${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class PlanDefinitionSearchParams with _$PlanDefinitionSearchParams {
  const PlanDefinitionSearchParams._();
  const factory PlanDefinitionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [composedOf] What resource is being referenced
    @Default([])
    @JsonKey(name: 'composed-of')
        List<SearchParamReference> composedOf,

    /// [context] A use context assigned to the plan definition
    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] A quantity- or range-valued use context assigned to the plan definition
    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] A type of use context assigned to the plan definition
    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] The plan definition publication date
    @Default([]) List<SearchParamDate> date,

    /// [definition] Activity or plan definitions used by plan definition
    @Default([]) List<SearchParamReference> definition,

    /// [dependsOn] What resource is being referenced
    @Default([])
    @JsonKey(name: 'depends-on')
        List<SearchParamReference> dependsOn,

    /// [derivedFrom] What resource is being referenced
    @Default([])
    @JsonKey(name: 'derived-from')
        List<SearchParamReference> derivedFrom,

    /// [description] The description of the plan definition
    @Default([]) List<SearchParamString> description,

    /// [effective] The time during which the plan definition is intended to be in use
    @Default([]) List<SearchParamDate> effective,

    /// [identifier] External identifier for the plan definition
    @Default([]) List<SearchParamToken> identifier,

    /// [jurisdiction] Intended jurisdiction for the plan definition
    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Computationally friendly name of the plan definition
    @Default([]) List<SearchParamString> name,

    /// [predecessor] What resource is being referenced
    @Default([]) List<SearchParamReference> predecessor,

    /// [publisher] Name of the publisher of the plan definition
    @Default([]) List<SearchParamString> publisher,

    /// [status] The current status of the plan definition
    @Default([]) List<SearchParamToken> status,

    /// [successor] What resource is being referenced
    @Default([]) List<SearchParamReference> successor,

    /// [title] The human-friendly name of the plan definition
    @Default([]) List<SearchParamString> title,

    /// [topic] Topics associated with the module
    @Default([]) List<SearchParamToken> topic,

    /// [type] The type of artifact the plan (e.g. order-set, eca-rule, protocol)
    @Default([]) List<SearchParamToken> type,

    /// [url] The uri that identifies the plan definition
    @Default([]) List<SearchParamUri> url,

    /// [version] The business version of the plan definition
    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] A use context type and quantity- or range-based value assigned to the plan definition
    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] A use context type and value assigned to the plan definition
    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,
  }) = _PlanDefinitionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (composedOf.isNotEmpty) {
      composedOf.forEach(
          (element) => returnStrings.add('composed-of${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (definition.isNotEmpty) {
      definition.forEach(
          (element) => returnStrings.add('definition${element.toRequest()}'));
    }
    if (dependsOn.isNotEmpty) {
      dependsOn.forEach(
          (element) => returnStrings.add('depends-on${element.toRequest()}'));
    }
    if (derivedFrom.isNotEmpty) {
      derivedFrom.forEach(
          (element) => returnStrings.add('derived-from${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (effective.isNotEmpty) {
      effective.forEach(
          (element) => returnStrings.add('effective${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (predecessor.isNotEmpty) {
      predecessor.forEach(
          (element) => returnStrings.add('predecessor${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (successor.isNotEmpty) {
      successor.forEach(
          (element) => returnStrings.add('successor${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (topic.isNotEmpty) {
      topic.forEach(
          (element) => returnStrings.add('topic${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ProvenanceSearchParams with _$ProvenanceSearchParams {
  const ProvenanceSearchParams._();
  const factory ProvenanceSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [agent] Who participated
    @Default([]) List<SearchParamReference> agent,

    /// [agentRole] What the agents role was
    @Default([]) @JsonKey(name: 'agent-role') List<SearchParamToken> agentRole,

    /// [agentType] How the agent participated
    @Default([]) @JsonKey(name: 'agent-type') List<SearchParamToken> agentType,

    /// [entity] Identity of entity
    @Default([]) List<SearchParamReference> entity,

    /// [location] Where the activity occurred, if relevant
    @Default([]) List<SearchParamReference> location,

    /// [patient] Target Reference(s) (usually version specific)
    @Default([]) List<SearchParamReference> patient,

    /// [recorded] When the activity was recorded / updated
    @Default([]) List<SearchParamDate> recorded,

    /// [signatureType] Indication of the reason the entity signed the object(s)
    @Default([])
    @JsonKey(name: 'signature-type')
        List<SearchParamToken> signatureType,

    /// [target] Target Reference(s) (usually version specific)
    @Default([]) List<SearchParamReference> target,

    /// [when] When the activity occurred
    @Default([]) List<SearchParamDate> when,
  }) = _ProvenanceSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (agent.isNotEmpty) {
      agent.forEach(
          (element) => returnStrings.add('agent${element.toRequest()}'));
    }
    if (agentRole.isNotEmpty) {
      agentRole.forEach(
          (element) => returnStrings.add('agent-role${element.toRequest()}'));
    }
    if (agentType.isNotEmpty) {
      agentType.forEach(
          (element) => returnStrings.add('agent-type${element.toRequest()}'));
    }
    if (entity.isNotEmpty) {
      entity.forEach(
          (element) => returnStrings.add('entity${element.toRequest()}'));
    }
    if (location.isNotEmpty) {
      location.forEach(
          (element) => returnStrings.add('location${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (recorded.isNotEmpty) {
      recorded.forEach(
          (element) => returnStrings.add('recorded${element.toRequest()}'));
    }
    if (signatureType.isNotEmpty) {
      signatureType.forEach((element) =>
          returnStrings.add('signature-type${element.toRequest()}'));
    }
    if (target.isNotEmpty) {
      target.forEach(
          (element) => returnStrings.add('target${element.toRequest()}'));
    }
    if (when.isNotEmpty) {
      when.forEach(
          (element) => returnStrings.add('when${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class QuestionnaireSearchParams with _$QuestionnaireSearchParams {
  const QuestionnaireSearchParams._();
  const factory QuestionnaireSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [code] A code that corresponds to one of its items in the questionnaire
    @Default([]) List<SearchParamToken> code,

    /// [context] A use context assigned to the questionnaire
    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] A quantity- or range-valued use context assigned to the questionnaire
    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] A type of use context assigned to the questionnaire
    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] The questionnaire publication date
    @Default([]) List<SearchParamDate> date,

    /// [definition] ElementDefinition - details for the item
    @Default([]) List<SearchParamUri> definition,

    /// [description] The description of the questionnaire
    @Default([]) List<SearchParamString> description,

    /// [effective] The time during which the questionnaire is intended to be in use
    @Default([]) List<SearchParamDate> effective,

    /// [identifier] External identifier for the questionnaire
    @Default([]) List<SearchParamToken> identifier,

    /// [jurisdiction] Intended jurisdiction for the questionnaire
    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Computationally friendly name of the questionnaire
    @Default([]) List<SearchParamString> name,

    /// [publisher] Name of the publisher of the questionnaire
    @Default([]) List<SearchParamString> publisher,

    /// [status] The current status of the questionnaire
    @Default([]) List<SearchParamToken> status,

    /// [subjectType] Resource that can be subject of QuestionnaireResponse
    @Default([])
    @JsonKey(name: 'subject-type')
        List<SearchParamToken> subjectType,

    /// [title] The human-friendly name of the questionnaire
    @Default([]) List<SearchParamString> title,

    /// [url] The uri that identifies the questionnaire
    @Default([]) List<SearchParamUri> url,

    /// [version] The business version of the questionnaire
    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] A use context type and quantity- or range-based value assigned to the questionnaire
    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] A use context type and value assigned to the questionnaire
    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,
  }) = _QuestionnaireSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (definition.isNotEmpty) {
      definition.forEach(
          (element) => returnStrings.add('definition${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (effective.isNotEmpty) {
      effective.forEach(
          (element) => returnStrings.add('effective${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subjectType.isNotEmpty) {
      subjectType.forEach(
          (element) => returnStrings.add('subject-type${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class QuestionnaireResponseSearchParams
    with _$QuestionnaireResponseSearchParams {
  const QuestionnaireResponseSearchParams._();
  const factory QuestionnaireResponseSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [author] The author of the questionnaire response
    @Default([]) List<SearchParamReference> author,

    /// [authored] When the questionnaire response was last changed
    @Default([]) List<SearchParamDate> authored,

    /// [basedOn] Plan/proposal/order fulfilled by this questionnaire response
    @Default([]) @JsonKey(name: 'based-on') List<SearchParamReference> basedOn,

    /// [encounter] Encounter associated with the questionnaire response
    @Default([]) List<SearchParamReference> encounter,

    /// [identifier] The unique identifier for the questionnaire response
    @Default([]) List<SearchParamToken> identifier,

    /// [partOf] Procedure or observation this questionnaire response was performed as a part of
    @Default([]) @JsonKey(name: 'part-of') List<SearchParamReference> partOf,

    /// [patient] The patient that is the subject of the questionnaire response
    @Default([]) List<SearchParamReference> patient,

    /// [questionnaire] The questionnaire the answers are provided for
    @Default([]) List<SearchParamReference> questionnaire,

    /// [source] The individual providing the information reflected in the questionnaire respose
    @Default([]) List<SearchParamReference> source,

    /// [status] The status of the questionnaire response
    @Default([]) List<SearchParamToken> status,

    /// [subject] The subject of the questionnaire response
    @Default([]) List<SearchParamReference> subject,
  }) = _QuestionnaireResponseSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (author.isNotEmpty) {
      author.forEach(
          (element) => returnStrings.add('author${element.toRequest()}'));
    }
    if (authored.isNotEmpty) {
      authored.forEach(
          (element) => returnStrings.add('authored${element.toRequest()}'));
    }
    if (basedOn.isNotEmpty) {
      basedOn.forEach(
          (element) => returnStrings.add('based-on${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (partOf.isNotEmpty) {
      partOf.forEach(
          (element) => returnStrings.add('part-of${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (questionnaire.isNotEmpty) {
      questionnaire.forEach((element) =>
          returnStrings.add('questionnaire${element.toRequest()}'));
    }
    if (source.isNotEmpty) {
      source.forEach(
          (element) => returnStrings.add('source${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class RegulatedAuthorizationSearchParams
    with _$RegulatedAuthorizationSearchParams {
  const RegulatedAuthorizationSearchParams._();
  const factory RegulatedAuthorizationSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [case_] The case or procedure number
    @Default([]) @JsonKey(name: 'case') List<SearchParamToken> case_,

    /// [caseType] The defining type of case
    @Default([]) @JsonKey(name: 'case-type') List<SearchParamToken> caseType,

    /// [holder] The organization that holds the granted authorization
    @Default([]) List<SearchParamReference> holder,

    /// [identifier] Business identifier for the authorization, typically assigned by the authorizing body
    @Default([]) List<SearchParamToken> identifier,

    /// [region] The territory (e.g., country, jurisdiction etc.) in which the authorization has been granted
    @Default([]) List<SearchParamToken> region,

    /// [status] The status that is authorised e.g. approved. Intermediate states can be tracked with cases and applications
    @Default([]) List<SearchParamToken> status,

    /// [subject] The type of regulated product, treatment, facility or activity that is being authorized
    @Default([]) List<SearchParamReference> subject,
  }) = _RegulatedAuthorizationSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (case_.isNotEmpty) {
      case_.forEach(
          (element) => returnStrings.add('case${element.toRequest()}'));
    }
    if (caseType.isNotEmpty) {
      caseType.forEach(
          (element) => returnStrings.add('case-type${element.toRequest()}'));
    }
    if (holder.isNotEmpty) {
      holder.forEach(
          (element) => returnStrings.add('holder${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (region.isNotEmpty) {
      region.forEach(
          (element) => returnStrings.add('region${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class RequestGroupSearchParams with _$RequestGroupSearchParams {
  const RequestGroupSearchParams._();
  const factory RequestGroupSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [author] The author of the request group
    @Default([]) List<SearchParamReference> author,

    /// [authored] The date the request group was authored
    @Default([]) List<SearchParamDate> authored,

    /// [code] The code of the request group
    @Default([]) List<SearchParamToken> code,

    /// [encounter] The encounter the request group applies to
    @Default([]) List<SearchParamReference> encounter,

    /// [groupIdentifier] The group identifier for the request group
    @Default([])
    @JsonKey(name: 'group-identifier')
        List<SearchParamToken> groupIdentifier,

    /// [identifier] External identifiers for the request group
    @Default([]) List<SearchParamToken> identifier,

    /// [instantiatesCanonical] The FHIR-based definition from which the request group is realized
    @Default([])
    @JsonKey(name: 'instantiates-canonical')
        List<SearchParamReference> instantiatesCanonical,

    /// [instantiatesUri] The external definition from which the request group is realized
    @Default([])
    @JsonKey(name: 'instantiates-uri')
        List<SearchParamUri> instantiatesUri,

    /// [intent] The intent of the request group
    @Default([]) List<SearchParamToken> intent,

    /// [participant] The participant in the requests in the group
    @Default([]) List<SearchParamReference> participant,

    /// [patient] The identity of a patient to search for request groups
    @Default([]) List<SearchParamReference> patient,

    /// [priority] The priority of the request group
    @Default([]) List<SearchParamToken> priority,

    /// [status] The status of the request group
    @Default([]) List<SearchParamToken> status,

    /// [subject] The subject that the request group is about
    @Default([]) List<SearchParamReference> subject,
  }) = _RequestGroupSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (author.isNotEmpty) {
      author.forEach(
          (element) => returnStrings.add('author${element.toRequest()}'));
    }
    if (authored.isNotEmpty) {
      authored.forEach(
          (element) => returnStrings.add('authored${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (groupIdentifier.isNotEmpty) {
      groupIdentifier.forEach((element) =>
          returnStrings.add('group-identifier${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (instantiatesCanonical.isNotEmpty) {
      instantiatesCanonical.forEach((element) =>
          returnStrings.add('instantiates-canonical${element.toRequest()}'));
    }
    if (instantiatesUri.isNotEmpty) {
      instantiatesUri.forEach((element) =>
          returnStrings.add('instantiates-uri${element.toRequest()}'));
    }
    if (intent.isNotEmpty) {
      intent.forEach(
          (element) => returnStrings.add('intent${element.toRequest()}'));
    }
    if (participant.isNotEmpty) {
      participant.forEach(
          (element) => returnStrings.add('participant${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (priority.isNotEmpty) {
      priority.forEach(
          (element) => returnStrings.add('priority${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ResearchDefinitionSearchParams with _$ResearchDefinitionSearchParams {
  const ResearchDefinitionSearchParams._();
  const factory ResearchDefinitionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [composedOf] What resource is being referenced
    @Default([])
    @JsonKey(name: 'composed-of')
        List<SearchParamReference> composedOf,

    /// [context] A use context assigned to the research definition
    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] A quantity- or range-valued use context assigned to the research definition
    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] A type of use context assigned to the research definition
    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] The research definition publication date
    @Default([]) List<SearchParamDate> date,

    /// [dependsOn] What resource is being referenced
    @Default([])
    @JsonKey(name: 'depends-on')
        List<SearchParamReference> dependsOn,

    /// [derivedFrom] What resource is being referenced
    @Default([])
    @JsonKey(name: 'derived-from')
        List<SearchParamReference> derivedFrom,

    /// [description] The description of the research definition
    @Default([]) List<SearchParamString> description,

    /// [effective] The time during which the research definition is intended to be in use
    @Default([]) List<SearchParamDate> effective,

    /// [identifier] External identifier for the research definition
    @Default([]) List<SearchParamToken> identifier,

    /// [jurisdiction] Intended jurisdiction for the research definition
    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Computationally friendly name of the research definition
    @Default([]) List<SearchParamString> name,

    /// [predecessor] What resource is being referenced
    @Default([]) List<SearchParamReference> predecessor,

    /// [publisher] Name of the publisher of the research definition
    @Default([]) List<SearchParamString> publisher,

    /// [status] The current status of the research definition
    @Default([]) List<SearchParamToken> status,

    /// [successor] What resource is being referenced
    @Default([]) List<SearchParamReference> successor,

    /// [title] The human-friendly name of the research definition
    @Default([]) List<SearchParamString> title,

    /// [topic] Topics associated with the ResearchDefinition
    @Default([]) List<SearchParamToken> topic,

    /// [url] The uri that identifies the research definition
    @Default([]) List<SearchParamUri> url,

    /// [version] The business version of the research definition
    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] A use context type and quantity- or range-based value assigned to the research definition
    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] A use context type and value assigned to the research definition
    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,
  }) = _ResearchDefinitionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (composedOf.isNotEmpty) {
      composedOf.forEach(
          (element) => returnStrings.add('composed-of${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (dependsOn.isNotEmpty) {
      dependsOn.forEach(
          (element) => returnStrings.add('depends-on${element.toRequest()}'));
    }
    if (derivedFrom.isNotEmpty) {
      derivedFrom.forEach(
          (element) => returnStrings.add('derived-from${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (effective.isNotEmpty) {
      effective.forEach(
          (element) => returnStrings.add('effective${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (predecessor.isNotEmpty) {
      predecessor.forEach(
          (element) => returnStrings.add('predecessor${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (successor.isNotEmpty) {
      successor.forEach(
          (element) => returnStrings.add('successor${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (topic.isNotEmpty) {
      topic.forEach(
          (element) => returnStrings.add('topic${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ResearchElementDefinitionSearchParams
    with _$ResearchElementDefinitionSearchParams {
  const ResearchElementDefinitionSearchParams._();
  const factory ResearchElementDefinitionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [composedOf] What resource is being referenced
    @Default([])
    @JsonKey(name: 'composed-of')
        List<SearchParamReference> composedOf,

    /// [context] A use context assigned to the research element definition
    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] A quantity- or range-valued use context assigned to the research element definition
    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] A type of use context assigned to the research element definition
    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] The research element definition publication date
    @Default([]) List<SearchParamDate> date,

    /// [dependsOn] What resource is being referenced
    @Default([])
    @JsonKey(name: 'depends-on')
        List<SearchParamReference> dependsOn,

    /// [derivedFrom] What resource is being referenced
    @Default([])
    @JsonKey(name: 'derived-from')
        List<SearchParamReference> derivedFrom,

    /// [description] The description of the research element definition
    @Default([]) List<SearchParamString> description,

    /// [effective] The time during which the research element definition is intended to be in use
    @Default([]) List<SearchParamDate> effective,

    /// [identifier] External identifier for the research element definition
    @Default([]) List<SearchParamToken> identifier,

    /// [jurisdiction] Intended jurisdiction for the research element definition
    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Computationally friendly name of the research element definition
    @Default([]) List<SearchParamString> name,

    /// [predecessor] What resource is being referenced
    @Default([]) List<SearchParamReference> predecessor,

    /// [publisher] Name of the publisher of the research element definition
    @Default([]) List<SearchParamString> publisher,

    /// [status] The current status of the research element definition
    @Default([]) List<SearchParamToken> status,

    /// [successor] What resource is being referenced
    @Default([]) List<SearchParamReference> successor,

    /// [title] The human-friendly name of the research element definition
    @Default([]) List<SearchParamString> title,

    /// [topic] Topics associated with the ResearchElementDefinition
    @Default([]) List<SearchParamToken> topic,

    /// [url] The uri that identifies the research element definition
    @Default([]) List<SearchParamUri> url,

    /// [version] The business version of the research element definition
    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] A use context type and quantity- or range-based value assigned to the research element definition
    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] A use context type and value assigned to the research element definition
    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,
  }) = _ResearchElementDefinitionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (composedOf.isNotEmpty) {
      composedOf.forEach(
          (element) => returnStrings.add('composed-of${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (dependsOn.isNotEmpty) {
      dependsOn.forEach(
          (element) => returnStrings.add('depends-on${element.toRequest()}'));
    }
    if (derivedFrom.isNotEmpty) {
      derivedFrom.forEach(
          (element) => returnStrings.add('derived-from${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (effective.isNotEmpty) {
      effective.forEach(
          (element) => returnStrings.add('effective${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (predecessor.isNotEmpty) {
      predecessor.forEach(
          (element) => returnStrings.add('predecessor${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (successor.isNotEmpty) {
      successor.forEach(
          (element) => returnStrings.add('successor${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (topic.isNotEmpty) {
      topic.forEach(
          (element) => returnStrings.add('topic${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ResearchStudySearchParams with _$ResearchStudySearchParams {
  const ResearchStudySearchParams._();
  const factory ResearchStudySearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [category] Classifications for the study
    @Default([]) List<SearchParamToken> category,

    /// [date] When the study began and ended
    @Default([]) List<SearchParamDate> date,

    /// [focus] Drugs, devices, etc. under study
    @Default([]) List<SearchParamToken> focus,

    /// [identifier] Business Identifier for study
    @Default([]) List<SearchParamToken> identifier,

    /// [keyword] Used to search for the study
    @Default([]) List<SearchParamToken> keyword,

    /// [location] Geographic region(s) for study
    @Default([]) List<SearchParamToken> location,

    /// [partof] Part of larger study
    @Default([]) List<SearchParamReference> partof,

    /// [principalinvestigator] Researcher who oversees multiple aspects of the study
    @Default([]) List<SearchParamReference> principalinvestigator,

    /// [protocol] Steps followed in executing study
    @Default([]) List<SearchParamReference> protocol,

    /// [site] Facility where study activities are conducted
    @Default([]) List<SearchParamReference> site,

    /// [sponsor] Organization that initiates and is legally responsible for the study
    @Default([]) List<SearchParamReference> sponsor,

    /// [status] active | administratively-completed | approved | closed-to-accrual | closed-to-accrual-and-intervention | completed | disapproved | in-review | temporarily-closed-to-accrual | temporarily-closed-to-accrual-and-intervention | withdrawn
    @Default([]) List<SearchParamToken> status,

    /// [title] Name for this study
    @Default([]) List<SearchParamString> title,
  }) = _ResearchStudySearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (focus.isNotEmpty) {
      focus.forEach(
          (element) => returnStrings.add('focus${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (keyword.isNotEmpty) {
      keyword.forEach(
          (element) => returnStrings.add('keyword${element.toRequest()}'));
    }
    if (location.isNotEmpty) {
      location.forEach(
          (element) => returnStrings.add('location${element.toRequest()}'));
    }
    if (partof.isNotEmpty) {
      partof.forEach(
          (element) => returnStrings.add('partof${element.toRequest()}'));
    }
    if (principalinvestigator.isNotEmpty) {
      principalinvestigator.forEach((element) =>
          returnStrings.add('principalinvestigator${element.toRequest()}'));
    }
    if (protocol.isNotEmpty) {
      protocol.forEach(
          (element) => returnStrings.add('protocol${element.toRequest()}'));
    }
    if (site.isNotEmpty) {
      site.forEach(
          (element) => returnStrings.add('site${element.toRequest()}'));
    }
    if (sponsor.isNotEmpty) {
      sponsor.forEach(
          (element) => returnStrings.add('sponsor${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ResearchSubjectSearchParams with _$ResearchSubjectSearchParams {
  const ResearchSubjectSearchParams._();
  const factory ResearchSubjectSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [date] Start and end of participation
    @Default([]) List<SearchParamDate> date,

    /// [identifier] Business Identifier for research subject in a study
    @Default([]) List<SearchParamToken> identifier,

    /// [individual] Who is part of study
    @Default([]) List<SearchParamReference> individual,

    /// [patient] Who is part of study
    @Default([]) List<SearchParamReference> patient,

    /// [status] candidate | eligible | follow-up | ineligible | not-registered | off-study | on-study | on-study-intervention | on-study-observation | pending-on-study | potential-candidate | screening | withdrawn
    @Default([]) List<SearchParamToken> status,

    /// [study] Study subject is part of
    @Default([]) List<SearchParamReference> study,
  }) = _ResearchSubjectSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (individual.isNotEmpty) {
      individual.forEach(
          (element) => returnStrings.add('individual${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (study.isNotEmpty) {
      study.forEach(
          (element) => returnStrings.add('study${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class ScheduleSearchParams with _$ScheduleSearchParams {
  const ScheduleSearchParams._();
  const factory ScheduleSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [active] Is the schedule in active use
    @Default([]) List<SearchParamToken> active,

    /// [actor] The individual(HealthcareService, Practitioner, Location, ...) to find a Schedule for
    @Default([]) List<SearchParamReference> actor,

    /// [date] Search for Schedule resources that have a period that contains this date specified
    @Default([]) List<SearchParamDate> date,

    /// [identifier] A Schedule Identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [serviceCategory] High-level category
    @Default([])
    @JsonKey(name: 'service-category')
        List<SearchParamToken> serviceCategory,

    /// [serviceType] The type of appointments that can be booked into associated slot(s)
    @Default([])
    @JsonKey(name: 'service-type')
        List<SearchParamToken> serviceType,

    /// [specialty] Type of specialty needed
    @Default([]) List<SearchParamToken> specialty,
  }) = _ScheduleSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (active.isNotEmpty) {
      active.forEach(
          (element) => returnStrings.add('active${element.toRequest()}'));
    }
    if (actor.isNotEmpty) {
      actor.forEach(
          (element) => returnStrings.add('actor${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (serviceCategory.isNotEmpty) {
      serviceCategory.forEach((element) =>
          returnStrings.add('service-category${element.toRequest()}'));
    }
    if (serviceType.isNotEmpty) {
      serviceType.forEach(
          (element) => returnStrings.add('service-type${element.toRequest()}'));
    }
    if (specialty.isNotEmpty) {
      specialty.forEach(
          (element) => returnStrings.add('specialty${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class SlotSearchParams with _$SlotSearchParams {
  const SlotSearchParams._();
  const factory SlotSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [appointmentType] The style of appointment or patient that may be booked in the slot (not service type)
    @Default([])
    @JsonKey(name: 'appointment-type')
        List<SearchParamToken> appointmentType,

    /// [identifier] A Slot Identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [schedule] The Schedule Resource that we are seeking a slot within
    @Default([]) List<SearchParamReference> schedule,

    /// [serviceCategory] A broad categorization of the service that is to be performed during this appointment
    @Default([])
    @JsonKey(name: 'service-category')
        List<SearchParamToken> serviceCategory,

    /// [serviceType] The type of appointments that can be booked into the slot
    @Default([])
    @JsonKey(name: 'service-type')
        List<SearchParamToken> serviceType,

    /// [specialty] The specialty of a practitioner that would be required to perform the service requested in this appointment
    @Default([]) List<SearchParamToken> specialty,

    /// [start] Appointment date/time.
    @Default([]) List<SearchParamDate> start,

    /// [status] The free/busy status of the appointment
    @Default([]) List<SearchParamToken> status,
  }) = _SlotSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (appointmentType.isNotEmpty) {
      appointmentType.forEach((element) =>
          returnStrings.add('appointment-type${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (schedule.isNotEmpty) {
      schedule.forEach(
          (element) => returnStrings.add('schedule${element.toRequest()}'));
    }
    if (serviceCategory.isNotEmpty) {
      serviceCategory.forEach((element) =>
          returnStrings.add('service-category${element.toRequest()}'));
    }
    if (serviceType.isNotEmpty) {
      serviceType.forEach(
          (element) => returnStrings.add('service-type${element.toRequest()}'));
    }
    if (specialty.isNotEmpty) {
      specialty.forEach(
          (element) => returnStrings.add('specialty${element.toRequest()}'));
    }
    if (start.isNotEmpty) {
      start.forEach(
          (element) => returnStrings.add('start${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class SpecimenSearchParams with _$SpecimenSearchParams {
  const SpecimenSearchParams._();
  const factory SpecimenSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [accession] The accession number associated with the specimen
    @Default([]) List<SearchParamToken> accession,

    /// [bodysite] The code for the body site from where the specimen originated
    @Default([]) List<SearchParamToken> bodysite,

    /// [collected] The date the specimen was collected
    @Default([]) List<SearchParamDate> collected,

    /// [collector] Who collected the specimen
    @Default([]) List<SearchParamReference> collector,

    /// [container] The kind of specimen container
    @Default([]) List<SearchParamToken> container,

    /// [containerId] The unique identifier associated with the specimen container
    @Default([])
    @JsonKey(name: 'container-id')
        List<SearchParamToken> containerId,

    /// [identifier] The unique identifier associated with the specimen
    @Default([]) List<SearchParamToken> identifier,

    /// [parent] The parent of the specimen
    @Default([]) List<SearchParamReference> parent,

    /// [patient] The patient the specimen comes from
    @Default([]) List<SearchParamReference> patient,

    /// [status] available | unavailable | unsatisfactory | entered-in-error
    @Default([]) List<SearchParamToken> status,

    /// [subject] The subject of the specimen
    @Default([]) List<SearchParamReference> subject,

    /// [type] The specimen type
    @Default([]) List<SearchParamToken> type,
  }) = _SpecimenSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (accession.isNotEmpty) {
      accession.forEach(
          (element) => returnStrings.add('accession${element.toRequest()}'));
    }
    if (bodysite.isNotEmpty) {
      bodysite.forEach(
          (element) => returnStrings.add('bodysite${element.toRequest()}'));
    }
    if (collected.isNotEmpty) {
      collected.forEach(
          (element) => returnStrings.add('collected${element.toRequest()}'));
    }
    if (collector.isNotEmpty) {
      collector.forEach(
          (element) => returnStrings.add('collector${element.toRequest()}'));
    }
    if (container.isNotEmpty) {
      container.forEach(
          (element) => returnStrings.add('container${element.toRequest()}'));
    }
    if (containerId.isNotEmpty) {
      containerId.forEach(
          (element) => returnStrings.add('container-id${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (parent.isNotEmpty) {
      parent.forEach(
          (element) => returnStrings.add('parent${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class SpecimenDefinitionSearchParams with _$SpecimenDefinitionSearchParams {
  const SpecimenDefinitionSearchParams._();
  const factory SpecimenDefinitionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [container] The type of specimen conditioned in container expected by the lab
    @Default([]) List<SearchParamToken> container,

    /// [identifier] The unique identifier associated with the specimen
    @Default([]) List<SearchParamToken> identifier,

    /// [type] The type of collected specimen
    @Default([]) List<SearchParamToken> type,
  }) = _SpecimenDefinitionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (container.isNotEmpty) {
      container.forEach(
          (element) => returnStrings.add('container${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class SubscriptionSearchParams with _$SubscriptionSearchParams {
  const SubscriptionSearchParams._();
  const factory SubscriptionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [contact] Contact details for the subscription
    @Default([]) List<SearchParamToken> contact,

    /// [criteria] The search rules used to determine when to send a notification
    @Default([]) List<SearchParamString> criteria,

    /// [payload] The mime-type of the notification payload
    @Default([]) List<SearchParamToken> payload,

    /// [status] The current state of the subscription
    @Default([]) List<SearchParamToken> status,

    /// [type] The type of channel for the sent notifications
    @Default([]) List<SearchParamToken> type,

    /// [url] The uri that will receive the notifications
    @Default([]) List<SearchParamUri> url,
  }) = _SubscriptionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (contact.isNotEmpty) {
      contact.forEach(
          (element) => returnStrings.add('contact${element.toRequest()}'));
    }
    if (criteria.isNotEmpty) {
      criteria.forEach(
          (element) => returnStrings.add('criteria${element.toRequest()}'));
    }
    if (payload.isNotEmpty) {
      payload.forEach(
          (element) => returnStrings.add('payload${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (type.isNotEmpty) {
      type.forEach(
          (element) => returnStrings.add('type${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class SubscriptionTopicSearchParams with _$SubscriptionTopicSearchParams {
  const SubscriptionTopicSearchParams._();
  const factory SubscriptionTopicSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [date] Date status first applied
    @Default([]) List<SearchParamDate> date,

    /// [derivedOrSelf] A server defined search that matches either the url or derivedFrom
    @Default([])
    @JsonKey(name: 'derived-or-self')
        List<SearchParamUri> derivedOrSelf,

    /// [identifier] Business Identifier for SubscriptionTopic
    @Default([]) List<SearchParamToken> identifier,

    /// [resource] Allowed Data type or Resource (reference to definition) for this definition, searches resourceTrigger, eventTrigger, and notificationShape for matches.
    @Default([]) List<SearchParamUri> resource,

    /// [status] draft | active | retired | unknown
    @Default([]) List<SearchParamToken> status,

    /// [title] Name for this SubscriptionTopic (Human friendly)
    @Default([]) List<SearchParamString> title,

    /// [triggerDescription] Text representation of the trigger
    @Default([])
    @JsonKey(name: 'trigger-description')
        List<SearchParamString> triggerDescription,

    /// [url] Logical canonical URL to reference this SubscriptionTopic (globally unique)
    @Default([]) List<SearchParamUri> url,

    /// [version] Business version of the SubscriptionTopic
    @Default([]) List<SearchParamToken> version,
  }) = _SubscriptionTopicSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (derivedOrSelf.isNotEmpty) {
      derivedOrSelf.forEach((element) =>
          returnStrings.add('derived-or-self${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (resource.isNotEmpty) {
      resource.forEach(
          (element) => returnStrings.add('resource${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (triggerDescription.isNotEmpty) {
      triggerDescription.forEach((element) =>
          returnStrings.add('trigger-description${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class SubstanceSearchParams with _$SubstanceSearchParams {
  const SubstanceSearchParams._();
  const factory SubstanceSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [category] The category of the substance
    @Default([]) List<SearchParamToken> category,

    /// [code] The code of the substance or ingredient
    @Default([]) List<SearchParamToken> code,

    /// [containerIdentifier] Identifier of the package/container
    @Default([])
    @JsonKey(name: 'container-identifier')
        List<SearchParamToken> containerIdentifier,

    /// [expiry] Expiry date of package or container of substance
    @Default([]) List<SearchParamDate> expiry,

    /// [identifier] Unique identifier for the substance
    @Default([]) List<SearchParamToken> identifier,

    /// [quantity] Amount of substance in the package
    @Default([]) List<SearchParamQuantity> quantity,

    /// [status] active | inactive | entered-in-error
    @Default([]) List<SearchParamToken> status,

    /// [substanceReference] A component of the substance
    @Default([])
    @JsonKey(name: 'substance-reference')
        List<SearchParamReference> substanceReference,
  }) = _SubstanceSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (category.isNotEmpty) {
      category.forEach(
          (element) => returnStrings.add('category${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (containerIdentifier.isNotEmpty) {
      containerIdentifier.forEach((element) =>
          returnStrings.add('container-identifier${element.toRequest()}'));
    }
    if (expiry.isNotEmpty) {
      expiry.forEach(
          (element) => returnStrings.add('expiry${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (quantity.isNotEmpty) {
      quantity.forEach(
          (element) => returnStrings.add('quantity${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (substanceReference.isNotEmpty) {
      substanceReference.forEach((element) =>
          returnStrings.add('substance-reference${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class SubstanceDefinitionSearchParams with _$SubstanceDefinitionSearchParams {
  const SubstanceDefinitionSearchParams._();
  const factory SubstanceDefinitionSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [classification] High or low level categorization, e.g. polymer vs. nucleic acid or linear vs. branch chain
    @Default([]) List<SearchParamToken> classification,

    /// [code] The specific code
    @Default([]) List<SearchParamToken> code,

    /// [domain] If the substance applies to only human or veterinary use
    @Default([]) List<SearchParamToken> domain,

    /// [identifier] Identifier by which this substance is known
    @Default([]) List<SearchParamToken> identifier,

    /// [name] The actual name
    @Default([]) List<SearchParamString> name,
  }) = _SubstanceDefinitionSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (classification.isNotEmpty) {
      classification.forEach((element) =>
          returnStrings.add('classification${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (domain.isNotEmpty) {
      domain.forEach(
          (element) => returnStrings.add('domain${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class TaskSearchParams with _$TaskSearchParams {
  const TaskSearchParams._();
  const factory TaskSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [authoredOn] Search by creation date
    @Default([]) @JsonKey(name: 'authored-on') List<SearchParamDate> authoredOn,

    /// [basedOn] Search by requests this task is based on
    @Default([]) @JsonKey(name: 'based-on') List<SearchParamReference> basedOn,

    /// [businessStatus] Search by business status
    @Default([])
    @JsonKey(name: 'business-status')
        List<SearchParamToken> businessStatus,

    /// [code] Search by task code
    @Default([]) List<SearchParamToken> code,

    /// [encounter] Search by encounter
    @Default([]) List<SearchParamReference> encounter,

    /// [focus] Search by task focus
    @Default([]) List<SearchParamReference> focus,

    /// [groupIdentifier] Search by group identifier
    @Default([])
    @JsonKey(name: 'group-identifier')
        List<SearchParamToken> groupIdentifier,

    /// [identifier] Search for a task instance by its business identifier
    @Default([]) List<SearchParamToken> identifier,

    /// [intent] Search by task intent
    @Default([]) List<SearchParamToken> intent,

    /// [modified] Search by last modification date
    @Default([]) List<SearchParamDate> modified,

    /// [owner] Search by task owner
    @Default([]) List<SearchParamReference> owner,

    /// [partOf] Search by task this task is part of
    @Default([]) @JsonKey(name: 'part-of') List<SearchParamReference> partOf,

    /// [patient] Search by patient
    @Default([]) List<SearchParamReference> patient,

    /// [performer] Search by recommended type of performer (e.g., Requester, Performer, Scheduler).
    @Default([]) List<SearchParamToken> performer,

    /// [period] Search by period Task is/was underway
    @Default([]) List<SearchParamDate> period,

    /// [priority] Search by task priority
    @Default([]) List<SearchParamToken> priority,

    /// [requester] Search by task requester
    @Default([]) List<SearchParamReference> requester,

    /// [status] Search by task status
    @Default([]) List<SearchParamToken> status,

    /// [subject] Search by subject
    @Default([]) List<SearchParamReference> subject,
  }) = _TaskSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (authoredOn.isNotEmpty) {
      authoredOn.forEach(
          (element) => returnStrings.add('authored-on${element.toRequest()}'));
    }
    if (basedOn.isNotEmpty) {
      basedOn.forEach(
          (element) => returnStrings.add('based-on${element.toRequest()}'));
    }
    if (businessStatus.isNotEmpty) {
      businessStatus.forEach((element) =>
          returnStrings.add('business-status${element.toRequest()}'));
    }
    if (code.isNotEmpty) {
      code.forEach(
          (element) => returnStrings.add('code${element.toRequest()}'));
    }
    if (encounter.isNotEmpty) {
      encounter.forEach(
          (element) => returnStrings.add('encounter${element.toRequest()}'));
    }
    if (focus.isNotEmpty) {
      focus.forEach(
          (element) => returnStrings.add('focus${element.toRequest()}'));
    }
    if (groupIdentifier.isNotEmpty) {
      groupIdentifier.forEach((element) =>
          returnStrings.add('group-identifier${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (intent.isNotEmpty) {
      intent.forEach(
          (element) => returnStrings.add('intent${element.toRequest()}'));
    }
    if (modified.isNotEmpty) {
      modified.forEach(
          (element) => returnStrings.add('modified${element.toRequest()}'));
    }
    if (owner.isNotEmpty) {
      owner.forEach(
          (element) => returnStrings.add('owner${element.toRequest()}'));
    }
    if (partOf.isNotEmpty) {
      partOf.forEach(
          (element) => returnStrings.add('part-of${element.toRequest()}'));
    }
    if (patient.isNotEmpty) {
      patient.forEach(
          (element) => returnStrings.add('patient${element.toRequest()}'));
    }
    if (performer.isNotEmpty) {
      performer.forEach(
          (element) => returnStrings.add('performer${element.toRequest()}'));
    }
    if (period.isNotEmpty) {
      period.forEach(
          (element) => returnStrings.add('period${element.toRequest()}'));
    }
    if (priority.isNotEmpty) {
      priority.forEach(
          (element) => returnStrings.add('priority${element.toRequest()}'));
    }
    if (requester.isNotEmpty) {
      requester.forEach(
          (element) => returnStrings.add('requester${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (subject.isNotEmpty) {
      subject.forEach(
          (element) => returnStrings.add('subject${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class TestReportSearchParams with _$TestReportSearchParams {
  const TestReportSearchParams._();
  const factory TestReportSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [identifier] An external identifier for the test report
    @Default([]) List<SearchParamToken> identifier,

    /// [issued] The test report generation date
    @Default([]) List<SearchParamDate> issued,

    /// [participant] The reference to a participant in the test execution
    @Default([]) List<SearchParamUri> participant,

    /// [result] The result disposition of the test execution
    @Default([]) List<SearchParamToken> result,

    /// [tester] The name of the testing organization
    @Default([]) List<SearchParamString> tester,

    /// [testscript] The test script executed to produce this report
    @Default([]) List<SearchParamReference> testscript,
  }) = _TestReportSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (issued.isNotEmpty) {
      issued.forEach(
          (element) => returnStrings.add('issued${element.toRequest()}'));
    }
    if (participant.isNotEmpty) {
      participant.forEach(
          (element) => returnStrings.add('participant${element.toRequest()}'));
    }
    if (result.isNotEmpty) {
      result.forEach(
          (element) => returnStrings.add('result${element.toRequest()}'));
    }
    if (tester.isNotEmpty) {
      tester.forEach(
          (element) => returnStrings.add('tester${element.toRequest()}'));
    }
    if (testscript.isNotEmpty) {
      testscript.forEach(
          (element) => returnStrings.add('testscript${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class TestScriptSearchParams with _$TestScriptSearchParams {
  const TestScriptSearchParams._();
  const factory TestScriptSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [context] A use context assigned to the test script
    @Default([]) List<SearchParamToken> context,

    /// [contextQuantity] A quantity- or range-valued use context assigned to the test script
    @Default([])
    @JsonKey(name: 'context-quantity')
        List<SearchParamQuantity> contextQuantity,

    /// [contextType] A type of use context assigned to the test script
    @Default([])
    @JsonKey(name: 'context-type')
        List<SearchParamToken> contextType,

    /// [date] The test script publication date
    @Default([]) List<SearchParamDate> date,

    /// [description] The description of the test script
    @Default([]) List<SearchParamString> description,

    /// [identifier] External identifier for the test script
    @Default([]) List<SearchParamToken> identifier,

    /// [jurisdiction] Intended jurisdiction for the test script
    @Default([]) List<SearchParamToken> jurisdiction,

    /// [name] Computationally friendly name of the test script
    @Default([]) List<SearchParamString> name,

    /// [publisher] Name of the publisher of the test script
    @Default([]) List<SearchParamString> publisher,

    /// [status] The current status of the test script
    @Default([]) List<SearchParamToken> status,

    /// [testscriptCapability] TestScript required and validated capability
    @Default([])
    @JsonKey(name: 'testscript-capability')
        List<SearchParamString> testscriptCapability,

    /// [title] The human-friendly name of the test script
    @Default([]) List<SearchParamString> title,

    /// [url] The uri that identifies the test script
    @Default([]) List<SearchParamUri> url,

    /// [version] The business version of the test script
    @Default([]) List<SearchParamToken> version,

    /// [contextTypeQuantity] A use context type and quantity- or range-based value assigned to the test script
    @Default([])
    @JsonKey(name: 'context-type-quantity')
        List<SearchParamComposite> contextTypeQuantity,

    /// [contextTypeValue] A use context type and value assigned to the test script
    @Default([])
    @JsonKey(name: 'context-type-value')
        List<SearchParamComposite> contextTypeValue,
  }) = _TestScriptSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (context.isNotEmpty) {
      context.forEach(
          (element) => returnStrings.add('context${element.toRequest()}'));
    }
    if (contextQuantity.isNotEmpty) {
      contextQuantity.forEach((element) =>
          returnStrings.add('context-quantity${element.toRequest()}'));
    }
    if (contextType.isNotEmpty) {
      contextType.forEach(
          (element) => returnStrings.add('context-type${element.toRequest()}'));
    }
    if (date.isNotEmpty) {
      date.forEach(
          (element) => returnStrings.add('date${element.toRequest()}'));
    }
    if (description.isNotEmpty) {
      description.forEach(
          (element) => returnStrings.add('description${element.toRequest()}'));
    }
    if (identifier.isNotEmpty) {
      identifier.forEach(
          (element) => returnStrings.add('identifier${element.toRequest()}'));
    }
    if (jurisdiction.isNotEmpty) {
      jurisdiction.forEach(
          (element) => returnStrings.add('jurisdiction${element.toRequest()}'));
    }
    if (name.isNotEmpty) {
      name.forEach(
          (element) => returnStrings.add('name${element.toRequest()}'));
    }
    if (publisher.isNotEmpty) {
      publisher.forEach(
          (element) => returnStrings.add('publisher${element.toRequest()}'));
    }
    if (status.isNotEmpty) {
      status.forEach(
          (element) => returnStrings.add('status${element.toRequest()}'));
    }
    if (testscriptCapability.isNotEmpty) {
      testscriptCapability.forEach((element) =>
          returnStrings.add('testscript-capability${element.toRequest()}'));
    }
    if (title.isNotEmpty) {
      title.forEach(
          (element) => returnStrings.add('title${element.toRequest()}'));
    }
    if (url.isNotEmpty) {
      url.forEach((element) => returnStrings.add('url${element.toRequest()}'));
    }
    if (version.isNotEmpty) {
      version.forEach(
          (element) => returnStrings.add('version${element.toRequest()}'));
    }
    if (contextTypeQuantity.isNotEmpty) {
      contextTypeQuantity.forEach((element) =>
          returnStrings.add('context-type-quantity${element.toRequest()}'));
    }
    if (contextTypeValue.isNotEmpty) {
      contextTypeValue.forEach((element) =>
          returnStrings.add('context-type-value${element.toRequest()}'));
    }
    return returnStrings;
  }
}

@freezed
class VerificationResultSearchParams with _$VerificationResultSearchParams {
  const VerificationResultSearchParams._();
  const factory VerificationResultSearchParams({
    /// [resourceContent] Search on the entire content of the resource
    @Default([])
    @JsonKey(name: '_content')
        List<SearchParamString> resourceContent,

    /// [resourceFilter] Filter search parameter which supports a more sophisticated grammar for searching. See [documentation](search_filter.html) for further details
    @Default([])
    @JsonKey(name: '_filter')
        List<SearchParamToken> resourceFilter,

    /// [resourceHas] Provides limited support for reverse chaining - that is, selecting resources based on the properties of resources that refer to them (instead of chaining where resources can be selected based on the properties of resources that they refer to). See the FHIR search page for further documentation
    @Default([]) @JsonKey(name: '_has') List<SearchParamString> resourceHas,

    /// [resourceId] Logical id of this artifact
    @Default([]) @JsonKey(name: '_id') List<SearchParamToken> resourceId,

    /// [resourceLastUpdated] When the resource version last changed
    @Default([])
    @JsonKey(name: '_lastUpdated')
        List<SearchParamDate> resourceLastUpdated,

    /// [resourceList] All resources in nominated list (by id, Type/id, url or one of the magic List types)
    @Default([]) @JsonKey(name: '_list') List<SearchParamString> resourceList,

    /// [resourceProfile] Profiles this resource claims to conform to
    @Default([])
    @JsonKey(name: '_profile')
        List<SearchParamUri> resourceProfile,

    /// [resourceQuery] A custom search profile that describes a specific defined query operation
    @Default([]) @JsonKey(name: '_query') List<SearchParamToken> resourceQuery,

    /// [resourceSecurity] Security Labels applied to this resource
    @Default([])
    @JsonKey(name: '_security')
        List<SearchParamToken> resourceSecurity,

    /// [resourceSource] Identifies where the resource comes from
    @Default([]) @JsonKey(name: '_source') List<SearchParamUri> resourceSource,

    /// [resourceTag] Tags applied to this resource
    @Default([]) @JsonKey(name: '_tag') List<SearchParamToken> resourceTag,

    /// [resourceText] Search on the narrative text (html) of the resource
    @Default([]) @JsonKey(name: '_text') List<SearchParamString> resourceText,

    /// [resourceType] Used when a search is performed in a context which doesn't limit the search to indicate which types are being searched. See the FHIR search page for further discussion
    @Default([]) @JsonKey(name: '_type') List<SearchParamToken> resourceType,

    /// [target] A resource that was validated
    @Default([]) List<SearchParamReference> target,
  }) = _VerificationResultSearchParams;

  /// Factory constructor, accepts [Map<String, dynamic>] as an argument
  List<String> toRequest() {
    final returnStrings = <String>[];
    if (resourceContent.isNotEmpty) {
      resourceContent.forEach(
          (element) => returnStrings.add('_content${element.toRequest()}'));
    }
    if (resourceFilter.isNotEmpty) {
      resourceFilter.forEach(
          (element) => returnStrings.add('_filter${element.toRequest()}'));
    }
    if (resourceHas.isNotEmpty) {
      resourceHas.forEach(
          (element) => returnStrings.add('_has${element.toRequest()}'));
    }
    if (resourceId.isNotEmpty) {
      resourceId
          .forEach((element) => returnStrings.add('_id${element.toRequest()}'));
    }
    if (resourceLastUpdated.isNotEmpty) {
      resourceLastUpdated.forEach(
          (element) => returnStrings.add('_lastUpdated${element.toRequest()}'));
    }
    if (resourceList.isNotEmpty) {
      resourceList.forEach(
          (element) => returnStrings.add('_list${element.toRequest()}'));
    }
    if (resourceProfile.isNotEmpty) {
      resourceProfile.forEach(
          (element) => returnStrings.add('_profile${element.toRequest()}'));
    }
    if (resourceQuery.isNotEmpty) {
      resourceQuery.forEach(
          (element) => returnStrings.add('_query${element.toRequest()}'));
    }
    if (resourceSecurity.isNotEmpty) {
      resourceSecurity.forEach(
          (element) => returnStrings.add('_security${element.toRequest()}'));
    }
    if (resourceSource.isNotEmpty) {
      resourceSource.forEach(
          (element) => returnStrings.add('_source${element.toRequest()}'));
    }
    if (resourceTag.isNotEmpty) {
      resourceTag.forEach(
          (element) => returnStrings.add('_tag${element.toRequest()}'));
    }
    if (resourceText.isNotEmpty) {
      resourceText.forEach(
          (element) => returnStrings.add('_text${element.toRequest()}'));
    }
    if (resourceType.isNotEmpty) {
      resourceType.forEach(
          (element) => returnStrings.add('_type${element.toRequest()}'));
    }
    if (target.isNotEmpty) {
      target.forEach(
          (element) => returnStrings.add('target${element.toRequest()}'));
    }
    return returnStrings;
  }
}
