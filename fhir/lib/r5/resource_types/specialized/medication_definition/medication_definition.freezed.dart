// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'medication_definition.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

AdministrableProductDefinition _$AdministrableProductDefinitionFromJson(
    Map<String, dynamic> json) {
  return _AdministrableProductDefinition.fromJson(json);
}

/// @nodoc
mixin _$AdministrableProductDefinition {
  /// [resourceType] This is a AdministrableProductDefinition resource
  @JsonKey(unknownEnumValue: R5ResourceType.AdministrableProductDefinition)
  R5ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] An identifier for the administrable product.
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [status] The status of this administrable product. Enables tracking the life-cycle of the content.
  Code? get status => throw _privateConstructorUsedError;

  /// [statusElement] ("_status") Extensions for status
  @JsonKey(name: '_status')
  Element? get statusElement => throw _privateConstructorUsedError;

  /// [formOf] References a product from which one or more of the constituent parts of that product can be prepared and used as described by this administrable product.  If this administrable product describes the administration of a crushed tablet, the 'formOf' would be the product representing a distribution containing tablets and possibly also a cream.  This is distinct from the 'producedFrom' which refers to the specific components of the product that are used in this preparation, rather than the product as a whole.
  List<Reference>? get formOf => throw _privateConstructorUsedError;

  /// [administrableDoseForm] The dose form of the final product after necessary reconstitution or processing. Contrasts to the manufactured dose form (see ManufacturedItemDefinition). If the manufactured form was 'powder for solution for injection', the administrable dose form could be 'solution for injection' (once mixed with another item having manufactured form 'solvent for solution for injection').
  CodeableConcept? get administrableDoseForm =>
      throw _privateConstructorUsedError;

  /// [unitOfPresentation] The presentation type in which this item is given to a patient. e.g. for a spray - 'puff' (as in 'contains 100 mcg per puff'), or for a liquid - 'vial' (as in 'contains 5 ml per vial').
  CodeableConcept? get unitOfPresentation => throw _privateConstructorUsedError;

  /// [producedFrom] Indicates the specific manufactured items that are part of the 'formOf' product that are used in the preparation of this specific administrable form.  In some cases, an administrable form might use all of the items from the overall product (or there might only be one item), while in other cases, an administrable form might use only a subset of the items available in the overall product.  For example, an administrable form might involve combining a liquid and a powder available as part of an overall product, but not involve applying the also supplied cream.
  List<Reference>? get producedFrom => throw _privateConstructorUsedError;

  /// [ingredient] The ingredients of this administrable medicinal product. This is only needed if the ingredients are not specified either using ManufacturedItemDefiniton (via AdministrableProductDefinition.producedFrom) to state which component items are used to make this, or using by incoming references from the Ingredient resource, to state in detail which substances exist within this. This element allows a basic coded ingredient to be used.
  List<CodeableConcept>? get ingredient => throw _privateConstructorUsedError;

  /// [device] A device that is integral to the medicinal product, in effect being considered as an "ingredient" of the medicinal product. This is not intended for devices that are just co-packaged.
  Reference? get device => throw _privateConstructorUsedError;

  /// [property] Characteristics e.g. a product's onset of action.
  List<AdministrableProductDefinitionProperty>? get property =>
      throw _privateConstructorUsedError;

  /// [routeOfAdministration] The path by which the product is taken into or makes contact with the body. In some regions this is referred to as the licenced or approved route. RouteOfAdministration cannot be used when the 'formOf' product already uses MedicinalProductDefinition.route (and vice versa).
  List<AdministrableProductDefinitionRouteOfAdministration>
      get routeOfAdministration => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AdministrableProductDefinitionCopyWith<AdministrableProductDefinition>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AdministrableProductDefinitionCopyWith<$Res> {
  factory $AdministrableProductDefinitionCopyWith(
          AdministrableProductDefinition value,
          $Res Function(AdministrableProductDefinition) then) =
      _$AdministrableProductDefinitionCopyWithImpl<$Res,
          AdministrableProductDefinition>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.AdministrableProductDefinition)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      Code? status,
      @JsonKey(name: '_status')
          Element? statusElement,
      List<Reference>? formOf,
      CodeableConcept? administrableDoseForm,
      CodeableConcept? unitOfPresentation,
      List<Reference>? producedFrom,
      List<CodeableConcept>? ingredient,
      Reference? device,
      List<AdministrableProductDefinitionProperty>? property,
      List<AdministrableProductDefinitionRouteOfAdministration>
          routeOfAdministration});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $ElementCopyWith<$Res>? get statusElement;
  $CodeableConceptCopyWith<$Res>? get administrableDoseForm;
  $CodeableConceptCopyWith<$Res>? get unitOfPresentation;
  $ReferenceCopyWith<$Res>? get device;
}

/// @nodoc
class _$AdministrableProductDefinitionCopyWithImpl<$Res,
        $Val extends AdministrableProductDefinition>
    implements $AdministrableProductDefinitionCopyWith<$Res> {
  _$AdministrableProductDefinitionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? formOf = freezed,
    Object? administrableDoseForm = freezed,
    Object? unitOfPresentation = freezed,
    Object? producedFrom = freezed,
    Object? ingredient = freezed,
    Object? device = freezed,
    Object? property = freezed,
    Object? routeOfAdministration = null,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as Code?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      formOf: freezed == formOf
          ? _value.formOf
          : formOf // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      administrableDoseForm: freezed == administrableDoseForm
          ? _value.administrableDoseForm
          : administrableDoseForm // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      unitOfPresentation: freezed == unitOfPresentation
          ? _value.unitOfPresentation
          : unitOfPresentation // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      producedFrom: freezed == producedFrom
          ? _value.producedFrom
          : producedFrom // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      ingredient: freezed == ingredient
          ? _value.ingredient
          : ingredient // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      device: freezed == device
          ? _value.device
          : device // ignore: cast_nullable_to_non_nullable
              as Reference?,
      property: freezed == property
          ? _value.property
          : property // ignore: cast_nullable_to_non_nullable
              as List<AdministrableProductDefinitionProperty>?,
      routeOfAdministration: null == routeOfAdministration
          ? _value.routeOfAdministration
          : routeOfAdministration // ignore: cast_nullable_to_non_nullable
              as List<AdministrableProductDefinitionRouteOfAdministration>,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusElement {
    if (_value.statusElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusElement!, (value) {
      return _then(_value.copyWith(statusElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get administrableDoseForm {
    if (_value.administrableDoseForm == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.administrableDoseForm!,
        (value) {
      return _then(_value.copyWith(administrableDoseForm: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get unitOfPresentation {
    if (_value.unitOfPresentation == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.unitOfPresentation!, (value) {
      return _then(_value.copyWith(unitOfPresentation: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get device {
    if (_value.device == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.device!, (value) {
      return _then(_value.copyWith(device: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AdministrableProductDefinitionCopyWith<$Res>
    implements $AdministrableProductDefinitionCopyWith<$Res> {
  factory _$$_AdministrableProductDefinitionCopyWith(
          _$_AdministrableProductDefinition value,
          $Res Function(_$_AdministrableProductDefinition) then) =
      __$$_AdministrableProductDefinitionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.AdministrableProductDefinition)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      Code? status,
      @JsonKey(name: '_status')
          Element? statusElement,
      List<Reference>? formOf,
      CodeableConcept? administrableDoseForm,
      CodeableConcept? unitOfPresentation,
      List<Reference>? producedFrom,
      List<CodeableConcept>? ingredient,
      Reference? device,
      List<AdministrableProductDefinitionProperty>? property,
      List<AdministrableProductDefinitionRouteOfAdministration>
          routeOfAdministration});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $ElementCopyWith<$Res>? get statusElement;
  @override
  $CodeableConceptCopyWith<$Res>? get administrableDoseForm;
  @override
  $CodeableConceptCopyWith<$Res>? get unitOfPresentation;
  @override
  $ReferenceCopyWith<$Res>? get device;
}

/// @nodoc
class __$$_AdministrableProductDefinitionCopyWithImpl<$Res>
    extends _$AdministrableProductDefinitionCopyWithImpl<$Res,
        _$_AdministrableProductDefinition>
    implements _$$_AdministrableProductDefinitionCopyWith<$Res> {
  __$$_AdministrableProductDefinitionCopyWithImpl(
      _$_AdministrableProductDefinition _value,
      $Res Function(_$_AdministrableProductDefinition) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? formOf = freezed,
    Object? administrableDoseForm = freezed,
    Object? unitOfPresentation = freezed,
    Object? producedFrom = freezed,
    Object? ingredient = freezed,
    Object? device = freezed,
    Object? property = freezed,
    Object? routeOfAdministration = null,
  }) {
    return _then(_$_AdministrableProductDefinition(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as Code?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      formOf: freezed == formOf
          ? _value._formOf
          : formOf // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      administrableDoseForm: freezed == administrableDoseForm
          ? _value.administrableDoseForm
          : administrableDoseForm // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      unitOfPresentation: freezed == unitOfPresentation
          ? _value.unitOfPresentation
          : unitOfPresentation // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      producedFrom: freezed == producedFrom
          ? _value._producedFrom
          : producedFrom // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      ingredient: freezed == ingredient
          ? _value._ingredient
          : ingredient // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      device: freezed == device
          ? _value.device
          : device // ignore: cast_nullable_to_non_nullable
              as Reference?,
      property: freezed == property
          ? _value._property
          : property // ignore: cast_nullable_to_non_nullable
              as List<AdministrableProductDefinitionProperty>?,
      routeOfAdministration: null == routeOfAdministration
          ? _value._routeOfAdministration
          : routeOfAdministration // ignore: cast_nullable_to_non_nullable
              as List<AdministrableProductDefinitionRouteOfAdministration>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AdministrableProductDefinition
    extends _AdministrableProductDefinition {
  _$_AdministrableProductDefinition(
      {@JsonKey(unknownEnumValue: R5ResourceType.AdministrableProductDefinition)
          this.resourceType = R5ResourceType.AdministrableProductDefinition,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules')
          this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language')
          this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      this.status,
      @JsonKey(name: '_status')
          this.statusElement,
      final List<Reference>? formOf,
      this.administrableDoseForm,
      this.unitOfPresentation,
      final List<Reference>? producedFrom,
      final List<CodeableConcept>? ingredient,
      this.device,
      final List<AdministrableProductDefinitionProperty>? property,
      required final List<AdministrableProductDefinitionRouteOfAdministration>
          routeOfAdministration})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _formOf = formOf,
        _producedFrom = producedFrom,
        _ingredient = ingredient,
        _property = property,
        _routeOfAdministration = routeOfAdministration,
        super._();

  factory _$_AdministrableProductDefinition.fromJson(
          Map<String, dynamic> json) =>
      _$$_AdministrableProductDefinitionFromJson(json);

  /// [resourceType] This is a AdministrableProductDefinition resource
  @override
  @JsonKey(unknownEnumValue: R5ResourceType.AdministrableProductDefinition)
  final R5ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.
  @override
  final Code? language;

  /// [languageElement] ("_language") Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] An identifier for the administrable product.
  final List<Identifier>? _identifier;

  /// [identifier] An identifier for the administrable product.
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [status] The status of this administrable product. Enables tracking the life-cycle of the content.
  @override
  final Code? status;

  /// [statusElement] ("_status") Extensions for status
  @override
  @JsonKey(name: '_status')
  final Element? statusElement;

  /// [formOf] References a product from which one or more of the constituent parts of that product can be prepared and used as described by this administrable product.  If this administrable product describes the administration of a crushed tablet, the 'formOf' would be the product representing a distribution containing tablets and possibly also a cream.  This is distinct from the 'producedFrom' which refers to the specific components of the product that are used in this preparation, rather than the product as a whole.
  final List<Reference>? _formOf;

  /// [formOf] References a product from which one or more of the constituent parts of that product can be prepared and used as described by this administrable product.  If this administrable product describes the administration of a crushed tablet, the 'formOf' would be the product representing a distribution containing tablets and possibly also a cream.  This is distinct from the 'producedFrom' which refers to the specific components of the product that are used in this preparation, rather than the product as a whole.
  @override
  List<Reference>? get formOf {
    final value = _formOf;
    if (value == null) return null;
    if (_formOf is EqualUnmodifiableListView) return _formOf;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [administrableDoseForm] The dose form of the final product after necessary reconstitution or processing. Contrasts to the manufactured dose form (see ManufacturedItemDefinition). If the manufactured form was 'powder for solution for injection', the administrable dose form could be 'solution for injection' (once mixed with another item having manufactured form 'solvent for solution for injection').
  @override
  final CodeableConcept? administrableDoseForm;

  /// [unitOfPresentation] The presentation type in which this item is given to a patient. e.g. for a spray - 'puff' (as in 'contains 100 mcg per puff'), or for a liquid - 'vial' (as in 'contains 5 ml per vial').
  @override
  final CodeableConcept? unitOfPresentation;

  /// [producedFrom] Indicates the specific manufactured items that are part of the 'formOf' product that are used in the preparation of this specific administrable form.  In some cases, an administrable form might use all of the items from the overall product (or there might only be one item), while in other cases, an administrable form might use only a subset of the items available in the overall product.  For example, an administrable form might involve combining a liquid and a powder available as part of an overall product, but not involve applying the also supplied cream.
  final List<Reference>? _producedFrom;

  /// [producedFrom] Indicates the specific manufactured items that are part of the 'formOf' product that are used in the preparation of this specific administrable form.  In some cases, an administrable form might use all of the items from the overall product (or there might only be one item), while in other cases, an administrable form might use only a subset of the items available in the overall product.  For example, an administrable form might involve combining a liquid and a powder available as part of an overall product, but not involve applying the also supplied cream.
  @override
  List<Reference>? get producedFrom {
    final value = _producedFrom;
    if (value == null) return null;
    if (_producedFrom is EqualUnmodifiableListView) return _producedFrom;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [ingredient] The ingredients of this administrable medicinal product. This is only needed if the ingredients are not specified either using ManufacturedItemDefiniton (via AdministrableProductDefinition.producedFrom) to state which component items are used to make this, or using by incoming references from the Ingredient resource, to state in detail which substances exist within this. This element allows a basic coded ingredient to be used.
  final List<CodeableConcept>? _ingredient;

  /// [ingredient] The ingredients of this administrable medicinal product. This is only needed if the ingredients are not specified either using ManufacturedItemDefiniton (via AdministrableProductDefinition.producedFrom) to state which component items are used to make this, or using by incoming references from the Ingredient resource, to state in detail which substances exist within this. This element allows a basic coded ingredient to be used.
  @override
  List<CodeableConcept>? get ingredient {
    final value = _ingredient;
    if (value == null) return null;
    if (_ingredient is EqualUnmodifiableListView) return _ingredient;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [device] A device that is integral to the medicinal product, in effect being considered as an "ingredient" of the medicinal product. This is not intended for devices that are just co-packaged.
  @override
  final Reference? device;

  /// [property] Characteristics e.g. a product's onset of action.
  final List<AdministrableProductDefinitionProperty>? _property;

  /// [property] Characteristics e.g. a product's onset of action.
  @override
  List<AdministrableProductDefinitionProperty>? get property {
    final value = _property;
    if (value == null) return null;
    if (_property is EqualUnmodifiableListView) return _property;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [routeOfAdministration] The path by which the product is taken into or makes contact with the body. In some regions this is referred to as the licenced or approved route. RouteOfAdministration cannot be used when the 'formOf' product already uses MedicinalProductDefinition.route (and vice versa).
  final List<AdministrableProductDefinitionRouteOfAdministration>
      _routeOfAdministration;

  /// [routeOfAdministration] The path by which the product is taken into or makes contact with the body. In some regions this is referred to as the licenced or approved route. RouteOfAdministration cannot be used when the 'formOf' product already uses MedicinalProductDefinition.route (and vice versa).
  @override
  List<AdministrableProductDefinitionRouteOfAdministration>
      get routeOfAdministration {
    if (_routeOfAdministration is EqualUnmodifiableListView)
      return _routeOfAdministration;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_routeOfAdministration);
  }

  @override
  String toString() {
    return 'AdministrableProductDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, status: $status, statusElement: $statusElement, formOf: $formOf, administrableDoseForm: $administrableDoseForm, unitOfPresentation: $unitOfPresentation, producedFrom: $producedFrom, ingredient: $ingredient, device: $device, property: $property, routeOfAdministration: $routeOfAdministration)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AdministrableProductDefinition &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusElement, statusElement) ||
                other.statusElement == statusElement) &&
            const DeepCollectionEquality().equals(other._formOf, _formOf) &&
            (identical(other.administrableDoseForm, administrableDoseForm) ||
                other.administrableDoseForm == administrableDoseForm) &&
            (identical(other.unitOfPresentation, unitOfPresentation) ||
                other.unitOfPresentation == unitOfPresentation) &&
            const DeepCollectionEquality()
                .equals(other._producedFrom, _producedFrom) &&
            const DeepCollectionEquality()
                .equals(other._ingredient, _ingredient) &&
            (identical(other.device, device) || other.device == device) &&
            const DeepCollectionEquality().equals(other._property, _property) &&
            const DeepCollectionEquality()
                .equals(other._routeOfAdministration, _routeOfAdministration));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_identifier),
        status,
        statusElement,
        const DeepCollectionEquality().hash(_formOf),
        administrableDoseForm,
        unitOfPresentation,
        const DeepCollectionEquality().hash(_producedFrom),
        const DeepCollectionEquality().hash(_ingredient),
        device,
        const DeepCollectionEquality().hash(_property),
        const DeepCollectionEquality().hash(_routeOfAdministration)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AdministrableProductDefinitionCopyWith<_$_AdministrableProductDefinition>
      get copyWith => __$$_AdministrableProductDefinitionCopyWithImpl<
          _$_AdministrableProductDefinition>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AdministrableProductDefinitionToJson(
      this,
    );
  }
}

abstract class _AdministrableProductDefinition
    extends AdministrableProductDefinition {
  factory _AdministrableProductDefinition(
      {@JsonKey(unknownEnumValue: R5ResourceType.AdministrableProductDefinition)
          final R5ResourceType resourceType,
      final FhirId? id,
      final Meta? meta,
      final FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          final Element? implicitRulesElement,
      final Code? language,
      @JsonKey(name: '_language')
          final Element? languageElement,
      final Narrative? text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      final Code? status,
      @JsonKey(name: '_status')
          final Element? statusElement,
      final List<Reference>? formOf,
      final CodeableConcept? administrableDoseForm,
      final CodeableConcept? unitOfPresentation,
      final List<Reference>? producedFrom,
      final List<CodeableConcept>? ingredient,
      final Reference? device,
      final List<AdministrableProductDefinitionProperty>? property,
      required final List<AdministrableProductDefinitionRouteOfAdministration>
          routeOfAdministration}) = _$_AdministrableProductDefinition;
  _AdministrableProductDefinition._() : super._();

  factory _AdministrableProductDefinition.fromJson(Map<String, dynamic> json) =
      _$_AdministrableProductDefinition.fromJson;

  @override

  /// [resourceType] This is a AdministrableProductDefinition resource
  @JsonKey(unknownEnumValue: R5ResourceType.AdministrableProductDefinition)
  R5ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.
  Code? get language;
  @override

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained;
  @override

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] An identifier for the administrable product.
  List<Identifier>? get identifier;
  @override

  /// [status] The status of this administrable product. Enables tracking the life-cycle of the content.
  Code? get status;
  @override

  /// [statusElement] ("_status") Extensions for status
  @JsonKey(name: '_status')
  Element? get statusElement;
  @override

  /// [formOf] References a product from which one or more of the constituent parts of that product can be prepared and used as described by this administrable product.  If this administrable product describes the administration of a crushed tablet, the 'formOf' would be the product representing a distribution containing tablets and possibly also a cream.  This is distinct from the 'producedFrom' which refers to the specific components of the product that are used in this preparation, rather than the product as a whole.
  List<Reference>? get formOf;
  @override

  /// [administrableDoseForm] The dose form of the final product after necessary reconstitution or processing. Contrasts to the manufactured dose form (see ManufacturedItemDefinition). If the manufactured form was 'powder for solution for injection', the administrable dose form could be 'solution for injection' (once mixed with another item having manufactured form 'solvent for solution for injection').
  CodeableConcept? get administrableDoseForm;
  @override

  /// [unitOfPresentation] The presentation type in which this item is given to a patient. e.g. for a spray - 'puff' (as in 'contains 100 mcg per puff'), or for a liquid - 'vial' (as in 'contains 5 ml per vial').
  CodeableConcept? get unitOfPresentation;
  @override

  /// [producedFrom] Indicates the specific manufactured items that are part of the 'formOf' product that are used in the preparation of this specific administrable form.  In some cases, an administrable form might use all of the items from the overall product (or there might only be one item), while in other cases, an administrable form might use only a subset of the items available in the overall product.  For example, an administrable form might involve combining a liquid and a powder available as part of an overall product, but not involve applying the also supplied cream.
  List<Reference>? get producedFrom;
  @override

  /// [ingredient] The ingredients of this administrable medicinal product. This is only needed if the ingredients are not specified either using ManufacturedItemDefiniton (via AdministrableProductDefinition.producedFrom) to state which component items are used to make this, or using by incoming references from the Ingredient resource, to state in detail which substances exist within this. This element allows a basic coded ingredient to be used.
  List<CodeableConcept>? get ingredient;
  @override

  /// [device] A device that is integral to the medicinal product, in effect being considered as an "ingredient" of the medicinal product. This is not intended for devices that are just co-packaged.
  Reference? get device;
  @override

  /// [property] Characteristics e.g. a product's onset of action.
  List<AdministrableProductDefinitionProperty>? get property;
  @override

  /// [routeOfAdministration] The path by which the product is taken into or makes contact with the body. In some regions this is referred to as the licenced or approved route. RouteOfAdministration cannot be used when the 'formOf' product already uses MedicinalProductDefinition.route (and vice versa).
  List<AdministrableProductDefinitionRouteOfAdministration>
      get routeOfAdministration;
  @override
  @JsonKey(ignore: true)
  _$$_AdministrableProductDefinitionCopyWith<_$_AdministrableProductDefinition>
      get copyWith => throw _privateConstructorUsedError;
}

AdministrableProductDefinitionProperty
    _$AdministrableProductDefinitionPropertyFromJson(
        Map<String, dynamic> json) {
  return _AdministrableProductDefinitionProperty.fromJson(json);
}

/// @nodoc
mixin _$AdministrableProductDefinitionProperty {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] A code expressing the type of characteristic.
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [valueCodeableConcept] A value for the characteristic.
  CodeableConcept? get valueCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [valueQuantity] A value for the characteristic.
  Quantity? get valueQuantity => throw _privateConstructorUsedError;

  /// [valueDate] A value for the characteristic.
  Date? get valueDate => throw _privateConstructorUsedError;

  /// [valueDateElement] ("_valueDate") Extensions for valueDate
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement => throw _privateConstructorUsedError;

  /// [valueBoolean] A value for the characteristic.
  Boolean? get valueBoolean => throw _privateConstructorUsedError;

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement => throw _privateConstructorUsedError;

  /// [valueAttachment] A value for the characteristic.
  Attachment? get valueAttachment => throw _privateConstructorUsedError;

  /// [status] The status of characteristic e.g. assigned or pending.
  CodeableConcept? get status => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AdministrableProductDefinitionPropertyCopyWith<
          AdministrableProductDefinitionProperty>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AdministrableProductDefinitionPropertyCopyWith<$Res> {
  factory $AdministrableProductDefinitionPropertyCopyWith(
          AdministrableProductDefinitionProperty value,
          $Res Function(AdministrableProductDefinitionProperty) then) =
      _$AdministrableProductDefinitionPropertyCopyWithImpl<$Res,
          AdministrableProductDefinitionProperty>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      Quantity? valueQuantity,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment,
      CodeableConcept? status});

  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  $QuantityCopyWith<$Res>? get valueQuantity;
  $ElementCopyWith<$Res>? get valueDateElement;
  $ElementCopyWith<$Res>? get valueBooleanElement;
  $AttachmentCopyWith<$Res>? get valueAttachment;
  $CodeableConceptCopyWith<$Res>? get status;
}

/// @nodoc
class _$AdministrableProductDefinitionPropertyCopyWithImpl<$Res,
        $Val extends AdministrableProductDefinitionProperty>
    implements $AdministrableProductDefinitionPropertyCopyWith<$Res> {
  _$AdministrableProductDefinitionPropertyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueQuantity = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
    Object? status = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept {
    if (_value.valueCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.valueCodeableConcept!,
        (value) {
      return _then(_value.copyWith(valueCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get valueQuantity {
    if (_value.valueQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.valueQuantity!, (value) {
      return _then(_value.copyWith(valueQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueDateElement {
    if (_value.valueDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueDateElement!, (value) {
      return _then(_value.copyWith(valueDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueBooleanElement {
    if (_value.valueBooleanElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueBooleanElement!, (value) {
      return _then(_value.copyWith(valueBooleanElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get valueAttachment {
    if (_value.valueAttachment == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.valueAttachment!, (value) {
      return _then(_value.copyWith(valueAttachment: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AdministrableProductDefinitionPropertyCopyWith<$Res>
    implements $AdministrableProductDefinitionPropertyCopyWith<$Res> {
  factory _$$_AdministrableProductDefinitionPropertyCopyWith(
          _$_AdministrableProductDefinitionProperty value,
          $Res Function(_$_AdministrableProductDefinitionProperty) then) =
      __$$_AdministrableProductDefinitionPropertyCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      Quantity? valueQuantity,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment,
      CodeableConcept? status});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  @override
  $QuantityCopyWith<$Res>? get valueQuantity;
  @override
  $ElementCopyWith<$Res>? get valueDateElement;
  @override
  $ElementCopyWith<$Res>? get valueBooleanElement;
  @override
  $AttachmentCopyWith<$Res>? get valueAttachment;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
}

/// @nodoc
class __$$_AdministrableProductDefinitionPropertyCopyWithImpl<$Res>
    extends _$AdministrableProductDefinitionPropertyCopyWithImpl<$Res,
        _$_AdministrableProductDefinitionProperty>
    implements _$$_AdministrableProductDefinitionPropertyCopyWith<$Res> {
  __$$_AdministrableProductDefinitionPropertyCopyWithImpl(
      _$_AdministrableProductDefinitionProperty _value,
      $Res Function(_$_AdministrableProductDefinitionProperty) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueQuantity = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
    Object? status = freezed,
  }) {
    return _then(_$_AdministrableProductDefinitionProperty(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AdministrableProductDefinitionProperty
    extends _AdministrableProductDefinitionProperty {
  _$_AdministrableProductDefinitionProperty(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.type,
      this.valueCodeableConcept,
      this.valueQuantity,
      this.valueDate,
      @JsonKey(name: '_valueDate') this.valueDateElement,
      this.valueBoolean,
      @JsonKey(name: '_valueBoolean') this.valueBooleanElement,
      this.valueAttachment,
      this.status})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_AdministrableProductDefinitionProperty.fromJson(
          Map<String, dynamic> json) =>
      _$$_AdministrableProductDefinitionPropertyFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] A code expressing the type of characteristic.
  @override
  final CodeableConcept type;

  /// [valueCodeableConcept] A value for the characteristic.
  @override
  final CodeableConcept? valueCodeableConcept;

  /// [valueQuantity] A value for the characteristic.
  @override
  final Quantity? valueQuantity;

  /// [valueDate] A value for the characteristic.
  @override
  final Date? valueDate;

  /// [valueDateElement] ("_valueDate") Extensions for valueDate
  @override
  @JsonKey(name: '_valueDate')
  final Element? valueDateElement;

  /// [valueBoolean] A value for the characteristic.
  @override
  final Boolean? valueBoolean;

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @override
  @JsonKey(name: '_valueBoolean')
  final Element? valueBooleanElement;

  /// [valueAttachment] A value for the characteristic.
  @override
  final Attachment? valueAttachment;

  /// [status] The status of characteristic e.g. assigned or pending.
  @override
  final CodeableConcept? status;

  @override
  String toString() {
    return 'AdministrableProductDefinitionProperty(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, valueCodeableConcept: $valueCodeableConcept, valueQuantity: $valueQuantity, valueDate: $valueDate, valueDateElement: $valueDateElement, valueBoolean: $valueBoolean, valueBooleanElement: $valueBooleanElement, valueAttachment: $valueAttachment, status: $status)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AdministrableProductDefinitionProperty &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.valueCodeableConcept, valueCodeableConcept) ||
                other.valueCodeableConcept == valueCodeableConcept) &&
            (identical(other.valueQuantity, valueQuantity) ||
                other.valueQuantity == valueQuantity) &&
            (identical(other.valueDate, valueDate) ||
                other.valueDate == valueDate) &&
            (identical(other.valueDateElement, valueDateElement) ||
                other.valueDateElement == valueDateElement) &&
            (identical(other.valueBoolean, valueBoolean) ||
                other.valueBoolean == valueBoolean) &&
            (identical(other.valueBooleanElement, valueBooleanElement) ||
                other.valueBooleanElement == valueBooleanElement) &&
            (identical(other.valueAttachment, valueAttachment) ||
                other.valueAttachment == valueAttachment) &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      valueCodeableConcept,
      valueQuantity,
      valueDate,
      valueDateElement,
      valueBoolean,
      valueBooleanElement,
      valueAttachment,
      status);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AdministrableProductDefinitionPropertyCopyWith<
          _$_AdministrableProductDefinitionProperty>
      get copyWith => __$$_AdministrableProductDefinitionPropertyCopyWithImpl<
          _$_AdministrableProductDefinitionProperty>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AdministrableProductDefinitionPropertyToJson(
      this,
    );
  }
}

abstract class _AdministrableProductDefinitionProperty
    extends AdministrableProductDefinitionProperty {
  factory _AdministrableProductDefinitionProperty(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept type,
          final CodeableConcept? valueCodeableConcept,
          final Quantity? valueQuantity,
          final Date? valueDate,
          @JsonKey(name: '_valueDate') final Element? valueDateElement,
          final Boolean? valueBoolean,
          @JsonKey(name: '_valueBoolean') final Element? valueBooleanElement,
          final Attachment? valueAttachment,
          final CodeableConcept? status}) =
      _$_AdministrableProductDefinitionProperty;
  _AdministrableProductDefinitionProperty._() : super._();

  factory _AdministrableProductDefinitionProperty.fromJson(
          Map<String, dynamic> json) =
      _$_AdministrableProductDefinitionProperty.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] A code expressing the type of characteristic.
  CodeableConcept get type;
  @override

  /// [valueCodeableConcept] A value for the characteristic.
  CodeableConcept? get valueCodeableConcept;
  @override

  /// [valueQuantity] A value for the characteristic.
  Quantity? get valueQuantity;
  @override

  /// [valueDate] A value for the characteristic.
  Date? get valueDate;
  @override

  /// [valueDateElement] ("_valueDate") Extensions for valueDate
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement;
  @override

  /// [valueBoolean] A value for the characteristic.
  Boolean? get valueBoolean;
  @override

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement;
  @override

  /// [valueAttachment] A value for the characteristic.
  Attachment? get valueAttachment;
  @override

  /// [status] The status of characteristic e.g. assigned or pending.
  CodeableConcept? get status;
  @override
  @JsonKey(ignore: true)
  _$$_AdministrableProductDefinitionPropertyCopyWith<
          _$_AdministrableProductDefinitionProperty>
      get copyWith => throw _privateConstructorUsedError;
}

AdministrableProductDefinitionRouteOfAdministration
    _$AdministrableProductDefinitionRouteOfAdministrationFromJson(
        Map<String, dynamic> json) {
  return _AdministrableProductDefinitionRouteOfAdministration.fromJson(json);
}

/// @nodoc
mixin _$AdministrableProductDefinitionRouteOfAdministration {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [code] Coded expression for the route.
  CodeableConcept get code => throw _privateConstructorUsedError;

  /// [firstDose] The first dose (dose quantity) administered can be specified for the product, using a numerical value and its unit of measurement.
  Quantity? get firstDose => throw _privateConstructorUsedError;

  /// [maxSingleDose] The maximum single dose that can be administered, specified using a numerical value and its unit of measurement.
  Quantity? get maxSingleDose => throw _privateConstructorUsedError;

  /// [maxDosePerDay] The maximum dose per day (maximum dose quantity to be administered in any one 24-h period) that can be administered.
  Quantity? get maxDosePerDay => throw _privateConstructorUsedError;

  /// [maxDosePerTreatmentPeriod] The maximum dose per treatment period that can be administered.
  Ratio? get maxDosePerTreatmentPeriod => throw _privateConstructorUsedError;

  /// [maxTreatmentPeriod] The maximum treatment period during which the product can be administered.
  FhirDuration? get maxTreatmentPeriod => throw _privateConstructorUsedError;

  /// [targetSpecies] A species for which this route applies.
  List<AdministrableProductDefinitionTargetSpecies>? get targetSpecies =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AdministrableProductDefinitionRouteOfAdministrationCopyWith<
          AdministrableProductDefinitionRouteOfAdministration>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AdministrableProductDefinitionRouteOfAdministrationCopyWith<
    $Res> {
  factory $AdministrableProductDefinitionRouteOfAdministrationCopyWith(
          AdministrableProductDefinitionRouteOfAdministration value,
          $Res Function(AdministrableProductDefinitionRouteOfAdministration)
              then) =
      _$AdministrableProductDefinitionRouteOfAdministrationCopyWithImpl<$Res,
          AdministrableProductDefinitionRouteOfAdministration>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept code,
      Quantity? firstDose,
      Quantity? maxSingleDose,
      Quantity? maxDosePerDay,
      Ratio? maxDosePerTreatmentPeriod,
      FhirDuration? maxTreatmentPeriod,
      List<AdministrableProductDefinitionTargetSpecies>? targetSpecies});

  $CodeableConceptCopyWith<$Res> get code;
  $QuantityCopyWith<$Res>? get firstDose;
  $QuantityCopyWith<$Res>? get maxSingleDose;
  $QuantityCopyWith<$Res>? get maxDosePerDay;
  $RatioCopyWith<$Res>? get maxDosePerTreatmentPeriod;
  $FhirDurationCopyWith<$Res>? get maxTreatmentPeriod;
}

/// @nodoc
class _$AdministrableProductDefinitionRouteOfAdministrationCopyWithImpl<$Res,
        $Val extends AdministrableProductDefinitionRouteOfAdministration>
    implements
        $AdministrableProductDefinitionRouteOfAdministrationCopyWith<$Res> {
  _$AdministrableProductDefinitionRouteOfAdministrationCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = null,
    Object? firstDose = freezed,
    Object? maxSingleDose = freezed,
    Object? maxDosePerDay = freezed,
    Object? maxDosePerTreatmentPeriod = freezed,
    Object? maxTreatmentPeriod = freezed,
    Object? targetSpecies = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      firstDose: freezed == firstDose
          ? _value.firstDose
          : firstDose // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      maxSingleDose: freezed == maxSingleDose
          ? _value.maxSingleDose
          : maxSingleDose // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      maxDosePerDay: freezed == maxDosePerDay
          ? _value.maxDosePerDay
          : maxDosePerDay // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      maxDosePerTreatmentPeriod: freezed == maxDosePerTreatmentPeriod
          ? _value.maxDosePerTreatmentPeriod
          : maxDosePerTreatmentPeriod // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      maxTreatmentPeriod: freezed == maxTreatmentPeriod
          ? _value.maxTreatmentPeriod
          : maxTreatmentPeriod // ignore: cast_nullable_to_non_nullable
              as FhirDuration?,
      targetSpecies: freezed == targetSpecies
          ? _value.targetSpecies
          : targetSpecies // ignore: cast_nullable_to_non_nullable
              as List<AdministrableProductDefinitionTargetSpecies>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get code {
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get firstDose {
    if (_value.firstDose == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.firstDose!, (value) {
      return _then(_value.copyWith(firstDose: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get maxSingleDose {
    if (_value.maxSingleDose == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.maxSingleDose!, (value) {
      return _then(_value.copyWith(maxSingleDose: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get maxDosePerDay {
    if (_value.maxDosePerDay == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.maxDosePerDay!, (value) {
      return _then(_value.copyWith(maxDosePerDay: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RatioCopyWith<$Res>? get maxDosePerTreatmentPeriod {
    if (_value.maxDosePerTreatmentPeriod == null) {
      return null;
    }

    return $RatioCopyWith<$Res>(_value.maxDosePerTreatmentPeriod!, (value) {
      return _then(_value.copyWith(maxDosePerTreatmentPeriod: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FhirDurationCopyWith<$Res>? get maxTreatmentPeriod {
    if (_value.maxTreatmentPeriod == null) {
      return null;
    }

    return $FhirDurationCopyWith<$Res>(_value.maxTreatmentPeriod!, (value) {
      return _then(_value.copyWith(maxTreatmentPeriod: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AdministrableProductDefinitionRouteOfAdministrationCopyWith<
        $Res>
    implements
        $AdministrableProductDefinitionRouteOfAdministrationCopyWith<$Res> {
  factory _$$_AdministrableProductDefinitionRouteOfAdministrationCopyWith(
          _$_AdministrableProductDefinitionRouteOfAdministration value,
          $Res Function(_$_AdministrableProductDefinitionRouteOfAdministration)
              then) =
      __$$_AdministrableProductDefinitionRouteOfAdministrationCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept code,
      Quantity? firstDose,
      Quantity? maxSingleDose,
      Quantity? maxDosePerDay,
      Ratio? maxDosePerTreatmentPeriod,
      FhirDuration? maxTreatmentPeriod,
      List<AdministrableProductDefinitionTargetSpecies>? targetSpecies});

  @override
  $CodeableConceptCopyWith<$Res> get code;
  @override
  $QuantityCopyWith<$Res>? get firstDose;
  @override
  $QuantityCopyWith<$Res>? get maxSingleDose;
  @override
  $QuantityCopyWith<$Res>? get maxDosePerDay;
  @override
  $RatioCopyWith<$Res>? get maxDosePerTreatmentPeriod;
  @override
  $FhirDurationCopyWith<$Res>? get maxTreatmentPeriod;
}

/// @nodoc
class __$$_AdministrableProductDefinitionRouteOfAdministrationCopyWithImpl<$Res>
    extends _$AdministrableProductDefinitionRouteOfAdministrationCopyWithImpl<
        $Res, _$_AdministrableProductDefinitionRouteOfAdministration>
    implements
        _$$_AdministrableProductDefinitionRouteOfAdministrationCopyWith<$Res> {
  __$$_AdministrableProductDefinitionRouteOfAdministrationCopyWithImpl(
      _$_AdministrableProductDefinitionRouteOfAdministration _value,
      $Res Function(_$_AdministrableProductDefinitionRouteOfAdministration)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = null,
    Object? firstDose = freezed,
    Object? maxSingleDose = freezed,
    Object? maxDosePerDay = freezed,
    Object? maxDosePerTreatmentPeriod = freezed,
    Object? maxTreatmentPeriod = freezed,
    Object? targetSpecies = freezed,
  }) {
    return _then(_$_AdministrableProductDefinitionRouteOfAdministration(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      firstDose: freezed == firstDose
          ? _value.firstDose
          : firstDose // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      maxSingleDose: freezed == maxSingleDose
          ? _value.maxSingleDose
          : maxSingleDose // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      maxDosePerDay: freezed == maxDosePerDay
          ? _value.maxDosePerDay
          : maxDosePerDay // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      maxDosePerTreatmentPeriod: freezed == maxDosePerTreatmentPeriod
          ? _value.maxDosePerTreatmentPeriod
          : maxDosePerTreatmentPeriod // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      maxTreatmentPeriod: freezed == maxTreatmentPeriod
          ? _value.maxTreatmentPeriod
          : maxTreatmentPeriod // ignore: cast_nullable_to_non_nullable
              as FhirDuration?,
      targetSpecies: freezed == targetSpecies
          ? _value._targetSpecies
          : targetSpecies // ignore: cast_nullable_to_non_nullable
              as List<AdministrableProductDefinitionTargetSpecies>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AdministrableProductDefinitionRouteOfAdministration
    extends _AdministrableProductDefinitionRouteOfAdministration {
  _$_AdministrableProductDefinitionRouteOfAdministration(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.code,
      this.firstDose,
      this.maxSingleDose,
      this.maxDosePerDay,
      this.maxDosePerTreatmentPeriod,
      this.maxTreatmentPeriod,
      final List<AdministrableProductDefinitionTargetSpecies>? targetSpecies})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _targetSpecies = targetSpecies,
        super._();

  factory _$_AdministrableProductDefinitionRouteOfAdministration.fromJson(
          Map<String, dynamic> json) =>
      _$$_AdministrableProductDefinitionRouteOfAdministrationFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [code] Coded expression for the route.
  @override
  final CodeableConcept code;

  /// [firstDose] The first dose (dose quantity) administered can be specified for the product, using a numerical value and its unit of measurement.
  @override
  final Quantity? firstDose;

  /// [maxSingleDose] The maximum single dose that can be administered, specified using a numerical value and its unit of measurement.
  @override
  final Quantity? maxSingleDose;

  /// [maxDosePerDay] The maximum dose per day (maximum dose quantity to be administered in any one 24-h period) that can be administered.
  @override
  final Quantity? maxDosePerDay;

  /// [maxDosePerTreatmentPeriod] The maximum dose per treatment period that can be administered.
  @override
  final Ratio? maxDosePerTreatmentPeriod;

  /// [maxTreatmentPeriod] The maximum treatment period during which the product can be administered.
  @override
  final FhirDuration? maxTreatmentPeriod;

  /// [targetSpecies] A species for which this route applies.
  final List<AdministrableProductDefinitionTargetSpecies>? _targetSpecies;

  /// [targetSpecies] A species for which this route applies.
  @override
  List<AdministrableProductDefinitionTargetSpecies>? get targetSpecies {
    final value = _targetSpecies;
    if (value == null) return null;
    if (_targetSpecies is EqualUnmodifiableListView) return _targetSpecies;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'AdministrableProductDefinitionRouteOfAdministration(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, firstDose: $firstDose, maxSingleDose: $maxSingleDose, maxDosePerDay: $maxDosePerDay, maxDosePerTreatmentPeriod: $maxDosePerTreatmentPeriod, maxTreatmentPeriod: $maxTreatmentPeriod, targetSpecies: $targetSpecies)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AdministrableProductDefinitionRouteOfAdministration &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.firstDose, firstDose) ||
                other.firstDose == firstDose) &&
            (identical(other.maxSingleDose, maxSingleDose) ||
                other.maxSingleDose == maxSingleDose) &&
            (identical(other.maxDosePerDay, maxDosePerDay) ||
                other.maxDosePerDay == maxDosePerDay) &&
            (identical(other.maxDosePerTreatmentPeriod,
                    maxDosePerTreatmentPeriod) ||
                other.maxDosePerTreatmentPeriod == maxDosePerTreatmentPeriod) &&
            (identical(other.maxTreatmentPeriod, maxTreatmentPeriod) ||
                other.maxTreatmentPeriod == maxTreatmentPeriod) &&
            const DeepCollectionEquality()
                .equals(other._targetSpecies, _targetSpecies));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      code,
      firstDose,
      maxSingleDose,
      maxDosePerDay,
      maxDosePerTreatmentPeriod,
      maxTreatmentPeriod,
      const DeepCollectionEquality().hash(_targetSpecies));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AdministrableProductDefinitionRouteOfAdministrationCopyWith<
          _$_AdministrableProductDefinitionRouteOfAdministration>
      get copyWith =>
          __$$_AdministrableProductDefinitionRouteOfAdministrationCopyWithImpl<
                  _$_AdministrableProductDefinitionRouteOfAdministration>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AdministrableProductDefinitionRouteOfAdministrationToJson(
      this,
    );
  }
}

abstract class _AdministrableProductDefinitionRouteOfAdministration
    extends AdministrableProductDefinitionRouteOfAdministration {
  factory _AdministrableProductDefinitionRouteOfAdministration(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept code,
          final Quantity? firstDose,
          final Quantity? maxSingleDose,
          final Quantity? maxDosePerDay,
          final Ratio? maxDosePerTreatmentPeriod,
          final FhirDuration? maxTreatmentPeriod,
          final List<AdministrableProductDefinitionTargetSpecies>?
              targetSpecies}) =
      _$_AdministrableProductDefinitionRouteOfAdministration;
  _AdministrableProductDefinitionRouteOfAdministration._() : super._();

  factory _AdministrableProductDefinitionRouteOfAdministration.fromJson(
          Map<String, dynamic> json) =
      _$_AdministrableProductDefinitionRouteOfAdministration.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [code] Coded expression for the route.
  CodeableConcept get code;
  @override

  /// [firstDose] The first dose (dose quantity) administered can be specified for the product, using a numerical value and its unit of measurement.
  Quantity? get firstDose;
  @override

  /// [maxSingleDose] The maximum single dose that can be administered, specified using a numerical value and its unit of measurement.
  Quantity? get maxSingleDose;
  @override

  /// [maxDosePerDay] The maximum dose per day (maximum dose quantity to be administered in any one 24-h period) that can be administered.
  Quantity? get maxDosePerDay;
  @override

  /// [maxDosePerTreatmentPeriod] The maximum dose per treatment period that can be administered.
  Ratio? get maxDosePerTreatmentPeriod;
  @override

  /// [maxTreatmentPeriod] The maximum treatment period during which the product can be administered.
  FhirDuration? get maxTreatmentPeriod;
  @override

  /// [targetSpecies] A species for which this route applies.
  List<AdministrableProductDefinitionTargetSpecies>? get targetSpecies;
  @override
  @JsonKey(ignore: true)
  _$$_AdministrableProductDefinitionRouteOfAdministrationCopyWith<
          _$_AdministrableProductDefinitionRouteOfAdministration>
      get copyWith => throw _privateConstructorUsedError;
}

AdministrableProductDefinitionTargetSpecies
    _$AdministrableProductDefinitionTargetSpeciesFromJson(
        Map<String, dynamic> json) {
  return _AdministrableProductDefinitionTargetSpecies.fromJson(json);
}

/// @nodoc
mixin _$AdministrableProductDefinitionTargetSpecies {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [code] Coded expression for the species.
  CodeableConcept get code => throw _privateConstructorUsedError;

  /// [withdrawalPeriod] A species specific time during which consumption of animal product is not appropriate.
  List<AdministrableProductDefinitionWithdrawalPeriod>? get withdrawalPeriod =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AdministrableProductDefinitionTargetSpeciesCopyWith<
          AdministrableProductDefinitionTargetSpecies>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AdministrableProductDefinitionTargetSpeciesCopyWith<$Res> {
  factory $AdministrableProductDefinitionTargetSpeciesCopyWith(
          AdministrableProductDefinitionTargetSpecies value,
          $Res Function(AdministrableProductDefinitionTargetSpecies) then) =
      _$AdministrableProductDefinitionTargetSpeciesCopyWithImpl<$Res,
          AdministrableProductDefinitionTargetSpecies>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept code,
      List<AdministrableProductDefinitionWithdrawalPeriod>? withdrawalPeriod});

  $CodeableConceptCopyWith<$Res> get code;
}

/// @nodoc
class _$AdministrableProductDefinitionTargetSpeciesCopyWithImpl<$Res,
        $Val extends AdministrableProductDefinitionTargetSpecies>
    implements $AdministrableProductDefinitionTargetSpeciesCopyWith<$Res> {
  _$AdministrableProductDefinitionTargetSpeciesCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = null,
    Object? withdrawalPeriod = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      withdrawalPeriod: freezed == withdrawalPeriod
          ? _value.withdrawalPeriod
          : withdrawalPeriod // ignore: cast_nullable_to_non_nullable
              as List<AdministrableProductDefinitionWithdrawalPeriod>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get code {
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AdministrableProductDefinitionTargetSpeciesCopyWith<$Res>
    implements $AdministrableProductDefinitionTargetSpeciesCopyWith<$Res> {
  factory _$$_AdministrableProductDefinitionTargetSpeciesCopyWith(
          _$_AdministrableProductDefinitionTargetSpecies value,
          $Res Function(_$_AdministrableProductDefinitionTargetSpecies) then) =
      __$$_AdministrableProductDefinitionTargetSpeciesCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept code,
      List<AdministrableProductDefinitionWithdrawalPeriod>? withdrawalPeriod});

  @override
  $CodeableConceptCopyWith<$Res> get code;
}

/// @nodoc
class __$$_AdministrableProductDefinitionTargetSpeciesCopyWithImpl<$Res>
    extends _$AdministrableProductDefinitionTargetSpeciesCopyWithImpl<$Res,
        _$_AdministrableProductDefinitionTargetSpecies>
    implements _$$_AdministrableProductDefinitionTargetSpeciesCopyWith<$Res> {
  __$$_AdministrableProductDefinitionTargetSpeciesCopyWithImpl(
      _$_AdministrableProductDefinitionTargetSpecies _value,
      $Res Function(_$_AdministrableProductDefinitionTargetSpecies) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = null,
    Object? withdrawalPeriod = freezed,
  }) {
    return _then(_$_AdministrableProductDefinitionTargetSpecies(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      withdrawalPeriod: freezed == withdrawalPeriod
          ? _value._withdrawalPeriod
          : withdrawalPeriod // ignore: cast_nullable_to_non_nullable
              as List<AdministrableProductDefinitionWithdrawalPeriod>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AdministrableProductDefinitionTargetSpecies
    extends _AdministrableProductDefinitionTargetSpecies {
  _$_AdministrableProductDefinitionTargetSpecies(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.code,
      final List<AdministrableProductDefinitionWithdrawalPeriod>?
          withdrawalPeriod})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _withdrawalPeriod = withdrawalPeriod,
        super._();

  factory _$_AdministrableProductDefinitionTargetSpecies.fromJson(
          Map<String, dynamic> json) =>
      _$$_AdministrableProductDefinitionTargetSpeciesFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [code] Coded expression for the species.
  @override
  final CodeableConcept code;

  /// [withdrawalPeriod] A species specific time during which consumption of animal product is not appropriate.
  final List<AdministrableProductDefinitionWithdrawalPeriod>? _withdrawalPeriod;

  /// [withdrawalPeriod] A species specific time during which consumption of animal product is not appropriate.
  @override
  List<AdministrableProductDefinitionWithdrawalPeriod>? get withdrawalPeriod {
    final value = _withdrawalPeriod;
    if (value == null) return null;
    if (_withdrawalPeriod is EqualUnmodifiableListView)
      return _withdrawalPeriod;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'AdministrableProductDefinitionTargetSpecies(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, withdrawalPeriod: $withdrawalPeriod)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AdministrableProductDefinitionTargetSpecies &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.code, code) || other.code == code) &&
            const DeepCollectionEquality()
                .equals(other._withdrawalPeriod, _withdrawalPeriod));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      code,
      const DeepCollectionEquality().hash(_withdrawalPeriod));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AdministrableProductDefinitionTargetSpeciesCopyWith<
          _$_AdministrableProductDefinitionTargetSpecies>
      get copyWith =>
          __$$_AdministrableProductDefinitionTargetSpeciesCopyWithImpl<
              _$_AdministrableProductDefinitionTargetSpecies>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AdministrableProductDefinitionTargetSpeciesToJson(
      this,
    );
  }
}

abstract class _AdministrableProductDefinitionTargetSpecies
    extends AdministrableProductDefinitionTargetSpecies {
  factory _AdministrableProductDefinitionTargetSpecies(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final CodeableConcept code,
      final List<AdministrableProductDefinitionWithdrawalPeriod>?
          withdrawalPeriod}) = _$_AdministrableProductDefinitionTargetSpecies;
  _AdministrableProductDefinitionTargetSpecies._() : super._();

  factory _AdministrableProductDefinitionTargetSpecies.fromJson(
          Map<String, dynamic> json) =
      _$_AdministrableProductDefinitionTargetSpecies.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [code] Coded expression for the species.
  CodeableConcept get code;
  @override

  /// [withdrawalPeriod] A species specific time during which consumption of animal product is not appropriate.
  List<AdministrableProductDefinitionWithdrawalPeriod>? get withdrawalPeriod;
  @override
  @JsonKey(ignore: true)
  _$$_AdministrableProductDefinitionTargetSpeciesCopyWith<
          _$_AdministrableProductDefinitionTargetSpecies>
      get copyWith => throw _privateConstructorUsedError;
}

AdministrableProductDefinitionWithdrawalPeriod
    _$AdministrableProductDefinitionWithdrawalPeriodFromJson(
        Map<String, dynamic> json) {
  return _AdministrableProductDefinitionWithdrawalPeriod.fromJson(json);
}

/// @nodoc
mixin _$AdministrableProductDefinitionWithdrawalPeriod {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [tissue] Coded expression for the type of tissue for which the withdrawal period applies, e.g. meat, milk.
  CodeableConcept get tissue => throw _privateConstructorUsedError;

  /// [value] A value for the time.
  Quantity get value => throw _privateConstructorUsedError;

  /// [supportingInformation] Extra information about the withdrawal period.
  String? get supportingInformation => throw _privateConstructorUsedError;

  /// [supportingInformationElement] ("_supportingInformation") Extensions for supportingInformation
  @JsonKey(name: '_supportingInformation')
  Element? get supportingInformationElement =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AdministrableProductDefinitionWithdrawalPeriodCopyWith<
          AdministrableProductDefinitionWithdrawalPeriod>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AdministrableProductDefinitionWithdrawalPeriodCopyWith<$Res> {
  factory $AdministrableProductDefinitionWithdrawalPeriodCopyWith(
          AdministrableProductDefinitionWithdrawalPeriod value,
          $Res Function(AdministrableProductDefinitionWithdrawalPeriod) then) =
      _$AdministrableProductDefinitionWithdrawalPeriodCopyWithImpl<$Res,
          AdministrableProductDefinitionWithdrawalPeriod>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept tissue,
      Quantity value,
      String? supportingInformation,
      @JsonKey(name: '_supportingInformation')
          Element? supportingInformationElement});

  $CodeableConceptCopyWith<$Res> get tissue;
  $QuantityCopyWith<$Res> get value;
  $ElementCopyWith<$Res>? get supportingInformationElement;
}

/// @nodoc
class _$AdministrableProductDefinitionWithdrawalPeriodCopyWithImpl<$Res,
        $Val extends AdministrableProductDefinitionWithdrawalPeriod>
    implements $AdministrableProductDefinitionWithdrawalPeriodCopyWith<$Res> {
  _$AdministrableProductDefinitionWithdrawalPeriodCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? tissue = null,
    Object? value = null,
    Object? supportingInformation = freezed,
    Object? supportingInformationElement = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      tissue: null == tissue
          ? _value.tissue
          : tissue // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Quantity,
      supportingInformation: freezed == supportingInformation
          ? _value.supportingInformation
          : supportingInformation // ignore: cast_nullable_to_non_nullable
              as String?,
      supportingInformationElement: freezed == supportingInformationElement
          ? _value.supportingInformationElement
          : supportingInformationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get tissue {
    return $CodeableConceptCopyWith<$Res>(_value.tissue, (value) {
      return _then(_value.copyWith(tissue: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res> get value {
    return $QuantityCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get supportingInformationElement {
    if (_value.supportingInformationElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.supportingInformationElement!,
        (value) {
      return _then(
          _value.copyWith(supportingInformationElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AdministrableProductDefinitionWithdrawalPeriodCopyWith<$Res>
    implements $AdministrableProductDefinitionWithdrawalPeriodCopyWith<$Res> {
  factory _$$_AdministrableProductDefinitionWithdrawalPeriodCopyWith(
          _$_AdministrableProductDefinitionWithdrawalPeriod value,
          $Res Function(_$_AdministrableProductDefinitionWithdrawalPeriod)
              then) =
      __$$_AdministrableProductDefinitionWithdrawalPeriodCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept tissue,
      Quantity value,
      String? supportingInformation,
      @JsonKey(name: '_supportingInformation')
          Element? supportingInformationElement});

  @override
  $CodeableConceptCopyWith<$Res> get tissue;
  @override
  $QuantityCopyWith<$Res> get value;
  @override
  $ElementCopyWith<$Res>? get supportingInformationElement;
}

/// @nodoc
class __$$_AdministrableProductDefinitionWithdrawalPeriodCopyWithImpl<$Res>
    extends _$AdministrableProductDefinitionWithdrawalPeriodCopyWithImpl<$Res,
        _$_AdministrableProductDefinitionWithdrawalPeriod>
    implements
        _$$_AdministrableProductDefinitionWithdrawalPeriodCopyWith<$Res> {
  __$$_AdministrableProductDefinitionWithdrawalPeriodCopyWithImpl(
      _$_AdministrableProductDefinitionWithdrawalPeriod _value,
      $Res Function(_$_AdministrableProductDefinitionWithdrawalPeriod) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? tissue = null,
    Object? value = null,
    Object? supportingInformation = freezed,
    Object? supportingInformationElement = freezed,
  }) {
    return _then(_$_AdministrableProductDefinitionWithdrawalPeriod(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      tissue: null == tissue
          ? _value.tissue
          : tissue // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Quantity,
      supportingInformation: freezed == supportingInformation
          ? _value.supportingInformation
          : supportingInformation // ignore: cast_nullable_to_non_nullable
              as String?,
      supportingInformationElement: freezed == supportingInformationElement
          ? _value.supportingInformationElement
          : supportingInformationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AdministrableProductDefinitionWithdrawalPeriod
    extends _AdministrableProductDefinitionWithdrawalPeriod {
  _$_AdministrableProductDefinitionWithdrawalPeriod(
      {this.id,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.tissue,
      required this.value,
      this.supportingInformation,
      @JsonKey(name: '_supportingInformation')
          this.supportingInformationElement})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_AdministrableProductDefinitionWithdrawalPeriod.fromJson(
          Map<String, dynamic> json) =>
      _$$_AdministrableProductDefinitionWithdrawalPeriodFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [tissue] Coded expression for the type of tissue for which the withdrawal period applies, e.g. meat, milk.
  @override
  final CodeableConcept tissue;

  /// [value] A value for the time.
  @override
  final Quantity value;

  /// [supportingInformation] Extra information about the withdrawal period.
  @override
  final String? supportingInformation;

  /// [supportingInformationElement] ("_supportingInformation") Extensions for supportingInformation
  @override
  @JsonKey(name: '_supportingInformation')
  final Element? supportingInformationElement;

  @override
  String toString() {
    return 'AdministrableProductDefinitionWithdrawalPeriod(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, tissue: $tissue, value: $value, supportingInformation: $supportingInformation, supportingInformationElement: $supportingInformationElement)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AdministrableProductDefinitionWithdrawalPeriod &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.tissue, tissue) || other.tissue == tissue) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.supportingInformation, supportingInformation) ||
                other.supportingInformation == supportingInformation) &&
            (identical(other.supportingInformationElement,
                    supportingInformationElement) ||
                other.supportingInformationElement ==
                    supportingInformationElement));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      tissue,
      value,
      supportingInformation,
      supportingInformationElement);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AdministrableProductDefinitionWithdrawalPeriodCopyWith<
          _$_AdministrableProductDefinitionWithdrawalPeriod>
      get copyWith =>
          __$$_AdministrableProductDefinitionWithdrawalPeriodCopyWithImpl<
                  _$_AdministrableProductDefinitionWithdrawalPeriod>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AdministrableProductDefinitionWithdrawalPeriodToJson(
      this,
    );
  }
}

abstract class _AdministrableProductDefinitionWithdrawalPeriod
    extends AdministrableProductDefinitionWithdrawalPeriod {
  factory _AdministrableProductDefinitionWithdrawalPeriod(
          {final String? id,
          @JsonKey(name: 'extension')
              final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept tissue,
          required final Quantity value,
          final String? supportingInformation,
          @JsonKey(name: '_supportingInformation')
              final Element? supportingInformationElement}) =
      _$_AdministrableProductDefinitionWithdrawalPeriod;
  _AdministrableProductDefinitionWithdrawalPeriod._() : super._();

  factory _AdministrableProductDefinitionWithdrawalPeriod.fromJson(
          Map<String, dynamic> json) =
      _$_AdministrableProductDefinitionWithdrawalPeriod.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [tissue] Coded expression for the type of tissue for which the withdrawal period applies, e.g. meat, milk.
  CodeableConcept get tissue;
  @override

  /// [value] A value for the time.
  Quantity get value;
  @override

  /// [supportingInformation] Extra information about the withdrawal period.
  String? get supportingInformation;
  @override

  /// [supportingInformationElement] ("_supportingInformation") Extensions for supportingInformation
  @JsonKey(name: '_supportingInformation')
  Element? get supportingInformationElement;
  @override
  @JsonKey(ignore: true)
  _$$_AdministrableProductDefinitionWithdrawalPeriodCopyWith<
          _$_AdministrableProductDefinitionWithdrawalPeriod>
      get copyWith => throw _privateConstructorUsedError;
}

ClinicalUseDefinition _$ClinicalUseDefinitionFromJson(
    Map<String, dynamic> json) {
  return _ClinicalUseDefinition.fromJson(json);
}

/// @nodoc
mixin _$ClinicalUseDefinition {
  /// [resourceType] This is a ClinicalUseDefinition resource
  @JsonKey(unknownEnumValue: R5ResourceType.ClinicalUseDefinition)
  R5ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] Business identifier for this issue.
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [type] indication | contraindication | interaction | undesirable-effect | warning.
  Code? get type => throw _privateConstructorUsedError;

  /// [typeElement] ("_type") Extensions for type
  @JsonKey(name: '_type')
  Element? get typeElement => throw _privateConstructorUsedError;

  /// [category] A categorisation of the issue, primarily for dividing warnings into subject heading areas such as "Pregnancy and Lactation", "Overdose", "Effects on Ability to Drive and Use Machines".
  List<CodeableConcept>? get category => throw _privateConstructorUsedError;

  /// [subject] The medication or procedure for which this is an indication.
  List<Reference>? get subject => throw _privateConstructorUsedError;

  /// [status] Whether this is a current issue or one that has been retired etc.
  CodeableConcept? get status => throw _privateConstructorUsedError;

  /// [contraindication] Specifics for when this is a contraindication.
  ClinicalUseDefinitionContraindication? get contraindication =>
      throw _privateConstructorUsedError;

  /// [indication] Specifics for when this is an indication.
  ClinicalUseDefinitionIndication? get indication =>
      throw _privateConstructorUsedError;

  /// [interaction] Specifics for when this is an interaction.
  ClinicalUseDefinitionInteraction? get interaction =>
      throw _privateConstructorUsedError;

  /// [population] The population group to which this applies.
  List<Reference>? get population => throw _privateConstructorUsedError;

  /// [library_] ("library") Logic used by the clinical use definition.
  @JsonKey(name: 'library')
  List<Canonical>? get library_ => throw _privateConstructorUsedError;

  /// [undesirableEffect] Describe the possible undesirable effects (negative outcomes) from the use of the medicinal product as treatment.
  ClinicalUseDefinitionUndesirableEffect? get undesirableEffect =>
      throw _privateConstructorUsedError;

  /// [warning] A critical piece of information about environmental, health or physical risks or hazards that serve as caution to the user. For example 'Do not operate heavy machinery', 'May cause drowsiness', or 'Get medical advice/attention if you feel unwell'.
  ClinicalUseDefinitionWarning? get warning =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ClinicalUseDefinitionCopyWith<ClinicalUseDefinition> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClinicalUseDefinitionCopyWith<$Res> {
  factory $ClinicalUseDefinitionCopyWith(ClinicalUseDefinition value,
          $Res Function(ClinicalUseDefinition) then) =
      _$ClinicalUseDefinitionCopyWithImpl<$Res, ClinicalUseDefinition>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.ClinicalUseDefinition)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      Code? type,
      @JsonKey(name: '_type')
          Element? typeElement,
      List<CodeableConcept>? category,
      List<Reference>? subject,
      CodeableConcept? status,
      ClinicalUseDefinitionContraindication? contraindication,
      ClinicalUseDefinitionIndication? indication,
      ClinicalUseDefinitionInteraction? interaction,
      List<Reference>? population,
      @JsonKey(name: 'library')
          List<Canonical>? library_,
      ClinicalUseDefinitionUndesirableEffect? undesirableEffect,
      ClinicalUseDefinitionWarning? warning});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $ElementCopyWith<$Res>? get typeElement;
  $CodeableConceptCopyWith<$Res>? get status;
  $ClinicalUseDefinitionContraindicationCopyWith<$Res>? get contraindication;
  $ClinicalUseDefinitionIndicationCopyWith<$Res>? get indication;
  $ClinicalUseDefinitionInteractionCopyWith<$Res>? get interaction;
  $ClinicalUseDefinitionUndesirableEffectCopyWith<$Res>? get undesirableEffect;
  $ClinicalUseDefinitionWarningCopyWith<$Res>? get warning;
}

/// @nodoc
class _$ClinicalUseDefinitionCopyWithImpl<$Res,
        $Val extends ClinicalUseDefinition>
    implements $ClinicalUseDefinitionCopyWith<$Res> {
  _$ClinicalUseDefinitionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = freezed,
    Object? typeElement = freezed,
    Object? category = freezed,
    Object? subject = freezed,
    Object? status = freezed,
    Object? contraindication = freezed,
    Object? indication = freezed,
    Object? interaction = freezed,
    Object? population = freezed,
    Object? library_ = freezed,
    Object? undesirableEffect = freezed,
    Object? warning = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as Code?,
      typeElement: freezed == typeElement
          ? _value.typeElement
          : typeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      subject: freezed == subject
          ? _value.subject
          : subject // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      contraindication: freezed == contraindication
          ? _value.contraindication
          : contraindication // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionContraindication?,
      indication: freezed == indication
          ? _value.indication
          : indication // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionIndication?,
      interaction: freezed == interaction
          ? _value.interaction
          : interaction // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionInteraction?,
      population: freezed == population
          ? _value.population
          : population // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      library_: freezed == library_
          ? _value.library_
          : library_ // ignore: cast_nullable_to_non_nullable
              as List<Canonical>?,
      undesirableEffect: freezed == undesirableEffect
          ? _value.undesirableEffect
          : undesirableEffect // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionUndesirableEffect?,
      warning: freezed == warning
          ? _value.warning
          : warning // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionWarning?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get typeElement {
    if (_value.typeElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.typeElement!, (value) {
      return _then(_value.copyWith(typeElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ClinicalUseDefinitionContraindicationCopyWith<$Res>? get contraindication {
    if (_value.contraindication == null) {
      return null;
    }

    return $ClinicalUseDefinitionContraindicationCopyWith<$Res>(
        _value.contraindication!, (value) {
      return _then(_value.copyWith(contraindication: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ClinicalUseDefinitionIndicationCopyWith<$Res>? get indication {
    if (_value.indication == null) {
      return null;
    }

    return $ClinicalUseDefinitionIndicationCopyWith<$Res>(_value.indication!,
        (value) {
      return _then(_value.copyWith(indication: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ClinicalUseDefinitionInteractionCopyWith<$Res>? get interaction {
    if (_value.interaction == null) {
      return null;
    }

    return $ClinicalUseDefinitionInteractionCopyWith<$Res>(_value.interaction!,
        (value) {
      return _then(_value.copyWith(interaction: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ClinicalUseDefinitionUndesirableEffectCopyWith<$Res>? get undesirableEffect {
    if (_value.undesirableEffect == null) {
      return null;
    }

    return $ClinicalUseDefinitionUndesirableEffectCopyWith<$Res>(
        _value.undesirableEffect!, (value) {
      return _then(_value.copyWith(undesirableEffect: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ClinicalUseDefinitionWarningCopyWith<$Res>? get warning {
    if (_value.warning == null) {
      return null;
    }

    return $ClinicalUseDefinitionWarningCopyWith<$Res>(_value.warning!,
        (value) {
      return _then(_value.copyWith(warning: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ClinicalUseDefinitionCopyWith<$Res>
    implements $ClinicalUseDefinitionCopyWith<$Res> {
  factory _$$_ClinicalUseDefinitionCopyWith(_$_ClinicalUseDefinition value,
          $Res Function(_$_ClinicalUseDefinition) then) =
      __$$_ClinicalUseDefinitionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.ClinicalUseDefinition)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      Code? type,
      @JsonKey(name: '_type')
          Element? typeElement,
      List<CodeableConcept>? category,
      List<Reference>? subject,
      CodeableConcept? status,
      ClinicalUseDefinitionContraindication? contraindication,
      ClinicalUseDefinitionIndication? indication,
      ClinicalUseDefinitionInteraction? interaction,
      List<Reference>? population,
      @JsonKey(name: 'library')
          List<Canonical>? library_,
      ClinicalUseDefinitionUndesirableEffect? undesirableEffect,
      ClinicalUseDefinitionWarning? warning});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $ElementCopyWith<$Res>? get typeElement;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
  @override
  $ClinicalUseDefinitionContraindicationCopyWith<$Res>? get contraindication;
  @override
  $ClinicalUseDefinitionIndicationCopyWith<$Res>? get indication;
  @override
  $ClinicalUseDefinitionInteractionCopyWith<$Res>? get interaction;
  @override
  $ClinicalUseDefinitionUndesirableEffectCopyWith<$Res>? get undesirableEffect;
  @override
  $ClinicalUseDefinitionWarningCopyWith<$Res>? get warning;
}

/// @nodoc
class __$$_ClinicalUseDefinitionCopyWithImpl<$Res>
    extends _$ClinicalUseDefinitionCopyWithImpl<$Res, _$_ClinicalUseDefinition>
    implements _$$_ClinicalUseDefinitionCopyWith<$Res> {
  __$$_ClinicalUseDefinitionCopyWithImpl(_$_ClinicalUseDefinition _value,
      $Res Function(_$_ClinicalUseDefinition) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = freezed,
    Object? typeElement = freezed,
    Object? category = freezed,
    Object? subject = freezed,
    Object? status = freezed,
    Object? contraindication = freezed,
    Object? indication = freezed,
    Object? interaction = freezed,
    Object? population = freezed,
    Object? library_ = freezed,
    Object? undesirableEffect = freezed,
    Object? warning = freezed,
  }) {
    return _then(_$_ClinicalUseDefinition(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as Code?,
      typeElement: freezed == typeElement
          ? _value.typeElement
          : typeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      category: freezed == category
          ? _value._category
          : category // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      subject: freezed == subject
          ? _value._subject
          : subject // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      contraindication: freezed == contraindication
          ? _value.contraindication
          : contraindication // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionContraindication?,
      indication: freezed == indication
          ? _value.indication
          : indication // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionIndication?,
      interaction: freezed == interaction
          ? _value.interaction
          : interaction // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionInteraction?,
      population: freezed == population
          ? _value._population
          : population // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      library_: freezed == library_
          ? _value._library_
          : library_ // ignore: cast_nullable_to_non_nullable
              as List<Canonical>?,
      undesirableEffect: freezed == undesirableEffect
          ? _value.undesirableEffect
          : undesirableEffect // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionUndesirableEffect?,
      warning: freezed == warning
          ? _value.warning
          : warning // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionWarning?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ClinicalUseDefinition extends _ClinicalUseDefinition {
  _$_ClinicalUseDefinition(
      {@JsonKey(unknownEnumValue: R5ResourceType.ClinicalUseDefinition)
          this.resourceType = R5ResourceType.ClinicalUseDefinition,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules')
          this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language')
          this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      this.type,
      @JsonKey(name: '_type')
          this.typeElement,
      final List<CodeableConcept>? category,
      final List<Reference>? subject,
      this.status,
      this.contraindication,
      this.indication,
      this.interaction,
      final List<Reference>? population,
      @JsonKey(name: 'library')
          final List<Canonical>? library_,
      this.undesirableEffect,
      this.warning})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _category = category,
        _subject = subject,
        _population = population,
        _library_ = library_,
        super._();

  factory _$_ClinicalUseDefinition.fromJson(Map<String, dynamic> json) =>
      _$$_ClinicalUseDefinitionFromJson(json);

  /// [resourceType] This is a ClinicalUseDefinition resource
  @override
  @JsonKey(unknownEnumValue: R5ResourceType.ClinicalUseDefinition)
  final R5ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.
  @override
  final Code? language;

  /// [languageElement] ("_language") Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] Business identifier for this issue.
  final List<Identifier>? _identifier;

  /// [identifier] Business identifier for this issue.
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] indication | contraindication | interaction | undesirable-effect | warning.
  @override
  final Code? type;

  /// [typeElement] ("_type") Extensions for type
  @override
  @JsonKey(name: '_type')
  final Element? typeElement;

  /// [category] A categorisation of the issue, primarily for dividing warnings into subject heading areas such as "Pregnancy and Lactation", "Overdose", "Effects on Ability to Drive and Use Machines".
  final List<CodeableConcept>? _category;

  /// [category] A categorisation of the issue, primarily for dividing warnings into subject heading areas such as "Pregnancy and Lactation", "Overdose", "Effects on Ability to Drive and Use Machines".
  @override
  List<CodeableConcept>? get category {
    final value = _category;
    if (value == null) return null;
    if (_category is EqualUnmodifiableListView) return _category;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [subject] The medication or procedure for which this is an indication.
  final List<Reference>? _subject;

  /// [subject] The medication or procedure for which this is an indication.
  @override
  List<Reference>? get subject {
    final value = _subject;
    if (value == null) return null;
    if (_subject is EqualUnmodifiableListView) return _subject;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [status] Whether this is a current issue or one that has been retired etc.
  @override
  final CodeableConcept? status;

  /// [contraindication] Specifics for when this is a contraindication.
  @override
  final ClinicalUseDefinitionContraindication? contraindication;

  /// [indication] Specifics for when this is an indication.
  @override
  final ClinicalUseDefinitionIndication? indication;

  /// [interaction] Specifics for when this is an interaction.
  @override
  final ClinicalUseDefinitionInteraction? interaction;

  /// [population] The population group to which this applies.
  final List<Reference>? _population;

  /// [population] The population group to which this applies.
  @override
  List<Reference>? get population {
    final value = _population;
    if (value == null) return null;
    if (_population is EqualUnmodifiableListView) return _population;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [library_] ("library") Logic used by the clinical use definition.
  final List<Canonical>? _library_;

  /// [library_] ("library") Logic used by the clinical use definition.
  @override
  @JsonKey(name: 'library')
  List<Canonical>? get library_ {
    final value = _library_;
    if (value == null) return null;
    if (_library_ is EqualUnmodifiableListView) return _library_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [undesirableEffect] Describe the possible undesirable effects (negative outcomes) from the use of the medicinal product as treatment.
  @override
  final ClinicalUseDefinitionUndesirableEffect? undesirableEffect;

  /// [warning] A critical piece of information about environmental, health or physical risks or hazards that serve as caution to the user. For example 'Do not operate heavy machinery', 'May cause drowsiness', or 'Get medical advice/attention if you feel unwell'.
  @override
  final ClinicalUseDefinitionWarning? warning;

  @override
  String toString() {
    return 'ClinicalUseDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, type: $type, typeElement: $typeElement, category: $category, subject: $subject, status: $status, contraindication: $contraindication, indication: $indication, interaction: $interaction, population: $population, library_: $library_, undesirableEffect: $undesirableEffect, warning: $warning)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ClinicalUseDefinition &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.typeElement, typeElement) ||
                other.typeElement == typeElement) &&
            const DeepCollectionEquality().equals(other._category, _category) &&
            const DeepCollectionEquality().equals(other._subject, _subject) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.contraindication, contraindication) ||
                other.contraindication == contraindication) &&
            (identical(other.indication, indication) ||
                other.indication == indication) &&
            (identical(other.interaction, interaction) ||
                other.interaction == interaction) &&
            const DeepCollectionEquality()
                .equals(other._population, _population) &&
            const DeepCollectionEquality().equals(other._library_, _library_) &&
            (identical(other.undesirableEffect, undesirableEffect) ||
                other.undesirableEffect == undesirableEffect) &&
            (identical(other.warning, warning) || other.warning == warning));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_identifier),
        type,
        typeElement,
        const DeepCollectionEquality().hash(_category),
        const DeepCollectionEquality().hash(_subject),
        status,
        contraindication,
        indication,
        interaction,
        const DeepCollectionEquality().hash(_population),
        const DeepCollectionEquality().hash(_library_),
        undesirableEffect,
        warning
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ClinicalUseDefinitionCopyWith<_$_ClinicalUseDefinition> get copyWith =>
      __$$_ClinicalUseDefinitionCopyWithImpl<_$_ClinicalUseDefinition>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ClinicalUseDefinitionToJson(
      this,
    );
  }
}

abstract class _ClinicalUseDefinition extends ClinicalUseDefinition {
  factory _ClinicalUseDefinition(
      {@JsonKey(unknownEnumValue: R5ResourceType.ClinicalUseDefinition)
          final R5ResourceType resourceType,
      final FhirId? id,
      final Meta? meta,
      final FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          final Element? implicitRulesElement,
      final Code? language,
      @JsonKey(name: '_language')
          final Element? languageElement,
      final Narrative? text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      final Code? type,
      @JsonKey(name: '_type')
          final Element? typeElement,
      final List<CodeableConcept>? category,
      final List<Reference>? subject,
      final CodeableConcept? status,
      final ClinicalUseDefinitionContraindication? contraindication,
      final ClinicalUseDefinitionIndication? indication,
      final ClinicalUseDefinitionInteraction? interaction,
      final List<Reference>? population,
      @JsonKey(name: 'library')
          final List<Canonical>? library_,
      final ClinicalUseDefinitionUndesirableEffect? undesirableEffect,
      final ClinicalUseDefinitionWarning? warning}) = _$_ClinicalUseDefinition;
  _ClinicalUseDefinition._() : super._();

  factory _ClinicalUseDefinition.fromJson(Map<String, dynamic> json) =
      _$_ClinicalUseDefinition.fromJson;

  @override

  /// [resourceType] This is a ClinicalUseDefinition resource
  @JsonKey(unknownEnumValue: R5ResourceType.ClinicalUseDefinition)
  R5ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.
  Code? get language;
  @override

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained;
  @override

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] Business identifier for this issue.
  List<Identifier>? get identifier;
  @override

  /// [type] indication | contraindication | interaction | undesirable-effect | warning.
  Code? get type;
  @override

  /// [typeElement] ("_type") Extensions for type
  @JsonKey(name: '_type')
  Element? get typeElement;
  @override

  /// [category] A categorisation of the issue, primarily for dividing warnings into subject heading areas such as "Pregnancy and Lactation", "Overdose", "Effects on Ability to Drive and Use Machines".
  List<CodeableConcept>? get category;
  @override

  /// [subject] The medication or procedure for which this is an indication.
  List<Reference>? get subject;
  @override

  /// [status] Whether this is a current issue or one that has been retired etc.
  CodeableConcept? get status;
  @override

  /// [contraindication] Specifics for when this is a contraindication.
  ClinicalUseDefinitionContraindication? get contraindication;
  @override

  /// [indication] Specifics for when this is an indication.
  ClinicalUseDefinitionIndication? get indication;
  @override

  /// [interaction] Specifics for when this is an interaction.
  ClinicalUseDefinitionInteraction? get interaction;
  @override

  /// [population] The population group to which this applies.
  List<Reference>? get population;
  @override

  /// [library_] ("library") Logic used by the clinical use definition.
  @JsonKey(name: 'library')
  List<Canonical>? get library_;
  @override

  /// [undesirableEffect] Describe the possible undesirable effects (negative outcomes) from the use of the medicinal product as treatment.
  ClinicalUseDefinitionUndesirableEffect? get undesirableEffect;
  @override

  /// [warning] A critical piece of information about environmental, health or physical risks or hazards that serve as caution to the user. For example 'Do not operate heavy machinery', 'May cause drowsiness', or 'Get medical advice/attention if you feel unwell'.
  ClinicalUseDefinitionWarning? get warning;
  @override
  @JsonKey(ignore: true)
  _$$_ClinicalUseDefinitionCopyWith<_$_ClinicalUseDefinition> get copyWith =>
      throw _privateConstructorUsedError;
}

ClinicalUseDefinitionContraindication
    _$ClinicalUseDefinitionContraindicationFromJson(Map<String, dynamic> json) {
  return _ClinicalUseDefinitionContraindication.fromJson(json);
}

/// @nodoc
mixin _$ClinicalUseDefinitionContraindication {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [diseaseSymptomProcedure] The situation that is being documented as contraindicating against this item.
  CodeableReference? get diseaseSymptomProcedure =>
      throw _privateConstructorUsedError;

  /// [diseaseStatus] The status of the disease or symptom for the contraindication, for example "chronic" or "metastatic".
  CodeableReference? get diseaseStatus => throw _privateConstructorUsedError;

  /// [comorbidity] A comorbidity (concurrent condition) or coinfection.
  List<CodeableReference>? get comorbidity =>
      throw _privateConstructorUsedError;

  /// [indication] The indication which this is a contraidication for.
  List<Reference>? get indication => throw _privateConstructorUsedError;

  /// [applicability] An expression that returns true or false, indicating whether the indication is applicable or not, after having applied its other elements.
  Expression? get applicability => throw _privateConstructorUsedError;

  /// [otherTherapy] Information about the use of the medicinal product in relation to other therapies described as part of the contraindication.
  List<ClinicalUseDefinitionOtherTherapy>? get otherTherapy =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ClinicalUseDefinitionContraindicationCopyWith<
          ClinicalUseDefinitionContraindication>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClinicalUseDefinitionContraindicationCopyWith<$Res> {
  factory $ClinicalUseDefinitionContraindicationCopyWith(
          ClinicalUseDefinitionContraindication value,
          $Res Function(ClinicalUseDefinitionContraindication) then) =
      _$ClinicalUseDefinitionContraindicationCopyWithImpl<$Res,
          ClinicalUseDefinitionContraindication>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? diseaseSymptomProcedure,
      CodeableReference? diseaseStatus,
      List<CodeableReference>? comorbidity,
      List<Reference>? indication,
      Expression? applicability,
      List<ClinicalUseDefinitionOtherTherapy>? otherTherapy});

  $CodeableReferenceCopyWith<$Res>? get diseaseSymptomProcedure;
  $CodeableReferenceCopyWith<$Res>? get diseaseStatus;
  $ExpressionCopyWith<$Res>? get applicability;
}

/// @nodoc
class _$ClinicalUseDefinitionContraindicationCopyWithImpl<$Res,
        $Val extends ClinicalUseDefinitionContraindication>
    implements $ClinicalUseDefinitionContraindicationCopyWith<$Res> {
  _$ClinicalUseDefinitionContraindicationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? diseaseSymptomProcedure = freezed,
    Object? diseaseStatus = freezed,
    Object? comorbidity = freezed,
    Object? indication = freezed,
    Object? applicability = freezed,
    Object? otherTherapy = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      diseaseSymptomProcedure: freezed == diseaseSymptomProcedure
          ? _value.diseaseSymptomProcedure
          : diseaseSymptomProcedure // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      diseaseStatus: freezed == diseaseStatus
          ? _value.diseaseStatus
          : diseaseStatus // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      comorbidity: freezed == comorbidity
          ? _value.comorbidity
          : comorbidity // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      indication: freezed == indication
          ? _value.indication
          : indication // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      applicability: freezed == applicability
          ? _value.applicability
          : applicability // ignore: cast_nullable_to_non_nullable
              as Expression?,
      otherTherapy: freezed == otherTherapy
          ? _value.otherTherapy
          : otherTherapy // ignore: cast_nullable_to_non_nullable
              as List<ClinicalUseDefinitionOtherTherapy>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res>? get diseaseSymptomProcedure {
    if (_value.diseaseSymptomProcedure == null) {
      return null;
    }

    return $CodeableReferenceCopyWith<$Res>(_value.diseaseSymptomProcedure!,
        (value) {
      return _then(_value.copyWith(diseaseSymptomProcedure: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res>? get diseaseStatus {
    if (_value.diseaseStatus == null) {
      return null;
    }

    return $CodeableReferenceCopyWith<$Res>(_value.diseaseStatus!, (value) {
      return _then(_value.copyWith(diseaseStatus: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExpressionCopyWith<$Res>? get applicability {
    if (_value.applicability == null) {
      return null;
    }

    return $ExpressionCopyWith<$Res>(_value.applicability!, (value) {
      return _then(_value.copyWith(applicability: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ClinicalUseDefinitionContraindicationCopyWith<$Res>
    implements $ClinicalUseDefinitionContraindicationCopyWith<$Res> {
  factory _$$_ClinicalUseDefinitionContraindicationCopyWith(
          _$_ClinicalUseDefinitionContraindication value,
          $Res Function(_$_ClinicalUseDefinitionContraindication) then) =
      __$$_ClinicalUseDefinitionContraindicationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? diseaseSymptomProcedure,
      CodeableReference? diseaseStatus,
      List<CodeableReference>? comorbidity,
      List<Reference>? indication,
      Expression? applicability,
      List<ClinicalUseDefinitionOtherTherapy>? otherTherapy});

  @override
  $CodeableReferenceCopyWith<$Res>? get diseaseSymptomProcedure;
  @override
  $CodeableReferenceCopyWith<$Res>? get diseaseStatus;
  @override
  $ExpressionCopyWith<$Res>? get applicability;
}

/// @nodoc
class __$$_ClinicalUseDefinitionContraindicationCopyWithImpl<$Res>
    extends _$ClinicalUseDefinitionContraindicationCopyWithImpl<$Res,
        _$_ClinicalUseDefinitionContraindication>
    implements _$$_ClinicalUseDefinitionContraindicationCopyWith<$Res> {
  __$$_ClinicalUseDefinitionContraindicationCopyWithImpl(
      _$_ClinicalUseDefinitionContraindication _value,
      $Res Function(_$_ClinicalUseDefinitionContraindication) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? diseaseSymptomProcedure = freezed,
    Object? diseaseStatus = freezed,
    Object? comorbidity = freezed,
    Object? indication = freezed,
    Object? applicability = freezed,
    Object? otherTherapy = freezed,
  }) {
    return _then(_$_ClinicalUseDefinitionContraindication(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      diseaseSymptomProcedure: freezed == diseaseSymptomProcedure
          ? _value.diseaseSymptomProcedure
          : diseaseSymptomProcedure // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      diseaseStatus: freezed == diseaseStatus
          ? _value.diseaseStatus
          : diseaseStatus // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      comorbidity: freezed == comorbidity
          ? _value._comorbidity
          : comorbidity // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      indication: freezed == indication
          ? _value._indication
          : indication // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      applicability: freezed == applicability
          ? _value.applicability
          : applicability // ignore: cast_nullable_to_non_nullable
              as Expression?,
      otherTherapy: freezed == otherTherapy
          ? _value._otherTherapy
          : otherTherapy // ignore: cast_nullable_to_non_nullable
              as List<ClinicalUseDefinitionOtherTherapy>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ClinicalUseDefinitionContraindication
    extends _ClinicalUseDefinitionContraindication {
  _$_ClinicalUseDefinitionContraindication(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.diseaseSymptomProcedure,
      this.diseaseStatus,
      final List<CodeableReference>? comorbidity,
      final List<Reference>? indication,
      this.applicability,
      final List<ClinicalUseDefinitionOtherTherapy>? otherTherapy})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _comorbidity = comorbidity,
        _indication = indication,
        _otherTherapy = otherTherapy,
        super._();

  factory _$_ClinicalUseDefinitionContraindication.fromJson(
          Map<String, dynamic> json) =>
      _$$_ClinicalUseDefinitionContraindicationFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [diseaseSymptomProcedure] The situation that is being documented as contraindicating against this item.
  @override
  final CodeableReference? diseaseSymptomProcedure;

  /// [diseaseStatus] The status of the disease or symptom for the contraindication, for example "chronic" or "metastatic".
  @override
  final CodeableReference? diseaseStatus;

  /// [comorbidity] A comorbidity (concurrent condition) or coinfection.
  final List<CodeableReference>? _comorbidity;

  /// [comorbidity] A comorbidity (concurrent condition) or coinfection.
  @override
  List<CodeableReference>? get comorbidity {
    final value = _comorbidity;
    if (value == null) return null;
    if (_comorbidity is EqualUnmodifiableListView) return _comorbidity;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [indication] The indication which this is a contraidication for.
  final List<Reference>? _indication;

  /// [indication] The indication which this is a contraidication for.
  @override
  List<Reference>? get indication {
    final value = _indication;
    if (value == null) return null;
    if (_indication is EqualUnmodifiableListView) return _indication;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [applicability] An expression that returns true or false, indicating whether the indication is applicable or not, after having applied its other elements.
  @override
  final Expression? applicability;

  /// [otherTherapy] Information about the use of the medicinal product in relation to other therapies described as part of the contraindication.
  final List<ClinicalUseDefinitionOtherTherapy>? _otherTherapy;

  /// [otherTherapy] Information about the use of the medicinal product in relation to other therapies described as part of the contraindication.
  @override
  List<ClinicalUseDefinitionOtherTherapy>? get otherTherapy {
    final value = _otherTherapy;
    if (value == null) return null;
    if (_otherTherapy is EqualUnmodifiableListView) return _otherTherapy;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ClinicalUseDefinitionContraindication(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, diseaseSymptomProcedure: $diseaseSymptomProcedure, diseaseStatus: $diseaseStatus, comorbidity: $comorbidity, indication: $indication, applicability: $applicability, otherTherapy: $otherTherapy)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ClinicalUseDefinitionContraindication &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(
                    other.diseaseSymptomProcedure, diseaseSymptomProcedure) ||
                other.diseaseSymptomProcedure == diseaseSymptomProcedure) &&
            (identical(other.diseaseStatus, diseaseStatus) ||
                other.diseaseStatus == diseaseStatus) &&
            const DeepCollectionEquality()
                .equals(other._comorbidity, _comorbidity) &&
            const DeepCollectionEquality()
                .equals(other._indication, _indication) &&
            (identical(other.applicability, applicability) ||
                other.applicability == applicability) &&
            const DeepCollectionEquality()
                .equals(other._otherTherapy, _otherTherapy));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      diseaseSymptomProcedure,
      diseaseStatus,
      const DeepCollectionEquality().hash(_comorbidity),
      const DeepCollectionEquality().hash(_indication),
      applicability,
      const DeepCollectionEquality().hash(_otherTherapy));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ClinicalUseDefinitionContraindicationCopyWith<
          _$_ClinicalUseDefinitionContraindication>
      get copyWith => __$$_ClinicalUseDefinitionContraindicationCopyWithImpl<
          _$_ClinicalUseDefinitionContraindication>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ClinicalUseDefinitionContraindicationToJson(
      this,
    );
  }
}

abstract class _ClinicalUseDefinitionContraindication
    extends ClinicalUseDefinitionContraindication {
  factory _ClinicalUseDefinitionContraindication(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableReference? diseaseSymptomProcedure,
          final CodeableReference? diseaseStatus,
          final List<CodeableReference>? comorbidity,
          final List<Reference>? indication,
          final Expression? applicability,
          final List<ClinicalUseDefinitionOtherTherapy>? otherTherapy}) =
      _$_ClinicalUseDefinitionContraindication;
  _ClinicalUseDefinitionContraindication._() : super._();

  factory _ClinicalUseDefinitionContraindication.fromJson(
          Map<String, dynamic> json) =
      _$_ClinicalUseDefinitionContraindication.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [diseaseSymptomProcedure] The situation that is being documented as contraindicating against this item.
  CodeableReference? get diseaseSymptomProcedure;
  @override

  /// [diseaseStatus] The status of the disease or symptom for the contraindication, for example "chronic" or "metastatic".
  CodeableReference? get diseaseStatus;
  @override

  /// [comorbidity] A comorbidity (concurrent condition) or coinfection.
  List<CodeableReference>? get comorbidity;
  @override

  /// [indication] The indication which this is a contraidication for.
  List<Reference>? get indication;
  @override

  /// [applicability] An expression that returns true or false, indicating whether the indication is applicable or not, after having applied its other elements.
  Expression? get applicability;
  @override

  /// [otherTherapy] Information about the use of the medicinal product in relation to other therapies described as part of the contraindication.
  List<ClinicalUseDefinitionOtherTherapy>? get otherTherapy;
  @override
  @JsonKey(ignore: true)
  _$$_ClinicalUseDefinitionContraindicationCopyWith<
          _$_ClinicalUseDefinitionContraindication>
      get copyWith => throw _privateConstructorUsedError;
}

ClinicalUseDefinitionOtherTherapy _$ClinicalUseDefinitionOtherTherapyFromJson(
    Map<String, dynamic> json) {
  return _ClinicalUseDefinitionOtherTherapy.fromJson(json);
}

/// @nodoc
mixin _$ClinicalUseDefinitionOtherTherapy {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [relationshipType] The type of relationship between the medicinal product indication or contraindication and another therapy.
  CodeableConcept get relationshipType => throw _privateConstructorUsedError;

  /// [treatment] Reference to a specific medication (active substance, medicinal product or class of products) as part of an indication or contraindication.
  CodeableReference get treatment => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ClinicalUseDefinitionOtherTherapyCopyWith<ClinicalUseDefinitionOtherTherapy>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClinicalUseDefinitionOtherTherapyCopyWith<$Res> {
  factory $ClinicalUseDefinitionOtherTherapyCopyWith(
          ClinicalUseDefinitionOtherTherapy value,
          $Res Function(ClinicalUseDefinitionOtherTherapy) then) =
      _$ClinicalUseDefinitionOtherTherapyCopyWithImpl<$Res,
          ClinicalUseDefinitionOtherTherapy>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept relationshipType,
      CodeableReference treatment});

  $CodeableConceptCopyWith<$Res> get relationshipType;
  $CodeableReferenceCopyWith<$Res> get treatment;
}

/// @nodoc
class _$ClinicalUseDefinitionOtherTherapyCopyWithImpl<$Res,
        $Val extends ClinicalUseDefinitionOtherTherapy>
    implements $ClinicalUseDefinitionOtherTherapyCopyWith<$Res> {
  _$ClinicalUseDefinitionOtherTherapyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? relationshipType = null,
    Object? treatment = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      relationshipType: null == relationshipType
          ? _value.relationshipType
          : relationshipType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      treatment: null == treatment
          ? _value.treatment
          : treatment // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get relationshipType {
    return $CodeableConceptCopyWith<$Res>(_value.relationshipType, (value) {
      return _then(_value.copyWith(relationshipType: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res> get treatment {
    return $CodeableReferenceCopyWith<$Res>(_value.treatment, (value) {
      return _then(_value.copyWith(treatment: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ClinicalUseDefinitionOtherTherapyCopyWith<$Res>
    implements $ClinicalUseDefinitionOtherTherapyCopyWith<$Res> {
  factory _$$_ClinicalUseDefinitionOtherTherapyCopyWith(
          _$_ClinicalUseDefinitionOtherTherapy value,
          $Res Function(_$_ClinicalUseDefinitionOtherTherapy) then) =
      __$$_ClinicalUseDefinitionOtherTherapyCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept relationshipType,
      CodeableReference treatment});

  @override
  $CodeableConceptCopyWith<$Res> get relationshipType;
  @override
  $CodeableReferenceCopyWith<$Res> get treatment;
}

/// @nodoc
class __$$_ClinicalUseDefinitionOtherTherapyCopyWithImpl<$Res>
    extends _$ClinicalUseDefinitionOtherTherapyCopyWithImpl<$Res,
        _$_ClinicalUseDefinitionOtherTherapy>
    implements _$$_ClinicalUseDefinitionOtherTherapyCopyWith<$Res> {
  __$$_ClinicalUseDefinitionOtherTherapyCopyWithImpl(
      _$_ClinicalUseDefinitionOtherTherapy _value,
      $Res Function(_$_ClinicalUseDefinitionOtherTherapy) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? relationshipType = null,
    Object? treatment = null,
  }) {
    return _then(_$_ClinicalUseDefinitionOtherTherapy(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      relationshipType: null == relationshipType
          ? _value.relationshipType
          : relationshipType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      treatment: null == treatment
          ? _value.treatment
          : treatment // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ClinicalUseDefinitionOtherTherapy
    extends _ClinicalUseDefinitionOtherTherapy {
  _$_ClinicalUseDefinitionOtherTherapy(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.relationshipType,
      required this.treatment})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_ClinicalUseDefinitionOtherTherapy.fromJson(
          Map<String, dynamic> json) =>
      _$$_ClinicalUseDefinitionOtherTherapyFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [relationshipType] The type of relationship between the medicinal product indication or contraindication and another therapy.
  @override
  final CodeableConcept relationshipType;

  /// [treatment] Reference to a specific medication (active substance, medicinal product or class of products) as part of an indication or contraindication.
  @override
  final CodeableReference treatment;

  @override
  String toString() {
    return 'ClinicalUseDefinitionOtherTherapy(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, relationshipType: $relationshipType, treatment: $treatment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ClinicalUseDefinitionOtherTherapy &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.relationshipType, relationshipType) ||
                other.relationshipType == relationshipType) &&
            (identical(other.treatment, treatment) ||
                other.treatment == treatment));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      relationshipType,
      treatment);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ClinicalUseDefinitionOtherTherapyCopyWith<
          _$_ClinicalUseDefinitionOtherTherapy>
      get copyWith => __$$_ClinicalUseDefinitionOtherTherapyCopyWithImpl<
          _$_ClinicalUseDefinitionOtherTherapy>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ClinicalUseDefinitionOtherTherapyToJson(
      this,
    );
  }
}

abstract class _ClinicalUseDefinitionOtherTherapy
    extends ClinicalUseDefinitionOtherTherapy {
  factory _ClinicalUseDefinitionOtherTherapy(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept relationshipType,
          required final CodeableReference treatment}) =
      _$_ClinicalUseDefinitionOtherTherapy;
  _ClinicalUseDefinitionOtherTherapy._() : super._();

  factory _ClinicalUseDefinitionOtherTherapy.fromJson(
          Map<String, dynamic> json) =
      _$_ClinicalUseDefinitionOtherTherapy.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [relationshipType] The type of relationship between the medicinal product indication or contraindication and another therapy.
  CodeableConcept get relationshipType;
  @override

  /// [treatment] Reference to a specific medication (active substance, medicinal product or class of products) as part of an indication or contraindication.
  CodeableReference get treatment;
  @override
  @JsonKey(ignore: true)
  _$$_ClinicalUseDefinitionOtherTherapyCopyWith<
          _$_ClinicalUseDefinitionOtherTherapy>
      get copyWith => throw _privateConstructorUsedError;
}

ClinicalUseDefinitionIndication _$ClinicalUseDefinitionIndicationFromJson(
    Map<String, dynamic> json) {
  return _ClinicalUseDefinitionIndication.fromJson(json);
}

/// @nodoc
mixin _$ClinicalUseDefinitionIndication {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [diseaseSymptomProcedure] The situation that is being documented as an indicaton for this item.
  CodeableReference? get diseaseSymptomProcedure =>
      throw _privateConstructorUsedError;

  /// [diseaseStatus] The status of the disease or symptom for the indication, for example "chronic" or "metastatic".
  CodeableReference? get diseaseStatus => throw _privateConstructorUsedError;

  /// [comorbidity] A comorbidity (concurrent condition) or coinfection as part of the indication.
  List<CodeableReference>? get comorbidity =>
      throw _privateConstructorUsedError;

  /// [intendedEffect] The intended effect, aim or strategy to be achieved.
  CodeableReference? get intendedEffect => throw _privateConstructorUsedError;

  /// [durationRange] Timing or duration information, that may be associated with use with the indicated condition e.g. Adult patients suffering from myocardial infarction (from a few days until less than 35 days), ischaemic stroke (from 7 days until less than 6 months).
  Range? get durationRange => throw _privateConstructorUsedError;

  /// [durationString] Timing or duration information, that may be associated with use with the indicated condition e.g. Adult patients suffering from myocardial infarction (from a few days until less than 35 days), ischaemic stroke (from 7 days until less than 6 months).
  String? get durationString => throw _privateConstructorUsedError;

  /// [durationStringElement] ("_durationString") Extensions for durationString
  @JsonKey(name: '_durationString')
  Element? get durationStringElement => throw _privateConstructorUsedError;

  /// [undesirableEffect] An unwanted side effect or negative outcome that may happen if you use the drug (or other subject of this resource) for this indication.
  List<Reference>? get undesirableEffect => throw _privateConstructorUsedError;

  /// [applicability] An expression that returns true or false, indicating whether the indication is applicable or not, after having applied its other elements.
  Expression? get applicability => throw _privateConstructorUsedError;

  /// [otherTherapy] Information about the use of the medicinal product in relation to other therapies described as part of the indication.
  List<ClinicalUseDefinitionOtherTherapy>? get otherTherapy =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ClinicalUseDefinitionIndicationCopyWith<ClinicalUseDefinitionIndication>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClinicalUseDefinitionIndicationCopyWith<$Res> {
  factory $ClinicalUseDefinitionIndicationCopyWith(
          ClinicalUseDefinitionIndication value,
          $Res Function(ClinicalUseDefinitionIndication) then) =
      _$ClinicalUseDefinitionIndicationCopyWithImpl<$Res,
          ClinicalUseDefinitionIndication>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? diseaseSymptomProcedure,
      CodeableReference? diseaseStatus,
      List<CodeableReference>? comorbidity,
      CodeableReference? intendedEffect,
      Range? durationRange,
      String? durationString,
      @JsonKey(name: '_durationString') Element? durationStringElement,
      List<Reference>? undesirableEffect,
      Expression? applicability,
      List<ClinicalUseDefinitionOtherTherapy>? otherTherapy});

  $CodeableReferenceCopyWith<$Res>? get diseaseSymptomProcedure;
  $CodeableReferenceCopyWith<$Res>? get diseaseStatus;
  $CodeableReferenceCopyWith<$Res>? get intendedEffect;
  $RangeCopyWith<$Res>? get durationRange;
  $ElementCopyWith<$Res>? get durationStringElement;
  $ExpressionCopyWith<$Res>? get applicability;
}

/// @nodoc
class _$ClinicalUseDefinitionIndicationCopyWithImpl<$Res,
        $Val extends ClinicalUseDefinitionIndication>
    implements $ClinicalUseDefinitionIndicationCopyWith<$Res> {
  _$ClinicalUseDefinitionIndicationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? diseaseSymptomProcedure = freezed,
    Object? diseaseStatus = freezed,
    Object? comorbidity = freezed,
    Object? intendedEffect = freezed,
    Object? durationRange = freezed,
    Object? durationString = freezed,
    Object? durationStringElement = freezed,
    Object? undesirableEffect = freezed,
    Object? applicability = freezed,
    Object? otherTherapy = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      diseaseSymptomProcedure: freezed == diseaseSymptomProcedure
          ? _value.diseaseSymptomProcedure
          : diseaseSymptomProcedure // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      diseaseStatus: freezed == diseaseStatus
          ? _value.diseaseStatus
          : diseaseStatus // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      comorbidity: freezed == comorbidity
          ? _value.comorbidity
          : comorbidity // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      intendedEffect: freezed == intendedEffect
          ? _value.intendedEffect
          : intendedEffect // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      durationRange: freezed == durationRange
          ? _value.durationRange
          : durationRange // ignore: cast_nullable_to_non_nullable
              as Range?,
      durationString: freezed == durationString
          ? _value.durationString
          : durationString // ignore: cast_nullable_to_non_nullable
              as String?,
      durationStringElement: freezed == durationStringElement
          ? _value.durationStringElement
          : durationStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      undesirableEffect: freezed == undesirableEffect
          ? _value.undesirableEffect
          : undesirableEffect // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      applicability: freezed == applicability
          ? _value.applicability
          : applicability // ignore: cast_nullable_to_non_nullable
              as Expression?,
      otherTherapy: freezed == otherTherapy
          ? _value.otherTherapy
          : otherTherapy // ignore: cast_nullable_to_non_nullable
              as List<ClinicalUseDefinitionOtherTherapy>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res>? get diseaseSymptomProcedure {
    if (_value.diseaseSymptomProcedure == null) {
      return null;
    }

    return $CodeableReferenceCopyWith<$Res>(_value.diseaseSymptomProcedure!,
        (value) {
      return _then(_value.copyWith(diseaseSymptomProcedure: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res>? get diseaseStatus {
    if (_value.diseaseStatus == null) {
      return null;
    }

    return $CodeableReferenceCopyWith<$Res>(_value.diseaseStatus!, (value) {
      return _then(_value.copyWith(diseaseStatus: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res>? get intendedEffect {
    if (_value.intendedEffect == null) {
      return null;
    }

    return $CodeableReferenceCopyWith<$Res>(_value.intendedEffect!, (value) {
      return _then(_value.copyWith(intendedEffect: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RangeCopyWith<$Res>? get durationRange {
    if (_value.durationRange == null) {
      return null;
    }

    return $RangeCopyWith<$Res>(_value.durationRange!, (value) {
      return _then(_value.copyWith(durationRange: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get durationStringElement {
    if (_value.durationStringElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.durationStringElement!, (value) {
      return _then(_value.copyWith(durationStringElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExpressionCopyWith<$Res>? get applicability {
    if (_value.applicability == null) {
      return null;
    }

    return $ExpressionCopyWith<$Res>(_value.applicability!, (value) {
      return _then(_value.copyWith(applicability: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ClinicalUseDefinitionIndicationCopyWith<$Res>
    implements $ClinicalUseDefinitionIndicationCopyWith<$Res> {
  factory _$$_ClinicalUseDefinitionIndicationCopyWith(
          _$_ClinicalUseDefinitionIndication value,
          $Res Function(_$_ClinicalUseDefinitionIndication) then) =
      __$$_ClinicalUseDefinitionIndicationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? diseaseSymptomProcedure,
      CodeableReference? diseaseStatus,
      List<CodeableReference>? comorbidity,
      CodeableReference? intendedEffect,
      Range? durationRange,
      String? durationString,
      @JsonKey(name: '_durationString') Element? durationStringElement,
      List<Reference>? undesirableEffect,
      Expression? applicability,
      List<ClinicalUseDefinitionOtherTherapy>? otherTherapy});

  @override
  $CodeableReferenceCopyWith<$Res>? get diseaseSymptomProcedure;
  @override
  $CodeableReferenceCopyWith<$Res>? get diseaseStatus;
  @override
  $CodeableReferenceCopyWith<$Res>? get intendedEffect;
  @override
  $RangeCopyWith<$Res>? get durationRange;
  @override
  $ElementCopyWith<$Res>? get durationStringElement;
  @override
  $ExpressionCopyWith<$Res>? get applicability;
}

/// @nodoc
class __$$_ClinicalUseDefinitionIndicationCopyWithImpl<$Res>
    extends _$ClinicalUseDefinitionIndicationCopyWithImpl<$Res,
        _$_ClinicalUseDefinitionIndication>
    implements _$$_ClinicalUseDefinitionIndicationCopyWith<$Res> {
  __$$_ClinicalUseDefinitionIndicationCopyWithImpl(
      _$_ClinicalUseDefinitionIndication _value,
      $Res Function(_$_ClinicalUseDefinitionIndication) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? diseaseSymptomProcedure = freezed,
    Object? diseaseStatus = freezed,
    Object? comorbidity = freezed,
    Object? intendedEffect = freezed,
    Object? durationRange = freezed,
    Object? durationString = freezed,
    Object? durationStringElement = freezed,
    Object? undesirableEffect = freezed,
    Object? applicability = freezed,
    Object? otherTherapy = freezed,
  }) {
    return _then(_$_ClinicalUseDefinitionIndication(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      diseaseSymptomProcedure: freezed == diseaseSymptomProcedure
          ? _value.diseaseSymptomProcedure
          : diseaseSymptomProcedure // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      diseaseStatus: freezed == diseaseStatus
          ? _value.diseaseStatus
          : diseaseStatus // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      comorbidity: freezed == comorbidity
          ? _value._comorbidity
          : comorbidity // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      intendedEffect: freezed == intendedEffect
          ? _value.intendedEffect
          : intendedEffect // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      durationRange: freezed == durationRange
          ? _value.durationRange
          : durationRange // ignore: cast_nullable_to_non_nullable
              as Range?,
      durationString: freezed == durationString
          ? _value.durationString
          : durationString // ignore: cast_nullable_to_non_nullable
              as String?,
      durationStringElement: freezed == durationStringElement
          ? _value.durationStringElement
          : durationStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      undesirableEffect: freezed == undesirableEffect
          ? _value._undesirableEffect
          : undesirableEffect // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      applicability: freezed == applicability
          ? _value.applicability
          : applicability // ignore: cast_nullable_to_non_nullable
              as Expression?,
      otherTherapy: freezed == otherTherapy
          ? _value._otherTherapy
          : otherTherapy // ignore: cast_nullable_to_non_nullable
              as List<ClinicalUseDefinitionOtherTherapy>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ClinicalUseDefinitionIndication
    extends _ClinicalUseDefinitionIndication {
  _$_ClinicalUseDefinitionIndication(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.diseaseSymptomProcedure,
      this.diseaseStatus,
      final List<CodeableReference>? comorbidity,
      this.intendedEffect,
      this.durationRange,
      this.durationString,
      @JsonKey(name: '_durationString') this.durationStringElement,
      final List<Reference>? undesirableEffect,
      this.applicability,
      final List<ClinicalUseDefinitionOtherTherapy>? otherTherapy})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _comorbidity = comorbidity,
        _undesirableEffect = undesirableEffect,
        _otherTherapy = otherTherapy,
        super._();

  factory _$_ClinicalUseDefinitionIndication.fromJson(
          Map<String, dynamic> json) =>
      _$$_ClinicalUseDefinitionIndicationFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [diseaseSymptomProcedure] The situation that is being documented as an indicaton for this item.
  @override
  final CodeableReference? diseaseSymptomProcedure;

  /// [diseaseStatus] The status of the disease or symptom for the indication, for example "chronic" or "metastatic".
  @override
  final CodeableReference? diseaseStatus;

  /// [comorbidity] A comorbidity (concurrent condition) or coinfection as part of the indication.
  final List<CodeableReference>? _comorbidity;

  /// [comorbidity] A comorbidity (concurrent condition) or coinfection as part of the indication.
  @override
  List<CodeableReference>? get comorbidity {
    final value = _comorbidity;
    if (value == null) return null;
    if (_comorbidity is EqualUnmodifiableListView) return _comorbidity;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [intendedEffect] The intended effect, aim or strategy to be achieved.
  @override
  final CodeableReference? intendedEffect;

  /// [durationRange] Timing or duration information, that may be associated with use with the indicated condition e.g. Adult patients suffering from myocardial infarction (from a few days until less than 35 days), ischaemic stroke (from 7 days until less than 6 months).
  @override
  final Range? durationRange;

  /// [durationString] Timing or duration information, that may be associated with use with the indicated condition e.g. Adult patients suffering from myocardial infarction (from a few days until less than 35 days), ischaemic stroke (from 7 days until less than 6 months).
  @override
  final String? durationString;

  /// [durationStringElement] ("_durationString") Extensions for durationString
  @override
  @JsonKey(name: '_durationString')
  final Element? durationStringElement;

  /// [undesirableEffect] An unwanted side effect or negative outcome that may happen if you use the drug (or other subject of this resource) for this indication.
  final List<Reference>? _undesirableEffect;

  /// [undesirableEffect] An unwanted side effect or negative outcome that may happen if you use the drug (or other subject of this resource) for this indication.
  @override
  List<Reference>? get undesirableEffect {
    final value = _undesirableEffect;
    if (value == null) return null;
    if (_undesirableEffect is EqualUnmodifiableListView)
      return _undesirableEffect;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [applicability] An expression that returns true or false, indicating whether the indication is applicable or not, after having applied its other elements.
  @override
  final Expression? applicability;

  /// [otherTherapy] Information about the use of the medicinal product in relation to other therapies described as part of the indication.
  final List<ClinicalUseDefinitionOtherTherapy>? _otherTherapy;

  /// [otherTherapy] Information about the use of the medicinal product in relation to other therapies described as part of the indication.
  @override
  List<ClinicalUseDefinitionOtherTherapy>? get otherTherapy {
    final value = _otherTherapy;
    if (value == null) return null;
    if (_otherTherapy is EqualUnmodifiableListView) return _otherTherapy;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ClinicalUseDefinitionIndication(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, diseaseSymptomProcedure: $diseaseSymptomProcedure, diseaseStatus: $diseaseStatus, comorbidity: $comorbidity, intendedEffect: $intendedEffect, durationRange: $durationRange, durationString: $durationString, durationStringElement: $durationStringElement, undesirableEffect: $undesirableEffect, applicability: $applicability, otherTherapy: $otherTherapy)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ClinicalUseDefinitionIndication &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(
                    other.diseaseSymptomProcedure, diseaseSymptomProcedure) ||
                other.diseaseSymptomProcedure == diseaseSymptomProcedure) &&
            (identical(other.diseaseStatus, diseaseStatus) ||
                other.diseaseStatus == diseaseStatus) &&
            const DeepCollectionEquality()
                .equals(other._comorbidity, _comorbidity) &&
            (identical(other.intendedEffect, intendedEffect) ||
                other.intendedEffect == intendedEffect) &&
            (identical(other.durationRange, durationRange) ||
                other.durationRange == durationRange) &&
            (identical(other.durationString, durationString) ||
                other.durationString == durationString) &&
            (identical(other.durationStringElement, durationStringElement) ||
                other.durationStringElement == durationStringElement) &&
            const DeepCollectionEquality()
                .equals(other._undesirableEffect, _undesirableEffect) &&
            (identical(other.applicability, applicability) ||
                other.applicability == applicability) &&
            const DeepCollectionEquality()
                .equals(other._otherTherapy, _otherTherapy));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      diseaseSymptomProcedure,
      diseaseStatus,
      const DeepCollectionEquality().hash(_comorbidity),
      intendedEffect,
      durationRange,
      durationString,
      durationStringElement,
      const DeepCollectionEquality().hash(_undesirableEffect),
      applicability,
      const DeepCollectionEquality().hash(_otherTherapy));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ClinicalUseDefinitionIndicationCopyWith<
          _$_ClinicalUseDefinitionIndication>
      get copyWith => __$$_ClinicalUseDefinitionIndicationCopyWithImpl<
          _$_ClinicalUseDefinitionIndication>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ClinicalUseDefinitionIndicationToJson(
      this,
    );
  }
}

abstract class _ClinicalUseDefinitionIndication
    extends ClinicalUseDefinitionIndication {
  factory _ClinicalUseDefinitionIndication(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableReference? diseaseSymptomProcedure,
      final CodeableReference? diseaseStatus,
      final List<CodeableReference>? comorbidity,
      final CodeableReference? intendedEffect,
      final Range? durationRange,
      final String? durationString,
      @JsonKey(name: '_durationString') final Element? durationStringElement,
      final List<Reference>? undesirableEffect,
      final Expression? applicability,
      final List<ClinicalUseDefinitionOtherTherapy>?
          otherTherapy}) = _$_ClinicalUseDefinitionIndication;
  _ClinicalUseDefinitionIndication._() : super._();

  factory _ClinicalUseDefinitionIndication.fromJson(Map<String, dynamic> json) =
      _$_ClinicalUseDefinitionIndication.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [diseaseSymptomProcedure] The situation that is being documented as an indicaton for this item.
  CodeableReference? get diseaseSymptomProcedure;
  @override

  /// [diseaseStatus] The status of the disease or symptom for the indication, for example "chronic" or "metastatic".
  CodeableReference? get diseaseStatus;
  @override

  /// [comorbidity] A comorbidity (concurrent condition) or coinfection as part of the indication.
  List<CodeableReference>? get comorbidity;
  @override

  /// [intendedEffect] The intended effect, aim or strategy to be achieved.
  CodeableReference? get intendedEffect;
  @override

  /// [durationRange] Timing or duration information, that may be associated with use with the indicated condition e.g. Adult patients suffering from myocardial infarction (from a few days until less than 35 days), ischaemic stroke (from 7 days until less than 6 months).
  Range? get durationRange;
  @override

  /// [durationString] Timing or duration information, that may be associated with use with the indicated condition e.g. Adult patients suffering from myocardial infarction (from a few days until less than 35 days), ischaemic stroke (from 7 days until less than 6 months).
  String? get durationString;
  @override

  /// [durationStringElement] ("_durationString") Extensions for durationString
  @JsonKey(name: '_durationString')
  Element? get durationStringElement;
  @override

  /// [undesirableEffect] An unwanted side effect or negative outcome that may happen if you use the drug (or other subject of this resource) for this indication.
  List<Reference>? get undesirableEffect;
  @override

  /// [applicability] An expression that returns true or false, indicating whether the indication is applicable or not, after having applied its other elements.
  Expression? get applicability;
  @override

  /// [otherTherapy] Information about the use of the medicinal product in relation to other therapies described as part of the indication.
  List<ClinicalUseDefinitionOtherTherapy>? get otherTherapy;
  @override
  @JsonKey(ignore: true)
  _$$_ClinicalUseDefinitionIndicationCopyWith<
          _$_ClinicalUseDefinitionIndication>
      get copyWith => throw _privateConstructorUsedError;
}

ClinicalUseDefinitionInteraction _$ClinicalUseDefinitionInteractionFromJson(
    Map<String, dynamic> json) {
  return _ClinicalUseDefinitionInteraction.fromJson(json);
}

/// @nodoc
mixin _$ClinicalUseDefinitionInteraction {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [interactant] The specific medication, food, substance or laboratory test that interacts.
  List<ClinicalUseDefinitionInteractant>? get interactant =>
      throw _privateConstructorUsedError;

  /// [type] The type of the interaction e.g. drug-drug interaction, drug-food interaction, drug-lab test interaction.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [effect] The effect of the interaction, for example "reduced gastric absorption of primary medication".
  CodeableReference? get effect => throw _privateConstructorUsedError;

  /// [incidence] The incidence of the interaction, e.g. theoretical, observed.
  CodeableConcept? get incidence => throw _privateConstructorUsedError;

  /// [management] Actions for managing the interaction.
  List<CodeableConcept>? get management => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ClinicalUseDefinitionInteractionCopyWith<ClinicalUseDefinitionInteraction>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClinicalUseDefinitionInteractionCopyWith<$Res> {
  factory $ClinicalUseDefinitionInteractionCopyWith(
          ClinicalUseDefinitionInteraction value,
          $Res Function(ClinicalUseDefinitionInteraction) then) =
      _$ClinicalUseDefinitionInteractionCopyWithImpl<$Res,
          ClinicalUseDefinitionInteraction>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<ClinicalUseDefinitionInteractant>? interactant,
      CodeableConcept? type,
      CodeableReference? effect,
      CodeableConcept? incidence,
      List<CodeableConcept>? management});

  $CodeableConceptCopyWith<$Res>? get type;
  $CodeableReferenceCopyWith<$Res>? get effect;
  $CodeableConceptCopyWith<$Res>? get incidence;
}

/// @nodoc
class _$ClinicalUseDefinitionInteractionCopyWithImpl<$Res,
        $Val extends ClinicalUseDefinitionInteraction>
    implements $ClinicalUseDefinitionInteractionCopyWith<$Res> {
  _$ClinicalUseDefinitionInteractionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? interactant = freezed,
    Object? type = freezed,
    Object? effect = freezed,
    Object? incidence = freezed,
    Object? management = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      interactant: freezed == interactant
          ? _value.interactant
          : interactant // ignore: cast_nullable_to_non_nullable
              as List<ClinicalUseDefinitionInteractant>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      effect: freezed == effect
          ? _value.effect
          : effect // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      incidence: freezed == incidence
          ? _value.incidence
          : incidence // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      management: freezed == management
          ? _value.management
          : management // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res>? get effect {
    if (_value.effect == null) {
      return null;
    }

    return $CodeableReferenceCopyWith<$Res>(_value.effect!, (value) {
      return _then(_value.copyWith(effect: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get incidence {
    if (_value.incidence == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.incidence!, (value) {
      return _then(_value.copyWith(incidence: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ClinicalUseDefinitionInteractionCopyWith<$Res>
    implements $ClinicalUseDefinitionInteractionCopyWith<$Res> {
  factory _$$_ClinicalUseDefinitionInteractionCopyWith(
          _$_ClinicalUseDefinitionInteraction value,
          $Res Function(_$_ClinicalUseDefinitionInteraction) then) =
      __$$_ClinicalUseDefinitionInteractionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<ClinicalUseDefinitionInteractant>? interactant,
      CodeableConcept? type,
      CodeableReference? effect,
      CodeableConcept? incidence,
      List<CodeableConcept>? management});

  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $CodeableReferenceCopyWith<$Res>? get effect;
  @override
  $CodeableConceptCopyWith<$Res>? get incidence;
}

/// @nodoc
class __$$_ClinicalUseDefinitionInteractionCopyWithImpl<$Res>
    extends _$ClinicalUseDefinitionInteractionCopyWithImpl<$Res,
        _$_ClinicalUseDefinitionInteraction>
    implements _$$_ClinicalUseDefinitionInteractionCopyWith<$Res> {
  __$$_ClinicalUseDefinitionInteractionCopyWithImpl(
      _$_ClinicalUseDefinitionInteraction _value,
      $Res Function(_$_ClinicalUseDefinitionInteraction) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? interactant = freezed,
    Object? type = freezed,
    Object? effect = freezed,
    Object? incidence = freezed,
    Object? management = freezed,
  }) {
    return _then(_$_ClinicalUseDefinitionInteraction(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      interactant: freezed == interactant
          ? _value._interactant
          : interactant // ignore: cast_nullable_to_non_nullable
              as List<ClinicalUseDefinitionInteractant>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      effect: freezed == effect
          ? _value.effect
          : effect // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      incidence: freezed == incidence
          ? _value.incidence
          : incidence // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      management: freezed == management
          ? _value._management
          : management // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ClinicalUseDefinitionInteraction
    extends _ClinicalUseDefinitionInteraction {
  _$_ClinicalUseDefinitionInteraction(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<ClinicalUseDefinitionInteractant>? interactant,
      this.type,
      this.effect,
      this.incidence,
      final List<CodeableConcept>? management})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _interactant = interactant,
        _management = management,
        super._();

  factory _$_ClinicalUseDefinitionInteraction.fromJson(
          Map<String, dynamic> json) =>
      _$$_ClinicalUseDefinitionInteractionFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [interactant] The specific medication, food, substance or laboratory test that interacts.
  final List<ClinicalUseDefinitionInteractant>? _interactant;

  /// [interactant] The specific medication, food, substance or laboratory test that interacts.
  @override
  List<ClinicalUseDefinitionInteractant>? get interactant {
    final value = _interactant;
    if (value == null) return null;
    if (_interactant is EqualUnmodifiableListView) return _interactant;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] The type of the interaction e.g. drug-drug interaction, drug-food interaction, drug-lab test interaction.
  @override
  final CodeableConcept? type;

  /// [effect] The effect of the interaction, for example "reduced gastric absorption of primary medication".
  @override
  final CodeableReference? effect;

  /// [incidence] The incidence of the interaction, e.g. theoretical, observed.
  @override
  final CodeableConcept? incidence;

  /// [management] Actions for managing the interaction.
  final List<CodeableConcept>? _management;

  /// [management] Actions for managing the interaction.
  @override
  List<CodeableConcept>? get management {
    final value = _management;
    if (value == null) return null;
    if (_management is EqualUnmodifiableListView) return _management;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ClinicalUseDefinitionInteraction(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, interactant: $interactant, type: $type, effect: $effect, incidence: $incidence, management: $management)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ClinicalUseDefinitionInteraction &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._interactant, _interactant) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.effect, effect) || other.effect == effect) &&
            (identical(other.incidence, incidence) ||
                other.incidence == incidence) &&
            const DeepCollectionEquality()
                .equals(other._management, _management));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      const DeepCollectionEquality().hash(_interactant),
      type,
      effect,
      incidence,
      const DeepCollectionEquality().hash(_management));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ClinicalUseDefinitionInteractionCopyWith<
          _$_ClinicalUseDefinitionInteraction>
      get copyWith => __$$_ClinicalUseDefinitionInteractionCopyWithImpl<
          _$_ClinicalUseDefinitionInteraction>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ClinicalUseDefinitionInteractionToJson(
      this,
    );
  }
}

abstract class _ClinicalUseDefinitionInteraction
    extends ClinicalUseDefinitionInteraction {
  factory _ClinicalUseDefinitionInteraction(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final List<ClinicalUseDefinitionInteractant>? interactant,
          final CodeableConcept? type,
          final CodeableReference? effect,
          final CodeableConcept? incidence,
          final List<CodeableConcept>? management}) =
      _$_ClinicalUseDefinitionInteraction;
  _ClinicalUseDefinitionInteraction._() : super._();

  factory _ClinicalUseDefinitionInteraction.fromJson(
      Map<String, dynamic> json) = _$_ClinicalUseDefinitionInteraction.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [interactant] The specific medication, food, substance or laboratory test that interacts.
  List<ClinicalUseDefinitionInteractant>? get interactant;
  @override

  /// [type] The type of the interaction e.g. drug-drug interaction, drug-food interaction, drug-lab test interaction.
  CodeableConcept? get type;
  @override

  /// [effect] The effect of the interaction, for example "reduced gastric absorption of primary medication".
  CodeableReference? get effect;
  @override

  /// [incidence] The incidence of the interaction, e.g. theoretical, observed.
  CodeableConcept? get incidence;
  @override

  /// [management] Actions for managing the interaction.
  List<CodeableConcept>? get management;
  @override
  @JsonKey(ignore: true)
  _$$_ClinicalUseDefinitionInteractionCopyWith<
          _$_ClinicalUseDefinitionInteraction>
      get copyWith => throw _privateConstructorUsedError;
}

ClinicalUseDefinitionInteractant _$ClinicalUseDefinitionInteractantFromJson(
    Map<String, dynamic> json) {
  return _ClinicalUseDefinitionInteractant.fromJson(json);
}

/// @nodoc
mixin _$ClinicalUseDefinitionInteractant {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [itemReference] The specific medication, food or laboratory test that interacts.
  Reference? get itemReference => throw _privateConstructorUsedError;

  /// [itemCodeableConcept] The specific medication, food or laboratory test that interacts.
  CodeableConcept? get itemCodeableConcept =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ClinicalUseDefinitionInteractantCopyWith<ClinicalUseDefinitionInteractant>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClinicalUseDefinitionInteractantCopyWith<$Res> {
  factory $ClinicalUseDefinitionInteractantCopyWith(
          ClinicalUseDefinitionInteractant value,
          $Res Function(ClinicalUseDefinitionInteractant) then) =
      _$ClinicalUseDefinitionInteractantCopyWithImpl<$Res,
          ClinicalUseDefinitionInteractant>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Reference? itemReference,
      CodeableConcept? itemCodeableConcept});

  $ReferenceCopyWith<$Res>? get itemReference;
  $CodeableConceptCopyWith<$Res>? get itemCodeableConcept;
}

/// @nodoc
class _$ClinicalUseDefinitionInteractantCopyWithImpl<$Res,
        $Val extends ClinicalUseDefinitionInteractant>
    implements $ClinicalUseDefinitionInteractantCopyWith<$Res> {
  _$ClinicalUseDefinitionInteractantCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? itemReference = freezed,
    Object? itemCodeableConcept = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      itemReference: freezed == itemReference
          ? _value.itemReference
          : itemReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      itemCodeableConcept: freezed == itemCodeableConcept
          ? _value.itemCodeableConcept
          : itemCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get itemReference {
    if (_value.itemReference == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.itemReference!, (value) {
      return _then(_value.copyWith(itemReference: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get itemCodeableConcept {
    if (_value.itemCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.itemCodeableConcept!, (value) {
      return _then(_value.copyWith(itemCodeableConcept: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ClinicalUseDefinitionInteractantCopyWith<$Res>
    implements $ClinicalUseDefinitionInteractantCopyWith<$Res> {
  factory _$$_ClinicalUseDefinitionInteractantCopyWith(
          _$_ClinicalUseDefinitionInteractant value,
          $Res Function(_$_ClinicalUseDefinitionInteractant) then) =
      __$$_ClinicalUseDefinitionInteractantCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Reference? itemReference,
      CodeableConcept? itemCodeableConcept});

  @override
  $ReferenceCopyWith<$Res>? get itemReference;
  @override
  $CodeableConceptCopyWith<$Res>? get itemCodeableConcept;
}

/// @nodoc
class __$$_ClinicalUseDefinitionInteractantCopyWithImpl<$Res>
    extends _$ClinicalUseDefinitionInteractantCopyWithImpl<$Res,
        _$_ClinicalUseDefinitionInteractant>
    implements _$$_ClinicalUseDefinitionInteractantCopyWith<$Res> {
  __$$_ClinicalUseDefinitionInteractantCopyWithImpl(
      _$_ClinicalUseDefinitionInteractant _value,
      $Res Function(_$_ClinicalUseDefinitionInteractant) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? itemReference = freezed,
    Object? itemCodeableConcept = freezed,
  }) {
    return _then(_$_ClinicalUseDefinitionInteractant(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      itemReference: freezed == itemReference
          ? _value.itemReference
          : itemReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      itemCodeableConcept: freezed == itemCodeableConcept
          ? _value.itemCodeableConcept
          : itemCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ClinicalUseDefinitionInteractant
    extends _ClinicalUseDefinitionInteractant {
  _$_ClinicalUseDefinitionInteractant(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.itemReference,
      this.itemCodeableConcept})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_ClinicalUseDefinitionInteractant.fromJson(
          Map<String, dynamic> json) =>
      _$$_ClinicalUseDefinitionInteractantFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [itemReference] The specific medication, food or laboratory test that interacts.
  @override
  final Reference? itemReference;

  /// [itemCodeableConcept] The specific medication, food or laboratory test that interacts.
  @override
  final CodeableConcept? itemCodeableConcept;

  @override
  String toString() {
    return 'ClinicalUseDefinitionInteractant(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, itemReference: $itemReference, itemCodeableConcept: $itemCodeableConcept)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ClinicalUseDefinitionInteractant &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.itemReference, itemReference) ||
                other.itemReference == itemReference) &&
            (identical(other.itemCodeableConcept, itemCodeableConcept) ||
                other.itemCodeableConcept == itemCodeableConcept));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      itemReference,
      itemCodeableConcept);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ClinicalUseDefinitionInteractantCopyWith<
          _$_ClinicalUseDefinitionInteractant>
      get copyWith => __$$_ClinicalUseDefinitionInteractantCopyWithImpl<
          _$_ClinicalUseDefinitionInteractant>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ClinicalUseDefinitionInteractantToJson(
      this,
    );
  }
}

abstract class _ClinicalUseDefinitionInteractant
    extends ClinicalUseDefinitionInteractant {
  factory _ClinicalUseDefinitionInteractant(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final Reference? itemReference,
          final CodeableConcept? itemCodeableConcept}) =
      _$_ClinicalUseDefinitionInteractant;
  _ClinicalUseDefinitionInteractant._() : super._();

  factory _ClinicalUseDefinitionInteractant.fromJson(
      Map<String, dynamic> json) = _$_ClinicalUseDefinitionInteractant.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [itemReference] The specific medication, food or laboratory test that interacts.
  Reference? get itemReference;
  @override

  /// [itemCodeableConcept] The specific medication, food or laboratory test that interacts.
  CodeableConcept? get itemCodeableConcept;
  @override
  @JsonKey(ignore: true)
  _$$_ClinicalUseDefinitionInteractantCopyWith<
          _$_ClinicalUseDefinitionInteractant>
      get copyWith => throw _privateConstructorUsedError;
}

ClinicalUseDefinitionUndesirableEffect
    _$ClinicalUseDefinitionUndesirableEffectFromJson(
        Map<String, dynamic> json) {
  return _ClinicalUseDefinitionUndesirableEffect.fromJson(json);
}

/// @nodoc
mixin _$ClinicalUseDefinitionUndesirableEffect {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [symptomConditionEffect] The situation in which the undesirable effect may manifest.
  CodeableReference? get symptomConditionEffect =>
      throw _privateConstructorUsedError;

  /// [classification] High level classification of the effect.
  CodeableConcept? get classification => throw _privateConstructorUsedError;

  /// [frequencyOfOccurrence] How often the effect is seen.
  CodeableConcept? get frequencyOfOccurrence =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ClinicalUseDefinitionUndesirableEffectCopyWith<
          ClinicalUseDefinitionUndesirableEffect>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClinicalUseDefinitionUndesirableEffectCopyWith<$Res> {
  factory $ClinicalUseDefinitionUndesirableEffectCopyWith(
          ClinicalUseDefinitionUndesirableEffect value,
          $Res Function(ClinicalUseDefinitionUndesirableEffect) then) =
      _$ClinicalUseDefinitionUndesirableEffectCopyWithImpl<$Res,
          ClinicalUseDefinitionUndesirableEffect>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? symptomConditionEffect,
      CodeableConcept? classification,
      CodeableConcept? frequencyOfOccurrence});

  $CodeableReferenceCopyWith<$Res>? get symptomConditionEffect;
  $CodeableConceptCopyWith<$Res>? get classification;
  $CodeableConceptCopyWith<$Res>? get frequencyOfOccurrence;
}

/// @nodoc
class _$ClinicalUseDefinitionUndesirableEffectCopyWithImpl<$Res,
        $Val extends ClinicalUseDefinitionUndesirableEffect>
    implements $ClinicalUseDefinitionUndesirableEffectCopyWith<$Res> {
  _$ClinicalUseDefinitionUndesirableEffectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? symptomConditionEffect = freezed,
    Object? classification = freezed,
    Object? frequencyOfOccurrence = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      symptomConditionEffect: freezed == symptomConditionEffect
          ? _value.symptomConditionEffect
          : symptomConditionEffect // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      classification: freezed == classification
          ? _value.classification
          : classification // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      frequencyOfOccurrence: freezed == frequencyOfOccurrence
          ? _value.frequencyOfOccurrence
          : frequencyOfOccurrence // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res>? get symptomConditionEffect {
    if (_value.symptomConditionEffect == null) {
      return null;
    }

    return $CodeableReferenceCopyWith<$Res>(_value.symptomConditionEffect!,
        (value) {
      return _then(_value.copyWith(symptomConditionEffect: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get classification {
    if (_value.classification == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.classification!, (value) {
      return _then(_value.copyWith(classification: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get frequencyOfOccurrence {
    if (_value.frequencyOfOccurrence == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.frequencyOfOccurrence!,
        (value) {
      return _then(_value.copyWith(frequencyOfOccurrence: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ClinicalUseDefinitionUndesirableEffectCopyWith<$Res>
    implements $ClinicalUseDefinitionUndesirableEffectCopyWith<$Res> {
  factory _$$_ClinicalUseDefinitionUndesirableEffectCopyWith(
          _$_ClinicalUseDefinitionUndesirableEffect value,
          $Res Function(_$_ClinicalUseDefinitionUndesirableEffect) then) =
      __$$_ClinicalUseDefinitionUndesirableEffectCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? symptomConditionEffect,
      CodeableConcept? classification,
      CodeableConcept? frequencyOfOccurrence});

  @override
  $CodeableReferenceCopyWith<$Res>? get symptomConditionEffect;
  @override
  $CodeableConceptCopyWith<$Res>? get classification;
  @override
  $CodeableConceptCopyWith<$Res>? get frequencyOfOccurrence;
}

/// @nodoc
class __$$_ClinicalUseDefinitionUndesirableEffectCopyWithImpl<$Res>
    extends _$ClinicalUseDefinitionUndesirableEffectCopyWithImpl<$Res,
        _$_ClinicalUseDefinitionUndesirableEffect>
    implements _$$_ClinicalUseDefinitionUndesirableEffectCopyWith<$Res> {
  __$$_ClinicalUseDefinitionUndesirableEffectCopyWithImpl(
      _$_ClinicalUseDefinitionUndesirableEffect _value,
      $Res Function(_$_ClinicalUseDefinitionUndesirableEffect) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? symptomConditionEffect = freezed,
    Object? classification = freezed,
    Object? frequencyOfOccurrence = freezed,
  }) {
    return _then(_$_ClinicalUseDefinitionUndesirableEffect(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      symptomConditionEffect: freezed == symptomConditionEffect
          ? _value.symptomConditionEffect
          : symptomConditionEffect // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      classification: freezed == classification
          ? _value.classification
          : classification // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      frequencyOfOccurrence: freezed == frequencyOfOccurrence
          ? _value.frequencyOfOccurrence
          : frequencyOfOccurrence // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ClinicalUseDefinitionUndesirableEffect
    extends _ClinicalUseDefinitionUndesirableEffect {
  _$_ClinicalUseDefinitionUndesirableEffect(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.symptomConditionEffect,
      this.classification,
      this.frequencyOfOccurrence})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_ClinicalUseDefinitionUndesirableEffect.fromJson(
          Map<String, dynamic> json) =>
      _$$_ClinicalUseDefinitionUndesirableEffectFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [symptomConditionEffect] The situation in which the undesirable effect may manifest.
  @override
  final CodeableReference? symptomConditionEffect;

  /// [classification] High level classification of the effect.
  @override
  final CodeableConcept? classification;

  /// [frequencyOfOccurrence] How often the effect is seen.
  @override
  final CodeableConcept? frequencyOfOccurrence;

  @override
  String toString() {
    return 'ClinicalUseDefinitionUndesirableEffect(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, symptomConditionEffect: $symptomConditionEffect, classification: $classification, frequencyOfOccurrence: $frequencyOfOccurrence)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ClinicalUseDefinitionUndesirableEffect &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.symptomConditionEffect, symptomConditionEffect) ||
                other.symptomConditionEffect == symptomConditionEffect) &&
            (identical(other.classification, classification) ||
                other.classification == classification) &&
            (identical(other.frequencyOfOccurrence, frequencyOfOccurrence) ||
                other.frequencyOfOccurrence == frequencyOfOccurrence));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      symptomConditionEffect,
      classification,
      frequencyOfOccurrence);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ClinicalUseDefinitionUndesirableEffectCopyWith<
          _$_ClinicalUseDefinitionUndesirableEffect>
      get copyWith => __$$_ClinicalUseDefinitionUndesirableEffectCopyWithImpl<
          _$_ClinicalUseDefinitionUndesirableEffect>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ClinicalUseDefinitionUndesirableEffectToJson(
      this,
    );
  }
}

abstract class _ClinicalUseDefinitionUndesirableEffect
    extends ClinicalUseDefinitionUndesirableEffect {
  factory _ClinicalUseDefinitionUndesirableEffect(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableReference? symptomConditionEffect,
          final CodeableConcept? classification,
          final CodeableConcept? frequencyOfOccurrence}) =
      _$_ClinicalUseDefinitionUndesirableEffect;
  _ClinicalUseDefinitionUndesirableEffect._() : super._();

  factory _ClinicalUseDefinitionUndesirableEffect.fromJson(
          Map<String, dynamic> json) =
      _$_ClinicalUseDefinitionUndesirableEffect.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [symptomConditionEffect] The situation in which the undesirable effect may manifest.
  CodeableReference? get symptomConditionEffect;
  @override

  /// [classification] High level classification of the effect.
  CodeableConcept? get classification;
  @override

  /// [frequencyOfOccurrence] How often the effect is seen.
  CodeableConcept? get frequencyOfOccurrence;
  @override
  @JsonKey(ignore: true)
  _$$_ClinicalUseDefinitionUndesirableEffectCopyWith<
          _$_ClinicalUseDefinitionUndesirableEffect>
      get copyWith => throw _privateConstructorUsedError;
}

ClinicalUseDefinitionWarning _$ClinicalUseDefinitionWarningFromJson(
    Map<String, dynamic> json) {
  return _ClinicalUseDefinitionWarning.fromJson(json);
}

/// @nodoc
mixin _$ClinicalUseDefinitionWarning {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [description] A textual definition of this warning, with formatting.
  Markdown? get description => throw _privateConstructorUsedError;

  /// [descriptionElement] ("_description") Extensions for description
  @JsonKey(name: '_description')
  Element? get descriptionElement => throw _privateConstructorUsedError;

  /// [code] A coded or unformatted textual definition of this warning.
  CodeableConcept? get code => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ClinicalUseDefinitionWarningCopyWith<ClinicalUseDefinitionWarning>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClinicalUseDefinitionWarningCopyWith<$Res> {
  factory $ClinicalUseDefinitionWarningCopyWith(
          ClinicalUseDefinitionWarning value,
          $Res Function(ClinicalUseDefinitionWarning) then) =
      _$ClinicalUseDefinitionWarningCopyWithImpl<$Res,
          ClinicalUseDefinitionWarning>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Markdown? description,
      @JsonKey(name: '_description') Element? descriptionElement,
      CodeableConcept? code});

  $ElementCopyWith<$Res>? get descriptionElement;
  $CodeableConceptCopyWith<$Res>? get code;
}

/// @nodoc
class _$ClinicalUseDefinitionWarningCopyWithImpl<$Res,
        $Val extends ClinicalUseDefinitionWarning>
    implements $ClinicalUseDefinitionWarningCopyWith<$Res> {
  _$ClinicalUseDefinitionWarningCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? code = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get descriptionElement {
    if (_value.descriptionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.descriptionElement!, (value) {
      return _then(_value.copyWith(descriptionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get code {
    if (_value.code == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.code!, (value) {
      return _then(_value.copyWith(code: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ClinicalUseDefinitionWarningCopyWith<$Res>
    implements $ClinicalUseDefinitionWarningCopyWith<$Res> {
  factory _$$_ClinicalUseDefinitionWarningCopyWith(
          _$_ClinicalUseDefinitionWarning value,
          $Res Function(_$_ClinicalUseDefinitionWarning) then) =
      __$$_ClinicalUseDefinitionWarningCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Markdown? description,
      @JsonKey(name: '_description') Element? descriptionElement,
      CodeableConcept? code});

  @override
  $ElementCopyWith<$Res>? get descriptionElement;
  @override
  $CodeableConceptCopyWith<$Res>? get code;
}

/// @nodoc
class __$$_ClinicalUseDefinitionWarningCopyWithImpl<$Res>
    extends _$ClinicalUseDefinitionWarningCopyWithImpl<$Res,
        _$_ClinicalUseDefinitionWarning>
    implements _$$_ClinicalUseDefinitionWarningCopyWith<$Res> {
  __$$_ClinicalUseDefinitionWarningCopyWithImpl(
      _$_ClinicalUseDefinitionWarning _value,
      $Res Function(_$_ClinicalUseDefinitionWarning) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? code = freezed,
  }) {
    return _then(_$_ClinicalUseDefinitionWarning(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ClinicalUseDefinitionWarning extends _ClinicalUseDefinitionWarning {
  _$_ClinicalUseDefinitionWarning(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.description,
      @JsonKey(name: '_description') this.descriptionElement,
      this.code})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_ClinicalUseDefinitionWarning.fromJson(Map<String, dynamic> json) =>
      _$$_ClinicalUseDefinitionWarningFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [description] A textual definition of this warning, with formatting.
  @override
  final Markdown? description;

  /// [descriptionElement] ("_description") Extensions for description
  @override
  @JsonKey(name: '_description')
  final Element? descriptionElement;

  /// [code] A coded or unformatted textual definition of this warning.
  @override
  final CodeableConcept? code;

  @override
  String toString() {
    return 'ClinicalUseDefinitionWarning(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, description: $description, descriptionElement: $descriptionElement, code: $code)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ClinicalUseDefinitionWarning &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.descriptionElement, descriptionElement) ||
                other.descriptionElement == descriptionElement) &&
            (identical(other.code, code) || other.code == code));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      description,
      descriptionElement,
      code);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ClinicalUseDefinitionWarningCopyWith<_$_ClinicalUseDefinitionWarning>
      get copyWith => __$$_ClinicalUseDefinitionWarningCopyWithImpl<
          _$_ClinicalUseDefinitionWarning>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ClinicalUseDefinitionWarningToJson(
      this,
    );
  }
}

abstract class _ClinicalUseDefinitionWarning
    extends ClinicalUseDefinitionWarning {
  factory _ClinicalUseDefinitionWarning(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final Markdown? description,
      @JsonKey(name: '_description') final Element? descriptionElement,
      final CodeableConcept? code}) = _$_ClinicalUseDefinitionWarning;
  _ClinicalUseDefinitionWarning._() : super._();

  factory _ClinicalUseDefinitionWarning.fromJson(Map<String, dynamic> json) =
      _$_ClinicalUseDefinitionWarning.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [description] A textual definition of this warning, with formatting.
  Markdown? get description;
  @override

  /// [descriptionElement] ("_description") Extensions for description
  @JsonKey(name: '_description')
  Element? get descriptionElement;
  @override

  /// [code] A coded or unformatted textual definition of this warning.
  CodeableConcept? get code;
  @override
  @JsonKey(ignore: true)
  _$$_ClinicalUseDefinitionWarningCopyWith<_$_ClinicalUseDefinitionWarning>
      get copyWith => throw _privateConstructorUsedError;
}

Ingredient _$IngredientFromJson(Map<String, dynamic> json) {
  return _Ingredient.fromJson(json);
}

/// @nodoc
mixin _$Ingredient {
  /// [resourceType] This is a Ingredient resource
  @JsonKey(unknownEnumValue: R5ResourceType.Ingredient)
  R5ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] The identifier(s) of this Ingredient that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate.
  Identifier? get identifier => throw _privateConstructorUsedError;

  /// [status] The status of this ingredient. Enables tracking the life-cycle of the content.
  Code? get status => throw _privateConstructorUsedError;

  /// [statusElement] ("_status") Extensions for status
  @JsonKey(name: '_status')
  Element? get statusElement => throw _privateConstructorUsedError;

  /// [for_] ("for") The product which this ingredient is a constituent part of.
  @JsonKey(name: 'for')
  List<Reference>? get for_ => throw _privateConstructorUsedError;

  /// [role] A classification of the ingredient identifying its purpose within the product, e.g. active, inactive.
  CodeableConcept get role => throw _privateConstructorUsedError;

  /// [function_] ("function") A classification of the ingredient identifying its precise purpose(s) in the drug product. This extends the Ingredient.role to add more detail. Example: antioxidant, alkalizing agent.
  @JsonKey(name: 'function')
  List<CodeableConcept>? get function_ => throw _privateConstructorUsedError;

  /// [group] A classification of the ingredient according to where in the physical item it tends to be used, such the outer shell of a tablet, inner body or ink.
  CodeableConcept? get group => throw _privateConstructorUsedError;

  /// [allergenicIndicator] If the ingredient is a known or suspected allergen. Note that this is a property of the substance, so if a reference to a SubstanceDefinition is used to decribe that (rather than just a code), the allergen information should go there, not here.
  Boolean? get allergenicIndicator => throw _privateConstructorUsedError;

  /// [allergenicIndicatorElement] ("_allergenicIndicator") Extensions for allergenicIndicator
  @JsonKey(name: '_allergenicIndicator')
  Element? get allergenicIndicatorElement => throw _privateConstructorUsedError;

  /// [manufacturer] The organization(s) that manufacture this ingredient. Can be used to indicate:         1) Organizations we are aware of that manufacture this ingredient         2) Specific Manufacturer(s) currently being used         3) Set of organisations allowed to manufacture this ingredient for this product         Users must be clear on the application of context relevant to their use case.
  List<IngredientManufacturer>? get manufacturer =>
      throw _privateConstructorUsedError;

  /// [substance] The substance that comprises this ingredient.
  IngredientSubstance get substance => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $IngredientCopyWith<Ingredient> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IngredientCopyWith<$Res> {
  factory $IngredientCopyWith(
          Ingredient value, $Res Function(Ingredient) then) =
      _$IngredientCopyWithImpl<$Res, Ingredient>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.Ingredient)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Identifier? identifier,
      Code? status,
      @JsonKey(name: '_status')
          Element? statusElement,
      @JsonKey(name: 'for')
          List<Reference>? for_,
      CodeableConcept role,
      @JsonKey(name: 'function')
          List<CodeableConcept>? function_,
      CodeableConcept? group,
      Boolean? allergenicIndicator,
      @JsonKey(name: '_allergenicIndicator')
          Element? allergenicIndicatorElement,
      List<IngredientManufacturer>? manufacturer,
      IngredientSubstance substance});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $IdentifierCopyWith<$Res>? get identifier;
  $ElementCopyWith<$Res>? get statusElement;
  $CodeableConceptCopyWith<$Res> get role;
  $CodeableConceptCopyWith<$Res>? get group;
  $ElementCopyWith<$Res>? get allergenicIndicatorElement;
  $IngredientSubstanceCopyWith<$Res> get substance;
}

/// @nodoc
class _$IngredientCopyWithImpl<$Res, $Val extends Ingredient>
    implements $IngredientCopyWith<$Res> {
  _$IngredientCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? for_ = freezed,
    Object? role = null,
    Object? function_ = freezed,
    Object? group = freezed,
    Object? allergenicIndicator = freezed,
    Object? allergenicIndicatorElement = freezed,
    Object? manufacturer = freezed,
    Object? substance = null,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as Code?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      for_: freezed == for_
          ? _value.for_
          : for_ // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      function_: freezed == function_
          ? _value.function_
          : function_ // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      group: freezed == group
          ? _value.group
          : group // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      allergenicIndicator: freezed == allergenicIndicator
          ? _value.allergenicIndicator
          : allergenicIndicator // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      allergenicIndicatorElement: freezed == allergenicIndicatorElement
          ? _value.allergenicIndicatorElement
          : allergenicIndicatorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      manufacturer: freezed == manufacturer
          ? _value.manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<IngredientManufacturer>?,
      substance: null == substance
          ? _value.substance
          : substance // ignore: cast_nullable_to_non_nullable
              as IngredientSubstance,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get identifier {
    if (_value.identifier == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.identifier!, (value) {
      return _then(_value.copyWith(identifier: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusElement {
    if (_value.statusElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusElement!, (value) {
      return _then(_value.copyWith(statusElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get role {
    return $CodeableConceptCopyWith<$Res>(_value.role, (value) {
      return _then(_value.copyWith(role: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get group {
    if (_value.group == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.group!, (value) {
      return _then(_value.copyWith(group: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get allergenicIndicatorElement {
    if (_value.allergenicIndicatorElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.allergenicIndicatorElement!, (value) {
      return _then(_value.copyWith(allergenicIndicatorElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $IngredientSubstanceCopyWith<$Res> get substance {
    return $IngredientSubstanceCopyWith<$Res>(_value.substance, (value) {
      return _then(_value.copyWith(substance: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_IngredientCopyWith<$Res>
    implements $IngredientCopyWith<$Res> {
  factory _$$_IngredientCopyWith(
          _$_Ingredient value, $Res Function(_$_Ingredient) then) =
      __$$_IngredientCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.Ingredient)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Identifier? identifier,
      Code? status,
      @JsonKey(name: '_status')
          Element? statusElement,
      @JsonKey(name: 'for')
          List<Reference>? for_,
      CodeableConcept role,
      @JsonKey(name: 'function')
          List<CodeableConcept>? function_,
      CodeableConcept? group,
      Boolean? allergenicIndicator,
      @JsonKey(name: '_allergenicIndicator')
          Element? allergenicIndicatorElement,
      List<IngredientManufacturer>? manufacturer,
      IngredientSubstance substance});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $IdentifierCopyWith<$Res>? get identifier;
  @override
  $ElementCopyWith<$Res>? get statusElement;
  @override
  $CodeableConceptCopyWith<$Res> get role;
  @override
  $CodeableConceptCopyWith<$Res>? get group;
  @override
  $ElementCopyWith<$Res>? get allergenicIndicatorElement;
  @override
  $IngredientSubstanceCopyWith<$Res> get substance;
}

/// @nodoc
class __$$_IngredientCopyWithImpl<$Res>
    extends _$IngredientCopyWithImpl<$Res, _$_Ingredient>
    implements _$$_IngredientCopyWith<$Res> {
  __$$_IngredientCopyWithImpl(
      _$_Ingredient _value, $Res Function(_$_Ingredient) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? for_ = freezed,
    Object? role = null,
    Object? function_ = freezed,
    Object? group = freezed,
    Object? allergenicIndicator = freezed,
    Object? allergenicIndicatorElement = freezed,
    Object? manufacturer = freezed,
    Object? substance = null,
  }) {
    return _then(_$_Ingredient(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as Code?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      for_: freezed == for_
          ? _value._for_
          : for_ // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      function_: freezed == function_
          ? _value._function_
          : function_ // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      group: freezed == group
          ? _value.group
          : group // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      allergenicIndicator: freezed == allergenicIndicator
          ? _value.allergenicIndicator
          : allergenicIndicator // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      allergenicIndicatorElement: freezed == allergenicIndicatorElement
          ? _value.allergenicIndicatorElement
          : allergenicIndicatorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      manufacturer: freezed == manufacturer
          ? _value._manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<IngredientManufacturer>?,
      substance: null == substance
          ? _value.substance
          : substance // ignore: cast_nullable_to_non_nullable
              as IngredientSubstance,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Ingredient extends _Ingredient {
  _$_Ingredient(
      {@JsonKey(unknownEnumValue: R5ResourceType.Ingredient)
          this.resourceType = R5ResourceType.Ingredient,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules')
          this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language')
          this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.identifier,
      this.status,
      @JsonKey(name: '_status')
          this.statusElement,
      @JsonKey(name: 'for')
          final List<Reference>? for_,
      required this.role,
      @JsonKey(name: 'function')
          final List<CodeableConcept>? function_,
      this.group,
      this.allergenicIndicator,
      @JsonKey(name: '_allergenicIndicator')
          this.allergenicIndicatorElement,
      final List<IngredientManufacturer>? manufacturer,
      required this.substance})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _for_ = for_,
        _function_ = function_,
        _manufacturer = manufacturer,
        super._();

  factory _$_Ingredient.fromJson(Map<String, dynamic> json) =>
      _$$_IngredientFromJson(json);

  /// [resourceType] This is a Ingredient resource
  @override
  @JsonKey(unknownEnumValue: R5ResourceType.Ingredient)
  final R5ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.
  @override
  final Code? language;

  /// [languageElement] ("_language") Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] The identifier(s) of this Ingredient that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate.
  @override
  final Identifier? identifier;

  /// [status] The status of this ingredient. Enables tracking the life-cycle of the content.
  @override
  final Code? status;

  /// [statusElement] ("_status") Extensions for status
  @override
  @JsonKey(name: '_status')
  final Element? statusElement;

  /// [for_] ("for") The product which this ingredient is a constituent part of.
  final List<Reference>? _for_;

  /// [for_] ("for") The product which this ingredient is a constituent part of.
  @override
  @JsonKey(name: 'for')
  List<Reference>? get for_ {
    final value = _for_;
    if (value == null) return null;
    if (_for_ is EqualUnmodifiableListView) return _for_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [role] A classification of the ingredient identifying its purpose within the product, e.g. active, inactive.
  @override
  final CodeableConcept role;

  /// [function_] ("function") A classification of the ingredient identifying its precise purpose(s) in the drug product. This extends the Ingredient.role to add more detail. Example: antioxidant, alkalizing agent.
  final List<CodeableConcept>? _function_;

  /// [function_] ("function") A classification of the ingredient identifying its precise purpose(s) in the drug product. This extends the Ingredient.role to add more detail. Example: antioxidant, alkalizing agent.
  @override
  @JsonKey(name: 'function')
  List<CodeableConcept>? get function_ {
    final value = _function_;
    if (value == null) return null;
    if (_function_ is EqualUnmodifiableListView) return _function_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [group] A classification of the ingredient according to where in the physical item it tends to be used, such the outer shell of a tablet, inner body or ink.
  @override
  final CodeableConcept? group;

  /// [allergenicIndicator] If the ingredient is a known or suspected allergen. Note that this is a property of the substance, so if a reference to a SubstanceDefinition is used to decribe that (rather than just a code), the allergen information should go there, not here.
  @override
  final Boolean? allergenicIndicator;

  /// [allergenicIndicatorElement] ("_allergenicIndicator") Extensions for allergenicIndicator
  @override
  @JsonKey(name: '_allergenicIndicator')
  final Element? allergenicIndicatorElement;

  /// [manufacturer] The organization(s) that manufacture this ingredient. Can be used to indicate:         1) Organizations we are aware of that manufacture this ingredient         2) Specific Manufacturer(s) currently being used         3) Set of organisations allowed to manufacture this ingredient for this product         Users must be clear on the application of context relevant to their use case.
  final List<IngredientManufacturer>? _manufacturer;

  /// [manufacturer] The organization(s) that manufacture this ingredient. Can be used to indicate:         1) Organizations we are aware of that manufacture this ingredient         2) Specific Manufacturer(s) currently being used         3) Set of organisations allowed to manufacture this ingredient for this product         Users must be clear on the application of context relevant to their use case.
  @override
  List<IngredientManufacturer>? get manufacturer {
    final value = _manufacturer;
    if (value == null) return null;
    if (_manufacturer is EqualUnmodifiableListView) return _manufacturer;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [substance] The substance that comprises this ingredient.
  @override
  final IngredientSubstance substance;

  @override
  String toString() {
    return 'Ingredient(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, status: $status, statusElement: $statusElement, for_: $for_, role: $role, function_: $function_, group: $group, allergenicIndicator: $allergenicIndicator, allergenicIndicatorElement: $allergenicIndicatorElement, manufacturer: $manufacturer, substance: $substance)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Ingredient &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusElement, statusElement) ||
                other.statusElement == statusElement) &&
            const DeepCollectionEquality().equals(other._for_, _for_) &&
            (identical(other.role, role) || other.role == role) &&
            const DeepCollectionEquality()
                .equals(other._function_, _function_) &&
            (identical(other.group, group) || other.group == group) &&
            (identical(other.allergenicIndicator, allergenicIndicator) ||
                other.allergenicIndicator == allergenicIndicator) &&
            (identical(other.allergenicIndicatorElement,
                    allergenicIndicatorElement) ||
                other.allergenicIndicatorElement ==
                    allergenicIndicatorElement) &&
            const DeepCollectionEquality()
                .equals(other._manufacturer, _manufacturer) &&
            (identical(other.substance, substance) ||
                other.substance == substance));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        identifier,
        status,
        statusElement,
        const DeepCollectionEquality().hash(_for_),
        role,
        const DeepCollectionEquality().hash(_function_),
        group,
        allergenicIndicator,
        allergenicIndicatorElement,
        const DeepCollectionEquality().hash(_manufacturer),
        substance
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_IngredientCopyWith<_$_Ingredient> get copyWith =>
      __$$_IngredientCopyWithImpl<_$_Ingredient>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_IngredientToJson(
      this,
    );
  }
}

abstract class _Ingredient extends Ingredient {
  factory _Ingredient(
      {@JsonKey(unknownEnumValue: R5ResourceType.Ingredient)
          final R5ResourceType resourceType,
      final FhirId? id,
      final Meta? meta,
      final FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          final Element? implicitRulesElement,
      final Code? language,
      @JsonKey(name: '_language')
          final Element? languageElement,
      final Narrative? text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final Identifier? identifier,
      final Code? status,
      @JsonKey(name: '_status')
          final Element? statusElement,
      @JsonKey(name: 'for')
          final List<Reference>? for_,
      required final CodeableConcept role,
      @JsonKey(name: 'function')
          final List<CodeableConcept>? function_,
      final CodeableConcept? group,
      final Boolean? allergenicIndicator,
      @JsonKey(name: '_allergenicIndicator')
          final Element? allergenicIndicatorElement,
      final List<IngredientManufacturer>? manufacturer,
      required final IngredientSubstance substance}) = _$_Ingredient;
  _Ingredient._() : super._();

  factory _Ingredient.fromJson(Map<String, dynamic> json) =
      _$_Ingredient.fromJson;

  @override

  /// [resourceType] This is a Ingredient resource
  @JsonKey(unknownEnumValue: R5ResourceType.Ingredient)
  R5ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.
  Code? get language;
  @override

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained;
  @override

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] The identifier(s) of this Ingredient that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate.
  Identifier? get identifier;
  @override

  /// [status] The status of this ingredient. Enables tracking the life-cycle of the content.
  Code? get status;
  @override

  /// [statusElement] ("_status") Extensions for status
  @JsonKey(name: '_status')
  Element? get statusElement;
  @override

  /// [for_] ("for") The product which this ingredient is a constituent part of.
  @JsonKey(name: 'for')
  List<Reference>? get for_;
  @override

  /// [role] A classification of the ingredient identifying its purpose within the product, e.g. active, inactive.
  CodeableConcept get role;
  @override

  /// [function_] ("function") A classification of the ingredient identifying its precise purpose(s) in the drug product. This extends the Ingredient.role to add more detail. Example: antioxidant, alkalizing agent.
  @JsonKey(name: 'function')
  List<CodeableConcept>? get function_;
  @override

  /// [group] A classification of the ingredient according to where in the physical item it tends to be used, such the outer shell of a tablet, inner body or ink.
  CodeableConcept? get group;
  @override

  /// [allergenicIndicator] If the ingredient is a known or suspected allergen. Note that this is a property of the substance, so if a reference to a SubstanceDefinition is used to decribe that (rather than just a code), the allergen information should go there, not here.
  Boolean? get allergenicIndicator;
  @override

  /// [allergenicIndicatorElement] ("_allergenicIndicator") Extensions for allergenicIndicator
  @JsonKey(name: '_allergenicIndicator')
  Element? get allergenicIndicatorElement;
  @override

  /// [manufacturer] The organization(s) that manufacture this ingredient. Can be used to indicate:         1) Organizations we are aware of that manufacture this ingredient         2) Specific Manufacturer(s) currently being used         3) Set of organisations allowed to manufacture this ingredient for this product         Users must be clear on the application of context relevant to their use case.
  List<IngredientManufacturer>? get manufacturer;
  @override

  /// [substance] The substance that comprises this ingredient.
  IngredientSubstance get substance;
  @override
  @JsonKey(ignore: true)
  _$$_IngredientCopyWith<_$_Ingredient> get copyWith =>
      throw _privateConstructorUsedError;
}

IngredientManufacturer _$IngredientManufacturerFromJson(
    Map<String, dynamic> json) {
  return _IngredientManufacturer.fromJson(json);
}

/// @nodoc
mixin _$IngredientManufacturer {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [role] The way in which this manufacturer is associated with the ingredient. For example whether it is a possible one (others allowed), or an exclusive authorized one for this ingredient. Note that this is not the manufacturing process role.
  Code? get role => throw _privateConstructorUsedError;

  /// [roleElement] ("_role") Extensions for role
  @JsonKey(name: '_role')
  Element? get roleElement => throw _privateConstructorUsedError;

  /// [manufacturer] An organization that manufactures this ingredient.
  Reference get manufacturer => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $IngredientManufacturerCopyWith<IngredientManufacturer> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IngredientManufacturerCopyWith<$Res> {
  factory $IngredientManufacturerCopyWith(IngredientManufacturer value,
          $Res Function(IngredientManufacturer) then) =
      _$IngredientManufacturerCopyWithImpl<$Res, IngredientManufacturer>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Code? role,
      @JsonKey(name: '_role') Element? roleElement,
      Reference manufacturer});

  $ElementCopyWith<$Res>? get roleElement;
  $ReferenceCopyWith<$Res> get manufacturer;
}

/// @nodoc
class _$IngredientManufacturerCopyWithImpl<$Res,
        $Val extends IngredientManufacturer>
    implements $IngredientManufacturerCopyWith<$Res> {
  _$IngredientManufacturerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? role = freezed,
    Object? roleElement = freezed,
    Object? manufacturer = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as Code?,
      roleElement: freezed == roleElement
          ? _value.roleElement
          : roleElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      manufacturer: null == manufacturer
          ? _value.manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as Reference,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get roleElement {
    if (_value.roleElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.roleElement!, (value) {
      return _then(_value.copyWith(roleElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res> get manufacturer {
    return $ReferenceCopyWith<$Res>(_value.manufacturer, (value) {
      return _then(_value.copyWith(manufacturer: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_IngredientManufacturerCopyWith<$Res>
    implements $IngredientManufacturerCopyWith<$Res> {
  factory _$$_IngredientManufacturerCopyWith(_$_IngredientManufacturer value,
          $Res Function(_$_IngredientManufacturer) then) =
      __$$_IngredientManufacturerCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Code? role,
      @JsonKey(name: '_role') Element? roleElement,
      Reference manufacturer});

  @override
  $ElementCopyWith<$Res>? get roleElement;
  @override
  $ReferenceCopyWith<$Res> get manufacturer;
}

/// @nodoc
class __$$_IngredientManufacturerCopyWithImpl<$Res>
    extends _$IngredientManufacturerCopyWithImpl<$Res,
        _$_IngredientManufacturer>
    implements _$$_IngredientManufacturerCopyWith<$Res> {
  __$$_IngredientManufacturerCopyWithImpl(_$_IngredientManufacturer _value,
      $Res Function(_$_IngredientManufacturer) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? role = freezed,
    Object? roleElement = freezed,
    Object? manufacturer = null,
  }) {
    return _then(_$_IngredientManufacturer(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as Code?,
      roleElement: freezed == roleElement
          ? _value.roleElement
          : roleElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      manufacturer: null == manufacturer
          ? _value.manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as Reference,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_IngredientManufacturer extends _IngredientManufacturer {
  _$_IngredientManufacturer(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.role,
      @JsonKey(name: '_role') this.roleElement,
      required this.manufacturer})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_IngredientManufacturer.fromJson(Map<String, dynamic> json) =>
      _$$_IngredientManufacturerFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [role] The way in which this manufacturer is associated with the ingredient. For example whether it is a possible one (others allowed), or an exclusive authorized one for this ingredient. Note that this is not the manufacturing process role.
  @override
  final Code? role;

  /// [roleElement] ("_role") Extensions for role
  @override
  @JsonKey(name: '_role')
  final Element? roleElement;

  /// [manufacturer] An organization that manufactures this ingredient.
  @override
  final Reference manufacturer;

  @override
  String toString() {
    return 'IngredientManufacturer(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, role: $role, roleElement: $roleElement, manufacturer: $manufacturer)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_IngredientManufacturer &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.roleElement, roleElement) ||
                other.roleElement == roleElement) &&
            (identical(other.manufacturer, manufacturer) ||
                other.manufacturer == manufacturer));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      role,
      roleElement,
      manufacturer);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_IngredientManufacturerCopyWith<_$_IngredientManufacturer> get copyWith =>
      __$$_IngredientManufacturerCopyWithImpl<_$_IngredientManufacturer>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_IngredientManufacturerToJson(
      this,
    );
  }
}

abstract class _IngredientManufacturer extends IngredientManufacturer {
  factory _IngredientManufacturer(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final Code? role,
      @JsonKey(name: '_role') final Element? roleElement,
      required final Reference manufacturer}) = _$_IngredientManufacturer;
  _IngredientManufacturer._() : super._();

  factory _IngredientManufacturer.fromJson(Map<String, dynamic> json) =
      _$_IngredientManufacturer.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [role] The way in which this manufacturer is associated with the ingredient. For example whether it is a possible one (others allowed), or an exclusive authorized one for this ingredient. Note that this is not the manufacturing process role.
  Code? get role;
  @override

  /// [roleElement] ("_role") Extensions for role
  @JsonKey(name: '_role')
  Element? get roleElement;
  @override

  /// [manufacturer] An organization that manufactures this ingredient.
  Reference get manufacturer;
  @override
  @JsonKey(ignore: true)
  _$$_IngredientManufacturerCopyWith<_$_IngredientManufacturer> get copyWith =>
      throw _privateConstructorUsedError;
}

IngredientSubstance _$IngredientSubstanceFromJson(Map<String, dynamic> json) {
  return _IngredientSubstance.fromJson(json);
}

/// @nodoc
mixin _$IngredientSubstance {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [code] A code or full resource that represents the ingredient's substance.
  CodeableReference get code => throw _privateConstructorUsedError;

  /// [strength] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. The allowed repetitions do not represent different strengths, but are different representations - mathematically equivalent - of a single strength.
  List<IngredientStrength>? get strength => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $IngredientSubstanceCopyWith<IngredientSubstance> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IngredientSubstanceCopyWith<$Res> {
  factory $IngredientSubstanceCopyWith(
          IngredientSubstance value, $Res Function(IngredientSubstance) then) =
      _$IngredientSubstanceCopyWithImpl<$Res, IngredientSubstance>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference code,
      List<IngredientStrength>? strength});

  $CodeableReferenceCopyWith<$Res> get code;
}

/// @nodoc
class _$IngredientSubstanceCopyWithImpl<$Res, $Val extends IngredientSubstance>
    implements $IngredientSubstanceCopyWith<$Res> {
  _$IngredientSubstanceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = null,
    Object? strength = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
      strength: freezed == strength
          ? _value.strength
          : strength // ignore: cast_nullable_to_non_nullable
              as List<IngredientStrength>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res> get code {
    return $CodeableReferenceCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_IngredientSubstanceCopyWith<$Res>
    implements $IngredientSubstanceCopyWith<$Res> {
  factory _$$_IngredientSubstanceCopyWith(_$_IngredientSubstance value,
          $Res Function(_$_IngredientSubstance) then) =
      __$$_IngredientSubstanceCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference code,
      List<IngredientStrength>? strength});

  @override
  $CodeableReferenceCopyWith<$Res> get code;
}

/// @nodoc
class __$$_IngredientSubstanceCopyWithImpl<$Res>
    extends _$IngredientSubstanceCopyWithImpl<$Res, _$_IngredientSubstance>
    implements _$$_IngredientSubstanceCopyWith<$Res> {
  __$$_IngredientSubstanceCopyWithImpl(_$_IngredientSubstance _value,
      $Res Function(_$_IngredientSubstance) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = null,
    Object? strength = freezed,
  }) {
    return _then(_$_IngredientSubstance(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
      strength: freezed == strength
          ? _value._strength
          : strength // ignore: cast_nullable_to_non_nullable
              as List<IngredientStrength>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_IngredientSubstance extends _IngredientSubstance {
  _$_IngredientSubstance(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.code,
      final List<IngredientStrength>? strength})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _strength = strength,
        super._();

  factory _$_IngredientSubstance.fromJson(Map<String, dynamic> json) =>
      _$$_IngredientSubstanceFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [code] A code or full resource that represents the ingredient's substance.
  @override
  final CodeableReference code;

  /// [strength] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. The allowed repetitions do not represent different strengths, but are different representations - mathematically equivalent - of a single strength.
  final List<IngredientStrength>? _strength;

  /// [strength] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. The allowed repetitions do not represent different strengths, but are different representations - mathematically equivalent - of a single strength.
  @override
  List<IngredientStrength>? get strength {
    final value = _strength;
    if (value == null) return null;
    if (_strength is EqualUnmodifiableListView) return _strength;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'IngredientSubstance(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, strength: $strength)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_IngredientSubstance &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.code, code) || other.code == code) &&
            const DeepCollectionEquality().equals(other._strength, _strength));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      code,
      const DeepCollectionEquality().hash(_strength));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_IngredientSubstanceCopyWith<_$_IngredientSubstance> get copyWith =>
      __$$_IngredientSubstanceCopyWithImpl<_$_IngredientSubstance>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_IngredientSubstanceToJson(
      this,
    );
  }
}

abstract class _IngredientSubstance extends IngredientSubstance {
  factory _IngredientSubstance(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final CodeableReference code,
      final List<IngredientStrength>? strength}) = _$_IngredientSubstance;
  _IngredientSubstance._() : super._();

  factory _IngredientSubstance.fromJson(Map<String, dynamic> json) =
      _$_IngredientSubstance.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [code] A code or full resource that represents the ingredient's substance.
  CodeableReference get code;
  @override

  /// [strength] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. The allowed repetitions do not represent different strengths, but are different representations - mathematically equivalent - of a single strength.
  List<IngredientStrength>? get strength;
  @override
  @JsonKey(ignore: true)
  _$$_IngredientSubstanceCopyWith<_$_IngredientSubstance> get copyWith =>
      throw _privateConstructorUsedError;
}

IngredientStrength _$IngredientStrengthFromJson(Map<String, dynamic> json) {
  return _IngredientStrength.fromJson(json);
}

/// @nodoc
mixin _$IngredientStrength {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [presentationRatio] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg').
  Ratio? get presentationRatio => throw _privateConstructorUsedError;

  /// [presentationRatioRange] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg').
  RatioRange? get presentationRatioRange => throw _privateConstructorUsedError;

  /// [presentationCodeableConcept] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg').
  CodeableConcept? get presentationCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [presentationQuantity] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg').
  Quantity? get presentationQuantity => throw _privateConstructorUsedError;

  /// [textPresentation] A textual represention of either the whole of the presentation strength or a part of it - with the rest being in Strength.presentation as a ratio.
  String? get textPresentation => throw _privateConstructorUsedError;

  /// [textPresentationElement] ("_textPresentation") Extensions for textPresentation
  @JsonKey(name: '_textPresentation')
  Element? get textPresentationElement => throw _privateConstructorUsedError;

  /// [concentrationRatio] The strength per unitary volume (or mass).
  Ratio? get concentrationRatio => throw _privateConstructorUsedError;

  /// [concentrationRatioRange] The strength per unitary volume (or mass).
  RatioRange? get concentrationRatioRange => throw _privateConstructorUsedError;

  /// [concentrationCodeableConcept] The strength per unitary volume (or mass).
  CodeableConcept? get concentrationCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [concentrationQuantity] The strength per unitary volume (or mass).
  Quantity? get concentrationQuantity => throw _privateConstructorUsedError;

  /// [textConcentration] A textual represention of either the whole of the concentration strength or a part of it - with the rest being in Strength.concentration as a ratio.
  String? get textConcentration => throw _privateConstructorUsedError;

  /// [textConcentrationElement] ("_textConcentration") Extensions for textConcentration
  @JsonKey(name: '_textConcentration')
  Element? get textConcentrationElement => throw _privateConstructorUsedError;

  /// [basis] A code that indicates if the strength is, for example, based on the ingredient substance as stated or on the substance base (when the ingredient is a salt).
  CodeableConcept? get basis => throw _privateConstructorUsedError;

  /// [measurementPoint] For when strength is measured at a particular point or distance. There are products where strength is measured at a particular point. For example, the strength of the ingredient in some inhalers is measured at a particular position relative to the point of aerosolization.
  String? get measurementPoint => throw _privateConstructorUsedError;

  /// [measurementPointElement] ("_measurementPoint") Extensions for measurementPoint
  @JsonKey(name: '_measurementPoint')
  Element? get measurementPointElement => throw _privateConstructorUsedError;

  /// [country] The country or countries for which the strength range applies.
  List<CodeableConcept>? get country => throw _privateConstructorUsedError;

  /// [referenceStrength] Strength expressed in terms of a reference substance. For when the ingredient strength is additionally expressed as equivalent to the strength of some other closely related substance (e.g. salt vs. base). Reference strength represents the strength (quantitative composition) of the active moiety of the active substance. There are situations when the active substance and active moiety are different, therefore both a strength and a reference strength are needed.
  List<IngredientReferenceStrength>? get referenceStrength =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $IngredientStrengthCopyWith<IngredientStrength> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IngredientStrengthCopyWith<$Res> {
  factory $IngredientStrengthCopyWith(
          IngredientStrength value, $Res Function(IngredientStrength) then) =
      _$IngredientStrengthCopyWithImpl<$Res, IngredientStrength>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Ratio? presentationRatio,
      RatioRange? presentationRatioRange,
      CodeableConcept? presentationCodeableConcept,
      Quantity? presentationQuantity,
      String? textPresentation,
      @JsonKey(name: '_textPresentation') Element? textPresentationElement,
      Ratio? concentrationRatio,
      RatioRange? concentrationRatioRange,
      CodeableConcept? concentrationCodeableConcept,
      Quantity? concentrationQuantity,
      String? textConcentration,
      @JsonKey(name: '_textConcentration') Element? textConcentrationElement,
      CodeableConcept? basis,
      String? measurementPoint,
      @JsonKey(name: '_measurementPoint') Element? measurementPointElement,
      List<CodeableConcept>? country,
      List<IngredientReferenceStrength>? referenceStrength});

  $RatioCopyWith<$Res>? get presentationRatio;
  $RatioRangeCopyWith<$Res>? get presentationRatioRange;
  $CodeableConceptCopyWith<$Res>? get presentationCodeableConcept;
  $QuantityCopyWith<$Res>? get presentationQuantity;
  $ElementCopyWith<$Res>? get textPresentationElement;
  $RatioCopyWith<$Res>? get concentrationRatio;
  $RatioRangeCopyWith<$Res>? get concentrationRatioRange;
  $CodeableConceptCopyWith<$Res>? get concentrationCodeableConcept;
  $QuantityCopyWith<$Res>? get concentrationQuantity;
  $ElementCopyWith<$Res>? get textConcentrationElement;
  $CodeableConceptCopyWith<$Res>? get basis;
  $ElementCopyWith<$Res>? get measurementPointElement;
}

/// @nodoc
class _$IngredientStrengthCopyWithImpl<$Res, $Val extends IngredientStrength>
    implements $IngredientStrengthCopyWith<$Res> {
  _$IngredientStrengthCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? presentationRatio = freezed,
    Object? presentationRatioRange = freezed,
    Object? presentationCodeableConcept = freezed,
    Object? presentationQuantity = freezed,
    Object? textPresentation = freezed,
    Object? textPresentationElement = freezed,
    Object? concentrationRatio = freezed,
    Object? concentrationRatioRange = freezed,
    Object? concentrationCodeableConcept = freezed,
    Object? concentrationQuantity = freezed,
    Object? textConcentration = freezed,
    Object? textConcentrationElement = freezed,
    Object? basis = freezed,
    Object? measurementPoint = freezed,
    Object? measurementPointElement = freezed,
    Object? country = freezed,
    Object? referenceStrength = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      presentationRatio: freezed == presentationRatio
          ? _value.presentationRatio
          : presentationRatio // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      presentationRatioRange: freezed == presentationRatioRange
          ? _value.presentationRatioRange
          : presentationRatioRange // ignore: cast_nullable_to_non_nullable
              as RatioRange?,
      presentationCodeableConcept: freezed == presentationCodeableConcept
          ? _value.presentationCodeableConcept
          : presentationCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      presentationQuantity: freezed == presentationQuantity
          ? _value.presentationQuantity
          : presentationQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      textPresentation: freezed == textPresentation
          ? _value.textPresentation
          : textPresentation // ignore: cast_nullable_to_non_nullable
              as String?,
      textPresentationElement: freezed == textPresentationElement
          ? _value.textPresentationElement
          : textPresentationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      concentrationRatio: freezed == concentrationRatio
          ? _value.concentrationRatio
          : concentrationRatio // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      concentrationRatioRange: freezed == concentrationRatioRange
          ? _value.concentrationRatioRange
          : concentrationRatioRange // ignore: cast_nullable_to_non_nullable
              as RatioRange?,
      concentrationCodeableConcept: freezed == concentrationCodeableConcept
          ? _value.concentrationCodeableConcept
          : concentrationCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      concentrationQuantity: freezed == concentrationQuantity
          ? _value.concentrationQuantity
          : concentrationQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      textConcentration: freezed == textConcentration
          ? _value.textConcentration
          : textConcentration // ignore: cast_nullable_to_non_nullable
              as String?,
      textConcentrationElement: freezed == textConcentrationElement
          ? _value.textConcentrationElement
          : textConcentrationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      basis: freezed == basis
          ? _value.basis
          : basis // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      measurementPoint: freezed == measurementPoint
          ? _value.measurementPoint
          : measurementPoint // ignore: cast_nullable_to_non_nullable
              as String?,
      measurementPointElement: freezed == measurementPointElement
          ? _value.measurementPointElement
          : measurementPointElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      country: freezed == country
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      referenceStrength: freezed == referenceStrength
          ? _value.referenceStrength
          : referenceStrength // ignore: cast_nullable_to_non_nullable
              as List<IngredientReferenceStrength>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RatioCopyWith<$Res>? get presentationRatio {
    if (_value.presentationRatio == null) {
      return null;
    }

    return $RatioCopyWith<$Res>(_value.presentationRatio!, (value) {
      return _then(_value.copyWith(presentationRatio: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RatioRangeCopyWith<$Res>? get presentationRatioRange {
    if (_value.presentationRatioRange == null) {
      return null;
    }

    return $RatioRangeCopyWith<$Res>(_value.presentationRatioRange!, (value) {
      return _then(_value.copyWith(presentationRatioRange: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get presentationCodeableConcept {
    if (_value.presentationCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.presentationCodeableConcept!,
        (value) {
      return _then(_value.copyWith(presentationCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get presentationQuantity {
    if (_value.presentationQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.presentationQuantity!, (value) {
      return _then(_value.copyWith(presentationQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get textPresentationElement {
    if (_value.textPresentationElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.textPresentationElement!, (value) {
      return _then(_value.copyWith(textPresentationElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RatioCopyWith<$Res>? get concentrationRatio {
    if (_value.concentrationRatio == null) {
      return null;
    }

    return $RatioCopyWith<$Res>(_value.concentrationRatio!, (value) {
      return _then(_value.copyWith(concentrationRatio: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RatioRangeCopyWith<$Res>? get concentrationRatioRange {
    if (_value.concentrationRatioRange == null) {
      return null;
    }

    return $RatioRangeCopyWith<$Res>(_value.concentrationRatioRange!, (value) {
      return _then(_value.copyWith(concentrationRatioRange: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get concentrationCodeableConcept {
    if (_value.concentrationCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.concentrationCodeableConcept!,
        (value) {
      return _then(
          _value.copyWith(concentrationCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get concentrationQuantity {
    if (_value.concentrationQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.concentrationQuantity!, (value) {
      return _then(_value.copyWith(concentrationQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get textConcentrationElement {
    if (_value.textConcentrationElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.textConcentrationElement!, (value) {
      return _then(_value.copyWith(textConcentrationElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get basis {
    if (_value.basis == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.basis!, (value) {
      return _then(_value.copyWith(basis: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get measurementPointElement {
    if (_value.measurementPointElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.measurementPointElement!, (value) {
      return _then(_value.copyWith(measurementPointElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_IngredientStrengthCopyWith<$Res>
    implements $IngredientStrengthCopyWith<$Res> {
  factory _$$_IngredientStrengthCopyWith(_$_IngredientStrength value,
          $Res Function(_$_IngredientStrength) then) =
      __$$_IngredientStrengthCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Ratio? presentationRatio,
      RatioRange? presentationRatioRange,
      CodeableConcept? presentationCodeableConcept,
      Quantity? presentationQuantity,
      String? textPresentation,
      @JsonKey(name: '_textPresentation') Element? textPresentationElement,
      Ratio? concentrationRatio,
      RatioRange? concentrationRatioRange,
      CodeableConcept? concentrationCodeableConcept,
      Quantity? concentrationQuantity,
      String? textConcentration,
      @JsonKey(name: '_textConcentration') Element? textConcentrationElement,
      CodeableConcept? basis,
      String? measurementPoint,
      @JsonKey(name: '_measurementPoint') Element? measurementPointElement,
      List<CodeableConcept>? country,
      List<IngredientReferenceStrength>? referenceStrength});

  @override
  $RatioCopyWith<$Res>? get presentationRatio;
  @override
  $RatioRangeCopyWith<$Res>? get presentationRatioRange;
  @override
  $CodeableConceptCopyWith<$Res>? get presentationCodeableConcept;
  @override
  $QuantityCopyWith<$Res>? get presentationQuantity;
  @override
  $ElementCopyWith<$Res>? get textPresentationElement;
  @override
  $RatioCopyWith<$Res>? get concentrationRatio;
  @override
  $RatioRangeCopyWith<$Res>? get concentrationRatioRange;
  @override
  $CodeableConceptCopyWith<$Res>? get concentrationCodeableConcept;
  @override
  $QuantityCopyWith<$Res>? get concentrationQuantity;
  @override
  $ElementCopyWith<$Res>? get textConcentrationElement;
  @override
  $CodeableConceptCopyWith<$Res>? get basis;
  @override
  $ElementCopyWith<$Res>? get measurementPointElement;
}

/// @nodoc
class __$$_IngredientStrengthCopyWithImpl<$Res>
    extends _$IngredientStrengthCopyWithImpl<$Res, _$_IngredientStrength>
    implements _$$_IngredientStrengthCopyWith<$Res> {
  __$$_IngredientStrengthCopyWithImpl(
      _$_IngredientStrength _value, $Res Function(_$_IngredientStrength) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? presentationRatio = freezed,
    Object? presentationRatioRange = freezed,
    Object? presentationCodeableConcept = freezed,
    Object? presentationQuantity = freezed,
    Object? textPresentation = freezed,
    Object? textPresentationElement = freezed,
    Object? concentrationRatio = freezed,
    Object? concentrationRatioRange = freezed,
    Object? concentrationCodeableConcept = freezed,
    Object? concentrationQuantity = freezed,
    Object? textConcentration = freezed,
    Object? textConcentrationElement = freezed,
    Object? basis = freezed,
    Object? measurementPoint = freezed,
    Object? measurementPointElement = freezed,
    Object? country = freezed,
    Object? referenceStrength = freezed,
  }) {
    return _then(_$_IngredientStrength(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      presentationRatio: freezed == presentationRatio
          ? _value.presentationRatio
          : presentationRatio // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      presentationRatioRange: freezed == presentationRatioRange
          ? _value.presentationRatioRange
          : presentationRatioRange // ignore: cast_nullable_to_non_nullable
              as RatioRange?,
      presentationCodeableConcept: freezed == presentationCodeableConcept
          ? _value.presentationCodeableConcept
          : presentationCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      presentationQuantity: freezed == presentationQuantity
          ? _value.presentationQuantity
          : presentationQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      textPresentation: freezed == textPresentation
          ? _value.textPresentation
          : textPresentation // ignore: cast_nullable_to_non_nullable
              as String?,
      textPresentationElement: freezed == textPresentationElement
          ? _value.textPresentationElement
          : textPresentationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      concentrationRatio: freezed == concentrationRatio
          ? _value.concentrationRatio
          : concentrationRatio // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      concentrationRatioRange: freezed == concentrationRatioRange
          ? _value.concentrationRatioRange
          : concentrationRatioRange // ignore: cast_nullable_to_non_nullable
              as RatioRange?,
      concentrationCodeableConcept: freezed == concentrationCodeableConcept
          ? _value.concentrationCodeableConcept
          : concentrationCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      concentrationQuantity: freezed == concentrationQuantity
          ? _value.concentrationQuantity
          : concentrationQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      textConcentration: freezed == textConcentration
          ? _value.textConcentration
          : textConcentration // ignore: cast_nullable_to_non_nullable
              as String?,
      textConcentrationElement: freezed == textConcentrationElement
          ? _value.textConcentrationElement
          : textConcentrationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      basis: freezed == basis
          ? _value.basis
          : basis // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      measurementPoint: freezed == measurementPoint
          ? _value.measurementPoint
          : measurementPoint // ignore: cast_nullable_to_non_nullable
              as String?,
      measurementPointElement: freezed == measurementPointElement
          ? _value.measurementPointElement
          : measurementPointElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      country: freezed == country
          ? _value._country
          : country // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      referenceStrength: freezed == referenceStrength
          ? _value._referenceStrength
          : referenceStrength // ignore: cast_nullable_to_non_nullable
              as List<IngredientReferenceStrength>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_IngredientStrength extends _IngredientStrength {
  _$_IngredientStrength(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.presentationRatio,
      this.presentationRatioRange,
      this.presentationCodeableConcept,
      this.presentationQuantity,
      this.textPresentation,
      @JsonKey(name: '_textPresentation') this.textPresentationElement,
      this.concentrationRatio,
      this.concentrationRatioRange,
      this.concentrationCodeableConcept,
      this.concentrationQuantity,
      this.textConcentration,
      @JsonKey(name: '_textConcentration') this.textConcentrationElement,
      this.basis,
      this.measurementPoint,
      @JsonKey(name: '_measurementPoint') this.measurementPointElement,
      final List<CodeableConcept>? country,
      final List<IngredientReferenceStrength>? referenceStrength})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _country = country,
        _referenceStrength = referenceStrength,
        super._();

  factory _$_IngredientStrength.fromJson(Map<String, dynamic> json) =>
      _$$_IngredientStrengthFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [presentationRatio] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg').
  @override
  final Ratio? presentationRatio;

  /// [presentationRatioRange] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg').
  @override
  final RatioRange? presentationRatioRange;

  /// [presentationCodeableConcept] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg').
  @override
  final CodeableConcept? presentationCodeableConcept;

  /// [presentationQuantity] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg').
  @override
  final Quantity? presentationQuantity;

  /// [textPresentation] A textual represention of either the whole of the presentation strength or a part of it - with the rest being in Strength.presentation as a ratio.
  @override
  final String? textPresentation;

  /// [textPresentationElement] ("_textPresentation") Extensions for textPresentation
  @override
  @JsonKey(name: '_textPresentation')
  final Element? textPresentationElement;

  /// [concentrationRatio] The strength per unitary volume (or mass).
  @override
  final Ratio? concentrationRatio;

  /// [concentrationRatioRange] The strength per unitary volume (or mass).
  @override
  final RatioRange? concentrationRatioRange;

  /// [concentrationCodeableConcept] The strength per unitary volume (or mass).
  @override
  final CodeableConcept? concentrationCodeableConcept;

  /// [concentrationQuantity] The strength per unitary volume (or mass).
  @override
  final Quantity? concentrationQuantity;

  /// [textConcentration] A textual represention of either the whole of the concentration strength or a part of it - with the rest being in Strength.concentration as a ratio.
  @override
  final String? textConcentration;

  /// [textConcentrationElement] ("_textConcentration") Extensions for textConcentration
  @override
  @JsonKey(name: '_textConcentration')
  final Element? textConcentrationElement;

  /// [basis] A code that indicates if the strength is, for example, based on the ingredient substance as stated or on the substance base (when the ingredient is a salt).
  @override
  final CodeableConcept? basis;

  /// [measurementPoint] For when strength is measured at a particular point or distance. There are products where strength is measured at a particular point. For example, the strength of the ingredient in some inhalers is measured at a particular position relative to the point of aerosolization.
  @override
  final String? measurementPoint;

  /// [measurementPointElement] ("_measurementPoint") Extensions for measurementPoint
  @override
  @JsonKey(name: '_measurementPoint')
  final Element? measurementPointElement;

  /// [country] The country or countries for which the strength range applies.
  final List<CodeableConcept>? _country;

  /// [country] The country or countries for which the strength range applies.
  @override
  List<CodeableConcept>? get country {
    final value = _country;
    if (value == null) return null;
    if (_country is EqualUnmodifiableListView) return _country;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [referenceStrength] Strength expressed in terms of a reference substance. For when the ingredient strength is additionally expressed as equivalent to the strength of some other closely related substance (e.g. salt vs. base). Reference strength represents the strength (quantitative composition) of the active moiety of the active substance. There are situations when the active substance and active moiety are different, therefore both a strength and a reference strength are needed.
  final List<IngredientReferenceStrength>? _referenceStrength;

  /// [referenceStrength] Strength expressed in terms of a reference substance. For when the ingredient strength is additionally expressed as equivalent to the strength of some other closely related substance (e.g. salt vs. base). Reference strength represents the strength (quantitative composition) of the active moiety of the active substance. There are situations when the active substance and active moiety are different, therefore both a strength and a reference strength are needed.
  @override
  List<IngredientReferenceStrength>? get referenceStrength {
    final value = _referenceStrength;
    if (value == null) return null;
    if (_referenceStrength is EqualUnmodifiableListView)
      return _referenceStrength;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'IngredientStrength(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, presentationRatio: $presentationRatio, presentationRatioRange: $presentationRatioRange, presentationCodeableConcept: $presentationCodeableConcept, presentationQuantity: $presentationQuantity, textPresentation: $textPresentation, textPresentationElement: $textPresentationElement, concentrationRatio: $concentrationRatio, concentrationRatioRange: $concentrationRatioRange, concentrationCodeableConcept: $concentrationCodeableConcept, concentrationQuantity: $concentrationQuantity, textConcentration: $textConcentration, textConcentrationElement: $textConcentrationElement, basis: $basis, measurementPoint: $measurementPoint, measurementPointElement: $measurementPointElement, country: $country, referenceStrength: $referenceStrength)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_IngredientStrength &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.presentationRatio, presentationRatio) ||
                other.presentationRatio == presentationRatio) &&
            (identical(other.presentationRatioRange, presentationRatioRange) ||
                other.presentationRatioRange == presentationRatioRange) &&
            (identical(other.presentationCodeableConcept,
                    presentationCodeableConcept) ||
                other.presentationCodeableConcept ==
                    presentationCodeableConcept) &&
            (identical(other.presentationQuantity, presentationQuantity) ||
                other.presentationQuantity == presentationQuantity) &&
            (identical(other.textPresentation, textPresentation) ||
                other.textPresentation == textPresentation) &&
            (identical(other.textPresentationElement, textPresentationElement) ||
                other.textPresentationElement == textPresentationElement) &&
            (identical(other.concentrationRatio, concentrationRatio) ||
                other.concentrationRatio == concentrationRatio) &&
            (identical(other.concentrationRatioRange, concentrationRatioRange) ||
                other.concentrationRatioRange == concentrationRatioRange) &&
            (identical(other.concentrationCodeableConcept,
                    concentrationCodeableConcept) ||
                other.concentrationCodeableConcept ==
                    concentrationCodeableConcept) &&
            (identical(other.concentrationQuantity, concentrationQuantity) ||
                other.concentrationQuantity == concentrationQuantity) &&
            (identical(other.textConcentration, textConcentration) ||
                other.textConcentration == textConcentration) &&
            (identical(
                    other.textConcentrationElement, textConcentrationElement) ||
                other.textConcentrationElement == textConcentrationElement) &&
            (identical(other.basis, basis) || other.basis == basis) &&
            (identical(other.measurementPoint, measurementPoint) ||
                other.measurementPoint == measurementPoint) &&
            (identical(other.measurementPointElement, measurementPointElement) ||
                other.measurementPointElement == measurementPointElement) &&
            const DeepCollectionEquality().equals(other._country, _country) &&
            const DeepCollectionEquality()
                .equals(other._referenceStrength, _referenceStrength));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        presentationRatio,
        presentationRatioRange,
        presentationCodeableConcept,
        presentationQuantity,
        textPresentation,
        textPresentationElement,
        concentrationRatio,
        concentrationRatioRange,
        concentrationCodeableConcept,
        concentrationQuantity,
        textConcentration,
        textConcentrationElement,
        basis,
        measurementPoint,
        measurementPointElement,
        const DeepCollectionEquality().hash(_country),
        const DeepCollectionEquality().hash(_referenceStrength)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_IngredientStrengthCopyWith<_$_IngredientStrength> get copyWith =>
      __$$_IngredientStrengthCopyWithImpl<_$_IngredientStrength>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_IngredientStrengthToJson(
      this,
    );
  }
}

abstract class _IngredientStrength extends IngredientStrength {
  factory _IngredientStrength(
          {final String? id,
          @JsonKey(name: 'extension')
              final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final Ratio? presentationRatio,
          final RatioRange? presentationRatioRange,
          final CodeableConcept? presentationCodeableConcept,
          final Quantity? presentationQuantity,
          final String? textPresentation,
          @JsonKey(name: '_textPresentation')
              final Element? textPresentationElement,
          final Ratio? concentrationRatio,
          final RatioRange? concentrationRatioRange,
          final CodeableConcept? concentrationCodeableConcept,
          final Quantity? concentrationQuantity,
          final String? textConcentration,
          @JsonKey(name: '_textConcentration')
              final Element? textConcentrationElement,
          final CodeableConcept? basis,
          final String? measurementPoint,
          @JsonKey(name: '_measurementPoint')
              final Element? measurementPointElement,
          final List<CodeableConcept>? country,
          final List<IngredientReferenceStrength>? referenceStrength}) =
      _$_IngredientStrength;
  _IngredientStrength._() : super._();

  factory _IngredientStrength.fromJson(Map<String, dynamic> json) =
      _$_IngredientStrength.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [presentationRatio] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg').
  Ratio? get presentationRatio;
  @override

  /// [presentationRatioRange] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg').
  RatioRange? get presentationRatioRange;
  @override

  /// [presentationCodeableConcept] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg').
  CodeableConcept? get presentationCodeableConcept;
  @override

  /// [presentationQuantity] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg').
  Quantity? get presentationQuantity;
  @override

  /// [textPresentation] A textual represention of either the whole of the presentation strength or a part of it - with the rest being in Strength.presentation as a ratio.
  String? get textPresentation;
  @override

  /// [textPresentationElement] ("_textPresentation") Extensions for textPresentation
  @JsonKey(name: '_textPresentation')
  Element? get textPresentationElement;
  @override

  /// [concentrationRatio] The strength per unitary volume (or mass).
  Ratio? get concentrationRatio;
  @override

  /// [concentrationRatioRange] The strength per unitary volume (or mass).
  RatioRange? get concentrationRatioRange;
  @override

  /// [concentrationCodeableConcept] The strength per unitary volume (or mass).
  CodeableConcept? get concentrationCodeableConcept;
  @override

  /// [concentrationQuantity] The strength per unitary volume (or mass).
  Quantity? get concentrationQuantity;
  @override

  /// [textConcentration] A textual represention of either the whole of the concentration strength or a part of it - with the rest being in Strength.concentration as a ratio.
  String? get textConcentration;
  @override

  /// [textConcentrationElement] ("_textConcentration") Extensions for textConcentration
  @JsonKey(name: '_textConcentration')
  Element? get textConcentrationElement;
  @override

  /// [basis] A code that indicates if the strength is, for example, based on the ingredient substance as stated or on the substance base (when the ingredient is a salt).
  CodeableConcept? get basis;
  @override

  /// [measurementPoint] For when strength is measured at a particular point or distance. There are products where strength is measured at a particular point. For example, the strength of the ingredient in some inhalers is measured at a particular position relative to the point of aerosolization.
  String? get measurementPoint;
  @override

  /// [measurementPointElement] ("_measurementPoint") Extensions for measurementPoint
  @JsonKey(name: '_measurementPoint')
  Element? get measurementPointElement;
  @override

  /// [country] The country or countries for which the strength range applies.
  List<CodeableConcept>? get country;
  @override

  /// [referenceStrength] Strength expressed in terms of a reference substance. For when the ingredient strength is additionally expressed as equivalent to the strength of some other closely related substance (e.g. salt vs. base). Reference strength represents the strength (quantitative composition) of the active moiety of the active substance. There are situations when the active substance and active moiety are different, therefore both a strength and a reference strength are needed.
  List<IngredientReferenceStrength>? get referenceStrength;
  @override
  @JsonKey(ignore: true)
  _$$_IngredientStrengthCopyWith<_$_IngredientStrength> get copyWith =>
      throw _privateConstructorUsedError;
}

IngredientReferenceStrength _$IngredientReferenceStrengthFromJson(
    Map<String, dynamic> json) {
  return _IngredientReferenceStrength.fromJson(json);
}

/// @nodoc
mixin _$IngredientReferenceStrength {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [substance] Relevant reference substance.
  CodeableReference? get substance => throw _privateConstructorUsedError;

  /// [strengthRatio] Strength expressed in terms of a reference substance.
  Ratio? get strengthRatio => throw _privateConstructorUsedError;

  /// [strengthRatioRange] Strength expressed in terms of a reference substance.
  RatioRange? get strengthRatioRange => throw _privateConstructorUsedError;

  /// [strengthQuantity] Strength expressed in terms of a reference substance.
  Quantity? get strengthQuantity => throw _privateConstructorUsedError;

  /// [measurementPoint] For when strength is measured at a particular point or distance.
  String? get measurementPoint => throw _privateConstructorUsedError;

  /// [measurementPointElement] ("_measurementPoint") Extensions for measurementPoint
  @JsonKey(name: '_measurementPoint')
  Element? get measurementPointElement => throw _privateConstructorUsedError;

  /// [country] The country or countries for which the strength range applies.
  List<CodeableConcept>? get country => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $IngredientReferenceStrengthCopyWith<IngredientReferenceStrength>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IngredientReferenceStrengthCopyWith<$Res> {
  factory $IngredientReferenceStrengthCopyWith(
          IngredientReferenceStrength value,
          $Res Function(IngredientReferenceStrength) then) =
      _$IngredientReferenceStrengthCopyWithImpl<$Res,
          IngredientReferenceStrength>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? substance,
      Ratio? strengthRatio,
      RatioRange? strengthRatioRange,
      Quantity? strengthQuantity,
      String? measurementPoint,
      @JsonKey(name: '_measurementPoint') Element? measurementPointElement,
      List<CodeableConcept>? country});

  $CodeableReferenceCopyWith<$Res>? get substance;
  $RatioCopyWith<$Res>? get strengthRatio;
  $RatioRangeCopyWith<$Res>? get strengthRatioRange;
  $QuantityCopyWith<$Res>? get strengthQuantity;
  $ElementCopyWith<$Res>? get measurementPointElement;
}

/// @nodoc
class _$IngredientReferenceStrengthCopyWithImpl<$Res,
        $Val extends IngredientReferenceStrength>
    implements $IngredientReferenceStrengthCopyWith<$Res> {
  _$IngredientReferenceStrengthCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? substance = freezed,
    Object? strengthRatio = freezed,
    Object? strengthRatioRange = freezed,
    Object? strengthQuantity = freezed,
    Object? measurementPoint = freezed,
    Object? measurementPointElement = freezed,
    Object? country = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      substance: freezed == substance
          ? _value.substance
          : substance // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      strengthRatio: freezed == strengthRatio
          ? _value.strengthRatio
          : strengthRatio // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      strengthRatioRange: freezed == strengthRatioRange
          ? _value.strengthRatioRange
          : strengthRatioRange // ignore: cast_nullable_to_non_nullable
              as RatioRange?,
      strengthQuantity: freezed == strengthQuantity
          ? _value.strengthQuantity
          : strengthQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      measurementPoint: freezed == measurementPoint
          ? _value.measurementPoint
          : measurementPoint // ignore: cast_nullable_to_non_nullable
              as String?,
      measurementPointElement: freezed == measurementPointElement
          ? _value.measurementPointElement
          : measurementPointElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      country: freezed == country
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res>? get substance {
    if (_value.substance == null) {
      return null;
    }

    return $CodeableReferenceCopyWith<$Res>(_value.substance!, (value) {
      return _then(_value.copyWith(substance: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RatioCopyWith<$Res>? get strengthRatio {
    if (_value.strengthRatio == null) {
      return null;
    }

    return $RatioCopyWith<$Res>(_value.strengthRatio!, (value) {
      return _then(_value.copyWith(strengthRatio: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RatioRangeCopyWith<$Res>? get strengthRatioRange {
    if (_value.strengthRatioRange == null) {
      return null;
    }

    return $RatioRangeCopyWith<$Res>(_value.strengthRatioRange!, (value) {
      return _then(_value.copyWith(strengthRatioRange: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get strengthQuantity {
    if (_value.strengthQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.strengthQuantity!, (value) {
      return _then(_value.copyWith(strengthQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get measurementPointElement {
    if (_value.measurementPointElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.measurementPointElement!, (value) {
      return _then(_value.copyWith(measurementPointElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_IngredientReferenceStrengthCopyWith<$Res>
    implements $IngredientReferenceStrengthCopyWith<$Res> {
  factory _$$_IngredientReferenceStrengthCopyWith(
          _$_IngredientReferenceStrength value,
          $Res Function(_$_IngredientReferenceStrength) then) =
      __$$_IngredientReferenceStrengthCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? substance,
      Ratio? strengthRatio,
      RatioRange? strengthRatioRange,
      Quantity? strengthQuantity,
      String? measurementPoint,
      @JsonKey(name: '_measurementPoint') Element? measurementPointElement,
      List<CodeableConcept>? country});

  @override
  $CodeableReferenceCopyWith<$Res>? get substance;
  @override
  $RatioCopyWith<$Res>? get strengthRatio;
  @override
  $RatioRangeCopyWith<$Res>? get strengthRatioRange;
  @override
  $QuantityCopyWith<$Res>? get strengthQuantity;
  @override
  $ElementCopyWith<$Res>? get measurementPointElement;
}

/// @nodoc
class __$$_IngredientReferenceStrengthCopyWithImpl<$Res>
    extends _$IngredientReferenceStrengthCopyWithImpl<$Res,
        _$_IngredientReferenceStrength>
    implements _$$_IngredientReferenceStrengthCopyWith<$Res> {
  __$$_IngredientReferenceStrengthCopyWithImpl(
      _$_IngredientReferenceStrength _value,
      $Res Function(_$_IngredientReferenceStrength) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? substance = freezed,
    Object? strengthRatio = freezed,
    Object? strengthRatioRange = freezed,
    Object? strengthQuantity = freezed,
    Object? measurementPoint = freezed,
    Object? measurementPointElement = freezed,
    Object? country = freezed,
  }) {
    return _then(_$_IngredientReferenceStrength(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      substance: freezed == substance
          ? _value.substance
          : substance // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      strengthRatio: freezed == strengthRatio
          ? _value.strengthRatio
          : strengthRatio // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      strengthRatioRange: freezed == strengthRatioRange
          ? _value.strengthRatioRange
          : strengthRatioRange // ignore: cast_nullable_to_non_nullable
              as RatioRange?,
      strengthQuantity: freezed == strengthQuantity
          ? _value.strengthQuantity
          : strengthQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      measurementPoint: freezed == measurementPoint
          ? _value.measurementPoint
          : measurementPoint // ignore: cast_nullable_to_non_nullable
              as String?,
      measurementPointElement: freezed == measurementPointElement
          ? _value.measurementPointElement
          : measurementPointElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      country: freezed == country
          ? _value._country
          : country // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_IngredientReferenceStrength extends _IngredientReferenceStrength {
  _$_IngredientReferenceStrength(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.substance,
      this.strengthRatio,
      this.strengthRatioRange,
      this.strengthQuantity,
      this.measurementPoint,
      @JsonKey(name: '_measurementPoint') this.measurementPointElement,
      final List<CodeableConcept>? country})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _country = country,
        super._();

  factory _$_IngredientReferenceStrength.fromJson(Map<String, dynamic> json) =>
      _$$_IngredientReferenceStrengthFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [substance] Relevant reference substance.
  @override
  final CodeableReference? substance;

  /// [strengthRatio] Strength expressed in terms of a reference substance.
  @override
  final Ratio? strengthRatio;

  /// [strengthRatioRange] Strength expressed in terms of a reference substance.
  @override
  final RatioRange? strengthRatioRange;

  /// [strengthQuantity] Strength expressed in terms of a reference substance.
  @override
  final Quantity? strengthQuantity;

  /// [measurementPoint] For when strength is measured at a particular point or distance.
  @override
  final String? measurementPoint;

  /// [measurementPointElement] ("_measurementPoint") Extensions for measurementPoint
  @override
  @JsonKey(name: '_measurementPoint')
  final Element? measurementPointElement;

  /// [country] The country or countries for which the strength range applies.
  final List<CodeableConcept>? _country;

  /// [country] The country or countries for which the strength range applies.
  @override
  List<CodeableConcept>? get country {
    final value = _country;
    if (value == null) return null;
    if (_country is EqualUnmodifiableListView) return _country;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'IngredientReferenceStrength(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, substance: $substance, strengthRatio: $strengthRatio, strengthRatioRange: $strengthRatioRange, strengthQuantity: $strengthQuantity, measurementPoint: $measurementPoint, measurementPointElement: $measurementPointElement, country: $country)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_IngredientReferenceStrength &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.substance, substance) ||
                other.substance == substance) &&
            (identical(other.strengthRatio, strengthRatio) ||
                other.strengthRatio == strengthRatio) &&
            (identical(other.strengthRatioRange, strengthRatioRange) ||
                other.strengthRatioRange == strengthRatioRange) &&
            (identical(other.strengthQuantity, strengthQuantity) ||
                other.strengthQuantity == strengthQuantity) &&
            (identical(other.measurementPoint, measurementPoint) ||
                other.measurementPoint == measurementPoint) &&
            (identical(
                    other.measurementPointElement, measurementPointElement) ||
                other.measurementPointElement == measurementPointElement) &&
            const DeepCollectionEquality().equals(other._country, _country));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      substance,
      strengthRatio,
      strengthRatioRange,
      strengthQuantity,
      measurementPoint,
      measurementPointElement,
      const DeepCollectionEquality().hash(_country));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_IngredientReferenceStrengthCopyWith<_$_IngredientReferenceStrength>
      get copyWith => __$$_IngredientReferenceStrengthCopyWithImpl<
          _$_IngredientReferenceStrength>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_IngredientReferenceStrengthToJson(
      this,
    );
  }
}

abstract class _IngredientReferenceStrength
    extends IngredientReferenceStrength {
  factory _IngredientReferenceStrength(
      {final String? id,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableReference? substance,
      final Ratio? strengthRatio,
      final RatioRange? strengthRatioRange,
      final Quantity? strengthQuantity,
      final String? measurementPoint,
      @JsonKey(name: '_measurementPoint')
          final Element? measurementPointElement,
      final List<CodeableConcept>? country}) = _$_IngredientReferenceStrength;
  _IngredientReferenceStrength._() : super._();

  factory _IngredientReferenceStrength.fromJson(Map<String, dynamic> json) =
      _$_IngredientReferenceStrength.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [substance] Relevant reference substance.
  CodeableReference? get substance;
  @override

  /// [strengthRatio] Strength expressed in terms of a reference substance.
  Ratio? get strengthRatio;
  @override

  /// [strengthRatioRange] Strength expressed in terms of a reference substance.
  RatioRange? get strengthRatioRange;
  @override

  /// [strengthQuantity] Strength expressed in terms of a reference substance.
  Quantity? get strengthQuantity;
  @override

  /// [measurementPoint] For when strength is measured at a particular point or distance.
  String? get measurementPoint;
  @override

  /// [measurementPointElement] ("_measurementPoint") Extensions for measurementPoint
  @JsonKey(name: '_measurementPoint')
  Element? get measurementPointElement;
  @override

  /// [country] The country or countries for which the strength range applies.
  List<CodeableConcept>? get country;
  @override
  @JsonKey(ignore: true)
  _$$_IngredientReferenceStrengthCopyWith<_$_IngredientReferenceStrength>
      get copyWith => throw _privateConstructorUsedError;
}

ManufacturedItemDefinition _$ManufacturedItemDefinitionFromJson(
    Map<String, dynamic> json) {
  return _ManufacturedItemDefinition.fromJson(json);
}

/// @nodoc
mixin _$ManufacturedItemDefinition {
  /// [resourceType] This is a ManufacturedItemDefinition resource
  @JsonKey(unknownEnumValue: R5ResourceType.ManufacturedItemDefinition)
  R5ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] Unique identifier.
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [status] The status of this item. Enables tracking the life-cycle of the content.
  Code? get status => throw _privateConstructorUsedError;

  /// [statusElement] ("_status") Extensions for status
  @JsonKey(name: '_status')
  Element? get statusElement => throw _privateConstructorUsedError;

  /// [name] A descriptive name applied to this item.
  String? get name => throw _privateConstructorUsedError;

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement => throw _privateConstructorUsedError;

  /// [manufacturedDoseForm] Dose form as manufactured and before any transformation into the pharmaceutical product.
  CodeableConcept get manufacturedDoseForm =>
      throw _privateConstructorUsedError;

  /// [unitOfPresentation] The real world units in which the quantity of the manufactured item is described.
  CodeableConcept? get unitOfPresentation => throw _privateConstructorUsedError;

  /// [manufacturer] Manufacturer of the item, one of several possible.
  List<Reference>? get manufacturer => throw _privateConstructorUsedError;

  /// [marketingStatus] Allows specifying that an item is on the market for sale, or that it is not available, and the dates and locations associated.
  List<MarketingStatus>? get marketingStatus =>
      throw _privateConstructorUsedError;

  /// [ingredient] The ingredients of this manufactured item. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource.
  List<CodeableConcept>? get ingredient => throw _privateConstructorUsedError;

  /// [property] General characteristics of this item.
  List<ManufacturedItemDefinitionProperty>? get property =>
      throw _privateConstructorUsedError;

  /// [component] Physical parts of the manufactured item, that it is intrisically made from. This is distinct from the ingredients that are part of its chemical makeup.
  List<ManufacturedItemDefinitionComponent>? get component =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ManufacturedItemDefinitionCopyWith<ManufacturedItemDefinition>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ManufacturedItemDefinitionCopyWith<$Res> {
  factory $ManufacturedItemDefinitionCopyWith(ManufacturedItemDefinition value,
          $Res Function(ManufacturedItemDefinition) then) =
      _$ManufacturedItemDefinitionCopyWithImpl<$Res,
          ManufacturedItemDefinition>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.ManufacturedItemDefinition)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      Code? status,
      @JsonKey(name: '_status')
          Element? statusElement,
      String? name,
      @JsonKey(name: '_name')
          Element? nameElement,
      CodeableConcept manufacturedDoseForm,
      CodeableConcept? unitOfPresentation,
      List<Reference>? manufacturer,
      List<MarketingStatus>? marketingStatus,
      List<CodeableConcept>? ingredient,
      List<ManufacturedItemDefinitionProperty>? property,
      List<ManufacturedItemDefinitionComponent>? component});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $ElementCopyWith<$Res>? get statusElement;
  $ElementCopyWith<$Res>? get nameElement;
  $CodeableConceptCopyWith<$Res> get manufacturedDoseForm;
  $CodeableConceptCopyWith<$Res>? get unitOfPresentation;
}

/// @nodoc
class _$ManufacturedItemDefinitionCopyWithImpl<$Res,
        $Val extends ManufacturedItemDefinition>
    implements $ManufacturedItemDefinitionCopyWith<$Res> {
  _$ManufacturedItemDefinitionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? manufacturedDoseForm = null,
    Object? unitOfPresentation = freezed,
    Object? manufacturer = freezed,
    Object? marketingStatus = freezed,
    Object? ingredient = freezed,
    Object? property = freezed,
    Object? component = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as Code?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      manufacturedDoseForm: null == manufacturedDoseForm
          ? _value.manufacturedDoseForm
          : manufacturedDoseForm // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      unitOfPresentation: freezed == unitOfPresentation
          ? _value.unitOfPresentation
          : unitOfPresentation // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      manufacturer: freezed == manufacturer
          ? _value.manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      marketingStatus: freezed == marketingStatus
          ? _value.marketingStatus
          : marketingStatus // ignore: cast_nullable_to_non_nullable
              as List<MarketingStatus>?,
      ingredient: freezed == ingredient
          ? _value.ingredient
          : ingredient // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      property: freezed == property
          ? _value.property
          : property // ignore: cast_nullable_to_non_nullable
              as List<ManufacturedItemDefinitionProperty>?,
      component: freezed == component
          ? _value.component
          : component // ignore: cast_nullable_to_non_nullable
              as List<ManufacturedItemDefinitionComponent>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusElement {
    if (_value.statusElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusElement!, (value) {
      return _then(_value.copyWith(statusElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get nameElement {
    if (_value.nameElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.nameElement!, (value) {
      return _then(_value.copyWith(nameElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get manufacturedDoseForm {
    return $CodeableConceptCopyWith<$Res>(_value.manufacturedDoseForm, (value) {
      return _then(_value.copyWith(manufacturedDoseForm: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get unitOfPresentation {
    if (_value.unitOfPresentation == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.unitOfPresentation!, (value) {
      return _then(_value.copyWith(unitOfPresentation: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ManufacturedItemDefinitionCopyWith<$Res>
    implements $ManufacturedItemDefinitionCopyWith<$Res> {
  factory _$$_ManufacturedItemDefinitionCopyWith(
          _$_ManufacturedItemDefinition value,
          $Res Function(_$_ManufacturedItemDefinition) then) =
      __$$_ManufacturedItemDefinitionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.ManufacturedItemDefinition)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      Code? status,
      @JsonKey(name: '_status')
          Element? statusElement,
      String? name,
      @JsonKey(name: '_name')
          Element? nameElement,
      CodeableConcept manufacturedDoseForm,
      CodeableConcept? unitOfPresentation,
      List<Reference>? manufacturer,
      List<MarketingStatus>? marketingStatus,
      List<CodeableConcept>? ingredient,
      List<ManufacturedItemDefinitionProperty>? property,
      List<ManufacturedItemDefinitionComponent>? component});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $ElementCopyWith<$Res>? get statusElement;
  @override
  $ElementCopyWith<$Res>? get nameElement;
  @override
  $CodeableConceptCopyWith<$Res> get manufacturedDoseForm;
  @override
  $CodeableConceptCopyWith<$Res>? get unitOfPresentation;
}

/// @nodoc
class __$$_ManufacturedItemDefinitionCopyWithImpl<$Res>
    extends _$ManufacturedItemDefinitionCopyWithImpl<$Res,
        _$_ManufacturedItemDefinition>
    implements _$$_ManufacturedItemDefinitionCopyWith<$Res> {
  __$$_ManufacturedItemDefinitionCopyWithImpl(
      _$_ManufacturedItemDefinition _value,
      $Res Function(_$_ManufacturedItemDefinition) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? manufacturedDoseForm = null,
    Object? unitOfPresentation = freezed,
    Object? manufacturer = freezed,
    Object? marketingStatus = freezed,
    Object? ingredient = freezed,
    Object? property = freezed,
    Object? component = freezed,
  }) {
    return _then(_$_ManufacturedItemDefinition(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as Code?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      manufacturedDoseForm: null == manufacturedDoseForm
          ? _value.manufacturedDoseForm
          : manufacturedDoseForm // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      unitOfPresentation: freezed == unitOfPresentation
          ? _value.unitOfPresentation
          : unitOfPresentation // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      manufacturer: freezed == manufacturer
          ? _value._manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      marketingStatus: freezed == marketingStatus
          ? _value._marketingStatus
          : marketingStatus // ignore: cast_nullable_to_non_nullable
              as List<MarketingStatus>?,
      ingredient: freezed == ingredient
          ? _value._ingredient
          : ingredient // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      property: freezed == property
          ? _value._property
          : property // ignore: cast_nullable_to_non_nullable
              as List<ManufacturedItemDefinitionProperty>?,
      component: freezed == component
          ? _value._component
          : component // ignore: cast_nullable_to_non_nullable
              as List<ManufacturedItemDefinitionComponent>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ManufacturedItemDefinition extends _ManufacturedItemDefinition {
  _$_ManufacturedItemDefinition(
      {@JsonKey(unknownEnumValue: R5ResourceType.ManufacturedItemDefinition)
          this.resourceType = R5ResourceType.ManufacturedItemDefinition,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules')
          this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language')
          this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      this.status,
      @JsonKey(name: '_status')
          this.statusElement,
      this.name,
      @JsonKey(name: '_name')
          this.nameElement,
      required this.manufacturedDoseForm,
      this.unitOfPresentation,
      final List<Reference>? manufacturer,
      final List<MarketingStatus>? marketingStatus,
      final List<CodeableConcept>? ingredient,
      final List<ManufacturedItemDefinitionProperty>? property,
      final List<ManufacturedItemDefinitionComponent>? component})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _manufacturer = manufacturer,
        _marketingStatus = marketingStatus,
        _ingredient = ingredient,
        _property = property,
        _component = component,
        super._();

  factory _$_ManufacturedItemDefinition.fromJson(Map<String, dynamic> json) =>
      _$$_ManufacturedItemDefinitionFromJson(json);

  /// [resourceType] This is a ManufacturedItemDefinition resource
  @override
  @JsonKey(unknownEnumValue: R5ResourceType.ManufacturedItemDefinition)
  final R5ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.
  @override
  final Code? language;

  /// [languageElement] ("_language") Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] Unique identifier.
  final List<Identifier>? _identifier;

  /// [identifier] Unique identifier.
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [status] The status of this item. Enables tracking the life-cycle of the content.
  @override
  final Code? status;

  /// [statusElement] ("_status") Extensions for status
  @override
  @JsonKey(name: '_status')
  final Element? statusElement;

  /// [name] A descriptive name applied to this item.
  @override
  final String? name;

  /// [nameElement] ("_name") Extensions for name
  @override
  @JsonKey(name: '_name')
  final Element? nameElement;

  /// [manufacturedDoseForm] Dose form as manufactured and before any transformation into the pharmaceutical product.
  @override
  final CodeableConcept manufacturedDoseForm;

  /// [unitOfPresentation] The real world units in which the quantity of the manufactured item is described.
  @override
  final CodeableConcept? unitOfPresentation;

  /// [manufacturer] Manufacturer of the item, one of several possible.
  final List<Reference>? _manufacturer;

  /// [manufacturer] Manufacturer of the item, one of several possible.
  @override
  List<Reference>? get manufacturer {
    final value = _manufacturer;
    if (value == null) return null;
    if (_manufacturer is EqualUnmodifiableListView) return _manufacturer;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [marketingStatus] Allows specifying that an item is on the market for sale, or that it is not available, and the dates and locations associated.
  final List<MarketingStatus>? _marketingStatus;

  /// [marketingStatus] Allows specifying that an item is on the market for sale, or that it is not available, and the dates and locations associated.
  @override
  List<MarketingStatus>? get marketingStatus {
    final value = _marketingStatus;
    if (value == null) return null;
    if (_marketingStatus is EqualUnmodifiableListView) return _marketingStatus;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [ingredient] The ingredients of this manufactured item. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource.
  final List<CodeableConcept>? _ingredient;

  /// [ingredient] The ingredients of this manufactured item. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource.
  @override
  List<CodeableConcept>? get ingredient {
    final value = _ingredient;
    if (value == null) return null;
    if (_ingredient is EqualUnmodifiableListView) return _ingredient;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [property] General characteristics of this item.
  final List<ManufacturedItemDefinitionProperty>? _property;

  /// [property] General characteristics of this item.
  @override
  List<ManufacturedItemDefinitionProperty>? get property {
    final value = _property;
    if (value == null) return null;
    if (_property is EqualUnmodifiableListView) return _property;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [component] Physical parts of the manufactured item, that it is intrisically made from. This is distinct from the ingredients that are part of its chemical makeup.
  final List<ManufacturedItemDefinitionComponent>? _component;

  /// [component] Physical parts of the manufactured item, that it is intrisically made from. This is distinct from the ingredients that are part of its chemical makeup.
  @override
  List<ManufacturedItemDefinitionComponent>? get component {
    final value = _component;
    if (value == null) return null;
    if (_component is EqualUnmodifiableListView) return _component;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ManufacturedItemDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, status: $status, statusElement: $statusElement, name: $name, nameElement: $nameElement, manufacturedDoseForm: $manufacturedDoseForm, unitOfPresentation: $unitOfPresentation, manufacturer: $manufacturer, marketingStatus: $marketingStatus, ingredient: $ingredient, property: $property, component: $component)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ManufacturedItemDefinition &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusElement, statusElement) ||
                other.statusElement == statusElement) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.nameElement, nameElement) ||
                other.nameElement == nameElement) &&
            (identical(other.manufacturedDoseForm, manufacturedDoseForm) ||
                other.manufacturedDoseForm == manufacturedDoseForm) &&
            (identical(other.unitOfPresentation, unitOfPresentation) ||
                other.unitOfPresentation == unitOfPresentation) &&
            const DeepCollectionEquality()
                .equals(other._manufacturer, _manufacturer) &&
            const DeepCollectionEquality()
                .equals(other._marketingStatus, _marketingStatus) &&
            const DeepCollectionEquality()
                .equals(other._ingredient, _ingredient) &&
            const DeepCollectionEquality().equals(other._property, _property) &&
            const DeepCollectionEquality()
                .equals(other._component, _component));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_identifier),
        status,
        statusElement,
        name,
        nameElement,
        manufacturedDoseForm,
        unitOfPresentation,
        const DeepCollectionEquality().hash(_manufacturer),
        const DeepCollectionEquality().hash(_marketingStatus),
        const DeepCollectionEquality().hash(_ingredient),
        const DeepCollectionEquality().hash(_property),
        const DeepCollectionEquality().hash(_component)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ManufacturedItemDefinitionCopyWith<_$_ManufacturedItemDefinition>
      get copyWith => __$$_ManufacturedItemDefinitionCopyWithImpl<
          _$_ManufacturedItemDefinition>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ManufacturedItemDefinitionToJson(
      this,
    );
  }
}

abstract class _ManufacturedItemDefinition extends ManufacturedItemDefinition {
  factory _ManufacturedItemDefinition(
          {@JsonKey(unknownEnumValue: R5ResourceType.ManufacturedItemDefinition)
              final R5ResourceType resourceType,
          final FhirId? id,
          final Meta? meta,
          final FhirUri? implicitRules,
          @JsonKey(name: '_implicitRules')
              final Element? implicitRulesElement,
          final Code? language,
          @JsonKey(name: '_language')
              final Element? languageElement,
          final Narrative? text,
          final List<Resource>? contained,
          @JsonKey(name: 'extension')
              final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final List<Identifier>? identifier,
          final Code? status,
          @JsonKey(name: '_status')
              final Element? statusElement,
          final String? name,
          @JsonKey(name: '_name')
              final Element? nameElement,
          required final CodeableConcept manufacturedDoseForm,
          final CodeableConcept? unitOfPresentation,
          final List<Reference>? manufacturer,
          final List<MarketingStatus>? marketingStatus,
          final List<CodeableConcept>? ingredient,
          final List<ManufacturedItemDefinitionProperty>? property,
          final List<ManufacturedItemDefinitionComponent>? component}) =
      _$_ManufacturedItemDefinition;
  _ManufacturedItemDefinition._() : super._();

  factory _ManufacturedItemDefinition.fromJson(Map<String, dynamic> json) =
      _$_ManufacturedItemDefinition.fromJson;

  @override

  /// [resourceType] This is a ManufacturedItemDefinition resource
  @JsonKey(unknownEnumValue: R5ResourceType.ManufacturedItemDefinition)
  R5ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.
  Code? get language;
  @override

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained;
  @override

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] Unique identifier.
  List<Identifier>? get identifier;
  @override

  /// [status] The status of this item. Enables tracking the life-cycle of the content.
  Code? get status;
  @override

  /// [statusElement] ("_status") Extensions for status
  @JsonKey(name: '_status')
  Element? get statusElement;
  @override

  /// [name] A descriptive name applied to this item.
  String? get name;
  @override

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement;
  @override

  /// [manufacturedDoseForm] Dose form as manufactured and before any transformation into the pharmaceutical product.
  CodeableConcept get manufacturedDoseForm;
  @override

  /// [unitOfPresentation] The real world units in which the quantity of the manufactured item is described.
  CodeableConcept? get unitOfPresentation;
  @override

  /// [manufacturer] Manufacturer of the item, one of several possible.
  List<Reference>? get manufacturer;
  @override

  /// [marketingStatus] Allows specifying that an item is on the market for sale, or that it is not available, and the dates and locations associated.
  List<MarketingStatus>? get marketingStatus;
  @override

  /// [ingredient] The ingredients of this manufactured item. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource.
  List<CodeableConcept>? get ingredient;
  @override

  /// [property] General characteristics of this item.
  List<ManufacturedItemDefinitionProperty>? get property;
  @override

  /// [component] Physical parts of the manufactured item, that it is intrisically made from. This is distinct from the ingredients that are part of its chemical makeup.
  List<ManufacturedItemDefinitionComponent>? get component;
  @override
  @JsonKey(ignore: true)
  _$$_ManufacturedItemDefinitionCopyWith<_$_ManufacturedItemDefinition>
      get copyWith => throw _privateConstructorUsedError;
}

ManufacturedItemDefinitionProperty _$ManufacturedItemDefinitionPropertyFromJson(
    Map<String, dynamic> json) {
  return _ManufacturedItemDefinitionProperty.fromJson(json);
}

/// @nodoc
mixin _$ManufacturedItemDefinitionProperty {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] A code expressing the type of characteristic.
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [valueCodeableConcept] A value for the characteristic.
  CodeableConcept? get valueCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [valueQuantity] A value for the characteristic.
  Quantity? get valueQuantity => throw _privateConstructorUsedError;

  /// [valueDate] A value for the characteristic.
  Date? get valueDate => throw _privateConstructorUsedError;

  /// [valueDateElement] ("_valueDate") Extensions for valueDate
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement => throw _privateConstructorUsedError;

  /// [valueBoolean] A value for the characteristic.
  Boolean? get valueBoolean => throw _privateConstructorUsedError;

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement => throw _privateConstructorUsedError;

  /// [valueAttachment] A value for the characteristic.
  Attachment? get valueAttachment => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ManufacturedItemDefinitionPropertyCopyWith<
          ManufacturedItemDefinitionProperty>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ManufacturedItemDefinitionPropertyCopyWith<$Res> {
  factory $ManufacturedItemDefinitionPropertyCopyWith(
          ManufacturedItemDefinitionProperty value,
          $Res Function(ManufacturedItemDefinitionProperty) then) =
      _$ManufacturedItemDefinitionPropertyCopyWithImpl<$Res,
          ManufacturedItemDefinitionProperty>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      Quantity? valueQuantity,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment});

  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  $QuantityCopyWith<$Res>? get valueQuantity;
  $ElementCopyWith<$Res>? get valueDateElement;
  $ElementCopyWith<$Res>? get valueBooleanElement;
  $AttachmentCopyWith<$Res>? get valueAttachment;
}

/// @nodoc
class _$ManufacturedItemDefinitionPropertyCopyWithImpl<$Res,
        $Val extends ManufacturedItemDefinitionProperty>
    implements $ManufacturedItemDefinitionPropertyCopyWith<$Res> {
  _$ManufacturedItemDefinitionPropertyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueQuantity = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept {
    if (_value.valueCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.valueCodeableConcept!,
        (value) {
      return _then(_value.copyWith(valueCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get valueQuantity {
    if (_value.valueQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.valueQuantity!, (value) {
      return _then(_value.copyWith(valueQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueDateElement {
    if (_value.valueDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueDateElement!, (value) {
      return _then(_value.copyWith(valueDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueBooleanElement {
    if (_value.valueBooleanElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueBooleanElement!, (value) {
      return _then(_value.copyWith(valueBooleanElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get valueAttachment {
    if (_value.valueAttachment == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.valueAttachment!, (value) {
      return _then(_value.copyWith(valueAttachment: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ManufacturedItemDefinitionPropertyCopyWith<$Res>
    implements $ManufacturedItemDefinitionPropertyCopyWith<$Res> {
  factory _$$_ManufacturedItemDefinitionPropertyCopyWith(
          _$_ManufacturedItemDefinitionProperty value,
          $Res Function(_$_ManufacturedItemDefinitionProperty) then) =
      __$$_ManufacturedItemDefinitionPropertyCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      Quantity? valueQuantity,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  @override
  $QuantityCopyWith<$Res>? get valueQuantity;
  @override
  $ElementCopyWith<$Res>? get valueDateElement;
  @override
  $ElementCopyWith<$Res>? get valueBooleanElement;
  @override
  $AttachmentCopyWith<$Res>? get valueAttachment;
}

/// @nodoc
class __$$_ManufacturedItemDefinitionPropertyCopyWithImpl<$Res>
    extends _$ManufacturedItemDefinitionPropertyCopyWithImpl<$Res,
        _$_ManufacturedItemDefinitionProperty>
    implements _$$_ManufacturedItemDefinitionPropertyCopyWith<$Res> {
  __$$_ManufacturedItemDefinitionPropertyCopyWithImpl(
      _$_ManufacturedItemDefinitionProperty _value,
      $Res Function(_$_ManufacturedItemDefinitionProperty) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueQuantity = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
  }) {
    return _then(_$_ManufacturedItemDefinitionProperty(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ManufacturedItemDefinitionProperty
    extends _ManufacturedItemDefinitionProperty {
  _$_ManufacturedItemDefinitionProperty(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.type,
      this.valueCodeableConcept,
      this.valueQuantity,
      this.valueDate,
      @JsonKey(name: '_valueDate') this.valueDateElement,
      this.valueBoolean,
      @JsonKey(name: '_valueBoolean') this.valueBooleanElement,
      this.valueAttachment})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_ManufacturedItemDefinitionProperty.fromJson(
          Map<String, dynamic> json) =>
      _$$_ManufacturedItemDefinitionPropertyFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] A code expressing the type of characteristic.
  @override
  final CodeableConcept type;

  /// [valueCodeableConcept] A value for the characteristic.
  @override
  final CodeableConcept? valueCodeableConcept;

  /// [valueQuantity] A value for the characteristic.
  @override
  final Quantity? valueQuantity;

  /// [valueDate] A value for the characteristic.
  @override
  final Date? valueDate;

  /// [valueDateElement] ("_valueDate") Extensions for valueDate
  @override
  @JsonKey(name: '_valueDate')
  final Element? valueDateElement;

  /// [valueBoolean] A value for the characteristic.
  @override
  final Boolean? valueBoolean;

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @override
  @JsonKey(name: '_valueBoolean')
  final Element? valueBooleanElement;

  /// [valueAttachment] A value for the characteristic.
  @override
  final Attachment? valueAttachment;

  @override
  String toString() {
    return 'ManufacturedItemDefinitionProperty(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, valueCodeableConcept: $valueCodeableConcept, valueQuantity: $valueQuantity, valueDate: $valueDate, valueDateElement: $valueDateElement, valueBoolean: $valueBoolean, valueBooleanElement: $valueBooleanElement, valueAttachment: $valueAttachment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ManufacturedItemDefinitionProperty &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.valueCodeableConcept, valueCodeableConcept) ||
                other.valueCodeableConcept == valueCodeableConcept) &&
            (identical(other.valueQuantity, valueQuantity) ||
                other.valueQuantity == valueQuantity) &&
            (identical(other.valueDate, valueDate) ||
                other.valueDate == valueDate) &&
            (identical(other.valueDateElement, valueDateElement) ||
                other.valueDateElement == valueDateElement) &&
            (identical(other.valueBoolean, valueBoolean) ||
                other.valueBoolean == valueBoolean) &&
            (identical(other.valueBooleanElement, valueBooleanElement) ||
                other.valueBooleanElement == valueBooleanElement) &&
            (identical(other.valueAttachment, valueAttachment) ||
                other.valueAttachment == valueAttachment));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      valueCodeableConcept,
      valueQuantity,
      valueDate,
      valueDateElement,
      valueBoolean,
      valueBooleanElement,
      valueAttachment);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ManufacturedItemDefinitionPropertyCopyWith<
          _$_ManufacturedItemDefinitionProperty>
      get copyWith => __$$_ManufacturedItemDefinitionPropertyCopyWithImpl<
          _$_ManufacturedItemDefinitionProperty>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ManufacturedItemDefinitionPropertyToJson(
      this,
    );
  }
}

abstract class _ManufacturedItemDefinitionProperty
    extends ManufacturedItemDefinitionProperty {
  factory _ManufacturedItemDefinitionProperty(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept type,
          final CodeableConcept? valueCodeableConcept,
          final Quantity? valueQuantity,
          final Date? valueDate,
          @JsonKey(name: '_valueDate') final Element? valueDateElement,
          final Boolean? valueBoolean,
          @JsonKey(name: '_valueBoolean') final Element? valueBooleanElement,
          final Attachment? valueAttachment}) =
      _$_ManufacturedItemDefinitionProperty;
  _ManufacturedItemDefinitionProperty._() : super._();

  factory _ManufacturedItemDefinitionProperty.fromJson(
          Map<String, dynamic> json) =
      _$_ManufacturedItemDefinitionProperty.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] A code expressing the type of characteristic.
  CodeableConcept get type;
  @override

  /// [valueCodeableConcept] A value for the characteristic.
  CodeableConcept? get valueCodeableConcept;
  @override

  /// [valueQuantity] A value for the characteristic.
  Quantity? get valueQuantity;
  @override

  /// [valueDate] A value for the characteristic.
  Date? get valueDate;
  @override

  /// [valueDateElement] ("_valueDate") Extensions for valueDate
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement;
  @override

  /// [valueBoolean] A value for the characteristic.
  Boolean? get valueBoolean;
  @override

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement;
  @override

  /// [valueAttachment] A value for the characteristic.
  Attachment? get valueAttachment;
  @override
  @JsonKey(ignore: true)
  _$$_ManufacturedItemDefinitionPropertyCopyWith<
          _$_ManufacturedItemDefinitionProperty>
      get copyWith => throw _privateConstructorUsedError;
}

ManufacturedItemDefinitionComponent
    _$ManufacturedItemDefinitionComponentFromJson(Map<String, dynamic> json) {
  return _ManufacturedItemDefinitionComponent.fromJson(json);
}

/// @nodoc
mixin _$ManufacturedItemDefinitionComponent {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] Defining type of the component e.g. shell, layer, ink.
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [function_] ("function") The function of this component within the item e.g. delivers active ingredient, masks taste.
  @JsonKey(name: 'function')
  List<CodeableConcept>? get function_ => throw _privateConstructorUsedError;

  /// [amount] The measurable amount of total quantity of all substances in the component, expressable in different ways (e.g. by mass or volume).
  List<Quantity>? get amount => throw _privateConstructorUsedError;

  /// [constituent] A reference to an constituent of the manufactured item as a whole, linked here so that its component location within the item can be indicated. This not where the item's ingredient are primarily stated (for which see Ingredient.for or ManufacturedItemDefinition.ingredient).
  List<ManufacturedItemDefinitionConstituent>? get constituent =>
      throw _privateConstructorUsedError;

  /// [property] General characteristics of this component.
  List<ManufacturedItemDefinitionProperty>? get property =>
      throw _privateConstructorUsedError;

  /// [component] A component that this component contains or is made from.
  List<ManufacturedItemDefinitionComponent>? get component =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ManufacturedItemDefinitionComponentCopyWith<
          ManufacturedItemDefinitionComponent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ManufacturedItemDefinitionComponentCopyWith<$Res> {
  factory $ManufacturedItemDefinitionComponentCopyWith(
          ManufacturedItemDefinitionComponent value,
          $Res Function(ManufacturedItemDefinitionComponent) then) =
      _$ManufacturedItemDefinitionComponentCopyWithImpl<$Res,
          ManufacturedItemDefinitionComponent>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      @JsonKey(name: 'function') List<CodeableConcept>? function_,
      List<Quantity>? amount,
      List<ManufacturedItemDefinitionConstituent>? constituent,
      List<ManufacturedItemDefinitionProperty>? property,
      List<ManufacturedItemDefinitionComponent>? component});

  $CodeableConceptCopyWith<$Res> get type;
}

/// @nodoc
class _$ManufacturedItemDefinitionComponentCopyWithImpl<$Res,
        $Val extends ManufacturedItemDefinitionComponent>
    implements $ManufacturedItemDefinitionComponentCopyWith<$Res> {
  _$ManufacturedItemDefinitionComponentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? function_ = freezed,
    Object? amount = freezed,
    Object? constituent = freezed,
    Object? property = freezed,
    Object? component = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      function_: freezed == function_
          ? _value.function_
          : function_ // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as List<Quantity>?,
      constituent: freezed == constituent
          ? _value.constituent
          : constituent // ignore: cast_nullable_to_non_nullable
              as List<ManufacturedItemDefinitionConstituent>?,
      property: freezed == property
          ? _value.property
          : property // ignore: cast_nullable_to_non_nullable
              as List<ManufacturedItemDefinitionProperty>?,
      component: freezed == component
          ? _value.component
          : component // ignore: cast_nullable_to_non_nullable
              as List<ManufacturedItemDefinitionComponent>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ManufacturedItemDefinitionComponentCopyWith<$Res>
    implements $ManufacturedItemDefinitionComponentCopyWith<$Res> {
  factory _$$_ManufacturedItemDefinitionComponentCopyWith(
          _$_ManufacturedItemDefinitionComponent value,
          $Res Function(_$_ManufacturedItemDefinitionComponent) then) =
      __$$_ManufacturedItemDefinitionComponentCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      @JsonKey(name: 'function') List<CodeableConcept>? function_,
      List<Quantity>? amount,
      List<ManufacturedItemDefinitionConstituent>? constituent,
      List<ManufacturedItemDefinitionProperty>? property,
      List<ManufacturedItemDefinitionComponent>? component});

  @override
  $CodeableConceptCopyWith<$Res> get type;
}

/// @nodoc
class __$$_ManufacturedItemDefinitionComponentCopyWithImpl<$Res>
    extends _$ManufacturedItemDefinitionComponentCopyWithImpl<$Res,
        _$_ManufacturedItemDefinitionComponent>
    implements _$$_ManufacturedItemDefinitionComponentCopyWith<$Res> {
  __$$_ManufacturedItemDefinitionComponentCopyWithImpl(
      _$_ManufacturedItemDefinitionComponent _value,
      $Res Function(_$_ManufacturedItemDefinitionComponent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? function_ = freezed,
    Object? amount = freezed,
    Object? constituent = freezed,
    Object? property = freezed,
    Object? component = freezed,
  }) {
    return _then(_$_ManufacturedItemDefinitionComponent(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      function_: freezed == function_
          ? _value._function_
          : function_ // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      amount: freezed == amount
          ? _value._amount
          : amount // ignore: cast_nullable_to_non_nullable
              as List<Quantity>?,
      constituent: freezed == constituent
          ? _value._constituent
          : constituent // ignore: cast_nullable_to_non_nullable
              as List<ManufacturedItemDefinitionConstituent>?,
      property: freezed == property
          ? _value._property
          : property // ignore: cast_nullable_to_non_nullable
              as List<ManufacturedItemDefinitionProperty>?,
      component: freezed == component
          ? _value._component
          : component // ignore: cast_nullable_to_non_nullable
              as List<ManufacturedItemDefinitionComponent>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ManufacturedItemDefinitionComponent
    extends _ManufacturedItemDefinitionComponent {
  _$_ManufacturedItemDefinitionComponent(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.type,
      @JsonKey(name: 'function') final List<CodeableConcept>? function_,
      final List<Quantity>? amount,
      final List<ManufacturedItemDefinitionConstituent>? constituent,
      final List<ManufacturedItemDefinitionProperty>? property,
      final List<ManufacturedItemDefinitionComponent>? component})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _function_ = function_,
        _amount = amount,
        _constituent = constituent,
        _property = property,
        _component = component,
        super._();

  factory _$_ManufacturedItemDefinitionComponent.fromJson(
          Map<String, dynamic> json) =>
      _$$_ManufacturedItemDefinitionComponentFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] Defining type of the component e.g. shell, layer, ink.
  @override
  final CodeableConcept type;

  /// [function_] ("function") The function of this component within the item e.g. delivers active ingredient, masks taste.
  final List<CodeableConcept>? _function_;

  /// [function_] ("function") The function of this component within the item e.g. delivers active ingredient, masks taste.
  @override
  @JsonKey(name: 'function')
  List<CodeableConcept>? get function_ {
    final value = _function_;
    if (value == null) return null;
    if (_function_ is EqualUnmodifiableListView) return _function_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [amount] The measurable amount of total quantity of all substances in the component, expressable in different ways (e.g. by mass or volume).
  final List<Quantity>? _amount;

  /// [amount] The measurable amount of total quantity of all substances in the component, expressable in different ways (e.g. by mass or volume).
  @override
  List<Quantity>? get amount {
    final value = _amount;
    if (value == null) return null;
    if (_amount is EqualUnmodifiableListView) return _amount;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [constituent] A reference to an constituent of the manufactured item as a whole, linked here so that its component location within the item can be indicated. This not where the item's ingredient are primarily stated (for which see Ingredient.for or ManufacturedItemDefinition.ingredient).
  final List<ManufacturedItemDefinitionConstituent>? _constituent;

  /// [constituent] A reference to an constituent of the manufactured item as a whole, linked here so that its component location within the item can be indicated. This not where the item's ingredient are primarily stated (for which see Ingredient.for or ManufacturedItemDefinition.ingredient).
  @override
  List<ManufacturedItemDefinitionConstituent>? get constituent {
    final value = _constituent;
    if (value == null) return null;
    if (_constituent is EqualUnmodifiableListView) return _constituent;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [property] General characteristics of this component.
  final List<ManufacturedItemDefinitionProperty>? _property;

  /// [property] General characteristics of this component.
  @override
  List<ManufacturedItemDefinitionProperty>? get property {
    final value = _property;
    if (value == null) return null;
    if (_property is EqualUnmodifiableListView) return _property;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [component] A component that this component contains or is made from.
  final List<ManufacturedItemDefinitionComponent>? _component;

  /// [component] A component that this component contains or is made from.
  @override
  List<ManufacturedItemDefinitionComponent>? get component {
    final value = _component;
    if (value == null) return null;
    if (_component is EqualUnmodifiableListView) return _component;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ManufacturedItemDefinitionComponent(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, function_: $function_, amount: $amount, constituent: $constituent, property: $property, component: $component)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ManufacturedItemDefinitionComponent &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality()
                .equals(other._function_, _function_) &&
            const DeepCollectionEquality().equals(other._amount, _amount) &&
            const DeepCollectionEquality()
                .equals(other._constituent, _constituent) &&
            const DeepCollectionEquality().equals(other._property, _property) &&
            const DeepCollectionEquality()
                .equals(other._component, _component));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      const DeepCollectionEquality().hash(_function_),
      const DeepCollectionEquality().hash(_amount),
      const DeepCollectionEquality().hash(_constituent),
      const DeepCollectionEquality().hash(_property),
      const DeepCollectionEquality().hash(_component));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ManufacturedItemDefinitionComponentCopyWith<
          _$_ManufacturedItemDefinitionComponent>
      get copyWith => __$$_ManufacturedItemDefinitionComponentCopyWithImpl<
          _$_ManufacturedItemDefinitionComponent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ManufacturedItemDefinitionComponentToJson(
      this,
    );
  }
}

abstract class _ManufacturedItemDefinitionComponent
    extends ManufacturedItemDefinitionComponent {
  factory _ManufacturedItemDefinitionComponent(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept type,
          @JsonKey(name: 'function') final List<CodeableConcept>? function_,
          final List<Quantity>? amount,
          final List<ManufacturedItemDefinitionConstituent>? constituent,
          final List<ManufacturedItemDefinitionProperty>? property,
          final List<ManufacturedItemDefinitionComponent>? component}) =
      _$_ManufacturedItemDefinitionComponent;
  _ManufacturedItemDefinitionComponent._() : super._();

  factory _ManufacturedItemDefinitionComponent.fromJson(
          Map<String, dynamic> json) =
      _$_ManufacturedItemDefinitionComponent.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] Defining type of the component e.g. shell, layer, ink.
  CodeableConcept get type;
  @override

  /// [function_] ("function") The function of this component within the item e.g. delivers active ingredient, masks taste.
  @JsonKey(name: 'function')
  List<CodeableConcept>? get function_;
  @override

  /// [amount] The measurable amount of total quantity of all substances in the component, expressable in different ways (e.g. by mass or volume).
  List<Quantity>? get amount;
  @override

  /// [constituent] A reference to an constituent of the manufactured item as a whole, linked here so that its component location within the item can be indicated. This not where the item's ingredient are primarily stated (for which see Ingredient.for or ManufacturedItemDefinition.ingredient).
  List<ManufacturedItemDefinitionConstituent>? get constituent;
  @override

  /// [property] General characteristics of this component.
  List<ManufacturedItemDefinitionProperty>? get property;
  @override

  /// [component] A component that this component contains or is made from.
  List<ManufacturedItemDefinitionComponent>? get component;
  @override
  @JsonKey(ignore: true)
  _$$_ManufacturedItemDefinitionComponentCopyWith<
          _$_ManufacturedItemDefinitionComponent>
      get copyWith => throw _privateConstructorUsedError;
}

ManufacturedItemDefinitionConstituent
    _$ManufacturedItemDefinitionConstituentFromJson(Map<String, dynamic> json) {
  return _ManufacturedItemDefinitionConstituent.fromJson(json);
}

/// @nodoc
mixin _$ManufacturedItemDefinitionConstituent {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [amount] The measurable amount of the substance, expressable in different ways (e.g. by mass or volume).
  List<Quantity>? get amount => throw _privateConstructorUsedError;

  /// [location] The physical location of the constituent/ingredient within the component. Example  if the component is the bead in the capsule, then the location would be where the ingredient resides within the product part  intragranular, extra-granular, etc.
  List<CodeableConcept>? get location => throw _privateConstructorUsedError;

  /// [function_] ("function") The function of this constituent within the component e.g. binder.
  @JsonKey(name: 'function')
  List<CodeableConcept>? get function_ => throw _privateConstructorUsedError;

  /// [hasIngredient] The ingredient that is the constituent of the given component.
  List<CodeableReference>? get hasIngredient =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ManufacturedItemDefinitionConstituentCopyWith<
          ManufacturedItemDefinitionConstituent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ManufacturedItemDefinitionConstituentCopyWith<$Res> {
  factory $ManufacturedItemDefinitionConstituentCopyWith(
          ManufacturedItemDefinitionConstituent value,
          $Res Function(ManufacturedItemDefinitionConstituent) then) =
      _$ManufacturedItemDefinitionConstituentCopyWithImpl<$Res,
          ManufacturedItemDefinitionConstituent>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Quantity>? amount,
      List<CodeableConcept>? location,
      @JsonKey(name: 'function') List<CodeableConcept>? function_,
      List<CodeableReference>? hasIngredient});
}

/// @nodoc
class _$ManufacturedItemDefinitionConstituentCopyWithImpl<$Res,
        $Val extends ManufacturedItemDefinitionConstituent>
    implements $ManufacturedItemDefinitionConstituentCopyWith<$Res> {
  _$ManufacturedItemDefinitionConstituentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? amount = freezed,
    Object? location = freezed,
    Object? function_ = freezed,
    Object? hasIngredient = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as List<Quantity>?,
      location: freezed == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      function_: freezed == function_
          ? _value.function_
          : function_ // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      hasIngredient: freezed == hasIngredient
          ? _value.hasIngredient
          : hasIngredient // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ManufacturedItemDefinitionConstituentCopyWith<$Res>
    implements $ManufacturedItemDefinitionConstituentCopyWith<$Res> {
  factory _$$_ManufacturedItemDefinitionConstituentCopyWith(
          _$_ManufacturedItemDefinitionConstituent value,
          $Res Function(_$_ManufacturedItemDefinitionConstituent) then) =
      __$$_ManufacturedItemDefinitionConstituentCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Quantity>? amount,
      List<CodeableConcept>? location,
      @JsonKey(name: 'function') List<CodeableConcept>? function_,
      List<CodeableReference>? hasIngredient});
}

/// @nodoc
class __$$_ManufacturedItemDefinitionConstituentCopyWithImpl<$Res>
    extends _$ManufacturedItemDefinitionConstituentCopyWithImpl<$Res,
        _$_ManufacturedItemDefinitionConstituent>
    implements _$$_ManufacturedItemDefinitionConstituentCopyWith<$Res> {
  __$$_ManufacturedItemDefinitionConstituentCopyWithImpl(
      _$_ManufacturedItemDefinitionConstituent _value,
      $Res Function(_$_ManufacturedItemDefinitionConstituent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? amount = freezed,
    Object? location = freezed,
    Object? function_ = freezed,
    Object? hasIngredient = freezed,
  }) {
    return _then(_$_ManufacturedItemDefinitionConstituent(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      amount: freezed == amount
          ? _value._amount
          : amount // ignore: cast_nullable_to_non_nullable
              as List<Quantity>?,
      location: freezed == location
          ? _value._location
          : location // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      function_: freezed == function_
          ? _value._function_
          : function_ // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      hasIngredient: freezed == hasIngredient
          ? _value._hasIngredient
          : hasIngredient // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ManufacturedItemDefinitionConstituent
    extends _ManufacturedItemDefinitionConstituent {
  _$_ManufacturedItemDefinitionConstituent(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Quantity>? amount,
      final List<CodeableConcept>? location,
      @JsonKey(name: 'function') final List<CodeableConcept>? function_,
      final List<CodeableReference>? hasIngredient})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _amount = amount,
        _location = location,
        _function_ = function_,
        _hasIngredient = hasIngredient,
        super._();

  factory _$_ManufacturedItemDefinitionConstituent.fromJson(
          Map<String, dynamic> json) =>
      _$$_ManufacturedItemDefinitionConstituentFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [amount] The measurable amount of the substance, expressable in different ways (e.g. by mass or volume).
  final List<Quantity>? _amount;

  /// [amount] The measurable amount of the substance, expressable in different ways (e.g. by mass or volume).
  @override
  List<Quantity>? get amount {
    final value = _amount;
    if (value == null) return null;
    if (_amount is EqualUnmodifiableListView) return _amount;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [location] The physical location of the constituent/ingredient within the component. Example  if the component is the bead in the capsule, then the location would be where the ingredient resides within the product part  intragranular, extra-granular, etc.
  final List<CodeableConcept>? _location;

  /// [location] The physical location of the constituent/ingredient within the component. Example  if the component is the bead in the capsule, then the location would be where the ingredient resides within the product part  intragranular, extra-granular, etc.
  @override
  List<CodeableConcept>? get location {
    final value = _location;
    if (value == null) return null;
    if (_location is EqualUnmodifiableListView) return _location;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [function_] ("function") The function of this constituent within the component e.g. binder.
  final List<CodeableConcept>? _function_;

  /// [function_] ("function") The function of this constituent within the component e.g. binder.
  @override
  @JsonKey(name: 'function')
  List<CodeableConcept>? get function_ {
    final value = _function_;
    if (value == null) return null;
    if (_function_ is EqualUnmodifiableListView) return _function_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [hasIngredient] The ingredient that is the constituent of the given component.
  final List<CodeableReference>? _hasIngredient;

  /// [hasIngredient] The ingredient that is the constituent of the given component.
  @override
  List<CodeableReference>? get hasIngredient {
    final value = _hasIngredient;
    if (value == null) return null;
    if (_hasIngredient is EqualUnmodifiableListView) return _hasIngredient;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ManufacturedItemDefinitionConstituent(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, amount: $amount, location: $location, function_: $function_, hasIngredient: $hasIngredient)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ManufacturedItemDefinitionConstituent &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality().equals(other._amount, _amount) &&
            const DeepCollectionEquality().equals(other._location, _location) &&
            const DeepCollectionEquality()
                .equals(other._function_, _function_) &&
            const DeepCollectionEquality()
                .equals(other._hasIngredient, _hasIngredient));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      const DeepCollectionEquality().hash(_amount),
      const DeepCollectionEquality().hash(_location),
      const DeepCollectionEquality().hash(_function_),
      const DeepCollectionEquality().hash(_hasIngredient));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ManufacturedItemDefinitionConstituentCopyWith<
          _$_ManufacturedItemDefinitionConstituent>
      get copyWith => __$$_ManufacturedItemDefinitionConstituentCopyWithImpl<
          _$_ManufacturedItemDefinitionConstituent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ManufacturedItemDefinitionConstituentToJson(
      this,
    );
  }
}

abstract class _ManufacturedItemDefinitionConstituent
    extends ManufacturedItemDefinitionConstituent {
  factory _ManufacturedItemDefinitionConstituent(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final List<Quantity>? amount,
          final List<CodeableConcept>? location,
          @JsonKey(name: 'function') final List<CodeableConcept>? function_,
          final List<CodeableReference>? hasIngredient}) =
      _$_ManufacturedItemDefinitionConstituent;
  _ManufacturedItemDefinitionConstituent._() : super._();

  factory _ManufacturedItemDefinitionConstituent.fromJson(
          Map<String, dynamic> json) =
      _$_ManufacturedItemDefinitionConstituent.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [amount] The measurable amount of the substance, expressable in different ways (e.g. by mass or volume).
  List<Quantity>? get amount;
  @override

  /// [location] The physical location of the constituent/ingredient within the component. Example  if the component is the bead in the capsule, then the location would be where the ingredient resides within the product part  intragranular, extra-granular, etc.
  List<CodeableConcept>? get location;
  @override

  /// [function_] ("function") The function of this constituent within the component e.g. binder.
  @JsonKey(name: 'function')
  List<CodeableConcept>? get function_;
  @override

  /// [hasIngredient] The ingredient that is the constituent of the given component.
  List<CodeableReference>? get hasIngredient;
  @override
  @JsonKey(ignore: true)
  _$$_ManufacturedItemDefinitionConstituentCopyWith<
          _$_ManufacturedItemDefinitionConstituent>
      get copyWith => throw _privateConstructorUsedError;
}

MedicinalProductDefinition _$MedicinalProductDefinitionFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductDefinition.fromJson(json);
}

/// @nodoc
mixin _$MedicinalProductDefinition {
  /// [resourceType] This is a MedicinalProductDefinition resource
  @JsonKey(unknownEnumValue: R5ResourceType.MedicinalProductDefinition)
  R5ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] Business identifier for this product. Could be an MPID. When in development or being regulated, products are typically referenced by official identifiers, assigned by a manufacturer or regulator, and unique to a product (which, when compared to a product instance being prescribed, is actually a product type). See also MedicinalProductDefinition.code.
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [type] Regulatory type, e.g. Investigational or Authorized.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [domain] If this medicine applies to human or veterinary uses.
  CodeableConcept? get domain => throw _privateConstructorUsedError;

  /// [version] A business identifier relating to a specific version of the product, this is commonly used to support revisions to an existing product.
  String? get version => throw _privateConstructorUsedError;

  /// [versionElement] ("_version") Extensions for version
  @JsonKey(name: '_version')
  Element? get versionElement => throw _privateConstructorUsedError;

  /// [status] The status within the lifecycle of this product record. A high-level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization status.
  CodeableConcept? get status => throw _privateConstructorUsedError;

  /// [statusDate] The date at which the given status became applicable.
  FhirDateTime? get statusDate => throw _privateConstructorUsedError;

  /// [statusDateElement] ("_statusDate") Extensions for statusDate
  @JsonKey(name: '_statusDate')
  Element? get statusDateElement => throw _privateConstructorUsedError;

  /// [description] General description of this product.
  Markdown? get description => throw _privateConstructorUsedError;

  /// [descriptionElement] ("_description") Extensions for description
  @JsonKey(name: '_description')
  Element? get descriptionElement => throw _privateConstructorUsedError;

  /// [combinedPharmaceuticalDoseForm] The dose form for a single part product, or combined form of a multiple part product. This is one concept that describes all the components. It does not represent the form with components physically mixed, if that might be necessary, for which see (AdministrableProductDefinition.administrableDoseForm).
  CodeableConcept? get combinedPharmaceuticalDoseForm =>
      throw _privateConstructorUsedError;

  /// [route] The path by which the product is taken into or makes contact with the body. In some regions this is referred to as the licenced or approved route. See also AdministrableProductDefinition resource. MedicinalProductDefinition.route is the same concept as AdministrableProductDefinition.routeOfAdministration.code, and they cannot be used together.
  List<CodeableConcept>? get route => throw _privateConstructorUsedError;

  /// [indication] Description of indication(s) for this product, used when structured indications are not required. In cases where structured indications are required, they are captured using the ClinicalUseDefinition resource. An indication is a medical situation for which using the product is appropriate.
  Markdown? get indication => throw _privateConstructorUsedError;

  /// [indicationElement] ("_indication") Extensions for indication
  @JsonKey(name: '_indication')
  Element? get indicationElement => throw _privateConstructorUsedError;

  /// [legalStatusOfSupply] The legal status of supply of the medicinal product as classified by the regulator.
  CodeableConcept? get legalStatusOfSupply =>
      throw _privateConstructorUsedError;

  /// [additionalMonitoringIndicator] Whether the Medicinal Product is subject to additional monitoring for regulatory reasons, such as heightened reporting requirements.
  CodeableConcept? get additionalMonitoringIndicator =>
      throw _privateConstructorUsedError;

  /// [specialMeasures] Whether the Medicinal Product is subject to special measures for regulatory reasons, such as a requirement to conduct post-authorisation studies.
  List<CodeableConcept>? get specialMeasures =>
      throw _privateConstructorUsedError;

  /// [pediatricUseIndicator] If authorised for use in children, or infants, neonates etc.
  CodeableConcept? get pediatricUseIndicator =>
      throw _privateConstructorUsedError;

  /// [classification] Allows the product to be classified by various systems, commonly WHO ATC.
  List<CodeableConcept>? get classification =>
      throw _privateConstructorUsedError;

  /// [marketingStatus] Marketing status of the medicinal product, in contrast to marketing authorization. This refers to the product being actually 'on the market' as opposed to being allowed to be on the market (which is an authorization).
  List<MarketingStatus>? get marketingStatus =>
      throw _privateConstructorUsedError;

  /// [packagedMedicinalProduct] Package type for the product. See also the PackagedProductDefinition resource.
  List<CodeableConcept>? get packagedMedicinalProduct =>
      throw _privateConstructorUsedError;

  /// [comprisedOf] Types of medicinal manufactured items and/or devices that this product consists of, such as tablets, capsule, or syringes. Used as a direct link when the item's packaging is not being recorded (see also PackagedProductDefinition.package.containedItem.item).
  List<Reference>? get comprisedOf => throw _privateConstructorUsedError;

  /// [ingredient] The ingredients of this medicinal product - when not detailed in other resources. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource, or indirectly via incoming AdministrableProductDefinition, PackagedProductDefinition or ManufacturedItemDefinition references. In cases where those levels of detail are not used, the ingredients may be specified directly here as codes.
  List<CodeableConcept>? get ingredient => throw _privateConstructorUsedError;

  /// [impurity] Any component of the drug product which is not the chemical entity defined as the drug substance, or an excipient in the drug product. This includes process-related impurities and contaminants, product-related impurities including degradation products.
  List<CodeableReference>? get impurity => throw _privateConstructorUsedError;

  /// [attachedDocument] Additional information or supporting documentation about the medicinal product.
  List<Reference>? get attachedDocument => throw _privateConstructorUsedError;

  /// [masterFile] A master file for the medicinal product (e.g. Pharmacovigilance System Master File). Drug master files (DMFs) are documents submitted to regulatory agencies to provide confidential detailed information about facilities, processes or articles used in the manufacturing, processing, packaging and storing of drug products.
  List<Reference>? get masterFile => throw _privateConstructorUsedError;

  /// [contact] A product specific contact, person (in a role), or an organization.
  List<MedicinalProductDefinitionContact>? get contact =>
      throw _privateConstructorUsedError;

  /// [clinicalTrial] Clinical trials or studies that this product is involved in.
  List<Reference>? get clinicalTrial => throw _privateConstructorUsedError;

  /// [code] A code that this product is known by, usually within some formal terminology, perhaps assigned by a third party (i.e. not the manufacturer or regulator). Products (types of medications) tend to be known by identifiers during development and within regulatory process. However when they are prescribed they tend to be identified by codes. The same product may be have multiple codes, applied to it by multiple organizations.
  List<Coding>? get code => throw _privateConstructorUsedError;

  /// [name] The product's name, including full name and possibly coded parts.
  List<MedicinalProductDefinitionName> get name =>
      throw _privateConstructorUsedError;

  /// [crossReference] Reference to another product, e.g. for linking authorised to investigational product, or a virtual product.
  List<MedicinalProductDefinitionCrossReference>? get crossReference =>
      throw _privateConstructorUsedError;

  /// [operation] A manufacturing or administrative process or step associated with (or performed on) the medicinal product.
  List<MedicinalProductDefinitionOperation>? get operation =>
      throw _privateConstructorUsedError;

  /// [characteristic] Allows the key product features to be recorded, such as "sugar free", "modified release", "parallel import".
  List<MedicinalProductDefinitionCharacteristic>? get characteristic =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MedicinalProductDefinitionCopyWith<MedicinalProductDefinition>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MedicinalProductDefinitionCopyWith<$Res> {
  factory $MedicinalProductDefinitionCopyWith(MedicinalProductDefinition value,
          $Res Function(MedicinalProductDefinition) then) =
      _$MedicinalProductDefinitionCopyWithImpl<$Res,
          MedicinalProductDefinition>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.MedicinalProductDefinition)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      CodeableConcept? type,
      CodeableConcept? domain,
      String? version,
      @JsonKey(name: '_version')
          Element? versionElement,
      CodeableConcept? status,
      FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate')
          Element? statusDateElement,
      Markdown? description,
      @JsonKey(name: '_description')
          Element? descriptionElement,
      CodeableConcept? combinedPharmaceuticalDoseForm,
      List<CodeableConcept>? route,
      Markdown? indication,
      @JsonKey(name: '_indication')
          Element? indicationElement,
      CodeableConcept? legalStatusOfSupply,
      CodeableConcept? additionalMonitoringIndicator,
      List<CodeableConcept>? specialMeasures,
      CodeableConcept? pediatricUseIndicator,
      List<CodeableConcept>? classification,
      List<MarketingStatus>? marketingStatus,
      List<CodeableConcept>? packagedMedicinalProduct,
      List<Reference>? comprisedOf,
      List<CodeableConcept>? ingredient,
      List<CodeableReference>? impurity,
      List<Reference>? attachedDocument,
      List<Reference>? masterFile,
      List<MedicinalProductDefinitionContact>? contact,
      List<Reference>? clinicalTrial,
      List<Coding>? code,
      List<MedicinalProductDefinitionName> name,
      List<MedicinalProductDefinitionCrossReference>? crossReference,
      List<MedicinalProductDefinitionOperation>? operation,
      List<MedicinalProductDefinitionCharacteristic>? characteristic});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $CodeableConceptCopyWith<$Res>? get type;
  $CodeableConceptCopyWith<$Res>? get domain;
  $ElementCopyWith<$Res>? get versionElement;
  $CodeableConceptCopyWith<$Res>? get status;
  $ElementCopyWith<$Res>? get statusDateElement;
  $ElementCopyWith<$Res>? get descriptionElement;
  $CodeableConceptCopyWith<$Res>? get combinedPharmaceuticalDoseForm;
  $ElementCopyWith<$Res>? get indicationElement;
  $CodeableConceptCopyWith<$Res>? get legalStatusOfSupply;
  $CodeableConceptCopyWith<$Res>? get additionalMonitoringIndicator;
  $CodeableConceptCopyWith<$Res>? get pediatricUseIndicator;
}

/// @nodoc
class _$MedicinalProductDefinitionCopyWithImpl<$Res,
        $Val extends MedicinalProductDefinition>
    implements $MedicinalProductDefinitionCopyWith<$Res> {
  _$MedicinalProductDefinitionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = freezed,
    Object? domain = freezed,
    Object? version = freezed,
    Object? versionElement = freezed,
    Object? status = freezed,
    Object? statusDate = freezed,
    Object? statusDateElement = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? combinedPharmaceuticalDoseForm = freezed,
    Object? route = freezed,
    Object? indication = freezed,
    Object? indicationElement = freezed,
    Object? legalStatusOfSupply = freezed,
    Object? additionalMonitoringIndicator = freezed,
    Object? specialMeasures = freezed,
    Object? pediatricUseIndicator = freezed,
    Object? classification = freezed,
    Object? marketingStatus = freezed,
    Object? packagedMedicinalProduct = freezed,
    Object? comprisedOf = freezed,
    Object? ingredient = freezed,
    Object? impurity = freezed,
    Object? attachedDocument = freezed,
    Object? masterFile = freezed,
    Object? contact = freezed,
    Object? clinicalTrial = freezed,
    Object? code = freezed,
    Object? name = null,
    Object? crossReference = freezed,
    Object? operation = freezed,
    Object? characteristic = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      domain: freezed == domain
          ? _value.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      version: freezed == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String?,
      versionElement: freezed == versionElement
          ? _value.versionElement
          : versionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      statusDate: freezed == statusDate
          ? _value.statusDate
          : statusDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      statusDateElement: freezed == statusDateElement
          ? _value.statusDateElement
          : statusDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      combinedPharmaceuticalDoseForm: freezed == combinedPharmaceuticalDoseForm
          ? _value.combinedPharmaceuticalDoseForm
          : combinedPharmaceuticalDoseForm // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      route: freezed == route
          ? _value.route
          : route // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      indication: freezed == indication
          ? _value.indication
          : indication // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      indicationElement: freezed == indicationElement
          ? _value.indicationElement
          : indicationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      legalStatusOfSupply: freezed == legalStatusOfSupply
          ? _value.legalStatusOfSupply
          : legalStatusOfSupply // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      additionalMonitoringIndicator: freezed == additionalMonitoringIndicator
          ? _value.additionalMonitoringIndicator
          : additionalMonitoringIndicator // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      specialMeasures: freezed == specialMeasures
          ? _value.specialMeasures
          : specialMeasures // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      pediatricUseIndicator: freezed == pediatricUseIndicator
          ? _value.pediatricUseIndicator
          : pediatricUseIndicator // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      classification: freezed == classification
          ? _value.classification
          : classification // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      marketingStatus: freezed == marketingStatus
          ? _value.marketingStatus
          : marketingStatus // ignore: cast_nullable_to_non_nullable
              as List<MarketingStatus>?,
      packagedMedicinalProduct: freezed == packagedMedicinalProduct
          ? _value.packagedMedicinalProduct
          : packagedMedicinalProduct // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      comprisedOf: freezed == comprisedOf
          ? _value.comprisedOf
          : comprisedOf // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      ingredient: freezed == ingredient
          ? _value.ingredient
          : ingredient // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      impurity: freezed == impurity
          ? _value.impurity
          : impurity // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      attachedDocument: freezed == attachedDocument
          ? _value.attachedDocument
          : attachedDocument // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      masterFile: freezed == masterFile
          ? _value.masterFile
          : masterFile // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      contact: freezed == contact
          ? _value.contact
          : contact // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionContact>?,
      clinicalTrial: freezed == clinicalTrial
          ? _value.clinicalTrial
          : clinicalTrial // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as List<Coding>?,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionName>,
      crossReference: freezed == crossReference
          ? _value.crossReference
          : crossReference // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionCrossReference>?,
      operation: freezed == operation
          ? _value.operation
          : operation // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionOperation>?,
      characteristic: freezed == characteristic
          ? _value.characteristic
          : characteristic // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionCharacteristic>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get domain {
    if (_value.domain == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.domain!, (value) {
      return _then(_value.copyWith(domain: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get versionElement {
    if (_value.versionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.versionElement!, (value) {
      return _then(_value.copyWith(versionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusDateElement {
    if (_value.statusDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusDateElement!, (value) {
      return _then(_value.copyWith(statusDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get descriptionElement {
    if (_value.descriptionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.descriptionElement!, (value) {
      return _then(_value.copyWith(descriptionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get combinedPharmaceuticalDoseForm {
    if (_value.combinedPharmaceuticalDoseForm == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(
        _value.combinedPharmaceuticalDoseForm!, (value) {
      return _then(
          _value.copyWith(combinedPharmaceuticalDoseForm: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get indicationElement {
    if (_value.indicationElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.indicationElement!, (value) {
      return _then(_value.copyWith(indicationElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get legalStatusOfSupply {
    if (_value.legalStatusOfSupply == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.legalStatusOfSupply!, (value) {
      return _then(_value.copyWith(legalStatusOfSupply: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get additionalMonitoringIndicator {
    if (_value.additionalMonitoringIndicator == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.additionalMonitoringIndicator!,
        (value) {
      return _then(
          _value.copyWith(additionalMonitoringIndicator: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get pediatricUseIndicator {
    if (_value.pediatricUseIndicator == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.pediatricUseIndicator!,
        (value) {
      return _then(_value.copyWith(pediatricUseIndicator: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MedicinalProductDefinitionCopyWith<$Res>
    implements $MedicinalProductDefinitionCopyWith<$Res> {
  factory _$$_MedicinalProductDefinitionCopyWith(
          _$_MedicinalProductDefinition value,
          $Res Function(_$_MedicinalProductDefinition) then) =
      __$$_MedicinalProductDefinitionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.MedicinalProductDefinition)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      CodeableConcept? type,
      CodeableConcept? domain,
      String? version,
      @JsonKey(name: '_version')
          Element? versionElement,
      CodeableConcept? status,
      FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate')
          Element? statusDateElement,
      Markdown? description,
      @JsonKey(name: '_description')
          Element? descriptionElement,
      CodeableConcept? combinedPharmaceuticalDoseForm,
      List<CodeableConcept>? route,
      Markdown? indication,
      @JsonKey(name: '_indication')
          Element? indicationElement,
      CodeableConcept? legalStatusOfSupply,
      CodeableConcept? additionalMonitoringIndicator,
      List<CodeableConcept>? specialMeasures,
      CodeableConcept? pediatricUseIndicator,
      List<CodeableConcept>? classification,
      List<MarketingStatus>? marketingStatus,
      List<CodeableConcept>? packagedMedicinalProduct,
      List<Reference>? comprisedOf,
      List<CodeableConcept>? ingredient,
      List<CodeableReference>? impurity,
      List<Reference>? attachedDocument,
      List<Reference>? masterFile,
      List<MedicinalProductDefinitionContact>? contact,
      List<Reference>? clinicalTrial,
      List<Coding>? code,
      List<MedicinalProductDefinitionName> name,
      List<MedicinalProductDefinitionCrossReference>? crossReference,
      List<MedicinalProductDefinitionOperation>? operation,
      List<MedicinalProductDefinitionCharacteristic>? characteristic});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $CodeableConceptCopyWith<$Res>? get domain;
  @override
  $ElementCopyWith<$Res>? get versionElement;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
  @override
  $ElementCopyWith<$Res>? get statusDateElement;
  @override
  $ElementCopyWith<$Res>? get descriptionElement;
  @override
  $CodeableConceptCopyWith<$Res>? get combinedPharmaceuticalDoseForm;
  @override
  $ElementCopyWith<$Res>? get indicationElement;
  @override
  $CodeableConceptCopyWith<$Res>? get legalStatusOfSupply;
  @override
  $CodeableConceptCopyWith<$Res>? get additionalMonitoringIndicator;
  @override
  $CodeableConceptCopyWith<$Res>? get pediatricUseIndicator;
}

/// @nodoc
class __$$_MedicinalProductDefinitionCopyWithImpl<$Res>
    extends _$MedicinalProductDefinitionCopyWithImpl<$Res,
        _$_MedicinalProductDefinition>
    implements _$$_MedicinalProductDefinitionCopyWith<$Res> {
  __$$_MedicinalProductDefinitionCopyWithImpl(
      _$_MedicinalProductDefinition _value,
      $Res Function(_$_MedicinalProductDefinition) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = freezed,
    Object? domain = freezed,
    Object? version = freezed,
    Object? versionElement = freezed,
    Object? status = freezed,
    Object? statusDate = freezed,
    Object? statusDateElement = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? combinedPharmaceuticalDoseForm = freezed,
    Object? route = freezed,
    Object? indication = freezed,
    Object? indicationElement = freezed,
    Object? legalStatusOfSupply = freezed,
    Object? additionalMonitoringIndicator = freezed,
    Object? specialMeasures = freezed,
    Object? pediatricUseIndicator = freezed,
    Object? classification = freezed,
    Object? marketingStatus = freezed,
    Object? packagedMedicinalProduct = freezed,
    Object? comprisedOf = freezed,
    Object? ingredient = freezed,
    Object? impurity = freezed,
    Object? attachedDocument = freezed,
    Object? masterFile = freezed,
    Object? contact = freezed,
    Object? clinicalTrial = freezed,
    Object? code = freezed,
    Object? name = null,
    Object? crossReference = freezed,
    Object? operation = freezed,
    Object? characteristic = freezed,
  }) {
    return _then(_$_MedicinalProductDefinition(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      domain: freezed == domain
          ? _value.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      version: freezed == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String?,
      versionElement: freezed == versionElement
          ? _value.versionElement
          : versionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      statusDate: freezed == statusDate
          ? _value.statusDate
          : statusDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      statusDateElement: freezed == statusDateElement
          ? _value.statusDateElement
          : statusDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      combinedPharmaceuticalDoseForm: freezed == combinedPharmaceuticalDoseForm
          ? _value.combinedPharmaceuticalDoseForm
          : combinedPharmaceuticalDoseForm // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      route: freezed == route
          ? _value._route
          : route // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      indication: freezed == indication
          ? _value.indication
          : indication // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      indicationElement: freezed == indicationElement
          ? _value.indicationElement
          : indicationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      legalStatusOfSupply: freezed == legalStatusOfSupply
          ? _value.legalStatusOfSupply
          : legalStatusOfSupply // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      additionalMonitoringIndicator: freezed == additionalMonitoringIndicator
          ? _value.additionalMonitoringIndicator
          : additionalMonitoringIndicator // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      specialMeasures: freezed == specialMeasures
          ? _value._specialMeasures
          : specialMeasures // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      pediatricUseIndicator: freezed == pediatricUseIndicator
          ? _value.pediatricUseIndicator
          : pediatricUseIndicator // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      classification: freezed == classification
          ? _value._classification
          : classification // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      marketingStatus: freezed == marketingStatus
          ? _value._marketingStatus
          : marketingStatus // ignore: cast_nullable_to_non_nullable
              as List<MarketingStatus>?,
      packagedMedicinalProduct: freezed == packagedMedicinalProduct
          ? _value._packagedMedicinalProduct
          : packagedMedicinalProduct // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      comprisedOf: freezed == comprisedOf
          ? _value._comprisedOf
          : comprisedOf // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      ingredient: freezed == ingredient
          ? _value._ingredient
          : ingredient // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      impurity: freezed == impurity
          ? _value._impurity
          : impurity // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      attachedDocument: freezed == attachedDocument
          ? _value._attachedDocument
          : attachedDocument // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      masterFile: freezed == masterFile
          ? _value._masterFile
          : masterFile // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      contact: freezed == contact
          ? _value._contact
          : contact // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionContact>?,
      clinicalTrial: freezed == clinicalTrial
          ? _value._clinicalTrial
          : clinicalTrial // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      code: freezed == code
          ? _value._code
          : code // ignore: cast_nullable_to_non_nullable
              as List<Coding>?,
      name: null == name
          ? _value._name
          : name // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionName>,
      crossReference: freezed == crossReference
          ? _value._crossReference
          : crossReference // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionCrossReference>?,
      operation: freezed == operation
          ? _value._operation
          : operation // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionOperation>?,
      characteristic: freezed == characteristic
          ? _value._characteristic
          : characteristic // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionCharacteristic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MedicinalProductDefinition extends _MedicinalProductDefinition {
  _$_MedicinalProductDefinition(
      {@JsonKey(unknownEnumValue: R5ResourceType.MedicinalProductDefinition)
          this.resourceType = R5ResourceType.MedicinalProductDefinition,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules')
          this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language')
          this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      this.type,
      this.domain,
      this.version,
      @JsonKey(name: '_version')
          this.versionElement,
      this.status,
      this.statusDate,
      @JsonKey(name: '_statusDate')
          this.statusDateElement,
      this.description,
      @JsonKey(name: '_description')
          this.descriptionElement,
      this.combinedPharmaceuticalDoseForm,
      final List<CodeableConcept>? route,
      this.indication,
      @JsonKey(name: '_indication')
          this.indicationElement,
      this.legalStatusOfSupply,
      this.additionalMonitoringIndicator,
      final List<CodeableConcept>? specialMeasures,
      this.pediatricUseIndicator,
      final List<CodeableConcept>? classification,
      final List<MarketingStatus>? marketingStatus,
      final List<CodeableConcept>? packagedMedicinalProduct,
      final List<Reference>? comprisedOf,
      final List<CodeableConcept>? ingredient,
      final List<CodeableReference>? impurity,
      final List<Reference>? attachedDocument,
      final List<Reference>? masterFile,
      final List<MedicinalProductDefinitionContact>? contact,
      final List<Reference>? clinicalTrial,
      final List<Coding>? code,
      required final List<MedicinalProductDefinitionName> name,
      final List<MedicinalProductDefinitionCrossReference>? crossReference,
      final List<MedicinalProductDefinitionOperation>? operation,
      final List<MedicinalProductDefinitionCharacteristic>? characteristic})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _route = route,
        _specialMeasures = specialMeasures,
        _classification = classification,
        _marketingStatus = marketingStatus,
        _packagedMedicinalProduct = packagedMedicinalProduct,
        _comprisedOf = comprisedOf,
        _ingredient = ingredient,
        _impurity = impurity,
        _attachedDocument = attachedDocument,
        _masterFile = masterFile,
        _contact = contact,
        _clinicalTrial = clinicalTrial,
        _code = code,
        _name = name,
        _crossReference = crossReference,
        _operation = operation,
        _characteristic = characteristic,
        super._();

  factory _$_MedicinalProductDefinition.fromJson(Map<String, dynamic> json) =>
      _$$_MedicinalProductDefinitionFromJson(json);

  /// [resourceType] This is a MedicinalProductDefinition resource
  @override
  @JsonKey(unknownEnumValue: R5ResourceType.MedicinalProductDefinition)
  final R5ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.
  @override
  final Code? language;

  /// [languageElement] ("_language") Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] Business identifier for this product. Could be an MPID. When in development or being regulated, products are typically referenced by official identifiers, assigned by a manufacturer or regulator, and unique to a product (which, when compared to a product instance being prescribed, is actually a product type). See also MedicinalProductDefinition.code.
  final List<Identifier>? _identifier;

  /// [identifier] Business identifier for this product. Could be an MPID. When in development or being regulated, products are typically referenced by official identifiers, assigned by a manufacturer or regulator, and unique to a product (which, when compared to a product instance being prescribed, is actually a product type). See also MedicinalProductDefinition.code.
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] Regulatory type, e.g. Investigational or Authorized.
  @override
  final CodeableConcept? type;

  /// [domain] If this medicine applies to human or veterinary uses.
  @override
  final CodeableConcept? domain;

  /// [version] A business identifier relating to a specific version of the product, this is commonly used to support revisions to an existing product.
  @override
  final String? version;

  /// [versionElement] ("_version") Extensions for version
  @override
  @JsonKey(name: '_version')
  final Element? versionElement;

  /// [status] The status within the lifecycle of this product record. A high-level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization status.
  @override
  final CodeableConcept? status;

  /// [statusDate] The date at which the given status became applicable.
  @override
  final FhirDateTime? statusDate;

  /// [statusDateElement] ("_statusDate") Extensions for statusDate
  @override
  @JsonKey(name: '_statusDate')
  final Element? statusDateElement;

  /// [description] General description of this product.
  @override
  final Markdown? description;

  /// [descriptionElement] ("_description") Extensions for description
  @override
  @JsonKey(name: '_description')
  final Element? descriptionElement;

  /// [combinedPharmaceuticalDoseForm] The dose form for a single part product, or combined form of a multiple part product. This is one concept that describes all the components. It does not represent the form with components physically mixed, if that might be necessary, for which see (AdministrableProductDefinition.administrableDoseForm).
  @override
  final CodeableConcept? combinedPharmaceuticalDoseForm;

  /// [route] The path by which the product is taken into or makes contact with the body. In some regions this is referred to as the licenced or approved route. See also AdministrableProductDefinition resource. MedicinalProductDefinition.route is the same concept as AdministrableProductDefinition.routeOfAdministration.code, and they cannot be used together.
  final List<CodeableConcept>? _route;

  /// [route] The path by which the product is taken into or makes contact with the body. In some regions this is referred to as the licenced or approved route. See also AdministrableProductDefinition resource. MedicinalProductDefinition.route is the same concept as AdministrableProductDefinition.routeOfAdministration.code, and they cannot be used together.
  @override
  List<CodeableConcept>? get route {
    final value = _route;
    if (value == null) return null;
    if (_route is EqualUnmodifiableListView) return _route;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [indication] Description of indication(s) for this product, used when structured indications are not required. In cases where structured indications are required, they are captured using the ClinicalUseDefinition resource. An indication is a medical situation for which using the product is appropriate.
  @override
  final Markdown? indication;

  /// [indicationElement] ("_indication") Extensions for indication
  @override
  @JsonKey(name: '_indication')
  final Element? indicationElement;

  /// [legalStatusOfSupply] The legal status of supply of the medicinal product as classified by the regulator.
  @override
  final CodeableConcept? legalStatusOfSupply;

  /// [additionalMonitoringIndicator] Whether the Medicinal Product is subject to additional monitoring for regulatory reasons, such as heightened reporting requirements.
  @override
  final CodeableConcept? additionalMonitoringIndicator;

  /// [specialMeasures] Whether the Medicinal Product is subject to special measures for regulatory reasons, such as a requirement to conduct post-authorisation studies.
  final List<CodeableConcept>? _specialMeasures;

  /// [specialMeasures] Whether the Medicinal Product is subject to special measures for regulatory reasons, such as a requirement to conduct post-authorisation studies.
  @override
  List<CodeableConcept>? get specialMeasures {
    final value = _specialMeasures;
    if (value == null) return null;
    if (_specialMeasures is EqualUnmodifiableListView) return _specialMeasures;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [pediatricUseIndicator] If authorised for use in children, or infants, neonates etc.
  @override
  final CodeableConcept? pediatricUseIndicator;

  /// [classification] Allows the product to be classified by various systems, commonly WHO ATC.
  final List<CodeableConcept>? _classification;

  /// [classification] Allows the product to be classified by various systems, commonly WHO ATC.
  @override
  List<CodeableConcept>? get classification {
    final value = _classification;
    if (value == null) return null;
    if (_classification is EqualUnmodifiableListView) return _classification;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [marketingStatus] Marketing status of the medicinal product, in contrast to marketing authorization. This refers to the product being actually 'on the market' as opposed to being allowed to be on the market (which is an authorization).
  final List<MarketingStatus>? _marketingStatus;

  /// [marketingStatus] Marketing status of the medicinal product, in contrast to marketing authorization. This refers to the product being actually 'on the market' as opposed to being allowed to be on the market (which is an authorization).
  @override
  List<MarketingStatus>? get marketingStatus {
    final value = _marketingStatus;
    if (value == null) return null;
    if (_marketingStatus is EqualUnmodifiableListView) return _marketingStatus;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [packagedMedicinalProduct] Package type for the product. See also the PackagedProductDefinition resource.
  final List<CodeableConcept>? _packagedMedicinalProduct;

  /// [packagedMedicinalProduct] Package type for the product. See also the PackagedProductDefinition resource.
  @override
  List<CodeableConcept>? get packagedMedicinalProduct {
    final value = _packagedMedicinalProduct;
    if (value == null) return null;
    if (_packagedMedicinalProduct is EqualUnmodifiableListView)
      return _packagedMedicinalProduct;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [comprisedOf] Types of medicinal manufactured items and/or devices that this product consists of, such as tablets, capsule, or syringes. Used as a direct link when the item's packaging is not being recorded (see also PackagedProductDefinition.package.containedItem.item).
  final List<Reference>? _comprisedOf;

  /// [comprisedOf] Types of medicinal manufactured items and/or devices that this product consists of, such as tablets, capsule, or syringes. Used as a direct link when the item's packaging is not being recorded (see also PackagedProductDefinition.package.containedItem.item).
  @override
  List<Reference>? get comprisedOf {
    final value = _comprisedOf;
    if (value == null) return null;
    if (_comprisedOf is EqualUnmodifiableListView) return _comprisedOf;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [ingredient] The ingredients of this medicinal product - when not detailed in other resources. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource, or indirectly via incoming AdministrableProductDefinition, PackagedProductDefinition or ManufacturedItemDefinition references. In cases where those levels of detail are not used, the ingredients may be specified directly here as codes.
  final List<CodeableConcept>? _ingredient;

  /// [ingredient] The ingredients of this medicinal product - when not detailed in other resources. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource, or indirectly via incoming AdministrableProductDefinition, PackagedProductDefinition or ManufacturedItemDefinition references. In cases where those levels of detail are not used, the ingredients may be specified directly here as codes.
  @override
  List<CodeableConcept>? get ingredient {
    final value = _ingredient;
    if (value == null) return null;
    if (_ingredient is EqualUnmodifiableListView) return _ingredient;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [impurity] Any component of the drug product which is not the chemical entity defined as the drug substance, or an excipient in the drug product. This includes process-related impurities and contaminants, product-related impurities including degradation products.
  final List<CodeableReference>? _impurity;

  /// [impurity] Any component of the drug product which is not the chemical entity defined as the drug substance, or an excipient in the drug product. This includes process-related impurities and contaminants, product-related impurities including degradation products.
  @override
  List<CodeableReference>? get impurity {
    final value = _impurity;
    if (value == null) return null;
    if (_impurity is EqualUnmodifiableListView) return _impurity;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [attachedDocument] Additional information or supporting documentation about the medicinal product.
  final List<Reference>? _attachedDocument;

  /// [attachedDocument] Additional information or supporting documentation about the medicinal product.
  @override
  List<Reference>? get attachedDocument {
    final value = _attachedDocument;
    if (value == null) return null;
    if (_attachedDocument is EqualUnmodifiableListView)
      return _attachedDocument;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [masterFile] A master file for the medicinal product (e.g. Pharmacovigilance System Master File). Drug master files (DMFs) are documents submitted to regulatory agencies to provide confidential detailed information about facilities, processes or articles used in the manufacturing, processing, packaging and storing of drug products.
  final List<Reference>? _masterFile;

  /// [masterFile] A master file for the medicinal product (e.g. Pharmacovigilance System Master File). Drug master files (DMFs) are documents submitted to regulatory agencies to provide confidential detailed information about facilities, processes or articles used in the manufacturing, processing, packaging and storing of drug products.
  @override
  List<Reference>? get masterFile {
    final value = _masterFile;
    if (value == null) return null;
    if (_masterFile is EqualUnmodifiableListView) return _masterFile;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [contact] A product specific contact, person (in a role), or an organization.
  final List<MedicinalProductDefinitionContact>? _contact;

  /// [contact] A product specific contact, person (in a role), or an organization.
  @override
  List<MedicinalProductDefinitionContact>? get contact {
    final value = _contact;
    if (value == null) return null;
    if (_contact is EqualUnmodifiableListView) return _contact;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [clinicalTrial] Clinical trials or studies that this product is involved in.
  final List<Reference>? _clinicalTrial;

  /// [clinicalTrial] Clinical trials or studies that this product is involved in.
  @override
  List<Reference>? get clinicalTrial {
    final value = _clinicalTrial;
    if (value == null) return null;
    if (_clinicalTrial is EqualUnmodifiableListView) return _clinicalTrial;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [code] A code that this product is known by, usually within some formal terminology, perhaps assigned by a third party (i.e. not the manufacturer or regulator). Products (types of medications) tend to be known by identifiers during development and within regulatory process. However when they are prescribed they tend to be identified by codes. The same product may be have multiple codes, applied to it by multiple organizations.
  final List<Coding>? _code;

  /// [code] A code that this product is known by, usually within some formal terminology, perhaps assigned by a third party (i.e. not the manufacturer or regulator). Products (types of medications) tend to be known by identifiers during development and within regulatory process. However when they are prescribed they tend to be identified by codes. The same product may be have multiple codes, applied to it by multiple organizations.
  @override
  List<Coding>? get code {
    final value = _code;
    if (value == null) return null;
    if (_code is EqualUnmodifiableListView) return _code;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [name] The product's name, including full name and possibly coded parts.
  final List<MedicinalProductDefinitionName> _name;

  /// [name] The product's name, including full name and possibly coded parts.
  @override
  List<MedicinalProductDefinitionName> get name {
    if (_name is EqualUnmodifiableListView) return _name;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_name);
  }

  /// [crossReference] Reference to another product, e.g. for linking authorised to investigational product, or a virtual product.
  final List<MedicinalProductDefinitionCrossReference>? _crossReference;

  /// [crossReference] Reference to another product, e.g. for linking authorised to investigational product, or a virtual product.
  @override
  List<MedicinalProductDefinitionCrossReference>? get crossReference {
    final value = _crossReference;
    if (value == null) return null;
    if (_crossReference is EqualUnmodifiableListView) return _crossReference;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [operation] A manufacturing or administrative process or step associated with (or performed on) the medicinal product.
  final List<MedicinalProductDefinitionOperation>? _operation;

  /// [operation] A manufacturing or administrative process or step associated with (or performed on) the medicinal product.
  @override
  List<MedicinalProductDefinitionOperation>? get operation {
    final value = _operation;
    if (value == null) return null;
    if (_operation is EqualUnmodifiableListView) return _operation;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [characteristic] Allows the key product features to be recorded, such as "sugar free", "modified release", "parallel import".
  final List<MedicinalProductDefinitionCharacteristic>? _characteristic;

  /// [characteristic] Allows the key product features to be recorded, such as "sugar free", "modified release", "parallel import".
  @override
  List<MedicinalProductDefinitionCharacteristic>? get characteristic {
    final value = _characteristic;
    if (value == null) return null;
    if (_characteristic is EqualUnmodifiableListView) return _characteristic;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'MedicinalProductDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, type: $type, domain: $domain, version: $version, versionElement: $versionElement, status: $status, statusDate: $statusDate, statusDateElement: $statusDateElement, description: $description, descriptionElement: $descriptionElement, combinedPharmaceuticalDoseForm: $combinedPharmaceuticalDoseForm, route: $route, indication: $indication, indicationElement: $indicationElement, legalStatusOfSupply: $legalStatusOfSupply, additionalMonitoringIndicator: $additionalMonitoringIndicator, specialMeasures: $specialMeasures, pediatricUseIndicator: $pediatricUseIndicator, classification: $classification, marketingStatus: $marketingStatus, packagedMedicinalProduct: $packagedMedicinalProduct, comprisedOf: $comprisedOf, ingredient: $ingredient, impurity: $impurity, attachedDocument: $attachedDocument, masterFile: $masterFile, contact: $contact, clinicalTrial: $clinicalTrial, code: $code, name: $name, crossReference: $crossReference, operation: $operation, characteristic: $characteristic)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MedicinalProductDefinition &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.domain, domain) || other.domain == domain) &&
            (identical(other.version, version) || other.version == version) &&
            (identical(other.versionElement, versionElement) ||
                other.versionElement == versionElement) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusDate, statusDate) ||
                other.statusDate == statusDate) &&
            (identical(other.statusDateElement, statusDateElement) ||
                other.statusDateElement == statusDateElement) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.descriptionElement, descriptionElement) ||
                other.descriptionElement == descriptionElement) &&
            (identical(other.combinedPharmaceuticalDoseForm,
                    combinedPharmaceuticalDoseForm) ||
                other.combinedPharmaceuticalDoseForm ==
                    combinedPharmaceuticalDoseForm) &&
            const DeepCollectionEquality().equals(other._route, _route) &&
            (identical(other.indication, indication) ||
                other.indication == indication) &&
            (identical(other.indicationElement, indicationElement) ||
                other.indicationElement == indicationElement) &&
            (identical(other.legalStatusOfSupply, legalStatusOfSupply) ||
                other.legalStatusOfSupply == legalStatusOfSupply) &&
            (identical(other.additionalMonitoringIndicator, additionalMonitoringIndicator) ||
                other.additionalMonitoringIndicator ==
                    additionalMonitoringIndicator) &&
            const DeepCollectionEquality()
                .equals(other._specialMeasures, _specialMeasures) &&
            (identical(other.pediatricUseIndicator, pediatricUseIndicator) ||
                other.pediatricUseIndicator == pediatricUseIndicator) &&
            const DeepCollectionEquality()
                .equals(other._classification, _classification) &&
            const DeepCollectionEquality()
                .equals(other._marketingStatus, _marketingStatus) &&
            const DeepCollectionEquality().equals(
                other._packagedMedicinalProduct, _packagedMedicinalProduct) &&
            const DeepCollectionEquality()
                .equals(other._comprisedOf, _comprisedOf) &&
            const DeepCollectionEquality()
                .equals(other._ingredient, _ingredient) &&
            const DeepCollectionEquality().equals(other._impurity, _impurity) &&
            const DeepCollectionEquality()
                .equals(other._attachedDocument, _attachedDocument) &&
            const DeepCollectionEquality()
                .equals(other._masterFile, _masterFile) &&
            const DeepCollectionEquality().equals(other._contact, _contact) &&
            const DeepCollectionEquality()
                .equals(other._clinicalTrial, _clinicalTrial) &&
            const DeepCollectionEquality().equals(other._code, _code) &&
            const DeepCollectionEquality().equals(other._name, _name) &&
            const DeepCollectionEquality()
                .equals(other._crossReference, _crossReference) &&
            const DeepCollectionEquality().equals(other._operation, _operation) &&
            const DeepCollectionEquality().equals(other._characteristic, _characteristic));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_identifier),
        type,
        domain,
        version,
        versionElement,
        status,
        statusDate,
        statusDateElement,
        description,
        descriptionElement,
        combinedPharmaceuticalDoseForm,
        const DeepCollectionEquality().hash(_route),
        indication,
        indicationElement,
        legalStatusOfSupply,
        additionalMonitoringIndicator,
        const DeepCollectionEquality().hash(_specialMeasures),
        pediatricUseIndicator,
        const DeepCollectionEquality().hash(_classification),
        const DeepCollectionEquality().hash(_marketingStatus),
        const DeepCollectionEquality().hash(_packagedMedicinalProduct),
        const DeepCollectionEquality().hash(_comprisedOf),
        const DeepCollectionEquality().hash(_ingredient),
        const DeepCollectionEquality().hash(_impurity),
        const DeepCollectionEquality().hash(_attachedDocument),
        const DeepCollectionEquality().hash(_masterFile),
        const DeepCollectionEquality().hash(_contact),
        const DeepCollectionEquality().hash(_clinicalTrial),
        const DeepCollectionEquality().hash(_code),
        const DeepCollectionEquality().hash(_name),
        const DeepCollectionEquality().hash(_crossReference),
        const DeepCollectionEquality().hash(_operation),
        const DeepCollectionEquality().hash(_characteristic)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MedicinalProductDefinitionCopyWith<_$_MedicinalProductDefinition>
      get copyWith => __$$_MedicinalProductDefinitionCopyWithImpl<
          _$_MedicinalProductDefinition>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MedicinalProductDefinitionToJson(
      this,
    );
  }
}

abstract class _MedicinalProductDefinition extends MedicinalProductDefinition {
  factory _MedicinalProductDefinition(
      {@JsonKey(unknownEnumValue: R5ResourceType.MedicinalProductDefinition)
          final R5ResourceType resourceType,
      final FhirId? id,
      final Meta? meta,
      final FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          final Element? implicitRulesElement,
      final Code? language,
      @JsonKey(name: '_language')
          final Element? languageElement,
      final Narrative? text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      final CodeableConcept? type,
      final CodeableConcept? domain,
      final String? version,
      @JsonKey(name: '_version')
          final Element? versionElement,
      final CodeableConcept? status,
      final FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate')
          final Element? statusDateElement,
      final Markdown? description,
      @JsonKey(name: '_description')
          final Element? descriptionElement,
      final CodeableConcept? combinedPharmaceuticalDoseForm,
      final List<CodeableConcept>? route,
      final Markdown? indication,
      @JsonKey(name: '_indication')
          final Element? indicationElement,
      final CodeableConcept? legalStatusOfSupply,
      final CodeableConcept? additionalMonitoringIndicator,
      final List<CodeableConcept>? specialMeasures,
      final CodeableConcept? pediatricUseIndicator,
      final List<CodeableConcept>? classification,
      final List<MarketingStatus>? marketingStatus,
      final List<CodeableConcept>? packagedMedicinalProduct,
      final List<Reference>? comprisedOf,
      final List<CodeableConcept>? ingredient,
      final List<CodeableReference>? impurity,
      final List<Reference>? attachedDocument,
      final List<Reference>? masterFile,
      final List<MedicinalProductDefinitionContact>? contact,
      final List<Reference>? clinicalTrial,
      final List<Coding>? code,
      required final List<MedicinalProductDefinitionName> name,
      final List<MedicinalProductDefinitionCrossReference>? crossReference,
      final List<MedicinalProductDefinitionOperation>? operation,
      final List<MedicinalProductDefinitionCharacteristic>?
          characteristic}) = _$_MedicinalProductDefinition;
  _MedicinalProductDefinition._() : super._();

  factory _MedicinalProductDefinition.fromJson(Map<String, dynamic> json) =
      _$_MedicinalProductDefinition.fromJson;

  @override

  /// [resourceType] This is a MedicinalProductDefinition resource
  @JsonKey(unknownEnumValue: R5ResourceType.MedicinalProductDefinition)
  R5ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.
  Code? get language;
  @override

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained;
  @override

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] Business identifier for this product. Could be an MPID. When in development or being regulated, products are typically referenced by official identifiers, assigned by a manufacturer or regulator, and unique to a product (which, when compared to a product instance being prescribed, is actually a product type). See also MedicinalProductDefinition.code.
  List<Identifier>? get identifier;
  @override

  /// [type] Regulatory type, e.g. Investigational or Authorized.
  CodeableConcept? get type;
  @override

  /// [domain] If this medicine applies to human or veterinary uses.
  CodeableConcept? get domain;
  @override

  /// [version] A business identifier relating to a specific version of the product, this is commonly used to support revisions to an existing product.
  String? get version;
  @override

  /// [versionElement] ("_version") Extensions for version
  @JsonKey(name: '_version')
  Element? get versionElement;
  @override

  /// [status] The status within the lifecycle of this product record. A high-level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization status.
  CodeableConcept? get status;
  @override

  /// [statusDate] The date at which the given status became applicable.
  FhirDateTime? get statusDate;
  @override

  /// [statusDateElement] ("_statusDate") Extensions for statusDate
  @JsonKey(name: '_statusDate')
  Element? get statusDateElement;
  @override

  /// [description] General description of this product.
  Markdown? get description;
  @override

  /// [descriptionElement] ("_description") Extensions for description
  @JsonKey(name: '_description')
  Element? get descriptionElement;
  @override

  /// [combinedPharmaceuticalDoseForm] The dose form for a single part product, or combined form of a multiple part product. This is one concept that describes all the components. It does not represent the form with components physically mixed, if that might be necessary, for which see (AdministrableProductDefinition.administrableDoseForm).
  CodeableConcept? get combinedPharmaceuticalDoseForm;
  @override

  /// [route] The path by which the product is taken into or makes contact with the body. In some regions this is referred to as the licenced or approved route. See also AdministrableProductDefinition resource. MedicinalProductDefinition.route is the same concept as AdministrableProductDefinition.routeOfAdministration.code, and they cannot be used together.
  List<CodeableConcept>? get route;
  @override

  /// [indication] Description of indication(s) for this product, used when structured indications are not required. In cases where structured indications are required, they are captured using the ClinicalUseDefinition resource. An indication is a medical situation for which using the product is appropriate.
  Markdown? get indication;
  @override

  /// [indicationElement] ("_indication") Extensions for indication
  @JsonKey(name: '_indication')
  Element? get indicationElement;
  @override

  /// [legalStatusOfSupply] The legal status of supply of the medicinal product as classified by the regulator.
  CodeableConcept? get legalStatusOfSupply;
  @override

  /// [additionalMonitoringIndicator] Whether the Medicinal Product is subject to additional monitoring for regulatory reasons, such as heightened reporting requirements.
  CodeableConcept? get additionalMonitoringIndicator;
  @override

  /// [specialMeasures] Whether the Medicinal Product is subject to special measures for regulatory reasons, such as a requirement to conduct post-authorisation studies.
  List<CodeableConcept>? get specialMeasures;
  @override

  /// [pediatricUseIndicator] If authorised for use in children, or infants, neonates etc.
  CodeableConcept? get pediatricUseIndicator;
  @override

  /// [classification] Allows the product to be classified by various systems, commonly WHO ATC.
  List<CodeableConcept>? get classification;
  @override

  /// [marketingStatus] Marketing status of the medicinal product, in contrast to marketing authorization. This refers to the product being actually 'on the market' as opposed to being allowed to be on the market (which is an authorization).
  List<MarketingStatus>? get marketingStatus;
  @override

  /// [packagedMedicinalProduct] Package type for the product. See also the PackagedProductDefinition resource.
  List<CodeableConcept>? get packagedMedicinalProduct;
  @override

  /// [comprisedOf] Types of medicinal manufactured items and/or devices that this product consists of, such as tablets, capsule, or syringes. Used as a direct link when the item's packaging is not being recorded (see also PackagedProductDefinition.package.containedItem.item).
  List<Reference>? get comprisedOf;
  @override

  /// [ingredient] The ingredients of this medicinal product - when not detailed in other resources. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource, or indirectly via incoming AdministrableProductDefinition, PackagedProductDefinition or ManufacturedItemDefinition references. In cases where those levels of detail are not used, the ingredients may be specified directly here as codes.
  List<CodeableConcept>? get ingredient;
  @override

  /// [impurity] Any component of the drug product which is not the chemical entity defined as the drug substance, or an excipient in the drug product. This includes process-related impurities and contaminants, product-related impurities including degradation products.
  List<CodeableReference>? get impurity;
  @override

  /// [attachedDocument] Additional information or supporting documentation about the medicinal product.
  List<Reference>? get attachedDocument;
  @override

  /// [masterFile] A master file for the medicinal product (e.g. Pharmacovigilance System Master File). Drug master files (DMFs) are documents submitted to regulatory agencies to provide confidential detailed information about facilities, processes or articles used in the manufacturing, processing, packaging and storing of drug products.
  List<Reference>? get masterFile;
  @override

  /// [contact] A product specific contact, person (in a role), or an organization.
  List<MedicinalProductDefinitionContact>? get contact;
  @override

  /// [clinicalTrial] Clinical trials or studies that this product is involved in.
  List<Reference>? get clinicalTrial;
  @override

  /// [code] A code that this product is known by, usually within some formal terminology, perhaps assigned by a third party (i.e. not the manufacturer or regulator). Products (types of medications) tend to be known by identifiers during development and within regulatory process. However when they are prescribed they tend to be identified by codes. The same product may be have multiple codes, applied to it by multiple organizations.
  List<Coding>? get code;
  @override

  /// [name] The product's name, including full name and possibly coded parts.
  List<MedicinalProductDefinitionName> get name;
  @override

  /// [crossReference] Reference to another product, e.g. for linking authorised to investigational product, or a virtual product.
  List<MedicinalProductDefinitionCrossReference>? get crossReference;
  @override

  /// [operation] A manufacturing or administrative process or step associated with (or performed on) the medicinal product.
  List<MedicinalProductDefinitionOperation>? get operation;
  @override

  /// [characteristic] Allows the key product features to be recorded, such as "sugar free", "modified release", "parallel import".
  List<MedicinalProductDefinitionCharacteristic>? get characteristic;
  @override
  @JsonKey(ignore: true)
  _$$_MedicinalProductDefinitionCopyWith<_$_MedicinalProductDefinition>
      get copyWith => throw _privateConstructorUsedError;
}

MedicinalProductDefinitionContact _$MedicinalProductDefinitionContactFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductDefinitionContact.fromJson(json);
}

/// @nodoc
mixin _$MedicinalProductDefinitionContact {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] Allows the contact to be classified, for example QPPV, Pharmacovigilance Enquiry Information.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [contact] A product specific contact, person (in a role), or an organization.
  Reference get contact => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MedicinalProductDefinitionContactCopyWith<MedicinalProductDefinitionContact>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MedicinalProductDefinitionContactCopyWith<$Res> {
  factory $MedicinalProductDefinitionContactCopyWith(
          MedicinalProductDefinitionContact value,
          $Res Function(MedicinalProductDefinitionContact) then) =
      _$MedicinalProductDefinitionContactCopyWithImpl<$Res,
          MedicinalProductDefinitionContact>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      Reference contact});

  $CodeableConceptCopyWith<$Res>? get type;
  $ReferenceCopyWith<$Res> get contact;
}

/// @nodoc
class _$MedicinalProductDefinitionContactCopyWithImpl<$Res,
        $Val extends MedicinalProductDefinitionContact>
    implements $MedicinalProductDefinitionContactCopyWith<$Res> {
  _$MedicinalProductDefinitionContactCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? contact = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      contact: null == contact
          ? _value.contact
          : contact // ignore: cast_nullable_to_non_nullable
              as Reference,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res> get contact {
    return $ReferenceCopyWith<$Res>(_value.contact, (value) {
      return _then(_value.copyWith(contact: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MedicinalProductDefinitionContactCopyWith<$Res>
    implements $MedicinalProductDefinitionContactCopyWith<$Res> {
  factory _$$_MedicinalProductDefinitionContactCopyWith(
          _$_MedicinalProductDefinitionContact value,
          $Res Function(_$_MedicinalProductDefinitionContact) then) =
      __$$_MedicinalProductDefinitionContactCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      Reference contact});

  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $ReferenceCopyWith<$Res> get contact;
}

/// @nodoc
class __$$_MedicinalProductDefinitionContactCopyWithImpl<$Res>
    extends _$MedicinalProductDefinitionContactCopyWithImpl<$Res,
        _$_MedicinalProductDefinitionContact>
    implements _$$_MedicinalProductDefinitionContactCopyWith<$Res> {
  __$$_MedicinalProductDefinitionContactCopyWithImpl(
      _$_MedicinalProductDefinitionContact _value,
      $Res Function(_$_MedicinalProductDefinitionContact) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? contact = null,
  }) {
    return _then(_$_MedicinalProductDefinitionContact(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      contact: null == contact
          ? _value.contact
          : contact // ignore: cast_nullable_to_non_nullable
              as Reference,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MedicinalProductDefinitionContact
    extends _MedicinalProductDefinitionContact {
  _$_MedicinalProductDefinitionContact(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.type,
      required this.contact})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_MedicinalProductDefinitionContact.fromJson(
          Map<String, dynamic> json) =>
      _$$_MedicinalProductDefinitionContactFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] Allows the contact to be classified, for example QPPV, Pharmacovigilance Enquiry Information.
  @override
  final CodeableConcept? type;

  /// [contact] A product specific contact, person (in a role), or an organization.
  @override
  final Reference contact;

  @override
  String toString() {
    return 'MedicinalProductDefinitionContact(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, contact: $contact)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MedicinalProductDefinitionContact &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.contact, contact) || other.contact == contact));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      contact);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MedicinalProductDefinitionContactCopyWith<
          _$_MedicinalProductDefinitionContact>
      get copyWith => __$$_MedicinalProductDefinitionContactCopyWithImpl<
          _$_MedicinalProductDefinitionContact>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MedicinalProductDefinitionContactToJson(
      this,
    );
  }
}

abstract class _MedicinalProductDefinitionContact
    extends MedicinalProductDefinitionContact {
  factory _MedicinalProductDefinitionContact(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? type,
      required final Reference contact}) = _$_MedicinalProductDefinitionContact;
  _MedicinalProductDefinitionContact._() : super._();

  factory _MedicinalProductDefinitionContact.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductDefinitionContact.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] Allows the contact to be classified, for example QPPV, Pharmacovigilance Enquiry Information.
  CodeableConcept? get type;
  @override

  /// [contact] A product specific contact, person (in a role), or an organization.
  Reference get contact;
  @override
  @JsonKey(ignore: true)
  _$$_MedicinalProductDefinitionContactCopyWith<
          _$_MedicinalProductDefinitionContact>
      get copyWith => throw _privateConstructorUsedError;
}

MedicinalProductDefinitionName _$MedicinalProductDefinitionNameFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductDefinitionName.fromJson(json);
}

/// @nodoc
mixin _$MedicinalProductDefinitionName {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [productName] The full product name.
  String? get productName => throw _privateConstructorUsedError;

  /// [productNameElement] ("_productName") Extensions for productName
  @JsonKey(name: '_productName')
  Element? get productNameElement => throw _privateConstructorUsedError;

  /// [type] Type of product name, such as rINN, BAN, Proprietary, Non-Proprietary.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [part_] ("part") Coding words or phrases of the name.
  @JsonKey(name: 'part')
  List<MedicinalProductDefinitionPart>? get part_ =>
      throw _privateConstructorUsedError;

  /// [usage] Country and jurisdiction where the name applies, and associated language.
  List<MedicinalProductDefinitionUsage>? get usage =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MedicinalProductDefinitionNameCopyWith<MedicinalProductDefinitionName>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MedicinalProductDefinitionNameCopyWith<$Res> {
  factory $MedicinalProductDefinitionNameCopyWith(
          MedicinalProductDefinitionName value,
          $Res Function(MedicinalProductDefinitionName) then) =
      _$MedicinalProductDefinitionNameCopyWithImpl<$Res,
          MedicinalProductDefinitionName>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? productName,
      @JsonKey(name: '_productName') Element? productNameElement,
      CodeableConcept? type,
      @JsonKey(name: 'part') List<MedicinalProductDefinitionPart>? part_,
      List<MedicinalProductDefinitionUsage>? usage});

  $ElementCopyWith<$Res>? get productNameElement;
  $CodeableConceptCopyWith<$Res>? get type;
}

/// @nodoc
class _$MedicinalProductDefinitionNameCopyWithImpl<$Res,
        $Val extends MedicinalProductDefinitionName>
    implements $MedicinalProductDefinitionNameCopyWith<$Res> {
  _$MedicinalProductDefinitionNameCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? productName = freezed,
    Object? productNameElement = freezed,
    Object? type = freezed,
    Object? part_ = freezed,
    Object? usage = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      productName: freezed == productName
          ? _value.productName
          : productName // ignore: cast_nullable_to_non_nullable
              as String?,
      productNameElement: freezed == productNameElement
          ? _value.productNameElement
          : productNameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      part_: freezed == part_
          ? _value.part_
          : part_ // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionPart>?,
      usage: freezed == usage
          ? _value.usage
          : usage // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionUsage>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get productNameElement {
    if (_value.productNameElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.productNameElement!, (value) {
      return _then(_value.copyWith(productNameElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MedicinalProductDefinitionNameCopyWith<$Res>
    implements $MedicinalProductDefinitionNameCopyWith<$Res> {
  factory _$$_MedicinalProductDefinitionNameCopyWith(
          _$_MedicinalProductDefinitionName value,
          $Res Function(_$_MedicinalProductDefinitionName) then) =
      __$$_MedicinalProductDefinitionNameCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? productName,
      @JsonKey(name: '_productName') Element? productNameElement,
      CodeableConcept? type,
      @JsonKey(name: 'part') List<MedicinalProductDefinitionPart>? part_,
      List<MedicinalProductDefinitionUsage>? usage});

  @override
  $ElementCopyWith<$Res>? get productNameElement;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
}

/// @nodoc
class __$$_MedicinalProductDefinitionNameCopyWithImpl<$Res>
    extends _$MedicinalProductDefinitionNameCopyWithImpl<$Res,
        _$_MedicinalProductDefinitionName>
    implements _$$_MedicinalProductDefinitionNameCopyWith<$Res> {
  __$$_MedicinalProductDefinitionNameCopyWithImpl(
      _$_MedicinalProductDefinitionName _value,
      $Res Function(_$_MedicinalProductDefinitionName) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? productName = freezed,
    Object? productNameElement = freezed,
    Object? type = freezed,
    Object? part_ = freezed,
    Object? usage = freezed,
  }) {
    return _then(_$_MedicinalProductDefinitionName(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      productName: freezed == productName
          ? _value.productName
          : productName // ignore: cast_nullable_to_non_nullable
              as String?,
      productNameElement: freezed == productNameElement
          ? _value.productNameElement
          : productNameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      part_: freezed == part_
          ? _value._part_
          : part_ // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionPart>?,
      usage: freezed == usage
          ? _value._usage
          : usage // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionUsage>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MedicinalProductDefinitionName
    extends _MedicinalProductDefinitionName {
  _$_MedicinalProductDefinitionName(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.productName,
      @JsonKey(name: '_productName') this.productNameElement,
      this.type,
      @JsonKey(name: 'part') final List<MedicinalProductDefinitionPart>? part_,
      final List<MedicinalProductDefinitionUsage>? usage})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _part_ = part_,
        _usage = usage,
        super._();

  factory _$_MedicinalProductDefinitionName.fromJson(
          Map<String, dynamic> json) =>
      _$$_MedicinalProductDefinitionNameFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [productName] The full product name.
  @override
  final String? productName;

  /// [productNameElement] ("_productName") Extensions for productName
  @override
  @JsonKey(name: '_productName')
  final Element? productNameElement;

  /// [type] Type of product name, such as rINN, BAN, Proprietary, Non-Proprietary.
  @override
  final CodeableConcept? type;

  /// [part_] ("part") Coding words or phrases of the name.
  final List<MedicinalProductDefinitionPart>? _part_;

  /// [part_] ("part") Coding words or phrases of the name.
  @override
  @JsonKey(name: 'part')
  List<MedicinalProductDefinitionPart>? get part_ {
    final value = _part_;
    if (value == null) return null;
    if (_part_ is EqualUnmodifiableListView) return _part_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [usage] Country and jurisdiction where the name applies, and associated language.
  final List<MedicinalProductDefinitionUsage>? _usage;

  /// [usage] Country and jurisdiction where the name applies, and associated language.
  @override
  List<MedicinalProductDefinitionUsage>? get usage {
    final value = _usage;
    if (value == null) return null;
    if (_usage is EqualUnmodifiableListView) return _usage;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'MedicinalProductDefinitionName(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, productName: $productName, productNameElement: $productNameElement, type: $type, part_: $part_, usage: $usage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MedicinalProductDefinitionName &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.productName, productName) ||
                other.productName == productName) &&
            (identical(other.productNameElement, productNameElement) ||
                other.productNameElement == productNameElement) &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality().equals(other._part_, _part_) &&
            const DeepCollectionEquality().equals(other._usage, _usage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      productName,
      productNameElement,
      type,
      const DeepCollectionEquality().hash(_part_),
      const DeepCollectionEquality().hash(_usage));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MedicinalProductDefinitionNameCopyWith<_$_MedicinalProductDefinitionName>
      get copyWith => __$$_MedicinalProductDefinitionNameCopyWithImpl<
          _$_MedicinalProductDefinitionName>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MedicinalProductDefinitionNameToJson(
      this,
    );
  }
}

abstract class _MedicinalProductDefinitionName
    extends MedicinalProductDefinitionName {
  factory _MedicinalProductDefinitionName(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final String? productName,
      @JsonKey(name: '_productName') final Element? productNameElement,
      final CodeableConcept? type,
      @JsonKey(name: 'part') final List<MedicinalProductDefinitionPart>? part_,
      final List<MedicinalProductDefinitionUsage>?
          usage}) = _$_MedicinalProductDefinitionName;
  _MedicinalProductDefinitionName._() : super._();

  factory _MedicinalProductDefinitionName.fromJson(Map<String, dynamic> json) =
      _$_MedicinalProductDefinitionName.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [productName] The full product name.
  String? get productName;
  @override

  /// [productNameElement] ("_productName") Extensions for productName
  @JsonKey(name: '_productName')
  Element? get productNameElement;
  @override

  /// [type] Type of product name, such as rINN, BAN, Proprietary, Non-Proprietary.
  CodeableConcept? get type;
  @override

  /// [part_] ("part") Coding words or phrases of the name.
  @JsonKey(name: 'part')
  List<MedicinalProductDefinitionPart>? get part_;
  @override

  /// [usage] Country and jurisdiction where the name applies, and associated language.
  List<MedicinalProductDefinitionUsage>? get usage;
  @override
  @JsonKey(ignore: true)
  _$$_MedicinalProductDefinitionNameCopyWith<_$_MedicinalProductDefinitionName>
      get copyWith => throw _privateConstructorUsedError;
}

MedicinalProductDefinitionPart _$MedicinalProductDefinitionPartFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductDefinitionPart.fromJson(json);
}

/// @nodoc
mixin _$MedicinalProductDefinitionPart {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [part_] ("part") A fragment of a product name.
  @JsonKey(name: 'part')
  String? get part_ => throw _privateConstructorUsedError;

  /// [partElement] ("_part") Extensions for part
  @JsonKey(name: '_part')
  Element? get partElement => throw _privateConstructorUsedError;

  /// [type] Identifying type for this part of the name (e.g. strength part).
  CodeableConcept get type => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MedicinalProductDefinitionPartCopyWith<MedicinalProductDefinitionPart>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MedicinalProductDefinitionPartCopyWith<$Res> {
  factory $MedicinalProductDefinitionPartCopyWith(
          MedicinalProductDefinitionPart value,
          $Res Function(MedicinalProductDefinitionPart) then) =
      _$MedicinalProductDefinitionPartCopyWithImpl<$Res,
          MedicinalProductDefinitionPart>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      @JsonKey(name: 'part') String? part_,
      @JsonKey(name: '_part') Element? partElement,
      CodeableConcept type});

  $ElementCopyWith<$Res>? get partElement;
  $CodeableConceptCopyWith<$Res> get type;
}

/// @nodoc
class _$MedicinalProductDefinitionPartCopyWithImpl<$Res,
        $Val extends MedicinalProductDefinitionPart>
    implements $MedicinalProductDefinitionPartCopyWith<$Res> {
  _$MedicinalProductDefinitionPartCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? part_ = freezed,
    Object? partElement = freezed,
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      part_: freezed == part_
          ? _value.part_
          : part_ // ignore: cast_nullable_to_non_nullable
              as String?,
      partElement: freezed == partElement
          ? _value.partElement
          : partElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get partElement {
    if (_value.partElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.partElement!, (value) {
      return _then(_value.copyWith(partElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MedicinalProductDefinitionPartCopyWith<$Res>
    implements $MedicinalProductDefinitionPartCopyWith<$Res> {
  factory _$$_MedicinalProductDefinitionPartCopyWith(
          _$_MedicinalProductDefinitionPart value,
          $Res Function(_$_MedicinalProductDefinitionPart) then) =
      __$$_MedicinalProductDefinitionPartCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      @JsonKey(name: 'part') String? part_,
      @JsonKey(name: '_part') Element? partElement,
      CodeableConcept type});

  @override
  $ElementCopyWith<$Res>? get partElement;
  @override
  $CodeableConceptCopyWith<$Res> get type;
}

/// @nodoc
class __$$_MedicinalProductDefinitionPartCopyWithImpl<$Res>
    extends _$MedicinalProductDefinitionPartCopyWithImpl<$Res,
        _$_MedicinalProductDefinitionPart>
    implements _$$_MedicinalProductDefinitionPartCopyWith<$Res> {
  __$$_MedicinalProductDefinitionPartCopyWithImpl(
      _$_MedicinalProductDefinitionPart _value,
      $Res Function(_$_MedicinalProductDefinitionPart) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? part_ = freezed,
    Object? partElement = freezed,
    Object? type = null,
  }) {
    return _then(_$_MedicinalProductDefinitionPart(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      part_: freezed == part_
          ? _value.part_
          : part_ // ignore: cast_nullable_to_non_nullable
              as String?,
      partElement: freezed == partElement
          ? _value.partElement
          : partElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MedicinalProductDefinitionPart
    extends _MedicinalProductDefinitionPart {
  _$_MedicinalProductDefinitionPart(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      @JsonKey(name: 'part') this.part_,
      @JsonKey(name: '_part') this.partElement,
      required this.type})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_MedicinalProductDefinitionPart.fromJson(
          Map<String, dynamic> json) =>
      _$$_MedicinalProductDefinitionPartFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [part_] ("part") A fragment of a product name.
  @override
  @JsonKey(name: 'part')
  final String? part_;

  /// [partElement] ("_part") Extensions for part
  @override
  @JsonKey(name: '_part')
  final Element? partElement;

  /// [type] Identifying type for this part of the name (e.g. strength part).
  @override
  final CodeableConcept type;

  @override
  String toString() {
    return 'MedicinalProductDefinitionPart(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, part_: $part_, partElement: $partElement, type: $type)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MedicinalProductDefinitionPart &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.part_, part_) || other.part_ == part_) &&
            (identical(other.partElement, partElement) ||
                other.partElement == partElement) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      part_,
      partElement,
      type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MedicinalProductDefinitionPartCopyWith<_$_MedicinalProductDefinitionPart>
      get copyWith => __$$_MedicinalProductDefinitionPartCopyWithImpl<
          _$_MedicinalProductDefinitionPart>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MedicinalProductDefinitionPartToJson(
      this,
    );
  }
}

abstract class _MedicinalProductDefinitionPart
    extends MedicinalProductDefinitionPart {
  factory _MedicinalProductDefinitionPart(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      @JsonKey(name: 'part') final String? part_,
      @JsonKey(name: '_part') final Element? partElement,
      required final CodeableConcept type}) = _$_MedicinalProductDefinitionPart;
  _MedicinalProductDefinitionPart._() : super._();

  factory _MedicinalProductDefinitionPart.fromJson(Map<String, dynamic> json) =
      _$_MedicinalProductDefinitionPart.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [part_] ("part") A fragment of a product name.
  @JsonKey(name: 'part')
  String? get part_;
  @override

  /// [partElement] ("_part") Extensions for part
  @JsonKey(name: '_part')
  Element? get partElement;
  @override

  /// [type] Identifying type for this part of the name (e.g. strength part).
  CodeableConcept get type;
  @override
  @JsonKey(ignore: true)
  _$$_MedicinalProductDefinitionPartCopyWith<_$_MedicinalProductDefinitionPart>
      get copyWith => throw _privateConstructorUsedError;
}

MedicinalProductDefinitionUsage _$MedicinalProductDefinitionUsageFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductDefinitionUsage.fromJson(json);
}

/// @nodoc
mixin _$MedicinalProductDefinitionUsage {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [country] Country code for where this name applies.
  CodeableConcept get country => throw _privateConstructorUsedError;

  /// [jurisdiction] Jurisdiction code for where this name applies. A jurisdiction may be a sub- or supra-national entity (e.g. a state or a geographic region).
  CodeableConcept? get jurisdiction => throw _privateConstructorUsedError;

  /// [language] Language code for this name.
  CodeableConcept get language => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MedicinalProductDefinitionUsageCopyWith<MedicinalProductDefinitionUsage>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MedicinalProductDefinitionUsageCopyWith<$Res> {
  factory $MedicinalProductDefinitionUsageCopyWith(
          MedicinalProductDefinitionUsage value,
          $Res Function(MedicinalProductDefinitionUsage) then) =
      _$MedicinalProductDefinitionUsageCopyWithImpl<$Res,
          MedicinalProductDefinitionUsage>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept country,
      CodeableConcept? jurisdiction,
      CodeableConcept language});

  $CodeableConceptCopyWith<$Res> get country;
  $CodeableConceptCopyWith<$Res>? get jurisdiction;
  $CodeableConceptCopyWith<$Res> get language;
}

/// @nodoc
class _$MedicinalProductDefinitionUsageCopyWithImpl<$Res,
        $Val extends MedicinalProductDefinitionUsage>
    implements $MedicinalProductDefinitionUsageCopyWith<$Res> {
  _$MedicinalProductDefinitionUsageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? country = null,
    Object? jurisdiction = freezed,
    Object? language = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      country: null == country
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      jurisdiction: freezed == jurisdiction
          ? _value.jurisdiction
          : jurisdiction // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      language: null == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get country {
    return $CodeableConceptCopyWith<$Res>(_value.country, (value) {
      return _then(_value.copyWith(country: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get jurisdiction {
    if (_value.jurisdiction == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.jurisdiction!, (value) {
      return _then(_value.copyWith(jurisdiction: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get language {
    return $CodeableConceptCopyWith<$Res>(_value.language, (value) {
      return _then(_value.copyWith(language: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MedicinalProductDefinitionUsageCopyWith<$Res>
    implements $MedicinalProductDefinitionUsageCopyWith<$Res> {
  factory _$$_MedicinalProductDefinitionUsageCopyWith(
          _$_MedicinalProductDefinitionUsage value,
          $Res Function(_$_MedicinalProductDefinitionUsage) then) =
      __$$_MedicinalProductDefinitionUsageCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept country,
      CodeableConcept? jurisdiction,
      CodeableConcept language});

  @override
  $CodeableConceptCopyWith<$Res> get country;
  @override
  $CodeableConceptCopyWith<$Res>? get jurisdiction;
  @override
  $CodeableConceptCopyWith<$Res> get language;
}

/// @nodoc
class __$$_MedicinalProductDefinitionUsageCopyWithImpl<$Res>
    extends _$MedicinalProductDefinitionUsageCopyWithImpl<$Res,
        _$_MedicinalProductDefinitionUsage>
    implements _$$_MedicinalProductDefinitionUsageCopyWith<$Res> {
  __$$_MedicinalProductDefinitionUsageCopyWithImpl(
      _$_MedicinalProductDefinitionUsage _value,
      $Res Function(_$_MedicinalProductDefinitionUsage) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? country = null,
    Object? jurisdiction = freezed,
    Object? language = null,
  }) {
    return _then(_$_MedicinalProductDefinitionUsage(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      country: null == country
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      jurisdiction: freezed == jurisdiction
          ? _value.jurisdiction
          : jurisdiction // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      language: null == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MedicinalProductDefinitionUsage
    extends _MedicinalProductDefinitionUsage {
  _$_MedicinalProductDefinitionUsage(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.country,
      this.jurisdiction,
      required this.language})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_MedicinalProductDefinitionUsage.fromJson(
          Map<String, dynamic> json) =>
      _$$_MedicinalProductDefinitionUsageFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [country] Country code for where this name applies.
  @override
  final CodeableConcept country;

  /// [jurisdiction] Jurisdiction code for where this name applies. A jurisdiction may be a sub- or supra-national entity (e.g. a state or a geographic region).
  @override
  final CodeableConcept? jurisdiction;

  /// [language] Language code for this name.
  @override
  final CodeableConcept language;

  @override
  String toString() {
    return 'MedicinalProductDefinitionUsage(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, country: $country, jurisdiction: $jurisdiction, language: $language)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MedicinalProductDefinitionUsage &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.country, country) || other.country == country) &&
            (identical(other.jurisdiction, jurisdiction) ||
                other.jurisdiction == jurisdiction) &&
            (identical(other.language, language) ||
                other.language == language));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      country,
      jurisdiction,
      language);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MedicinalProductDefinitionUsageCopyWith<
          _$_MedicinalProductDefinitionUsage>
      get copyWith => __$$_MedicinalProductDefinitionUsageCopyWithImpl<
          _$_MedicinalProductDefinitionUsage>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MedicinalProductDefinitionUsageToJson(
      this,
    );
  }
}

abstract class _MedicinalProductDefinitionUsage
    extends MedicinalProductDefinitionUsage {
  factory _MedicinalProductDefinitionUsage(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept country,
          final CodeableConcept? jurisdiction,
          required final CodeableConcept language}) =
      _$_MedicinalProductDefinitionUsage;
  _MedicinalProductDefinitionUsage._() : super._();

  factory _MedicinalProductDefinitionUsage.fromJson(Map<String, dynamic> json) =
      _$_MedicinalProductDefinitionUsage.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [country] Country code for where this name applies.
  CodeableConcept get country;
  @override

  /// [jurisdiction] Jurisdiction code for where this name applies. A jurisdiction may be a sub- or supra-national entity (e.g. a state or a geographic region).
  CodeableConcept? get jurisdiction;
  @override

  /// [language] Language code for this name.
  CodeableConcept get language;
  @override
  @JsonKey(ignore: true)
  _$$_MedicinalProductDefinitionUsageCopyWith<
          _$_MedicinalProductDefinitionUsage>
      get copyWith => throw _privateConstructorUsedError;
}

MedicinalProductDefinitionCrossReference
    _$MedicinalProductDefinitionCrossReferenceFromJson(
        Map<String, dynamic> json) {
  return _MedicinalProductDefinitionCrossReference.fromJson(json);
}

/// @nodoc
mixin _$MedicinalProductDefinitionCrossReference {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [product] Reference to another product, e.g. for linking authorised to investigational product.
  CodeableReference get product => throw _privateConstructorUsedError;

  /// [type] The type of relationship, for instance branded to generic, virtual to actual product, product to development product (investigational), parallel import version.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MedicinalProductDefinitionCrossReferenceCopyWith<
          MedicinalProductDefinitionCrossReference>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MedicinalProductDefinitionCrossReferenceCopyWith<$Res> {
  factory $MedicinalProductDefinitionCrossReferenceCopyWith(
          MedicinalProductDefinitionCrossReference value,
          $Res Function(MedicinalProductDefinitionCrossReference) then) =
      _$MedicinalProductDefinitionCrossReferenceCopyWithImpl<$Res,
          MedicinalProductDefinitionCrossReference>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference product,
      CodeableConcept? type});

  $CodeableReferenceCopyWith<$Res> get product;
  $CodeableConceptCopyWith<$Res>? get type;
}

/// @nodoc
class _$MedicinalProductDefinitionCrossReferenceCopyWithImpl<$Res,
        $Val extends MedicinalProductDefinitionCrossReference>
    implements $MedicinalProductDefinitionCrossReferenceCopyWith<$Res> {
  _$MedicinalProductDefinitionCrossReferenceCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? product = null,
    Object? type = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      product: null == product
          ? _value.product
          : product // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res> get product {
    return $CodeableReferenceCopyWith<$Res>(_value.product, (value) {
      return _then(_value.copyWith(product: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MedicinalProductDefinitionCrossReferenceCopyWith<$Res>
    implements $MedicinalProductDefinitionCrossReferenceCopyWith<$Res> {
  factory _$$_MedicinalProductDefinitionCrossReferenceCopyWith(
          _$_MedicinalProductDefinitionCrossReference value,
          $Res Function(_$_MedicinalProductDefinitionCrossReference) then) =
      __$$_MedicinalProductDefinitionCrossReferenceCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference product,
      CodeableConcept? type});

  @override
  $CodeableReferenceCopyWith<$Res> get product;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
}

/// @nodoc
class __$$_MedicinalProductDefinitionCrossReferenceCopyWithImpl<$Res>
    extends _$MedicinalProductDefinitionCrossReferenceCopyWithImpl<$Res,
        _$_MedicinalProductDefinitionCrossReference>
    implements _$$_MedicinalProductDefinitionCrossReferenceCopyWith<$Res> {
  __$$_MedicinalProductDefinitionCrossReferenceCopyWithImpl(
      _$_MedicinalProductDefinitionCrossReference _value,
      $Res Function(_$_MedicinalProductDefinitionCrossReference) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? product = null,
    Object? type = freezed,
  }) {
    return _then(_$_MedicinalProductDefinitionCrossReference(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      product: null == product
          ? _value.product
          : product // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MedicinalProductDefinitionCrossReference
    extends _MedicinalProductDefinitionCrossReference {
  _$_MedicinalProductDefinitionCrossReference(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.product,
      this.type})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_MedicinalProductDefinitionCrossReference.fromJson(
          Map<String, dynamic> json) =>
      _$$_MedicinalProductDefinitionCrossReferenceFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [product] Reference to another product, e.g. for linking authorised to investigational product.
  @override
  final CodeableReference product;

  /// [type] The type of relationship, for instance branded to generic, virtual to actual product, product to development product (investigational), parallel import version.
  @override
  final CodeableConcept? type;

  @override
  String toString() {
    return 'MedicinalProductDefinitionCrossReference(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, product: $product, type: $type)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MedicinalProductDefinitionCrossReference &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.product, product) || other.product == product) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      product,
      type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MedicinalProductDefinitionCrossReferenceCopyWith<
          _$_MedicinalProductDefinitionCrossReference>
      get copyWith => __$$_MedicinalProductDefinitionCrossReferenceCopyWithImpl<
          _$_MedicinalProductDefinitionCrossReference>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MedicinalProductDefinitionCrossReferenceToJson(
      this,
    );
  }
}

abstract class _MedicinalProductDefinitionCrossReference
    extends MedicinalProductDefinitionCrossReference {
  factory _MedicinalProductDefinitionCrossReference(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableReference product,
          final CodeableConcept? type}) =
      _$_MedicinalProductDefinitionCrossReference;
  _MedicinalProductDefinitionCrossReference._() : super._();

  factory _MedicinalProductDefinitionCrossReference.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductDefinitionCrossReference.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [product] Reference to another product, e.g. for linking authorised to investigational product.
  CodeableReference get product;
  @override

  /// [type] The type of relationship, for instance branded to generic, virtual to actual product, product to development product (investigational), parallel import version.
  CodeableConcept? get type;
  @override
  @JsonKey(ignore: true)
  _$$_MedicinalProductDefinitionCrossReferenceCopyWith<
          _$_MedicinalProductDefinitionCrossReference>
      get copyWith => throw _privateConstructorUsedError;
}

MedicinalProductDefinitionOperation
    _$MedicinalProductDefinitionOperationFromJson(Map<String, dynamic> json) {
  return _MedicinalProductDefinitionOperation.fromJson(json);
}

/// @nodoc
mixin _$MedicinalProductDefinitionOperation {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] The type of manufacturing operation e.g. manufacturing itself, re-packaging. For the authorization of this, a RegulatedAuthorization would point to the same plan or activity referenced here.
  CodeableReference? get type => throw _privateConstructorUsedError;

  /// [effectiveDate] Date range of applicability.
  Period? get effectiveDate => throw _privateConstructorUsedError;

  /// [organization] The organization or establishment responsible for (or associated with) the particular process or step, examples include the manufacturer, importer, agent.
  List<Reference>? get organization => throw _privateConstructorUsedError;

  /// [confidentialityIndicator] Specifies whether this particular business or manufacturing process is considered proprietary or confidential.
  CodeableConcept? get confidentialityIndicator =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MedicinalProductDefinitionOperationCopyWith<
          MedicinalProductDefinitionOperation>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MedicinalProductDefinitionOperationCopyWith<$Res> {
  factory $MedicinalProductDefinitionOperationCopyWith(
          MedicinalProductDefinitionOperation value,
          $Res Function(MedicinalProductDefinitionOperation) then) =
      _$MedicinalProductDefinitionOperationCopyWithImpl<$Res,
          MedicinalProductDefinitionOperation>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? type,
      Period? effectiveDate,
      List<Reference>? organization,
      CodeableConcept? confidentialityIndicator});

  $CodeableReferenceCopyWith<$Res>? get type;
  $PeriodCopyWith<$Res>? get effectiveDate;
  $CodeableConceptCopyWith<$Res>? get confidentialityIndicator;
}

/// @nodoc
class _$MedicinalProductDefinitionOperationCopyWithImpl<$Res,
        $Val extends MedicinalProductDefinitionOperation>
    implements $MedicinalProductDefinitionOperationCopyWith<$Res> {
  _$MedicinalProductDefinitionOperationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? effectiveDate = freezed,
    Object? organization = freezed,
    Object? confidentialityIndicator = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      effectiveDate: freezed == effectiveDate
          ? _value.effectiveDate
          : effectiveDate // ignore: cast_nullable_to_non_nullable
              as Period?,
      organization: freezed == organization
          ? _value.organization
          : organization // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      confidentialityIndicator: freezed == confidentialityIndicator
          ? _value.confidentialityIndicator
          : confidentialityIndicator // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableReferenceCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get effectiveDate {
    if (_value.effectiveDate == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.effectiveDate!, (value) {
      return _then(_value.copyWith(effectiveDate: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get confidentialityIndicator {
    if (_value.confidentialityIndicator == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.confidentialityIndicator!,
        (value) {
      return _then(_value.copyWith(confidentialityIndicator: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MedicinalProductDefinitionOperationCopyWith<$Res>
    implements $MedicinalProductDefinitionOperationCopyWith<$Res> {
  factory _$$_MedicinalProductDefinitionOperationCopyWith(
          _$_MedicinalProductDefinitionOperation value,
          $Res Function(_$_MedicinalProductDefinitionOperation) then) =
      __$$_MedicinalProductDefinitionOperationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? type,
      Period? effectiveDate,
      List<Reference>? organization,
      CodeableConcept? confidentialityIndicator});

  @override
  $CodeableReferenceCopyWith<$Res>? get type;
  @override
  $PeriodCopyWith<$Res>? get effectiveDate;
  @override
  $CodeableConceptCopyWith<$Res>? get confidentialityIndicator;
}

/// @nodoc
class __$$_MedicinalProductDefinitionOperationCopyWithImpl<$Res>
    extends _$MedicinalProductDefinitionOperationCopyWithImpl<$Res,
        _$_MedicinalProductDefinitionOperation>
    implements _$$_MedicinalProductDefinitionOperationCopyWith<$Res> {
  __$$_MedicinalProductDefinitionOperationCopyWithImpl(
      _$_MedicinalProductDefinitionOperation _value,
      $Res Function(_$_MedicinalProductDefinitionOperation) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? effectiveDate = freezed,
    Object? organization = freezed,
    Object? confidentialityIndicator = freezed,
  }) {
    return _then(_$_MedicinalProductDefinitionOperation(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      effectiveDate: freezed == effectiveDate
          ? _value.effectiveDate
          : effectiveDate // ignore: cast_nullable_to_non_nullable
              as Period?,
      organization: freezed == organization
          ? _value._organization
          : organization // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      confidentialityIndicator: freezed == confidentialityIndicator
          ? _value.confidentialityIndicator
          : confidentialityIndicator // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MedicinalProductDefinitionOperation
    extends _MedicinalProductDefinitionOperation {
  _$_MedicinalProductDefinitionOperation(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.type,
      this.effectiveDate,
      final List<Reference>? organization,
      this.confidentialityIndicator})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _organization = organization,
        super._();

  factory _$_MedicinalProductDefinitionOperation.fromJson(
          Map<String, dynamic> json) =>
      _$$_MedicinalProductDefinitionOperationFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] The type of manufacturing operation e.g. manufacturing itself, re-packaging. For the authorization of this, a RegulatedAuthorization would point to the same plan or activity referenced here.
  @override
  final CodeableReference? type;

  /// [effectiveDate] Date range of applicability.
  @override
  final Period? effectiveDate;

  /// [organization] The organization or establishment responsible for (or associated with) the particular process or step, examples include the manufacturer, importer, agent.
  final List<Reference>? _organization;

  /// [organization] The organization or establishment responsible for (or associated with) the particular process or step, examples include the manufacturer, importer, agent.
  @override
  List<Reference>? get organization {
    final value = _organization;
    if (value == null) return null;
    if (_organization is EqualUnmodifiableListView) return _organization;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [confidentialityIndicator] Specifies whether this particular business or manufacturing process is considered proprietary or confidential.
  @override
  final CodeableConcept? confidentialityIndicator;

  @override
  String toString() {
    return 'MedicinalProductDefinitionOperation(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, effectiveDate: $effectiveDate, organization: $organization, confidentialityIndicator: $confidentialityIndicator)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MedicinalProductDefinitionOperation &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.effectiveDate, effectiveDate) ||
                other.effectiveDate == effectiveDate) &&
            const DeepCollectionEquality()
                .equals(other._organization, _organization) &&
            (identical(
                    other.confidentialityIndicator, confidentialityIndicator) ||
                other.confidentialityIndicator == confidentialityIndicator));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      effectiveDate,
      const DeepCollectionEquality().hash(_organization),
      confidentialityIndicator);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MedicinalProductDefinitionOperationCopyWith<
          _$_MedicinalProductDefinitionOperation>
      get copyWith => __$$_MedicinalProductDefinitionOperationCopyWithImpl<
          _$_MedicinalProductDefinitionOperation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MedicinalProductDefinitionOperationToJson(
      this,
    );
  }
}

abstract class _MedicinalProductDefinitionOperation
    extends MedicinalProductDefinitionOperation {
  factory _MedicinalProductDefinitionOperation(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableReference? type,
          final Period? effectiveDate,
          final List<Reference>? organization,
          final CodeableConcept? confidentialityIndicator}) =
      _$_MedicinalProductDefinitionOperation;
  _MedicinalProductDefinitionOperation._() : super._();

  factory _MedicinalProductDefinitionOperation.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductDefinitionOperation.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] The type of manufacturing operation e.g. manufacturing itself, re-packaging. For the authorization of this, a RegulatedAuthorization would point to the same plan or activity referenced here.
  CodeableReference? get type;
  @override

  /// [effectiveDate] Date range of applicability.
  Period? get effectiveDate;
  @override

  /// [organization] The organization or establishment responsible for (or associated with) the particular process or step, examples include the manufacturer, importer, agent.
  List<Reference>? get organization;
  @override

  /// [confidentialityIndicator] Specifies whether this particular business or manufacturing process is considered proprietary or confidential.
  CodeableConcept? get confidentialityIndicator;
  @override
  @JsonKey(ignore: true)
  _$$_MedicinalProductDefinitionOperationCopyWith<
          _$_MedicinalProductDefinitionOperation>
      get copyWith => throw _privateConstructorUsedError;
}

MedicinalProductDefinitionCharacteristic
    _$MedicinalProductDefinitionCharacteristicFromJson(
        Map<String, dynamic> json) {
  return _MedicinalProductDefinitionCharacteristic.fromJson(json);
}

/// @nodoc
mixin _$MedicinalProductDefinitionCharacteristic {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] A code expressing the type of characteristic.
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [valueCodeableConcept] A value for the characteristic.text.
  CodeableConcept? get valueCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [valueString] A value for the characteristic.text.
  String? get valueString => throw _privateConstructorUsedError;

  /// [valueStringElement] ("_valueString") Extensions for valueString
  @JsonKey(name: '_valueString')
  Element? get valueStringElement => throw _privateConstructorUsedError;

  /// [valueQuantity] A value for the characteristic.text.
  Quantity? get valueQuantity => throw _privateConstructorUsedError;

  /// [valueInteger] A value for the characteristic.text.
  Integer? get valueInteger => throw _privateConstructorUsedError;

  /// [valueIntegerElement] ("_valueInteger") Extensions for valueInteger
  @JsonKey(name: '_valueInteger')
  Element? get valueIntegerElement => throw _privateConstructorUsedError;

  /// [valueDate] A value for the characteristic.text.
  Date? get valueDate => throw _privateConstructorUsedError;

  /// [valueDateElement] ("_valueDate") Extensions for valueDate
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement => throw _privateConstructorUsedError;

  /// [valueBoolean] A value for the characteristic.text.
  Boolean? get valueBoolean => throw _privateConstructorUsedError;

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement => throw _privateConstructorUsedError;

  /// [valueAttachment] A value for the characteristic.text.
  Attachment? get valueAttachment => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MedicinalProductDefinitionCharacteristicCopyWith<
          MedicinalProductDefinitionCharacteristic>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MedicinalProductDefinitionCharacteristicCopyWith<$Res> {
  factory $MedicinalProductDefinitionCharacteristicCopyWith(
          MedicinalProductDefinitionCharacteristic value,
          $Res Function(MedicinalProductDefinitionCharacteristic) then) =
      _$MedicinalProductDefinitionCharacteristicCopyWithImpl<$Res,
          MedicinalProductDefinitionCharacteristic>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      String? valueString,
      @JsonKey(name: '_valueString') Element? valueStringElement,
      Quantity? valueQuantity,
      Integer? valueInteger,
      @JsonKey(name: '_valueInteger') Element? valueIntegerElement,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment});

  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  $ElementCopyWith<$Res>? get valueStringElement;
  $QuantityCopyWith<$Res>? get valueQuantity;
  $ElementCopyWith<$Res>? get valueIntegerElement;
  $ElementCopyWith<$Res>? get valueDateElement;
  $ElementCopyWith<$Res>? get valueBooleanElement;
  $AttachmentCopyWith<$Res>? get valueAttachment;
}

/// @nodoc
class _$MedicinalProductDefinitionCharacteristicCopyWithImpl<$Res,
        $Val extends MedicinalProductDefinitionCharacteristic>
    implements $MedicinalProductDefinitionCharacteristicCopyWith<$Res> {
  _$MedicinalProductDefinitionCharacteristicCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueString = freezed,
    Object? valueStringElement = freezed,
    Object? valueQuantity = freezed,
    Object? valueInteger = freezed,
    Object? valueIntegerElement = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueString: freezed == valueString
          ? _value.valueString
          : valueString // ignore: cast_nullable_to_non_nullable
              as String?,
      valueStringElement: freezed == valueStringElement
          ? _value.valueStringElement
          : valueStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueInteger: freezed == valueInteger
          ? _value.valueInteger
          : valueInteger // ignore: cast_nullable_to_non_nullable
              as Integer?,
      valueIntegerElement: freezed == valueIntegerElement
          ? _value.valueIntegerElement
          : valueIntegerElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept {
    if (_value.valueCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.valueCodeableConcept!,
        (value) {
      return _then(_value.copyWith(valueCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueStringElement {
    if (_value.valueStringElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueStringElement!, (value) {
      return _then(_value.copyWith(valueStringElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get valueQuantity {
    if (_value.valueQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.valueQuantity!, (value) {
      return _then(_value.copyWith(valueQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueIntegerElement {
    if (_value.valueIntegerElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueIntegerElement!, (value) {
      return _then(_value.copyWith(valueIntegerElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueDateElement {
    if (_value.valueDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueDateElement!, (value) {
      return _then(_value.copyWith(valueDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueBooleanElement {
    if (_value.valueBooleanElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueBooleanElement!, (value) {
      return _then(_value.copyWith(valueBooleanElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get valueAttachment {
    if (_value.valueAttachment == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.valueAttachment!, (value) {
      return _then(_value.copyWith(valueAttachment: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MedicinalProductDefinitionCharacteristicCopyWith<$Res>
    implements $MedicinalProductDefinitionCharacteristicCopyWith<$Res> {
  factory _$$_MedicinalProductDefinitionCharacteristicCopyWith(
          _$_MedicinalProductDefinitionCharacteristic value,
          $Res Function(_$_MedicinalProductDefinitionCharacteristic) then) =
      __$$_MedicinalProductDefinitionCharacteristicCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      String? valueString,
      @JsonKey(name: '_valueString') Element? valueStringElement,
      Quantity? valueQuantity,
      Integer? valueInteger,
      @JsonKey(name: '_valueInteger') Element? valueIntegerElement,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  @override
  $ElementCopyWith<$Res>? get valueStringElement;
  @override
  $QuantityCopyWith<$Res>? get valueQuantity;
  @override
  $ElementCopyWith<$Res>? get valueIntegerElement;
  @override
  $ElementCopyWith<$Res>? get valueDateElement;
  @override
  $ElementCopyWith<$Res>? get valueBooleanElement;
  @override
  $AttachmentCopyWith<$Res>? get valueAttachment;
}

/// @nodoc
class __$$_MedicinalProductDefinitionCharacteristicCopyWithImpl<$Res>
    extends _$MedicinalProductDefinitionCharacteristicCopyWithImpl<$Res,
        _$_MedicinalProductDefinitionCharacteristic>
    implements _$$_MedicinalProductDefinitionCharacteristicCopyWith<$Res> {
  __$$_MedicinalProductDefinitionCharacteristicCopyWithImpl(
      _$_MedicinalProductDefinitionCharacteristic _value,
      $Res Function(_$_MedicinalProductDefinitionCharacteristic) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueString = freezed,
    Object? valueStringElement = freezed,
    Object? valueQuantity = freezed,
    Object? valueInteger = freezed,
    Object? valueIntegerElement = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
  }) {
    return _then(_$_MedicinalProductDefinitionCharacteristic(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueString: freezed == valueString
          ? _value.valueString
          : valueString // ignore: cast_nullable_to_non_nullable
              as String?,
      valueStringElement: freezed == valueStringElement
          ? _value.valueStringElement
          : valueStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueInteger: freezed == valueInteger
          ? _value.valueInteger
          : valueInteger // ignore: cast_nullable_to_non_nullable
              as Integer?,
      valueIntegerElement: freezed == valueIntegerElement
          ? _value.valueIntegerElement
          : valueIntegerElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MedicinalProductDefinitionCharacteristic
    extends _MedicinalProductDefinitionCharacteristic {
  _$_MedicinalProductDefinitionCharacteristic(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.type,
      this.valueCodeableConcept,
      this.valueString,
      @JsonKey(name: '_valueString') this.valueStringElement,
      this.valueQuantity,
      this.valueInteger,
      @JsonKey(name: '_valueInteger') this.valueIntegerElement,
      this.valueDate,
      @JsonKey(name: '_valueDate') this.valueDateElement,
      this.valueBoolean,
      @JsonKey(name: '_valueBoolean') this.valueBooleanElement,
      this.valueAttachment})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_MedicinalProductDefinitionCharacteristic.fromJson(
          Map<String, dynamic> json) =>
      _$$_MedicinalProductDefinitionCharacteristicFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] A code expressing the type of characteristic.
  @override
  final CodeableConcept type;

  /// [valueCodeableConcept] A value for the characteristic.text.
  @override
  final CodeableConcept? valueCodeableConcept;

  /// [valueString] A value for the characteristic.text.
  @override
  final String? valueString;

  /// [valueStringElement] ("_valueString") Extensions for valueString
  @override
  @JsonKey(name: '_valueString')
  final Element? valueStringElement;

  /// [valueQuantity] A value for the characteristic.text.
  @override
  final Quantity? valueQuantity;

  /// [valueInteger] A value for the characteristic.text.
  @override
  final Integer? valueInteger;

  /// [valueIntegerElement] ("_valueInteger") Extensions for valueInteger
  @override
  @JsonKey(name: '_valueInteger')
  final Element? valueIntegerElement;

  /// [valueDate] A value for the characteristic.text.
  @override
  final Date? valueDate;

  /// [valueDateElement] ("_valueDate") Extensions for valueDate
  @override
  @JsonKey(name: '_valueDate')
  final Element? valueDateElement;

  /// [valueBoolean] A value for the characteristic.text.
  @override
  final Boolean? valueBoolean;

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @override
  @JsonKey(name: '_valueBoolean')
  final Element? valueBooleanElement;

  /// [valueAttachment] A value for the characteristic.text.
  @override
  final Attachment? valueAttachment;

  @override
  String toString() {
    return 'MedicinalProductDefinitionCharacteristic(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, valueCodeableConcept: $valueCodeableConcept, valueString: $valueString, valueStringElement: $valueStringElement, valueQuantity: $valueQuantity, valueInteger: $valueInteger, valueIntegerElement: $valueIntegerElement, valueDate: $valueDate, valueDateElement: $valueDateElement, valueBoolean: $valueBoolean, valueBooleanElement: $valueBooleanElement, valueAttachment: $valueAttachment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MedicinalProductDefinitionCharacteristic &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.valueCodeableConcept, valueCodeableConcept) ||
                other.valueCodeableConcept == valueCodeableConcept) &&
            (identical(other.valueString, valueString) ||
                other.valueString == valueString) &&
            (identical(other.valueStringElement, valueStringElement) ||
                other.valueStringElement == valueStringElement) &&
            (identical(other.valueQuantity, valueQuantity) ||
                other.valueQuantity == valueQuantity) &&
            (identical(other.valueInteger, valueInteger) ||
                other.valueInteger == valueInteger) &&
            (identical(other.valueIntegerElement, valueIntegerElement) ||
                other.valueIntegerElement == valueIntegerElement) &&
            (identical(other.valueDate, valueDate) ||
                other.valueDate == valueDate) &&
            (identical(other.valueDateElement, valueDateElement) ||
                other.valueDateElement == valueDateElement) &&
            (identical(other.valueBoolean, valueBoolean) ||
                other.valueBoolean == valueBoolean) &&
            (identical(other.valueBooleanElement, valueBooleanElement) ||
                other.valueBooleanElement == valueBooleanElement) &&
            (identical(other.valueAttachment, valueAttachment) ||
                other.valueAttachment == valueAttachment));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      valueCodeableConcept,
      valueString,
      valueStringElement,
      valueQuantity,
      valueInteger,
      valueIntegerElement,
      valueDate,
      valueDateElement,
      valueBoolean,
      valueBooleanElement,
      valueAttachment);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MedicinalProductDefinitionCharacteristicCopyWith<
          _$_MedicinalProductDefinitionCharacteristic>
      get copyWith => __$$_MedicinalProductDefinitionCharacteristicCopyWithImpl<
          _$_MedicinalProductDefinitionCharacteristic>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MedicinalProductDefinitionCharacteristicToJson(
      this,
    );
  }
}

abstract class _MedicinalProductDefinitionCharacteristic
    extends MedicinalProductDefinitionCharacteristic {
  factory _MedicinalProductDefinitionCharacteristic(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept type,
          final CodeableConcept? valueCodeableConcept,
          final String? valueString,
          @JsonKey(name: '_valueString') final Element? valueStringElement,
          final Quantity? valueQuantity,
          final Integer? valueInteger,
          @JsonKey(name: '_valueInteger') final Element? valueIntegerElement,
          final Date? valueDate,
          @JsonKey(name: '_valueDate') final Element? valueDateElement,
          final Boolean? valueBoolean,
          @JsonKey(name: '_valueBoolean') final Element? valueBooleanElement,
          final Attachment? valueAttachment}) =
      _$_MedicinalProductDefinitionCharacteristic;
  _MedicinalProductDefinitionCharacteristic._() : super._();

  factory _MedicinalProductDefinitionCharacteristic.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductDefinitionCharacteristic.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] A code expressing the type of characteristic.
  CodeableConcept get type;
  @override

  /// [valueCodeableConcept] A value for the characteristic.text.
  CodeableConcept? get valueCodeableConcept;
  @override

  /// [valueString] A value for the characteristic.text.
  String? get valueString;
  @override

  /// [valueStringElement] ("_valueString") Extensions for valueString
  @JsonKey(name: '_valueString')
  Element? get valueStringElement;
  @override

  /// [valueQuantity] A value for the characteristic.text.
  Quantity? get valueQuantity;
  @override

  /// [valueInteger] A value for the characteristic.text.
  Integer? get valueInteger;
  @override

  /// [valueIntegerElement] ("_valueInteger") Extensions for valueInteger
  @JsonKey(name: '_valueInteger')
  Element? get valueIntegerElement;
  @override

  /// [valueDate] A value for the characteristic.text.
  Date? get valueDate;
  @override

  /// [valueDateElement] ("_valueDate") Extensions for valueDate
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement;
  @override

  /// [valueBoolean] A value for the characteristic.text.
  Boolean? get valueBoolean;
  @override

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement;
  @override

  /// [valueAttachment] A value for the characteristic.text.
  Attachment? get valueAttachment;
  @override
  @JsonKey(ignore: true)
  _$$_MedicinalProductDefinitionCharacteristicCopyWith<
          _$_MedicinalProductDefinitionCharacteristic>
      get copyWith => throw _privateConstructorUsedError;
}

PackagedProductDefinition _$PackagedProductDefinitionFromJson(
    Map<String, dynamic> json) {
  return _PackagedProductDefinition.fromJson(json);
}

/// @nodoc
mixin _$PackagedProductDefinition {
  /// [resourceType] This is a PackagedProductDefinition resource
  @JsonKey(unknownEnumValue: R5ResourceType.PackagedProductDefinition)
  R5ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] A unique identifier for this package as whole - not the the content of the package. Unique instance identifiers assigned to a package by manufacturers, regulators, drug catalogue custodians or other organizations.
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [name] A name for this package. Typically what it would be listed as in a drug formulary or catalogue, inventory etc.
  String? get name => throw _privateConstructorUsedError;

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement => throw _privateConstructorUsedError;

  /// [type] A high level category e.g. medicinal product, raw material, shipping/transport container, etc.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [packageFor] The product this package model relates to, not the contents of the package (for which see package.containedItem).
  List<Reference>? get packageFor => throw _privateConstructorUsedError;

  /// [status] The status within the lifecycle of this item. A high level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization or marketing status.
  CodeableConcept? get status => throw _privateConstructorUsedError;

  /// [statusDate] The date at which the given status became applicable.
  FhirDateTime? get statusDate => throw _privateConstructorUsedError;

  /// [statusDateElement] ("_statusDate") Extensions for statusDate
  @JsonKey(name: '_statusDate')
  Element? get statusDateElement => throw _privateConstructorUsedError;

  /// [containedItemQuantity] A total of the complete count of contained items of a particular type/form, independent of sub-packaging or organization. This can be considered as the pack size. This attribute differs from containedItem.amount in that it can give a single aggregated count of all tablet types in a pack, even when these are different manufactured items. For example a pill pack of 21 tablets plus 7 sugar tablets, can be denoted here as '28 tablets'. This attribute is repeatable so that the different item types in one pack type can be counted (e.g. a count of vials and count of syringes). Each repeat must have different units, so that it is clear what the different sets of counted items are, and it is not intended to allow different counts of similar items (e.g. not '2 tubes and 3 tubes'). Repeats are not to be used to represent different pack sizes (e.g. 20 pack vs. 50 pack) - which would be different instances of this resource.
  List<Quantity>? get containedItemQuantity =>
      throw _privateConstructorUsedError;

  /// [description] Textual description. Note that this is not the name of the package or product.
  Markdown? get description => throw _privateConstructorUsedError;

  /// [descriptionElement] ("_description") Extensions for description
  @JsonKey(name: '_description')
  Element? get descriptionElement => throw _privateConstructorUsedError;

  /// [legalStatusOfSupply] The legal status of supply of the packaged item as classified by the regulator.
  List<PackagedProductDefinitionLegalStatusOfSupply>? get legalStatusOfSupply =>
      throw _privateConstructorUsedError;

  /// [marketingStatus] Allows specifying that an item is on the market for sale, or that it is not available, and the dates and locations associated.
  List<MarketingStatus>? get marketingStatus =>
      throw _privateConstructorUsedError;

  /// [copackagedIndicator] Identifies if the package contains different items, such as when a drug product is supplied with another item e.g. a diluent or adjuvant.
  Boolean? get copackagedIndicator => throw _privateConstructorUsedError;

  /// [copackagedIndicatorElement] ("_copackagedIndicator") Extensions for copackagedIndicator
  @JsonKey(name: '_copackagedIndicator')
  Element? get copackagedIndicatorElement => throw _privateConstructorUsedError;

  /// [manufacturer] Manufacturer of this package type. When there are multiple it means these are all possible manufacturers.
  List<Reference>? get manufacturer => throw _privateConstructorUsedError;

  /// [attachedDocument] Additional information or supporting documentation about the packaged product.
  List<Reference>? get attachedDocument => throw _privateConstructorUsedError;

  /// [packaging] A packaging item, as a container for medically related items, possibly with other packaging items within, or a packaging component, such as bottle cap (which is not a device or a medication manufactured item).
  PackagedProductDefinitionPackaging? get packaging =>
      throw _privateConstructorUsedError;

  /// [characteristic] Allows the key features to be recorded, such as "hospital pack", "nurse prescribable", "calendar pack".
  List<PackagedProductDefinitionProperty>? get characteristic =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PackagedProductDefinitionCopyWith<PackagedProductDefinition> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PackagedProductDefinitionCopyWith<$Res> {
  factory $PackagedProductDefinitionCopyWith(PackagedProductDefinition value,
          $Res Function(PackagedProductDefinition) then) =
      _$PackagedProductDefinitionCopyWithImpl<$Res, PackagedProductDefinition>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.PackagedProductDefinition)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      String? name,
      @JsonKey(name: '_name')
          Element? nameElement,
      CodeableConcept? type,
      List<Reference>? packageFor,
      CodeableConcept? status,
      FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate')
          Element? statusDateElement,
      List<Quantity>? containedItemQuantity,
      Markdown? description,
      @JsonKey(name: '_description')
          Element? descriptionElement,
      List<PackagedProductDefinitionLegalStatusOfSupply>? legalStatusOfSupply,
      List<MarketingStatus>? marketingStatus,
      Boolean? copackagedIndicator,
      @JsonKey(name: '_copackagedIndicator')
          Element? copackagedIndicatorElement,
      List<Reference>? manufacturer,
      List<Reference>? attachedDocument,
      PackagedProductDefinitionPackaging? packaging,
      List<PackagedProductDefinitionProperty>? characteristic});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $ElementCopyWith<$Res>? get nameElement;
  $CodeableConceptCopyWith<$Res>? get type;
  $CodeableConceptCopyWith<$Res>? get status;
  $ElementCopyWith<$Res>? get statusDateElement;
  $ElementCopyWith<$Res>? get descriptionElement;
  $ElementCopyWith<$Res>? get copackagedIndicatorElement;
  $PackagedProductDefinitionPackagingCopyWith<$Res>? get packaging;
}

/// @nodoc
class _$PackagedProductDefinitionCopyWithImpl<$Res,
        $Val extends PackagedProductDefinition>
    implements $PackagedProductDefinitionCopyWith<$Res> {
  _$PackagedProductDefinitionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? type = freezed,
    Object? packageFor = freezed,
    Object? status = freezed,
    Object? statusDate = freezed,
    Object? statusDateElement = freezed,
    Object? containedItemQuantity = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? legalStatusOfSupply = freezed,
    Object? marketingStatus = freezed,
    Object? copackagedIndicator = freezed,
    Object? copackagedIndicatorElement = freezed,
    Object? manufacturer = freezed,
    Object? attachedDocument = freezed,
    Object? packaging = freezed,
    Object? characteristic = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      packageFor: freezed == packageFor
          ? _value.packageFor
          : packageFor // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      statusDate: freezed == statusDate
          ? _value.statusDate
          : statusDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      statusDateElement: freezed == statusDateElement
          ? _value.statusDateElement
          : statusDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      containedItemQuantity: freezed == containedItemQuantity
          ? _value.containedItemQuantity
          : containedItemQuantity // ignore: cast_nullable_to_non_nullable
              as List<Quantity>?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      legalStatusOfSupply: freezed == legalStatusOfSupply
          ? _value.legalStatusOfSupply
          : legalStatusOfSupply // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionLegalStatusOfSupply>?,
      marketingStatus: freezed == marketingStatus
          ? _value.marketingStatus
          : marketingStatus // ignore: cast_nullable_to_non_nullable
              as List<MarketingStatus>?,
      copackagedIndicator: freezed == copackagedIndicator
          ? _value.copackagedIndicator
          : copackagedIndicator // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      copackagedIndicatorElement: freezed == copackagedIndicatorElement
          ? _value.copackagedIndicatorElement
          : copackagedIndicatorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      manufacturer: freezed == manufacturer
          ? _value.manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      attachedDocument: freezed == attachedDocument
          ? _value.attachedDocument
          : attachedDocument // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      packaging: freezed == packaging
          ? _value.packaging
          : packaging // ignore: cast_nullable_to_non_nullable
              as PackagedProductDefinitionPackaging?,
      characteristic: freezed == characteristic
          ? _value.characteristic
          : characteristic // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionProperty>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get nameElement {
    if (_value.nameElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.nameElement!, (value) {
      return _then(_value.copyWith(nameElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusDateElement {
    if (_value.statusDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusDateElement!, (value) {
      return _then(_value.copyWith(statusDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get descriptionElement {
    if (_value.descriptionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.descriptionElement!, (value) {
      return _then(_value.copyWith(descriptionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get copackagedIndicatorElement {
    if (_value.copackagedIndicatorElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.copackagedIndicatorElement!, (value) {
      return _then(_value.copyWith(copackagedIndicatorElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PackagedProductDefinitionPackagingCopyWith<$Res>? get packaging {
    if (_value.packaging == null) {
      return null;
    }

    return $PackagedProductDefinitionPackagingCopyWith<$Res>(_value.packaging!,
        (value) {
      return _then(_value.copyWith(packaging: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_PackagedProductDefinitionCopyWith<$Res>
    implements $PackagedProductDefinitionCopyWith<$Res> {
  factory _$$_PackagedProductDefinitionCopyWith(
          _$_PackagedProductDefinition value,
          $Res Function(_$_PackagedProductDefinition) then) =
      __$$_PackagedProductDefinitionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.PackagedProductDefinition)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      String? name,
      @JsonKey(name: '_name')
          Element? nameElement,
      CodeableConcept? type,
      List<Reference>? packageFor,
      CodeableConcept? status,
      FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate')
          Element? statusDateElement,
      List<Quantity>? containedItemQuantity,
      Markdown? description,
      @JsonKey(name: '_description')
          Element? descriptionElement,
      List<PackagedProductDefinitionLegalStatusOfSupply>? legalStatusOfSupply,
      List<MarketingStatus>? marketingStatus,
      Boolean? copackagedIndicator,
      @JsonKey(name: '_copackagedIndicator')
          Element? copackagedIndicatorElement,
      List<Reference>? manufacturer,
      List<Reference>? attachedDocument,
      PackagedProductDefinitionPackaging? packaging,
      List<PackagedProductDefinitionProperty>? characteristic});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $ElementCopyWith<$Res>? get nameElement;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
  @override
  $ElementCopyWith<$Res>? get statusDateElement;
  @override
  $ElementCopyWith<$Res>? get descriptionElement;
  @override
  $ElementCopyWith<$Res>? get copackagedIndicatorElement;
  @override
  $PackagedProductDefinitionPackagingCopyWith<$Res>? get packaging;
}

/// @nodoc
class __$$_PackagedProductDefinitionCopyWithImpl<$Res>
    extends _$PackagedProductDefinitionCopyWithImpl<$Res,
        _$_PackagedProductDefinition>
    implements _$$_PackagedProductDefinitionCopyWith<$Res> {
  __$$_PackagedProductDefinitionCopyWithImpl(
      _$_PackagedProductDefinition _value,
      $Res Function(_$_PackagedProductDefinition) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? type = freezed,
    Object? packageFor = freezed,
    Object? status = freezed,
    Object? statusDate = freezed,
    Object? statusDateElement = freezed,
    Object? containedItemQuantity = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? legalStatusOfSupply = freezed,
    Object? marketingStatus = freezed,
    Object? copackagedIndicator = freezed,
    Object? copackagedIndicatorElement = freezed,
    Object? manufacturer = freezed,
    Object? attachedDocument = freezed,
    Object? packaging = freezed,
    Object? characteristic = freezed,
  }) {
    return _then(_$_PackagedProductDefinition(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      packageFor: freezed == packageFor
          ? _value._packageFor
          : packageFor // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      statusDate: freezed == statusDate
          ? _value.statusDate
          : statusDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      statusDateElement: freezed == statusDateElement
          ? _value.statusDateElement
          : statusDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      containedItemQuantity: freezed == containedItemQuantity
          ? _value._containedItemQuantity
          : containedItemQuantity // ignore: cast_nullable_to_non_nullable
              as List<Quantity>?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      legalStatusOfSupply: freezed == legalStatusOfSupply
          ? _value._legalStatusOfSupply
          : legalStatusOfSupply // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionLegalStatusOfSupply>?,
      marketingStatus: freezed == marketingStatus
          ? _value._marketingStatus
          : marketingStatus // ignore: cast_nullable_to_non_nullable
              as List<MarketingStatus>?,
      copackagedIndicator: freezed == copackagedIndicator
          ? _value.copackagedIndicator
          : copackagedIndicator // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      copackagedIndicatorElement: freezed == copackagedIndicatorElement
          ? _value.copackagedIndicatorElement
          : copackagedIndicatorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      manufacturer: freezed == manufacturer
          ? _value._manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      attachedDocument: freezed == attachedDocument
          ? _value._attachedDocument
          : attachedDocument // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      packaging: freezed == packaging
          ? _value.packaging
          : packaging // ignore: cast_nullable_to_non_nullable
              as PackagedProductDefinitionPackaging?,
      characteristic: freezed == characteristic
          ? _value._characteristic
          : characteristic // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionProperty>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PackagedProductDefinition extends _PackagedProductDefinition {
  _$_PackagedProductDefinition(
      {@JsonKey(unknownEnumValue: R5ResourceType.PackagedProductDefinition)
          this.resourceType = R5ResourceType.PackagedProductDefinition,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules')
          this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language')
          this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      this.name,
      @JsonKey(name: '_name')
          this.nameElement,
      this.type,
      final List<Reference>? packageFor,
      this.status,
      this.statusDate,
      @JsonKey(name: '_statusDate')
          this.statusDateElement,
      final List<Quantity>? containedItemQuantity,
      this.description,
      @JsonKey(name: '_description')
          this.descriptionElement,
      final List<PackagedProductDefinitionLegalStatusOfSupply>?
          legalStatusOfSupply,
      final List<MarketingStatus>? marketingStatus,
      this.copackagedIndicator,
      @JsonKey(name: '_copackagedIndicator')
          this.copackagedIndicatorElement,
      final List<Reference>? manufacturer,
      final List<Reference>? attachedDocument,
      this.packaging,
      final List<PackagedProductDefinitionProperty>? characteristic})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _packageFor = packageFor,
        _containedItemQuantity = containedItemQuantity,
        _legalStatusOfSupply = legalStatusOfSupply,
        _marketingStatus = marketingStatus,
        _manufacturer = manufacturer,
        _attachedDocument = attachedDocument,
        _characteristic = characteristic,
        super._();

  factory _$_PackagedProductDefinition.fromJson(Map<String, dynamic> json) =>
      _$$_PackagedProductDefinitionFromJson(json);

  /// [resourceType] This is a PackagedProductDefinition resource
  @override
  @JsonKey(unknownEnumValue: R5ResourceType.PackagedProductDefinition)
  final R5ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.
  @override
  final Code? language;

  /// [languageElement] ("_language") Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] A unique identifier for this package as whole - not the the content of the package. Unique instance identifiers assigned to a package by manufacturers, regulators, drug catalogue custodians or other organizations.
  final List<Identifier>? _identifier;

  /// [identifier] A unique identifier for this package as whole - not the the content of the package. Unique instance identifiers assigned to a package by manufacturers, regulators, drug catalogue custodians or other organizations.
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [name] A name for this package. Typically what it would be listed as in a drug formulary or catalogue, inventory etc.
  @override
  final String? name;

  /// [nameElement] ("_name") Extensions for name
  @override
  @JsonKey(name: '_name')
  final Element? nameElement;

  /// [type] A high level category e.g. medicinal product, raw material, shipping/transport container, etc.
  @override
  final CodeableConcept? type;

  /// [packageFor] The product this package model relates to, not the contents of the package (for which see package.containedItem).
  final List<Reference>? _packageFor;

  /// [packageFor] The product this package model relates to, not the contents of the package (for which see package.containedItem).
  @override
  List<Reference>? get packageFor {
    final value = _packageFor;
    if (value == null) return null;
    if (_packageFor is EqualUnmodifiableListView) return _packageFor;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [status] The status within the lifecycle of this item. A high level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization or marketing status.
  @override
  final CodeableConcept? status;

  /// [statusDate] The date at which the given status became applicable.
  @override
  final FhirDateTime? statusDate;

  /// [statusDateElement] ("_statusDate") Extensions for statusDate
  @override
  @JsonKey(name: '_statusDate')
  final Element? statusDateElement;

  /// [containedItemQuantity] A total of the complete count of contained items of a particular type/form, independent of sub-packaging or organization. This can be considered as the pack size. This attribute differs from containedItem.amount in that it can give a single aggregated count of all tablet types in a pack, even when these are different manufactured items. For example a pill pack of 21 tablets plus 7 sugar tablets, can be denoted here as '28 tablets'. This attribute is repeatable so that the different item types in one pack type can be counted (e.g. a count of vials and count of syringes). Each repeat must have different units, so that it is clear what the different sets of counted items are, and it is not intended to allow different counts of similar items (e.g. not '2 tubes and 3 tubes'). Repeats are not to be used to represent different pack sizes (e.g. 20 pack vs. 50 pack) - which would be different instances of this resource.
  final List<Quantity>? _containedItemQuantity;

  /// [containedItemQuantity] A total of the complete count of contained items of a particular type/form, independent of sub-packaging or organization. This can be considered as the pack size. This attribute differs from containedItem.amount in that it can give a single aggregated count of all tablet types in a pack, even when these are different manufactured items. For example a pill pack of 21 tablets plus 7 sugar tablets, can be denoted here as '28 tablets'. This attribute is repeatable so that the different item types in one pack type can be counted (e.g. a count of vials and count of syringes). Each repeat must have different units, so that it is clear what the different sets of counted items are, and it is not intended to allow different counts of similar items (e.g. not '2 tubes and 3 tubes'). Repeats are not to be used to represent different pack sizes (e.g. 20 pack vs. 50 pack) - which would be different instances of this resource.
  @override
  List<Quantity>? get containedItemQuantity {
    final value = _containedItemQuantity;
    if (value == null) return null;
    if (_containedItemQuantity is EqualUnmodifiableListView)
      return _containedItemQuantity;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [description] Textual description. Note that this is not the name of the package or product.
  @override
  final Markdown? description;

  /// [descriptionElement] ("_description") Extensions for description
  @override
  @JsonKey(name: '_description')
  final Element? descriptionElement;

  /// [legalStatusOfSupply] The legal status of supply of the packaged item as classified by the regulator.
  final List<PackagedProductDefinitionLegalStatusOfSupply>?
      _legalStatusOfSupply;

  /// [legalStatusOfSupply] The legal status of supply of the packaged item as classified by the regulator.
  @override
  List<PackagedProductDefinitionLegalStatusOfSupply>? get legalStatusOfSupply {
    final value = _legalStatusOfSupply;
    if (value == null) return null;
    if (_legalStatusOfSupply is EqualUnmodifiableListView)
      return _legalStatusOfSupply;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [marketingStatus] Allows specifying that an item is on the market for sale, or that it is not available, and the dates and locations associated.
  final List<MarketingStatus>? _marketingStatus;

  /// [marketingStatus] Allows specifying that an item is on the market for sale, or that it is not available, and the dates and locations associated.
  @override
  List<MarketingStatus>? get marketingStatus {
    final value = _marketingStatus;
    if (value == null) return null;
    if (_marketingStatus is EqualUnmodifiableListView) return _marketingStatus;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [copackagedIndicator] Identifies if the package contains different items, such as when a drug product is supplied with another item e.g. a diluent or adjuvant.
  @override
  final Boolean? copackagedIndicator;

  /// [copackagedIndicatorElement] ("_copackagedIndicator") Extensions for copackagedIndicator
  @override
  @JsonKey(name: '_copackagedIndicator')
  final Element? copackagedIndicatorElement;

  /// [manufacturer] Manufacturer of this package type. When there are multiple it means these are all possible manufacturers.
  final List<Reference>? _manufacturer;

  /// [manufacturer] Manufacturer of this package type. When there are multiple it means these are all possible manufacturers.
  @override
  List<Reference>? get manufacturer {
    final value = _manufacturer;
    if (value == null) return null;
    if (_manufacturer is EqualUnmodifiableListView) return _manufacturer;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [attachedDocument] Additional information or supporting documentation about the packaged product.
  final List<Reference>? _attachedDocument;

  /// [attachedDocument] Additional information or supporting documentation about the packaged product.
  @override
  List<Reference>? get attachedDocument {
    final value = _attachedDocument;
    if (value == null) return null;
    if (_attachedDocument is EqualUnmodifiableListView)
      return _attachedDocument;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [packaging] A packaging item, as a container for medically related items, possibly with other packaging items within, or a packaging component, such as bottle cap (which is not a device or a medication manufactured item).
  @override
  final PackagedProductDefinitionPackaging? packaging;

  /// [characteristic] Allows the key features to be recorded, such as "hospital pack", "nurse prescribable", "calendar pack".
  final List<PackagedProductDefinitionProperty>? _characteristic;

  /// [characteristic] Allows the key features to be recorded, such as "hospital pack", "nurse prescribable", "calendar pack".
  @override
  List<PackagedProductDefinitionProperty>? get characteristic {
    final value = _characteristic;
    if (value == null) return null;
    if (_characteristic is EqualUnmodifiableListView) return _characteristic;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'PackagedProductDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, name: $name, nameElement: $nameElement, type: $type, packageFor: $packageFor, status: $status, statusDate: $statusDate, statusDateElement: $statusDateElement, containedItemQuantity: $containedItemQuantity, description: $description, descriptionElement: $descriptionElement, legalStatusOfSupply: $legalStatusOfSupply, marketingStatus: $marketingStatus, copackagedIndicator: $copackagedIndicator, copackagedIndicatorElement: $copackagedIndicatorElement, manufacturer: $manufacturer, attachedDocument: $attachedDocument, packaging: $packaging, characteristic: $characteristic)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PackagedProductDefinition &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.nameElement, nameElement) ||
                other.nameElement == nameElement) &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality()
                .equals(other._packageFor, _packageFor) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusDate, statusDate) ||
                other.statusDate == statusDate) &&
            (identical(other.statusDateElement, statusDateElement) ||
                other.statusDateElement == statusDateElement) &&
            const DeepCollectionEquality()
                .equals(other._containedItemQuantity, _containedItemQuantity) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.descriptionElement, descriptionElement) ||
                other.descriptionElement == descriptionElement) &&
            const DeepCollectionEquality()
                .equals(other._legalStatusOfSupply, _legalStatusOfSupply) &&
            const DeepCollectionEquality()
                .equals(other._marketingStatus, _marketingStatus) &&
            (identical(other.copackagedIndicator, copackagedIndicator) ||
                other.copackagedIndicator == copackagedIndicator) &&
            (identical(other.copackagedIndicatorElement,
                    copackagedIndicatorElement) ||
                other.copackagedIndicatorElement ==
                    copackagedIndicatorElement) &&
            const DeepCollectionEquality()
                .equals(other._manufacturer, _manufacturer) &&
            const DeepCollectionEquality()
                .equals(other._attachedDocument, _attachedDocument) &&
            (identical(other.packaging, packaging) ||
                other.packaging == packaging) &&
            const DeepCollectionEquality()
                .equals(other._characteristic, _characteristic));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_identifier),
        name,
        nameElement,
        type,
        const DeepCollectionEquality().hash(_packageFor),
        status,
        statusDate,
        statusDateElement,
        const DeepCollectionEquality().hash(_containedItemQuantity),
        description,
        descriptionElement,
        const DeepCollectionEquality().hash(_legalStatusOfSupply),
        const DeepCollectionEquality().hash(_marketingStatus),
        copackagedIndicator,
        copackagedIndicatorElement,
        const DeepCollectionEquality().hash(_manufacturer),
        const DeepCollectionEquality().hash(_attachedDocument),
        packaging,
        const DeepCollectionEquality().hash(_characteristic)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PackagedProductDefinitionCopyWith<_$_PackagedProductDefinition>
      get copyWith => __$$_PackagedProductDefinitionCopyWithImpl<
          _$_PackagedProductDefinition>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PackagedProductDefinitionToJson(
      this,
    );
  }
}

abstract class _PackagedProductDefinition extends PackagedProductDefinition {
  factory _PackagedProductDefinition(
          {@JsonKey(unknownEnumValue: R5ResourceType.PackagedProductDefinition)
              final R5ResourceType resourceType,
          final FhirId? id,
          final Meta? meta,
          final FhirUri? implicitRules,
          @JsonKey(name: '_implicitRules')
              final Element? implicitRulesElement,
          final Code? language,
          @JsonKey(name: '_language')
              final Element? languageElement,
          final Narrative? text,
          final List<Resource>? contained,
          @JsonKey(name: 'extension')
              final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final List<Identifier>? identifier,
          final String? name,
          @JsonKey(name: '_name')
              final Element? nameElement,
          final CodeableConcept? type,
          final List<Reference>? packageFor,
          final CodeableConcept? status,
          final FhirDateTime? statusDate,
          @JsonKey(name: '_statusDate')
              final Element? statusDateElement,
          final List<Quantity>? containedItemQuantity,
          final Markdown? description,
          @JsonKey(name: '_description')
              final Element? descriptionElement,
          final List<PackagedProductDefinitionLegalStatusOfSupply>?
              legalStatusOfSupply,
          final List<MarketingStatus>? marketingStatus,
          final Boolean? copackagedIndicator,
          @JsonKey(name: '_copackagedIndicator')
              final Element? copackagedIndicatorElement,
          final List<Reference>? manufacturer,
          final List<Reference>? attachedDocument,
          final PackagedProductDefinitionPackaging? packaging,
          final List<PackagedProductDefinitionProperty>? characteristic}) =
      _$_PackagedProductDefinition;
  _PackagedProductDefinition._() : super._();

  factory _PackagedProductDefinition.fromJson(Map<String, dynamic> json) =
      _$_PackagedProductDefinition.fromJson;

  @override

  /// [resourceType] This is a PackagedProductDefinition resource
  @JsonKey(unknownEnumValue: R5ResourceType.PackagedProductDefinition)
  R5ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.
  Code? get language;
  @override

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained;
  @override

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] A unique identifier for this package as whole - not the the content of the package. Unique instance identifiers assigned to a package by manufacturers, regulators, drug catalogue custodians or other organizations.
  List<Identifier>? get identifier;
  @override

  /// [name] A name for this package. Typically what it would be listed as in a drug formulary or catalogue, inventory etc.
  String? get name;
  @override

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement;
  @override

  /// [type] A high level category e.g. medicinal product, raw material, shipping/transport container, etc.
  CodeableConcept? get type;
  @override

  /// [packageFor] The product this package model relates to, not the contents of the package (for which see package.containedItem).
  List<Reference>? get packageFor;
  @override

  /// [status] The status within the lifecycle of this item. A high level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization or marketing status.
  CodeableConcept? get status;
  @override

  /// [statusDate] The date at which the given status became applicable.
  FhirDateTime? get statusDate;
  @override

  /// [statusDateElement] ("_statusDate") Extensions for statusDate
  @JsonKey(name: '_statusDate')
  Element? get statusDateElement;
  @override

  /// [containedItemQuantity] A total of the complete count of contained items of a particular type/form, independent of sub-packaging or organization. This can be considered as the pack size. This attribute differs from containedItem.amount in that it can give a single aggregated count of all tablet types in a pack, even when these are different manufactured items. For example a pill pack of 21 tablets plus 7 sugar tablets, can be denoted here as '28 tablets'. This attribute is repeatable so that the different item types in one pack type can be counted (e.g. a count of vials and count of syringes). Each repeat must have different units, so that it is clear what the different sets of counted items are, and it is not intended to allow different counts of similar items (e.g. not '2 tubes and 3 tubes'). Repeats are not to be used to represent different pack sizes (e.g. 20 pack vs. 50 pack) - which would be different instances of this resource.
  List<Quantity>? get containedItemQuantity;
  @override

  /// [description] Textual description. Note that this is not the name of the package or product.
  Markdown? get description;
  @override

  /// [descriptionElement] ("_description") Extensions for description
  @JsonKey(name: '_description')
  Element? get descriptionElement;
  @override

  /// [legalStatusOfSupply] The legal status of supply of the packaged item as classified by the regulator.
  List<PackagedProductDefinitionLegalStatusOfSupply>? get legalStatusOfSupply;
  @override

  /// [marketingStatus] Allows specifying that an item is on the market for sale, or that it is not available, and the dates and locations associated.
  List<MarketingStatus>? get marketingStatus;
  @override

  /// [copackagedIndicator] Identifies if the package contains different items, such as when a drug product is supplied with another item e.g. a diluent or adjuvant.
  Boolean? get copackagedIndicator;
  @override

  /// [copackagedIndicatorElement] ("_copackagedIndicator") Extensions for copackagedIndicator
  @JsonKey(name: '_copackagedIndicator')
  Element? get copackagedIndicatorElement;
  @override

  /// [manufacturer] Manufacturer of this package type. When there are multiple it means these are all possible manufacturers.
  List<Reference>? get manufacturer;
  @override

  /// [attachedDocument] Additional information or supporting documentation about the packaged product.
  List<Reference>? get attachedDocument;
  @override

  /// [packaging] A packaging item, as a container for medically related items, possibly with other packaging items within, or a packaging component, such as bottle cap (which is not a device or a medication manufactured item).
  PackagedProductDefinitionPackaging? get packaging;
  @override

  /// [characteristic] Allows the key features to be recorded, such as "hospital pack", "nurse prescribable", "calendar pack".
  List<PackagedProductDefinitionProperty>? get characteristic;
  @override
  @JsonKey(ignore: true)
  _$$_PackagedProductDefinitionCopyWith<_$_PackagedProductDefinition>
      get copyWith => throw _privateConstructorUsedError;
}

PackagedProductDefinitionLegalStatusOfSupply
    _$PackagedProductDefinitionLegalStatusOfSupplyFromJson(
        Map<String, dynamic> json) {
  return _PackagedProductDefinitionLegalStatusOfSupply.fromJson(json);
}

/// @nodoc
mixin _$PackagedProductDefinitionLegalStatusOfSupply {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [code] The actual status of supply. Conveys in what situation this package type may be supplied for use.
  CodeableConcept? get code => throw _privateConstructorUsedError;

  /// [jurisdiction] The place where the legal status of supply applies. When not specified, this indicates it is unknown in this context.
  CodeableConcept? get jurisdiction => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PackagedProductDefinitionLegalStatusOfSupplyCopyWith<
          PackagedProductDefinitionLegalStatusOfSupply>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PackagedProductDefinitionLegalStatusOfSupplyCopyWith<$Res> {
  factory $PackagedProductDefinitionLegalStatusOfSupplyCopyWith(
          PackagedProductDefinitionLegalStatusOfSupply value,
          $Res Function(PackagedProductDefinitionLegalStatusOfSupply) then) =
      _$PackagedProductDefinitionLegalStatusOfSupplyCopyWithImpl<$Res,
          PackagedProductDefinitionLegalStatusOfSupply>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? code,
      CodeableConcept? jurisdiction});

  $CodeableConceptCopyWith<$Res>? get code;
  $CodeableConceptCopyWith<$Res>? get jurisdiction;
}

/// @nodoc
class _$PackagedProductDefinitionLegalStatusOfSupplyCopyWithImpl<$Res,
        $Val extends PackagedProductDefinitionLegalStatusOfSupply>
    implements $PackagedProductDefinitionLegalStatusOfSupplyCopyWith<$Res> {
  _$PackagedProductDefinitionLegalStatusOfSupplyCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = freezed,
    Object? jurisdiction = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      jurisdiction: freezed == jurisdiction
          ? _value.jurisdiction
          : jurisdiction // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get code {
    if (_value.code == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.code!, (value) {
      return _then(_value.copyWith(code: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get jurisdiction {
    if (_value.jurisdiction == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.jurisdiction!, (value) {
      return _then(_value.copyWith(jurisdiction: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_PackagedProductDefinitionLegalStatusOfSupplyCopyWith<$Res>
    implements $PackagedProductDefinitionLegalStatusOfSupplyCopyWith<$Res> {
  factory _$$_PackagedProductDefinitionLegalStatusOfSupplyCopyWith(
          _$_PackagedProductDefinitionLegalStatusOfSupply value,
          $Res Function(_$_PackagedProductDefinitionLegalStatusOfSupply) then) =
      __$$_PackagedProductDefinitionLegalStatusOfSupplyCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? code,
      CodeableConcept? jurisdiction});

  @override
  $CodeableConceptCopyWith<$Res>? get code;
  @override
  $CodeableConceptCopyWith<$Res>? get jurisdiction;
}

/// @nodoc
class __$$_PackagedProductDefinitionLegalStatusOfSupplyCopyWithImpl<$Res>
    extends _$PackagedProductDefinitionLegalStatusOfSupplyCopyWithImpl<$Res,
        _$_PackagedProductDefinitionLegalStatusOfSupply>
    implements _$$_PackagedProductDefinitionLegalStatusOfSupplyCopyWith<$Res> {
  __$$_PackagedProductDefinitionLegalStatusOfSupplyCopyWithImpl(
      _$_PackagedProductDefinitionLegalStatusOfSupply _value,
      $Res Function(_$_PackagedProductDefinitionLegalStatusOfSupply) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = freezed,
    Object? jurisdiction = freezed,
  }) {
    return _then(_$_PackagedProductDefinitionLegalStatusOfSupply(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      jurisdiction: freezed == jurisdiction
          ? _value.jurisdiction
          : jurisdiction // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PackagedProductDefinitionLegalStatusOfSupply
    extends _PackagedProductDefinitionLegalStatusOfSupply {
  _$_PackagedProductDefinitionLegalStatusOfSupply(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.code,
      this.jurisdiction})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_PackagedProductDefinitionLegalStatusOfSupply.fromJson(
          Map<String, dynamic> json) =>
      _$$_PackagedProductDefinitionLegalStatusOfSupplyFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [code] The actual status of supply. Conveys in what situation this package type may be supplied for use.
  @override
  final CodeableConcept? code;

  /// [jurisdiction] The place where the legal status of supply applies. When not specified, this indicates it is unknown in this context.
  @override
  final CodeableConcept? jurisdiction;

  @override
  String toString() {
    return 'PackagedProductDefinitionLegalStatusOfSupply(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, jurisdiction: $jurisdiction)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PackagedProductDefinitionLegalStatusOfSupply &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.jurisdiction, jurisdiction) ||
                other.jurisdiction == jurisdiction));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      code,
      jurisdiction);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PackagedProductDefinitionLegalStatusOfSupplyCopyWith<
          _$_PackagedProductDefinitionLegalStatusOfSupply>
      get copyWith =>
          __$$_PackagedProductDefinitionLegalStatusOfSupplyCopyWithImpl<
                  _$_PackagedProductDefinitionLegalStatusOfSupply>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PackagedProductDefinitionLegalStatusOfSupplyToJson(
      this,
    );
  }
}

abstract class _PackagedProductDefinitionLegalStatusOfSupply
    extends PackagedProductDefinitionLegalStatusOfSupply {
  factory _PackagedProductDefinitionLegalStatusOfSupply(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableConcept? code,
          final CodeableConcept? jurisdiction}) =
      _$_PackagedProductDefinitionLegalStatusOfSupply;
  _PackagedProductDefinitionLegalStatusOfSupply._() : super._();

  factory _PackagedProductDefinitionLegalStatusOfSupply.fromJson(
          Map<String, dynamic> json) =
      _$_PackagedProductDefinitionLegalStatusOfSupply.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [code] The actual status of supply. Conveys in what situation this package type may be supplied for use.
  CodeableConcept? get code;
  @override

  /// [jurisdiction] The place where the legal status of supply applies. When not specified, this indicates it is unknown in this context.
  CodeableConcept? get jurisdiction;
  @override
  @JsonKey(ignore: true)
  _$$_PackagedProductDefinitionLegalStatusOfSupplyCopyWith<
          _$_PackagedProductDefinitionLegalStatusOfSupply>
      get copyWith => throw _privateConstructorUsedError;
}

PackagedProductDefinitionPackaging _$PackagedProductDefinitionPackagingFromJson(
    Map<String, dynamic> json) {
  return _PackagedProductDefinitionPackaging.fromJson(json);
}

/// @nodoc
mixin _$PackagedProductDefinitionPackaging {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] A business identifier that is specific to this particular part of the packaging, often assigned by the manufacturer. Including possibly Data Carrier Identifier (a GS1 barcode).
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [type] The physical type of the container of the items.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [componentPart] Is this a part of the packaging (e.g. a cap or bottle stopper), rather than the packaging itself (e.g. a bottle or vial). The latter type are designed be a container, but the former are not.
  Boolean? get componentPart => throw _privateConstructorUsedError;

  /// [componentPartElement] ("_componentPart") Extensions for componentPart
  @JsonKey(name: '_componentPart')
  Element? get componentPartElement => throw _privateConstructorUsedError;

  /// [quantity] The quantity of packaging items contained at this layer of the package. This does not relate to the number of contained items but relates solely to the number of packaging items. When looking at the outermost layer it is always 1. If there are two boxes within, at the next layer it would be 2.
  Integer? get quantity => throw _privateConstructorUsedError;

  /// [quantityElement] ("_quantity") Extensions for quantity
  @JsonKey(name: '_quantity')
  Element? get quantityElement => throw _privateConstructorUsedError;

  /// [material] Material type of the package item.
  List<CodeableConcept>? get material => throw _privateConstructorUsedError;

  /// [alternateMaterial] A possible alternate material for this part of the packaging, that is allowed to be used instead of the usual material (e.g. different types of plastic for a blister sleeve).
  List<CodeableConcept>? get alternateMaterial =>
      throw _privateConstructorUsedError;

  /// [shelfLifeStorage] Shelf Life and storage information.
  List<ProductShelfLife>? get shelfLifeStorage =>
      throw _privateConstructorUsedError;

  /// [manufacturer] Manufacturer of this packaging item. When there are multiple values each one is a potential manufacturer of this packaging item.
  List<Reference>? get manufacturer => throw _privateConstructorUsedError;

  /// [property] General characteristics of this item.
  List<PackagedProductDefinitionProperty>? get property =>
      throw _privateConstructorUsedError;

  /// [containedItem] The item(s) within the packaging.
  List<PackagedProductDefinitionContainedItem>? get containedItem =>
      throw _privateConstructorUsedError;

  /// [packaging] Allows containers (and parts of containers) within containers, still as a part of a single packaged product. See also PackagedProductDefinition.packaging.containedItem.item(PackagedProductDefinition).
  List<PackagedProductDefinitionPackaging>? get packaging =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PackagedProductDefinitionPackagingCopyWith<
          PackagedProductDefinitionPackaging>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PackagedProductDefinitionPackagingCopyWith<$Res> {
  factory $PackagedProductDefinitionPackagingCopyWith(
          PackagedProductDefinitionPackaging value,
          $Res Function(PackagedProductDefinitionPackaging) then) =
      _$PackagedProductDefinitionPackagingCopyWithImpl<$Res,
          PackagedProductDefinitionPackaging>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      CodeableConcept? type,
      Boolean? componentPart,
      @JsonKey(name: '_componentPart') Element? componentPartElement,
      Integer? quantity,
      @JsonKey(name: '_quantity') Element? quantityElement,
      List<CodeableConcept>? material,
      List<CodeableConcept>? alternateMaterial,
      List<ProductShelfLife>? shelfLifeStorage,
      List<Reference>? manufacturer,
      List<PackagedProductDefinitionProperty>? property,
      List<PackagedProductDefinitionContainedItem>? containedItem,
      List<PackagedProductDefinitionPackaging>? packaging});

  $CodeableConceptCopyWith<$Res>? get type;
  $ElementCopyWith<$Res>? get componentPartElement;
  $ElementCopyWith<$Res>? get quantityElement;
}

/// @nodoc
class _$PackagedProductDefinitionPackagingCopyWithImpl<$Res,
        $Val extends PackagedProductDefinitionPackaging>
    implements $PackagedProductDefinitionPackagingCopyWith<$Res> {
  _$PackagedProductDefinitionPackagingCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = freezed,
    Object? componentPart = freezed,
    Object? componentPartElement = freezed,
    Object? quantity = freezed,
    Object? quantityElement = freezed,
    Object? material = freezed,
    Object? alternateMaterial = freezed,
    Object? shelfLifeStorage = freezed,
    Object? manufacturer = freezed,
    Object? property = freezed,
    Object? containedItem = freezed,
    Object? packaging = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      componentPart: freezed == componentPart
          ? _value.componentPart
          : componentPart // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      componentPartElement: freezed == componentPartElement
          ? _value.componentPartElement
          : componentPartElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Integer?,
      quantityElement: freezed == quantityElement
          ? _value.quantityElement
          : quantityElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      material: freezed == material
          ? _value.material
          : material // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      alternateMaterial: freezed == alternateMaterial
          ? _value.alternateMaterial
          : alternateMaterial // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      shelfLifeStorage: freezed == shelfLifeStorage
          ? _value.shelfLifeStorage
          : shelfLifeStorage // ignore: cast_nullable_to_non_nullable
              as List<ProductShelfLife>?,
      manufacturer: freezed == manufacturer
          ? _value.manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      property: freezed == property
          ? _value.property
          : property // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionProperty>?,
      containedItem: freezed == containedItem
          ? _value.containedItem
          : containedItem // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionContainedItem>?,
      packaging: freezed == packaging
          ? _value.packaging
          : packaging // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionPackaging>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get componentPartElement {
    if (_value.componentPartElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.componentPartElement!, (value) {
      return _then(_value.copyWith(componentPartElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get quantityElement {
    if (_value.quantityElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.quantityElement!, (value) {
      return _then(_value.copyWith(quantityElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_PackagedProductDefinitionPackagingCopyWith<$Res>
    implements $PackagedProductDefinitionPackagingCopyWith<$Res> {
  factory _$$_PackagedProductDefinitionPackagingCopyWith(
          _$_PackagedProductDefinitionPackaging value,
          $Res Function(_$_PackagedProductDefinitionPackaging) then) =
      __$$_PackagedProductDefinitionPackagingCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      CodeableConcept? type,
      Boolean? componentPart,
      @JsonKey(name: '_componentPart') Element? componentPartElement,
      Integer? quantity,
      @JsonKey(name: '_quantity') Element? quantityElement,
      List<CodeableConcept>? material,
      List<CodeableConcept>? alternateMaterial,
      List<ProductShelfLife>? shelfLifeStorage,
      List<Reference>? manufacturer,
      List<PackagedProductDefinitionProperty>? property,
      List<PackagedProductDefinitionContainedItem>? containedItem,
      List<PackagedProductDefinitionPackaging>? packaging});

  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $ElementCopyWith<$Res>? get componentPartElement;
  @override
  $ElementCopyWith<$Res>? get quantityElement;
}

/// @nodoc
class __$$_PackagedProductDefinitionPackagingCopyWithImpl<$Res>
    extends _$PackagedProductDefinitionPackagingCopyWithImpl<$Res,
        _$_PackagedProductDefinitionPackaging>
    implements _$$_PackagedProductDefinitionPackagingCopyWith<$Res> {
  __$$_PackagedProductDefinitionPackagingCopyWithImpl(
      _$_PackagedProductDefinitionPackaging _value,
      $Res Function(_$_PackagedProductDefinitionPackaging) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = freezed,
    Object? componentPart = freezed,
    Object? componentPartElement = freezed,
    Object? quantity = freezed,
    Object? quantityElement = freezed,
    Object? material = freezed,
    Object? alternateMaterial = freezed,
    Object? shelfLifeStorage = freezed,
    Object? manufacturer = freezed,
    Object? property = freezed,
    Object? containedItem = freezed,
    Object? packaging = freezed,
  }) {
    return _then(_$_PackagedProductDefinitionPackaging(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      componentPart: freezed == componentPart
          ? _value.componentPart
          : componentPart // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      componentPartElement: freezed == componentPartElement
          ? _value.componentPartElement
          : componentPartElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Integer?,
      quantityElement: freezed == quantityElement
          ? _value.quantityElement
          : quantityElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      material: freezed == material
          ? _value._material
          : material // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      alternateMaterial: freezed == alternateMaterial
          ? _value._alternateMaterial
          : alternateMaterial // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      shelfLifeStorage: freezed == shelfLifeStorage
          ? _value._shelfLifeStorage
          : shelfLifeStorage // ignore: cast_nullable_to_non_nullable
              as List<ProductShelfLife>?,
      manufacturer: freezed == manufacturer
          ? _value._manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      property: freezed == property
          ? _value._property
          : property // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionProperty>?,
      containedItem: freezed == containedItem
          ? _value._containedItem
          : containedItem // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionContainedItem>?,
      packaging: freezed == packaging
          ? _value._packaging
          : packaging // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionPackaging>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PackagedProductDefinitionPackaging
    extends _PackagedProductDefinitionPackaging {
  _$_PackagedProductDefinitionPackaging(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      this.type,
      this.componentPart,
      @JsonKey(name: '_componentPart') this.componentPartElement,
      this.quantity,
      @JsonKey(name: '_quantity') this.quantityElement,
      final List<CodeableConcept>? material,
      final List<CodeableConcept>? alternateMaterial,
      final List<ProductShelfLife>? shelfLifeStorage,
      final List<Reference>? manufacturer,
      final List<PackagedProductDefinitionProperty>? property,
      final List<PackagedProductDefinitionContainedItem>? containedItem,
      final List<PackagedProductDefinitionPackaging>? packaging})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _material = material,
        _alternateMaterial = alternateMaterial,
        _shelfLifeStorage = shelfLifeStorage,
        _manufacturer = manufacturer,
        _property = property,
        _containedItem = containedItem,
        _packaging = packaging,
        super._();

  factory _$_PackagedProductDefinitionPackaging.fromJson(
          Map<String, dynamic> json) =>
      _$$_PackagedProductDefinitionPackagingFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] A business identifier that is specific to this particular part of the packaging, often assigned by the manufacturer. Including possibly Data Carrier Identifier (a GS1 barcode).
  final List<Identifier>? _identifier;

  /// [identifier] A business identifier that is specific to this particular part of the packaging, often assigned by the manufacturer. Including possibly Data Carrier Identifier (a GS1 barcode).
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] The physical type of the container of the items.
  @override
  final CodeableConcept? type;

  /// [componentPart] Is this a part of the packaging (e.g. a cap or bottle stopper), rather than the packaging itself (e.g. a bottle or vial). The latter type are designed be a container, but the former are not.
  @override
  final Boolean? componentPart;

  /// [componentPartElement] ("_componentPart") Extensions for componentPart
  @override
  @JsonKey(name: '_componentPart')
  final Element? componentPartElement;

  /// [quantity] The quantity of packaging items contained at this layer of the package. This does not relate to the number of contained items but relates solely to the number of packaging items. When looking at the outermost layer it is always 1. If there are two boxes within, at the next layer it would be 2.
  @override
  final Integer? quantity;

  /// [quantityElement] ("_quantity") Extensions for quantity
  @override
  @JsonKey(name: '_quantity')
  final Element? quantityElement;

  /// [material] Material type of the package item.
  final List<CodeableConcept>? _material;

  /// [material] Material type of the package item.
  @override
  List<CodeableConcept>? get material {
    final value = _material;
    if (value == null) return null;
    if (_material is EqualUnmodifiableListView) return _material;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [alternateMaterial] A possible alternate material for this part of the packaging, that is allowed to be used instead of the usual material (e.g. different types of plastic for a blister sleeve).
  final List<CodeableConcept>? _alternateMaterial;

  /// [alternateMaterial] A possible alternate material for this part of the packaging, that is allowed to be used instead of the usual material (e.g. different types of plastic for a blister sleeve).
  @override
  List<CodeableConcept>? get alternateMaterial {
    final value = _alternateMaterial;
    if (value == null) return null;
    if (_alternateMaterial is EqualUnmodifiableListView)
      return _alternateMaterial;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [shelfLifeStorage] Shelf Life and storage information.
  final List<ProductShelfLife>? _shelfLifeStorage;

  /// [shelfLifeStorage] Shelf Life and storage information.
  @override
  List<ProductShelfLife>? get shelfLifeStorage {
    final value = _shelfLifeStorage;
    if (value == null) return null;
    if (_shelfLifeStorage is EqualUnmodifiableListView)
      return _shelfLifeStorage;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [manufacturer] Manufacturer of this packaging item. When there are multiple values each one is a potential manufacturer of this packaging item.
  final List<Reference>? _manufacturer;

  /// [manufacturer] Manufacturer of this packaging item. When there are multiple values each one is a potential manufacturer of this packaging item.
  @override
  List<Reference>? get manufacturer {
    final value = _manufacturer;
    if (value == null) return null;
    if (_manufacturer is EqualUnmodifiableListView) return _manufacturer;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [property] General characteristics of this item.
  final List<PackagedProductDefinitionProperty>? _property;

  /// [property] General characteristics of this item.
  @override
  List<PackagedProductDefinitionProperty>? get property {
    final value = _property;
    if (value == null) return null;
    if (_property is EqualUnmodifiableListView) return _property;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [containedItem] The item(s) within the packaging.
  final List<PackagedProductDefinitionContainedItem>? _containedItem;

  /// [containedItem] The item(s) within the packaging.
  @override
  List<PackagedProductDefinitionContainedItem>? get containedItem {
    final value = _containedItem;
    if (value == null) return null;
    if (_containedItem is EqualUnmodifiableListView) return _containedItem;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [packaging] Allows containers (and parts of containers) within containers, still as a part of a single packaged product. See also PackagedProductDefinition.packaging.containedItem.item(PackagedProductDefinition).
  final List<PackagedProductDefinitionPackaging>? _packaging;

  /// [packaging] Allows containers (and parts of containers) within containers, still as a part of a single packaged product. See also PackagedProductDefinition.packaging.containedItem.item(PackagedProductDefinition).
  @override
  List<PackagedProductDefinitionPackaging>? get packaging {
    final value = _packaging;
    if (value == null) return null;
    if (_packaging is EqualUnmodifiableListView) return _packaging;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'PackagedProductDefinitionPackaging(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, type: $type, componentPart: $componentPart, componentPartElement: $componentPartElement, quantity: $quantity, quantityElement: $quantityElement, material: $material, alternateMaterial: $alternateMaterial, shelfLifeStorage: $shelfLifeStorage, manufacturer: $manufacturer, property: $property, containedItem: $containedItem, packaging: $packaging)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PackagedProductDefinitionPackaging &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.componentPart, componentPart) ||
                other.componentPart == componentPart) &&
            (identical(other.componentPartElement, componentPartElement) ||
                other.componentPartElement == componentPartElement) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            (identical(other.quantityElement, quantityElement) ||
                other.quantityElement == quantityElement) &&
            const DeepCollectionEquality().equals(other._material, _material) &&
            const DeepCollectionEquality()
                .equals(other._alternateMaterial, _alternateMaterial) &&
            const DeepCollectionEquality()
                .equals(other._shelfLifeStorage, _shelfLifeStorage) &&
            const DeepCollectionEquality()
                .equals(other._manufacturer, _manufacturer) &&
            const DeepCollectionEquality().equals(other._property, _property) &&
            const DeepCollectionEquality()
                .equals(other._containedItem, _containedItem) &&
            const DeepCollectionEquality()
                .equals(other._packaging, _packaging));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      const DeepCollectionEquality().hash(_identifier),
      type,
      componentPart,
      componentPartElement,
      quantity,
      quantityElement,
      const DeepCollectionEquality().hash(_material),
      const DeepCollectionEquality().hash(_alternateMaterial),
      const DeepCollectionEquality().hash(_shelfLifeStorage),
      const DeepCollectionEquality().hash(_manufacturer),
      const DeepCollectionEquality().hash(_property),
      const DeepCollectionEquality().hash(_containedItem),
      const DeepCollectionEquality().hash(_packaging));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PackagedProductDefinitionPackagingCopyWith<
          _$_PackagedProductDefinitionPackaging>
      get copyWith => __$$_PackagedProductDefinitionPackagingCopyWithImpl<
          _$_PackagedProductDefinitionPackaging>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PackagedProductDefinitionPackagingToJson(
      this,
    );
  }
}

abstract class _PackagedProductDefinitionPackaging
    extends PackagedProductDefinitionPackaging {
  factory _PackagedProductDefinitionPackaging(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final List<Identifier>? identifier,
          final CodeableConcept? type,
          final Boolean? componentPart,
          @JsonKey(name: '_componentPart') final Element? componentPartElement,
          final Integer? quantity,
          @JsonKey(name: '_quantity') final Element? quantityElement,
          final List<CodeableConcept>? material,
          final List<CodeableConcept>? alternateMaterial,
          final List<ProductShelfLife>? shelfLifeStorage,
          final List<Reference>? manufacturer,
          final List<PackagedProductDefinitionProperty>? property,
          final List<PackagedProductDefinitionContainedItem>? containedItem,
          final List<PackagedProductDefinitionPackaging>? packaging}) =
      _$_PackagedProductDefinitionPackaging;
  _PackagedProductDefinitionPackaging._() : super._();

  factory _PackagedProductDefinitionPackaging.fromJson(
          Map<String, dynamic> json) =
      _$_PackagedProductDefinitionPackaging.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] A business identifier that is specific to this particular part of the packaging, often assigned by the manufacturer. Including possibly Data Carrier Identifier (a GS1 barcode).
  List<Identifier>? get identifier;
  @override

  /// [type] The physical type of the container of the items.
  CodeableConcept? get type;
  @override

  /// [componentPart] Is this a part of the packaging (e.g. a cap or bottle stopper), rather than the packaging itself (e.g. a bottle or vial). The latter type are designed be a container, but the former are not.
  Boolean? get componentPart;
  @override

  /// [componentPartElement] ("_componentPart") Extensions for componentPart
  @JsonKey(name: '_componentPart')
  Element? get componentPartElement;
  @override

  /// [quantity] The quantity of packaging items contained at this layer of the package. This does not relate to the number of contained items but relates solely to the number of packaging items. When looking at the outermost layer it is always 1. If there are two boxes within, at the next layer it would be 2.
  Integer? get quantity;
  @override

  /// [quantityElement] ("_quantity") Extensions for quantity
  @JsonKey(name: '_quantity')
  Element? get quantityElement;
  @override

  /// [material] Material type of the package item.
  List<CodeableConcept>? get material;
  @override

  /// [alternateMaterial] A possible alternate material for this part of the packaging, that is allowed to be used instead of the usual material (e.g. different types of plastic for a blister sleeve).
  List<CodeableConcept>? get alternateMaterial;
  @override

  /// [shelfLifeStorage] Shelf Life and storage information.
  List<ProductShelfLife>? get shelfLifeStorage;
  @override

  /// [manufacturer] Manufacturer of this packaging item. When there are multiple values each one is a potential manufacturer of this packaging item.
  List<Reference>? get manufacturer;
  @override

  /// [property] General characteristics of this item.
  List<PackagedProductDefinitionProperty>? get property;
  @override

  /// [containedItem] The item(s) within the packaging.
  List<PackagedProductDefinitionContainedItem>? get containedItem;
  @override

  /// [packaging] Allows containers (and parts of containers) within containers, still as a part of a single packaged product. See also PackagedProductDefinition.packaging.containedItem.item(PackagedProductDefinition).
  List<PackagedProductDefinitionPackaging>? get packaging;
  @override
  @JsonKey(ignore: true)
  _$$_PackagedProductDefinitionPackagingCopyWith<
          _$_PackagedProductDefinitionPackaging>
      get copyWith => throw _privateConstructorUsedError;
}

PackagedProductDefinitionProperty _$PackagedProductDefinitionPropertyFromJson(
    Map<String, dynamic> json) {
  return _PackagedProductDefinitionProperty.fromJson(json);
}

/// @nodoc
mixin _$PackagedProductDefinitionProperty {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] A code expressing the type of characteristic.
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [valueCodeableConcept] A value for the characteristic.
  CodeableConcept? get valueCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [valueQuantity] A value for the characteristic.
  Quantity? get valueQuantity => throw _privateConstructorUsedError;

  /// [valueDate] A value for the characteristic.
  Date? get valueDate => throw _privateConstructorUsedError;

  /// [valueDateElement] ("_valueDate") Extensions for valueDate
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement => throw _privateConstructorUsedError;

  /// [valueBoolean] A value for the characteristic.
  Boolean? get valueBoolean => throw _privateConstructorUsedError;

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement => throw _privateConstructorUsedError;

  /// [valueAttachment] A value for the characteristic.
  Attachment? get valueAttachment => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PackagedProductDefinitionPropertyCopyWith<PackagedProductDefinitionProperty>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PackagedProductDefinitionPropertyCopyWith<$Res> {
  factory $PackagedProductDefinitionPropertyCopyWith(
          PackagedProductDefinitionProperty value,
          $Res Function(PackagedProductDefinitionProperty) then) =
      _$PackagedProductDefinitionPropertyCopyWithImpl<$Res,
          PackagedProductDefinitionProperty>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      Quantity? valueQuantity,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment});

  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  $QuantityCopyWith<$Res>? get valueQuantity;
  $ElementCopyWith<$Res>? get valueDateElement;
  $ElementCopyWith<$Res>? get valueBooleanElement;
  $AttachmentCopyWith<$Res>? get valueAttachment;
}

/// @nodoc
class _$PackagedProductDefinitionPropertyCopyWithImpl<$Res,
        $Val extends PackagedProductDefinitionProperty>
    implements $PackagedProductDefinitionPropertyCopyWith<$Res> {
  _$PackagedProductDefinitionPropertyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueQuantity = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept {
    if (_value.valueCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.valueCodeableConcept!,
        (value) {
      return _then(_value.copyWith(valueCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get valueQuantity {
    if (_value.valueQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.valueQuantity!, (value) {
      return _then(_value.copyWith(valueQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueDateElement {
    if (_value.valueDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueDateElement!, (value) {
      return _then(_value.copyWith(valueDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueBooleanElement {
    if (_value.valueBooleanElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueBooleanElement!, (value) {
      return _then(_value.copyWith(valueBooleanElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get valueAttachment {
    if (_value.valueAttachment == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.valueAttachment!, (value) {
      return _then(_value.copyWith(valueAttachment: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_PackagedProductDefinitionPropertyCopyWith<$Res>
    implements $PackagedProductDefinitionPropertyCopyWith<$Res> {
  factory _$$_PackagedProductDefinitionPropertyCopyWith(
          _$_PackagedProductDefinitionProperty value,
          $Res Function(_$_PackagedProductDefinitionProperty) then) =
      __$$_PackagedProductDefinitionPropertyCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      Quantity? valueQuantity,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  @override
  $QuantityCopyWith<$Res>? get valueQuantity;
  @override
  $ElementCopyWith<$Res>? get valueDateElement;
  @override
  $ElementCopyWith<$Res>? get valueBooleanElement;
  @override
  $AttachmentCopyWith<$Res>? get valueAttachment;
}

/// @nodoc
class __$$_PackagedProductDefinitionPropertyCopyWithImpl<$Res>
    extends _$PackagedProductDefinitionPropertyCopyWithImpl<$Res,
        _$_PackagedProductDefinitionProperty>
    implements _$$_PackagedProductDefinitionPropertyCopyWith<$Res> {
  __$$_PackagedProductDefinitionPropertyCopyWithImpl(
      _$_PackagedProductDefinitionProperty _value,
      $Res Function(_$_PackagedProductDefinitionProperty) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueQuantity = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
  }) {
    return _then(_$_PackagedProductDefinitionProperty(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PackagedProductDefinitionProperty
    extends _PackagedProductDefinitionProperty {
  _$_PackagedProductDefinitionProperty(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.type,
      this.valueCodeableConcept,
      this.valueQuantity,
      this.valueDate,
      @JsonKey(name: '_valueDate') this.valueDateElement,
      this.valueBoolean,
      @JsonKey(name: '_valueBoolean') this.valueBooleanElement,
      this.valueAttachment})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_PackagedProductDefinitionProperty.fromJson(
          Map<String, dynamic> json) =>
      _$$_PackagedProductDefinitionPropertyFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] A code expressing the type of characteristic.
  @override
  final CodeableConcept type;

  /// [valueCodeableConcept] A value for the characteristic.
  @override
  final CodeableConcept? valueCodeableConcept;

  /// [valueQuantity] A value for the characteristic.
  @override
  final Quantity? valueQuantity;

  /// [valueDate] A value for the characteristic.
  @override
  final Date? valueDate;

  /// [valueDateElement] ("_valueDate") Extensions for valueDate
  @override
  @JsonKey(name: '_valueDate')
  final Element? valueDateElement;

  /// [valueBoolean] A value for the characteristic.
  @override
  final Boolean? valueBoolean;

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @override
  @JsonKey(name: '_valueBoolean')
  final Element? valueBooleanElement;

  /// [valueAttachment] A value for the characteristic.
  @override
  final Attachment? valueAttachment;

  @override
  String toString() {
    return 'PackagedProductDefinitionProperty(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, valueCodeableConcept: $valueCodeableConcept, valueQuantity: $valueQuantity, valueDate: $valueDate, valueDateElement: $valueDateElement, valueBoolean: $valueBoolean, valueBooleanElement: $valueBooleanElement, valueAttachment: $valueAttachment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PackagedProductDefinitionProperty &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.valueCodeableConcept, valueCodeableConcept) ||
                other.valueCodeableConcept == valueCodeableConcept) &&
            (identical(other.valueQuantity, valueQuantity) ||
                other.valueQuantity == valueQuantity) &&
            (identical(other.valueDate, valueDate) ||
                other.valueDate == valueDate) &&
            (identical(other.valueDateElement, valueDateElement) ||
                other.valueDateElement == valueDateElement) &&
            (identical(other.valueBoolean, valueBoolean) ||
                other.valueBoolean == valueBoolean) &&
            (identical(other.valueBooleanElement, valueBooleanElement) ||
                other.valueBooleanElement == valueBooleanElement) &&
            (identical(other.valueAttachment, valueAttachment) ||
                other.valueAttachment == valueAttachment));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      valueCodeableConcept,
      valueQuantity,
      valueDate,
      valueDateElement,
      valueBoolean,
      valueBooleanElement,
      valueAttachment);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PackagedProductDefinitionPropertyCopyWith<
          _$_PackagedProductDefinitionProperty>
      get copyWith => __$$_PackagedProductDefinitionPropertyCopyWithImpl<
          _$_PackagedProductDefinitionProperty>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PackagedProductDefinitionPropertyToJson(
      this,
    );
  }
}

abstract class _PackagedProductDefinitionProperty
    extends PackagedProductDefinitionProperty {
  factory _PackagedProductDefinitionProperty(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept type,
          final CodeableConcept? valueCodeableConcept,
          final Quantity? valueQuantity,
          final Date? valueDate,
          @JsonKey(name: '_valueDate') final Element? valueDateElement,
          final Boolean? valueBoolean,
          @JsonKey(name: '_valueBoolean') final Element? valueBooleanElement,
          final Attachment? valueAttachment}) =
      _$_PackagedProductDefinitionProperty;
  _PackagedProductDefinitionProperty._() : super._();

  factory _PackagedProductDefinitionProperty.fromJson(
          Map<String, dynamic> json) =
      _$_PackagedProductDefinitionProperty.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] A code expressing the type of characteristic.
  CodeableConcept get type;
  @override

  /// [valueCodeableConcept] A value for the characteristic.
  CodeableConcept? get valueCodeableConcept;
  @override

  /// [valueQuantity] A value for the characteristic.
  Quantity? get valueQuantity;
  @override

  /// [valueDate] A value for the characteristic.
  Date? get valueDate;
  @override

  /// [valueDateElement] ("_valueDate") Extensions for valueDate
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement;
  @override

  /// [valueBoolean] A value for the characteristic.
  Boolean? get valueBoolean;
  @override

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement;
  @override

  /// [valueAttachment] A value for the characteristic.
  Attachment? get valueAttachment;
  @override
  @JsonKey(ignore: true)
  _$$_PackagedProductDefinitionPropertyCopyWith<
          _$_PackagedProductDefinitionProperty>
      get copyWith => throw _privateConstructorUsedError;
}

PackagedProductDefinitionContainedItem
    _$PackagedProductDefinitionContainedItemFromJson(
        Map<String, dynamic> json) {
  return _PackagedProductDefinitionContainedItem.fromJson(json);
}

/// @nodoc
mixin _$PackagedProductDefinitionContainedItem {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [item] The actual item(s) of medication, as manufactured, or a device (typically, but not necessarily, a co-packaged one), or other medically related item (such as food, biologicals, raw materials, medical fluids, gases etc.), as contained in the package. This also allows another whole packaged product to be included, which is solely for the case where a package of other entire packages is wanted - such as a wholesale or distribution pack (for layers within one package, use PackagedProductDefinition.packaging.packaging).
  CodeableReference get item => throw _privateConstructorUsedError;

  /// [amount] The number of this type of item within this packaging.
  Quantity? get amount => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PackagedProductDefinitionContainedItemCopyWith<
          PackagedProductDefinitionContainedItem>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PackagedProductDefinitionContainedItemCopyWith<$Res> {
  factory $PackagedProductDefinitionContainedItemCopyWith(
          PackagedProductDefinitionContainedItem value,
          $Res Function(PackagedProductDefinitionContainedItem) then) =
      _$PackagedProductDefinitionContainedItemCopyWithImpl<$Res,
          PackagedProductDefinitionContainedItem>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference item,
      Quantity? amount});

  $CodeableReferenceCopyWith<$Res> get item;
  $QuantityCopyWith<$Res>? get amount;
}

/// @nodoc
class _$PackagedProductDefinitionContainedItemCopyWithImpl<$Res,
        $Val extends PackagedProductDefinitionContainedItem>
    implements $PackagedProductDefinitionContainedItemCopyWith<$Res> {
  _$PackagedProductDefinitionContainedItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? item = null,
    Object? amount = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      item: null == item
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Quantity?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res> get item {
    return $CodeableReferenceCopyWith<$Res>(_value.item, (value) {
      return _then(_value.copyWith(item: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get amount {
    if (_value.amount == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.amount!, (value) {
      return _then(_value.copyWith(amount: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_PackagedProductDefinitionContainedItemCopyWith<$Res>
    implements $PackagedProductDefinitionContainedItemCopyWith<$Res> {
  factory _$$_PackagedProductDefinitionContainedItemCopyWith(
          _$_PackagedProductDefinitionContainedItem value,
          $Res Function(_$_PackagedProductDefinitionContainedItem) then) =
      __$$_PackagedProductDefinitionContainedItemCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference item,
      Quantity? amount});

  @override
  $CodeableReferenceCopyWith<$Res> get item;
  @override
  $QuantityCopyWith<$Res>? get amount;
}

/// @nodoc
class __$$_PackagedProductDefinitionContainedItemCopyWithImpl<$Res>
    extends _$PackagedProductDefinitionContainedItemCopyWithImpl<$Res,
        _$_PackagedProductDefinitionContainedItem>
    implements _$$_PackagedProductDefinitionContainedItemCopyWith<$Res> {
  __$$_PackagedProductDefinitionContainedItemCopyWithImpl(
      _$_PackagedProductDefinitionContainedItem _value,
      $Res Function(_$_PackagedProductDefinitionContainedItem) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? item = null,
    Object? amount = freezed,
  }) {
    return _then(_$_PackagedProductDefinitionContainedItem(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      item: null == item
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Quantity?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PackagedProductDefinitionContainedItem
    extends _PackagedProductDefinitionContainedItem {
  _$_PackagedProductDefinitionContainedItem(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.item,
      this.amount})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_PackagedProductDefinitionContainedItem.fromJson(
          Map<String, dynamic> json) =>
      _$$_PackagedProductDefinitionContainedItemFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [item] The actual item(s) of medication, as manufactured, or a device (typically, but not necessarily, a co-packaged one), or other medically related item (such as food, biologicals, raw materials, medical fluids, gases etc.), as contained in the package. This also allows another whole packaged product to be included, which is solely for the case where a package of other entire packages is wanted - such as a wholesale or distribution pack (for layers within one package, use PackagedProductDefinition.packaging.packaging).
  @override
  final CodeableReference item;

  /// [amount] The number of this type of item within this packaging.
  @override
  final Quantity? amount;

  @override
  String toString() {
    return 'PackagedProductDefinitionContainedItem(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, item: $item, amount: $amount)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PackagedProductDefinitionContainedItem &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.item, item) || other.item == item) &&
            (identical(other.amount, amount) || other.amount == amount));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      item,
      amount);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PackagedProductDefinitionContainedItemCopyWith<
          _$_PackagedProductDefinitionContainedItem>
      get copyWith => __$$_PackagedProductDefinitionContainedItemCopyWithImpl<
          _$_PackagedProductDefinitionContainedItem>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PackagedProductDefinitionContainedItemToJson(
      this,
    );
  }
}

abstract class _PackagedProductDefinitionContainedItem
    extends PackagedProductDefinitionContainedItem {
  factory _PackagedProductDefinitionContainedItem(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final CodeableReference item,
      final Quantity? amount}) = _$_PackagedProductDefinitionContainedItem;
  _PackagedProductDefinitionContainedItem._() : super._();

  factory _PackagedProductDefinitionContainedItem.fromJson(
          Map<String, dynamic> json) =
      _$_PackagedProductDefinitionContainedItem.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [item] The actual item(s) of medication, as manufactured, or a device (typically, but not necessarily, a co-packaged one), or other medically related item (such as food, biologicals, raw materials, medical fluids, gases etc.), as contained in the package. This also allows another whole packaged product to be included, which is solely for the case where a package of other entire packages is wanted - such as a wholesale or distribution pack (for layers within one package, use PackagedProductDefinition.packaging.packaging).
  CodeableReference get item;
  @override

  /// [amount] The number of this type of item within this packaging.
  Quantity? get amount;
  @override
  @JsonKey(ignore: true)
  _$$_PackagedProductDefinitionContainedItemCopyWith<
          _$_PackagedProductDefinitionContainedItem>
      get copyWith => throw _privateConstructorUsedError;
}

RegulatedAuthorization _$RegulatedAuthorizationFromJson(
    Map<String, dynamic> json) {
  return _RegulatedAuthorization.fromJson(json);
}

/// @nodoc
mixin _$RegulatedAuthorization {
  /// [resourceType] This is a RegulatedAuthorization resource
  @JsonKey(unknownEnumValue: R5ResourceType.RegulatedAuthorization)
  R5ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] Business identifier for the authorization, typically assigned by the authorizing body.
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [subject] The product type, treatment, facility or activity that is being authorized.
  List<Reference>? get subject => throw _privateConstructorUsedError;

  /// [type] Overall type of this authorization, for example drug marketing approval, orphan drug designation.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [description] General textual supporting information.
  Markdown? get description => throw _privateConstructorUsedError;

  /// [descriptionElement] ("_description") Extensions for description
  @JsonKey(name: '_description')
  Element? get descriptionElement => throw _privateConstructorUsedError;

  /// [region] The territory (e.g., country, jurisdiction etc.) in which the authorization has been granted.
  List<CodeableConcept>? get region => throw _privateConstructorUsedError;

  /// [status] The status that is authorised e.g. approved. Intermediate states and actions can be tracked with cases and applications.
  CodeableConcept? get status => throw _privateConstructorUsedError;

  /// [statusDate] The date at which the current status was assigned.
  FhirDateTime? get statusDate => throw _privateConstructorUsedError;

  /// [statusDateElement] ("_statusDate") Extensions for statusDate
  @JsonKey(name: '_statusDate')
  Element? get statusDateElement => throw _privateConstructorUsedError;

  /// [validityPeriod] The time period in which the regulatory approval, clearance or licencing is in effect. As an example, a Marketing Authorization includes the date of authorization and/or an expiration date.
  Period? get validityPeriod => throw _privateConstructorUsedError;

  /// [indication] Condition for which the use of the regulated product applies.
  List<CodeableReference>? get indication => throw _privateConstructorUsedError;

  /// [intendedUse] The intended use of the product, e.g. prevention, treatment, diagnosis.
  CodeableConcept? get intendedUse => throw _privateConstructorUsedError;

  /// [basis] The legal or regulatory framework against which this authorization is granted, or other reasons for it.
  List<CodeableConcept>? get basis => throw _privateConstructorUsedError;

  /// [holder] The organization that has been granted this authorization, by some authoritative body (the 'regulator').
  Reference? get holder => throw _privateConstructorUsedError;

  /// [regulator] The regulatory authority or authorizing body granting the authorization. For example, European Medicines Agency (EMA), Food and Drug Administration (FDA), Health Canada (HC), etc.
  Reference? get regulator => throw _privateConstructorUsedError;

  /// [attachedDocument] Additional information or supporting documentation about the authorization.
  List<Reference>? get attachedDocument => throw _privateConstructorUsedError;

  /// [case_] ("case") The case or regulatory procedure for granting or amending a regulated authorization. An authorization is granted in response to submissions/applications by those seeking authorization. A case is the administrative process that deals with the application(s) that relate to this and assesses them. Note: This area is subject to ongoing review and the workgroup is seeking implementer feedback on its use (see link at bottom of page).
  @JsonKey(name: 'case')
  RegulatedAuthorizationCase? get case_ => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RegulatedAuthorizationCopyWith<RegulatedAuthorization> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RegulatedAuthorizationCopyWith<$Res> {
  factory $RegulatedAuthorizationCopyWith(RegulatedAuthorization value,
          $Res Function(RegulatedAuthorization) then) =
      _$RegulatedAuthorizationCopyWithImpl<$Res, RegulatedAuthorization>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.RegulatedAuthorization)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      List<Reference>? subject,
      CodeableConcept? type,
      Markdown? description,
      @JsonKey(name: '_description')
          Element? descriptionElement,
      List<CodeableConcept>? region,
      CodeableConcept? status,
      FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate')
          Element? statusDateElement,
      Period? validityPeriod,
      List<CodeableReference>? indication,
      CodeableConcept? intendedUse,
      List<CodeableConcept>? basis,
      Reference? holder,
      Reference? regulator,
      List<Reference>? attachedDocument,
      @JsonKey(name: 'case')
          RegulatedAuthorizationCase? case_});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $CodeableConceptCopyWith<$Res>? get type;
  $ElementCopyWith<$Res>? get descriptionElement;
  $CodeableConceptCopyWith<$Res>? get status;
  $ElementCopyWith<$Res>? get statusDateElement;
  $PeriodCopyWith<$Res>? get validityPeriod;
  $CodeableConceptCopyWith<$Res>? get intendedUse;
  $ReferenceCopyWith<$Res>? get holder;
  $ReferenceCopyWith<$Res>? get regulator;
  $RegulatedAuthorizationCaseCopyWith<$Res>? get case_;
}

/// @nodoc
class _$RegulatedAuthorizationCopyWithImpl<$Res,
        $Val extends RegulatedAuthorization>
    implements $RegulatedAuthorizationCopyWith<$Res> {
  _$RegulatedAuthorizationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? subject = freezed,
    Object? type = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? region = freezed,
    Object? status = freezed,
    Object? statusDate = freezed,
    Object? statusDateElement = freezed,
    Object? validityPeriod = freezed,
    Object? indication = freezed,
    Object? intendedUse = freezed,
    Object? basis = freezed,
    Object? holder = freezed,
    Object? regulator = freezed,
    Object? attachedDocument = freezed,
    Object? case_ = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      subject: freezed == subject
          ? _value.subject
          : subject // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      region: freezed == region
          ? _value.region
          : region // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      statusDate: freezed == statusDate
          ? _value.statusDate
          : statusDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      statusDateElement: freezed == statusDateElement
          ? _value.statusDateElement
          : statusDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      validityPeriod: freezed == validityPeriod
          ? _value.validityPeriod
          : validityPeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      indication: freezed == indication
          ? _value.indication
          : indication // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      intendedUse: freezed == intendedUse
          ? _value.intendedUse
          : intendedUse // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      basis: freezed == basis
          ? _value.basis
          : basis // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      holder: freezed == holder
          ? _value.holder
          : holder // ignore: cast_nullable_to_non_nullable
              as Reference?,
      regulator: freezed == regulator
          ? _value.regulator
          : regulator // ignore: cast_nullable_to_non_nullable
              as Reference?,
      attachedDocument: freezed == attachedDocument
          ? _value.attachedDocument
          : attachedDocument // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      case_: freezed == case_
          ? _value.case_
          : case_ // ignore: cast_nullable_to_non_nullable
              as RegulatedAuthorizationCase?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get descriptionElement {
    if (_value.descriptionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.descriptionElement!, (value) {
      return _then(_value.copyWith(descriptionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusDateElement {
    if (_value.statusDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusDateElement!, (value) {
      return _then(_value.copyWith(statusDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get validityPeriod {
    if (_value.validityPeriod == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.validityPeriod!, (value) {
      return _then(_value.copyWith(validityPeriod: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get intendedUse {
    if (_value.intendedUse == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.intendedUse!, (value) {
      return _then(_value.copyWith(intendedUse: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get holder {
    if (_value.holder == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.holder!, (value) {
      return _then(_value.copyWith(holder: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get regulator {
    if (_value.regulator == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.regulator!, (value) {
      return _then(_value.copyWith(regulator: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RegulatedAuthorizationCaseCopyWith<$Res>? get case_ {
    if (_value.case_ == null) {
      return null;
    }

    return $RegulatedAuthorizationCaseCopyWith<$Res>(_value.case_!, (value) {
      return _then(_value.copyWith(case_: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_RegulatedAuthorizationCopyWith<$Res>
    implements $RegulatedAuthorizationCopyWith<$Res> {
  factory _$$_RegulatedAuthorizationCopyWith(_$_RegulatedAuthorization value,
          $Res Function(_$_RegulatedAuthorization) then) =
      __$$_RegulatedAuthorizationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.RegulatedAuthorization)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      List<Reference>? subject,
      CodeableConcept? type,
      Markdown? description,
      @JsonKey(name: '_description')
          Element? descriptionElement,
      List<CodeableConcept>? region,
      CodeableConcept? status,
      FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate')
          Element? statusDateElement,
      Period? validityPeriod,
      List<CodeableReference>? indication,
      CodeableConcept? intendedUse,
      List<CodeableConcept>? basis,
      Reference? holder,
      Reference? regulator,
      List<Reference>? attachedDocument,
      @JsonKey(name: 'case')
          RegulatedAuthorizationCase? case_});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $ElementCopyWith<$Res>? get descriptionElement;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
  @override
  $ElementCopyWith<$Res>? get statusDateElement;
  @override
  $PeriodCopyWith<$Res>? get validityPeriod;
  @override
  $CodeableConceptCopyWith<$Res>? get intendedUse;
  @override
  $ReferenceCopyWith<$Res>? get holder;
  @override
  $ReferenceCopyWith<$Res>? get regulator;
  @override
  $RegulatedAuthorizationCaseCopyWith<$Res>? get case_;
}

/// @nodoc
class __$$_RegulatedAuthorizationCopyWithImpl<$Res>
    extends _$RegulatedAuthorizationCopyWithImpl<$Res,
        _$_RegulatedAuthorization>
    implements _$$_RegulatedAuthorizationCopyWith<$Res> {
  __$$_RegulatedAuthorizationCopyWithImpl(_$_RegulatedAuthorization _value,
      $Res Function(_$_RegulatedAuthorization) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? subject = freezed,
    Object? type = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? region = freezed,
    Object? status = freezed,
    Object? statusDate = freezed,
    Object? statusDateElement = freezed,
    Object? validityPeriod = freezed,
    Object? indication = freezed,
    Object? intendedUse = freezed,
    Object? basis = freezed,
    Object? holder = freezed,
    Object? regulator = freezed,
    Object? attachedDocument = freezed,
    Object? case_ = freezed,
  }) {
    return _then(_$_RegulatedAuthorization(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      subject: freezed == subject
          ? _value._subject
          : subject // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      region: freezed == region
          ? _value._region
          : region // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      statusDate: freezed == statusDate
          ? _value.statusDate
          : statusDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      statusDateElement: freezed == statusDateElement
          ? _value.statusDateElement
          : statusDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      validityPeriod: freezed == validityPeriod
          ? _value.validityPeriod
          : validityPeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      indication: freezed == indication
          ? _value._indication
          : indication // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      intendedUse: freezed == intendedUse
          ? _value.intendedUse
          : intendedUse // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      basis: freezed == basis
          ? _value._basis
          : basis // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      holder: freezed == holder
          ? _value.holder
          : holder // ignore: cast_nullable_to_non_nullable
              as Reference?,
      regulator: freezed == regulator
          ? _value.regulator
          : regulator // ignore: cast_nullable_to_non_nullable
              as Reference?,
      attachedDocument: freezed == attachedDocument
          ? _value._attachedDocument
          : attachedDocument // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      case_: freezed == case_
          ? _value.case_
          : case_ // ignore: cast_nullable_to_non_nullable
              as RegulatedAuthorizationCase?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_RegulatedAuthorization extends _RegulatedAuthorization {
  _$_RegulatedAuthorization(
      {@JsonKey(unknownEnumValue: R5ResourceType.RegulatedAuthorization)
          this.resourceType = R5ResourceType.RegulatedAuthorization,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules')
          this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language')
          this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      final List<Reference>? subject,
      this.type,
      this.description,
      @JsonKey(name: '_description')
          this.descriptionElement,
      final List<CodeableConcept>? region,
      this.status,
      this.statusDate,
      @JsonKey(name: '_statusDate')
          this.statusDateElement,
      this.validityPeriod,
      final List<CodeableReference>? indication,
      this.intendedUse,
      final List<CodeableConcept>? basis,
      this.holder,
      this.regulator,
      final List<Reference>? attachedDocument,
      @JsonKey(name: 'case')
          this.case_})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _subject = subject,
        _region = region,
        _indication = indication,
        _basis = basis,
        _attachedDocument = attachedDocument,
        super._();

  factory _$_RegulatedAuthorization.fromJson(Map<String, dynamic> json) =>
      _$$_RegulatedAuthorizationFromJson(json);

  /// [resourceType] This is a RegulatedAuthorization resource
  @override
  @JsonKey(unknownEnumValue: R5ResourceType.RegulatedAuthorization)
  final R5ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.
  @override
  final Code? language;

  /// [languageElement] ("_language") Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] Business identifier for the authorization, typically assigned by the authorizing body.
  final List<Identifier>? _identifier;

  /// [identifier] Business identifier for the authorization, typically assigned by the authorizing body.
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [subject] The product type, treatment, facility or activity that is being authorized.
  final List<Reference>? _subject;

  /// [subject] The product type, treatment, facility or activity that is being authorized.
  @override
  List<Reference>? get subject {
    final value = _subject;
    if (value == null) return null;
    if (_subject is EqualUnmodifiableListView) return _subject;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] Overall type of this authorization, for example drug marketing approval, orphan drug designation.
  @override
  final CodeableConcept? type;

  /// [description] General textual supporting information.
  @override
  final Markdown? description;

  /// [descriptionElement] ("_description") Extensions for description
  @override
  @JsonKey(name: '_description')
  final Element? descriptionElement;

  /// [region] The territory (e.g., country, jurisdiction etc.) in which the authorization has been granted.
  final List<CodeableConcept>? _region;

  /// [region] The territory (e.g., country, jurisdiction etc.) in which the authorization has been granted.
  @override
  List<CodeableConcept>? get region {
    final value = _region;
    if (value == null) return null;
    if (_region is EqualUnmodifiableListView) return _region;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [status] The status that is authorised e.g. approved. Intermediate states and actions can be tracked with cases and applications.
  @override
  final CodeableConcept? status;

  /// [statusDate] The date at which the current status was assigned.
  @override
  final FhirDateTime? statusDate;

  /// [statusDateElement] ("_statusDate") Extensions for statusDate
  @override
  @JsonKey(name: '_statusDate')
  final Element? statusDateElement;

  /// [validityPeriod] The time period in which the regulatory approval, clearance or licencing is in effect. As an example, a Marketing Authorization includes the date of authorization and/or an expiration date.
  @override
  final Period? validityPeriod;

  /// [indication] Condition for which the use of the regulated product applies.
  final List<CodeableReference>? _indication;

  /// [indication] Condition for which the use of the regulated product applies.
  @override
  List<CodeableReference>? get indication {
    final value = _indication;
    if (value == null) return null;
    if (_indication is EqualUnmodifiableListView) return _indication;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [intendedUse] The intended use of the product, e.g. prevention, treatment, diagnosis.
  @override
  final CodeableConcept? intendedUse;

  /// [basis] The legal or regulatory framework against which this authorization is granted, or other reasons for it.
  final List<CodeableConcept>? _basis;

  /// [basis] The legal or regulatory framework against which this authorization is granted, or other reasons for it.
  @override
  List<CodeableConcept>? get basis {
    final value = _basis;
    if (value == null) return null;
    if (_basis is EqualUnmodifiableListView) return _basis;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [holder] The organization that has been granted this authorization, by some authoritative body (the 'regulator').
  @override
  final Reference? holder;

  /// [regulator] The regulatory authority or authorizing body granting the authorization. For example, European Medicines Agency (EMA), Food and Drug Administration (FDA), Health Canada (HC), etc.
  @override
  final Reference? regulator;

  /// [attachedDocument] Additional information or supporting documentation about the authorization.
  final List<Reference>? _attachedDocument;

  /// [attachedDocument] Additional information or supporting documentation about the authorization.
  @override
  List<Reference>? get attachedDocument {
    final value = _attachedDocument;
    if (value == null) return null;
    if (_attachedDocument is EqualUnmodifiableListView)
      return _attachedDocument;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [case_] ("case") The case or regulatory procedure for granting or amending a regulated authorization. An authorization is granted in response to submissions/applications by those seeking authorization. A case is the administrative process that deals with the application(s) that relate to this and assesses them. Note: This area is subject to ongoing review and the workgroup is seeking implementer feedback on its use (see link at bottom of page).
  @override
  @JsonKey(name: 'case')
  final RegulatedAuthorizationCase? case_;

  @override
  String toString() {
    return 'RegulatedAuthorization(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, subject: $subject, type: $type, description: $description, descriptionElement: $descriptionElement, region: $region, status: $status, statusDate: $statusDate, statusDateElement: $statusDateElement, validityPeriod: $validityPeriod, indication: $indication, intendedUse: $intendedUse, basis: $basis, holder: $holder, regulator: $regulator, attachedDocument: $attachedDocument, case_: $case_)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_RegulatedAuthorization &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            const DeepCollectionEquality().equals(other._subject, _subject) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.descriptionElement, descriptionElement) ||
                other.descriptionElement == descriptionElement) &&
            const DeepCollectionEquality().equals(other._region, _region) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusDate, statusDate) ||
                other.statusDate == statusDate) &&
            (identical(other.statusDateElement, statusDateElement) ||
                other.statusDateElement == statusDateElement) &&
            (identical(other.validityPeriod, validityPeriod) ||
                other.validityPeriod == validityPeriod) &&
            const DeepCollectionEquality()
                .equals(other._indication, _indication) &&
            (identical(other.intendedUse, intendedUse) ||
                other.intendedUse == intendedUse) &&
            const DeepCollectionEquality().equals(other._basis, _basis) &&
            (identical(other.holder, holder) || other.holder == holder) &&
            (identical(other.regulator, regulator) ||
                other.regulator == regulator) &&
            const DeepCollectionEquality()
                .equals(other._attachedDocument, _attachedDocument) &&
            (identical(other.case_, case_) || other.case_ == case_));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_identifier),
        const DeepCollectionEquality().hash(_subject),
        type,
        description,
        descriptionElement,
        const DeepCollectionEquality().hash(_region),
        status,
        statusDate,
        statusDateElement,
        validityPeriod,
        const DeepCollectionEquality().hash(_indication),
        intendedUse,
        const DeepCollectionEquality().hash(_basis),
        holder,
        regulator,
        const DeepCollectionEquality().hash(_attachedDocument),
        case_
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_RegulatedAuthorizationCopyWith<_$_RegulatedAuthorization> get copyWith =>
      __$$_RegulatedAuthorizationCopyWithImpl<_$_RegulatedAuthorization>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_RegulatedAuthorizationToJson(
      this,
    );
  }
}

abstract class _RegulatedAuthorization extends RegulatedAuthorization {
  factory _RegulatedAuthorization(
      {@JsonKey(unknownEnumValue: R5ResourceType.RegulatedAuthorization)
          final R5ResourceType resourceType,
      final FhirId? id,
      final Meta? meta,
      final FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          final Element? implicitRulesElement,
      final Code? language,
      @JsonKey(name: '_language')
          final Element? languageElement,
      final Narrative? text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      final List<Reference>? subject,
      final CodeableConcept? type,
      final Markdown? description,
      @JsonKey(name: '_description')
          final Element? descriptionElement,
      final List<CodeableConcept>? region,
      final CodeableConcept? status,
      final FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate')
          final Element? statusDateElement,
      final Period? validityPeriod,
      final List<CodeableReference>? indication,
      final CodeableConcept? intendedUse,
      final List<CodeableConcept>? basis,
      final Reference? holder,
      final Reference? regulator,
      final List<Reference>? attachedDocument,
      @JsonKey(name: 'case')
          final RegulatedAuthorizationCase? case_}) = _$_RegulatedAuthorization;
  _RegulatedAuthorization._() : super._();

  factory _RegulatedAuthorization.fromJson(Map<String, dynamic> json) =
      _$_RegulatedAuthorization.fromJson;

  @override

  /// [resourceType] This is a RegulatedAuthorization resource
  @JsonKey(unknownEnumValue: R5ResourceType.RegulatedAuthorization)
  R5ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.
  Code? get language;
  @override

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained;
  @override

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] Business identifier for the authorization, typically assigned by the authorizing body.
  List<Identifier>? get identifier;
  @override

  /// [subject] The product type, treatment, facility or activity that is being authorized.
  List<Reference>? get subject;
  @override

  /// [type] Overall type of this authorization, for example drug marketing approval, orphan drug designation.
  CodeableConcept? get type;
  @override

  /// [description] General textual supporting information.
  Markdown? get description;
  @override

  /// [descriptionElement] ("_description") Extensions for description
  @JsonKey(name: '_description')
  Element? get descriptionElement;
  @override

  /// [region] The territory (e.g., country, jurisdiction etc.) in which the authorization has been granted.
  List<CodeableConcept>? get region;
  @override

  /// [status] The status that is authorised e.g. approved. Intermediate states and actions can be tracked with cases and applications.
  CodeableConcept? get status;
  @override

  /// [statusDate] The date at which the current status was assigned.
  FhirDateTime? get statusDate;
  @override

  /// [statusDateElement] ("_statusDate") Extensions for statusDate
  @JsonKey(name: '_statusDate')
  Element? get statusDateElement;
  @override

  /// [validityPeriod] The time period in which the regulatory approval, clearance or licencing is in effect. As an example, a Marketing Authorization includes the date of authorization and/or an expiration date.
  Period? get validityPeriod;
  @override

  /// [indication] Condition for which the use of the regulated product applies.
  List<CodeableReference>? get indication;
  @override

  /// [intendedUse] The intended use of the product, e.g. prevention, treatment, diagnosis.
  CodeableConcept? get intendedUse;
  @override

  /// [basis] The legal or regulatory framework against which this authorization is granted, or other reasons for it.
  List<CodeableConcept>? get basis;
  @override

  /// [holder] The organization that has been granted this authorization, by some authoritative body (the 'regulator').
  Reference? get holder;
  @override

  /// [regulator] The regulatory authority or authorizing body granting the authorization. For example, European Medicines Agency (EMA), Food and Drug Administration (FDA), Health Canada (HC), etc.
  Reference? get regulator;
  @override

  /// [attachedDocument] Additional information or supporting documentation about the authorization.
  List<Reference>? get attachedDocument;
  @override

  /// [case_] ("case") The case or regulatory procedure for granting or amending a regulated authorization. An authorization is granted in response to submissions/applications by those seeking authorization. A case is the administrative process that deals with the application(s) that relate to this and assesses them. Note: This area is subject to ongoing review and the workgroup is seeking implementer feedback on its use (see link at bottom of page).
  @JsonKey(name: 'case')
  RegulatedAuthorizationCase? get case_;
  @override
  @JsonKey(ignore: true)
  _$$_RegulatedAuthorizationCopyWith<_$_RegulatedAuthorization> get copyWith =>
      throw _privateConstructorUsedError;
}

RegulatedAuthorizationCase _$RegulatedAuthorizationCaseFromJson(
    Map<String, dynamic> json) {
  return _RegulatedAuthorizationCase.fromJson(json);
}

/// @nodoc
mixin _$RegulatedAuthorizationCase {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] Identifier by which this case can be referenced.
  Identifier? get identifier => throw _privateConstructorUsedError;

  /// [type] The defining type of case.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [status] The status associated with the case.
  CodeableConcept? get status => throw _privateConstructorUsedError;

  /// [datePeriod] Relevant date for this case.
  Period? get datePeriod => throw _privateConstructorUsedError;

  /// [dateDateTime] Relevant date for this case.
  FhirDateTime? get dateDateTime => throw _privateConstructorUsedError;

  /// [dateDateTimeElement] ("_dateDateTime") Extensions for dateDateTime
  @JsonKey(name: '_dateDateTime')
  Element? get dateDateTimeElement => throw _privateConstructorUsedError;

  /// [application] A regulatory submission from an organization to a regulator, as part of an assessing case. Multiple applications may occur over time, with more or different information to support or modify the submission or the authorization. The applications can be considered as steps within the longer running case or procedure for this authorization process.
  List<RegulatedAuthorizationCase>? get application =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RegulatedAuthorizationCaseCopyWith<RegulatedAuthorizationCase>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RegulatedAuthorizationCaseCopyWith<$Res> {
  factory $RegulatedAuthorizationCaseCopyWith(RegulatedAuthorizationCase value,
          $Res Function(RegulatedAuthorizationCase) then) =
      _$RegulatedAuthorizationCaseCopyWithImpl<$Res,
          RegulatedAuthorizationCase>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Identifier? identifier,
      CodeableConcept? type,
      CodeableConcept? status,
      Period? datePeriod,
      FhirDateTime? dateDateTime,
      @JsonKey(name: '_dateDateTime') Element? dateDateTimeElement,
      List<RegulatedAuthorizationCase>? application});

  $IdentifierCopyWith<$Res>? get identifier;
  $CodeableConceptCopyWith<$Res>? get type;
  $CodeableConceptCopyWith<$Res>? get status;
  $PeriodCopyWith<$Res>? get datePeriod;
  $ElementCopyWith<$Res>? get dateDateTimeElement;
}

/// @nodoc
class _$RegulatedAuthorizationCaseCopyWithImpl<$Res,
        $Val extends RegulatedAuthorizationCase>
    implements $RegulatedAuthorizationCaseCopyWith<$Res> {
  _$RegulatedAuthorizationCaseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = freezed,
    Object? status = freezed,
    Object? datePeriod = freezed,
    Object? dateDateTime = freezed,
    Object? dateDateTimeElement = freezed,
    Object? application = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      datePeriod: freezed == datePeriod
          ? _value.datePeriod
          : datePeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      dateDateTime: freezed == dateDateTime
          ? _value.dateDateTime
          : dateDateTime // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      dateDateTimeElement: freezed == dateDateTimeElement
          ? _value.dateDateTimeElement
          : dateDateTimeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      application: freezed == application
          ? _value.application
          : application // ignore: cast_nullable_to_non_nullable
              as List<RegulatedAuthorizationCase>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get identifier {
    if (_value.identifier == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.identifier!, (value) {
      return _then(_value.copyWith(identifier: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get datePeriod {
    if (_value.datePeriod == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.datePeriod!, (value) {
      return _then(_value.copyWith(datePeriod: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get dateDateTimeElement {
    if (_value.dateDateTimeElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.dateDateTimeElement!, (value) {
      return _then(_value.copyWith(dateDateTimeElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_RegulatedAuthorizationCaseCopyWith<$Res>
    implements $RegulatedAuthorizationCaseCopyWith<$Res> {
  factory _$$_RegulatedAuthorizationCaseCopyWith(
          _$_RegulatedAuthorizationCase value,
          $Res Function(_$_RegulatedAuthorizationCase) then) =
      __$$_RegulatedAuthorizationCaseCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Identifier? identifier,
      CodeableConcept? type,
      CodeableConcept? status,
      Period? datePeriod,
      FhirDateTime? dateDateTime,
      @JsonKey(name: '_dateDateTime') Element? dateDateTimeElement,
      List<RegulatedAuthorizationCase>? application});

  @override
  $IdentifierCopyWith<$Res>? get identifier;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
  @override
  $PeriodCopyWith<$Res>? get datePeriod;
  @override
  $ElementCopyWith<$Res>? get dateDateTimeElement;
}

/// @nodoc
class __$$_RegulatedAuthorizationCaseCopyWithImpl<$Res>
    extends _$RegulatedAuthorizationCaseCopyWithImpl<$Res,
        _$_RegulatedAuthorizationCase>
    implements _$$_RegulatedAuthorizationCaseCopyWith<$Res> {
  __$$_RegulatedAuthorizationCaseCopyWithImpl(
      _$_RegulatedAuthorizationCase _value,
      $Res Function(_$_RegulatedAuthorizationCase) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = freezed,
    Object? status = freezed,
    Object? datePeriod = freezed,
    Object? dateDateTime = freezed,
    Object? dateDateTimeElement = freezed,
    Object? application = freezed,
  }) {
    return _then(_$_RegulatedAuthorizationCase(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      datePeriod: freezed == datePeriod
          ? _value.datePeriod
          : datePeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      dateDateTime: freezed == dateDateTime
          ? _value.dateDateTime
          : dateDateTime // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      dateDateTimeElement: freezed == dateDateTimeElement
          ? _value.dateDateTimeElement
          : dateDateTimeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      application: freezed == application
          ? _value._application
          : application // ignore: cast_nullable_to_non_nullable
              as List<RegulatedAuthorizationCase>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_RegulatedAuthorizationCase extends _RegulatedAuthorizationCase {
  _$_RegulatedAuthorizationCase(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.identifier,
      this.type,
      this.status,
      this.datePeriod,
      this.dateDateTime,
      @JsonKey(name: '_dateDateTime') this.dateDateTimeElement,
      final List<RegulatedAuthorizationCase>? application})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _application = application,
        super._();

  factory _$_RegulatedAuthorizationCase.fromJson(Map<String, dynamic> json) =>
      _$$_RegulatedAuthorizationCaseFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] Identifier by which this case can be referenced.
  @override
  final Identifier? identifier;

  /// [type] The defining type of case.
  @override
  final CodeableConcept? type;

  /// [status] The status associated with the case.
  @override
  final CodeableConcept? status;

  /// [datePeriod] Relevant date for this case.
  @override
  final Period? datePeriod;

  /// [dateDateTime] Relevant date for this case.
  @override
  final FhirDateTime? dateDateTime;

  /// [dateDateTimeElement] ("_dateDateTime") Extensions for dateDateTime
  @override
  @JsonKey(name: '_dateDateTime')
  final Element? dateDateTimeElement;

  /// [application] A regulatory submission from an organization to a regulator, as part of an assessing case. Multiple applications may occur over time, with more or different information to support or modify the submission or the authorization. The applications can be considered as steps within the longer running case or procedure for this authorization process.
  final List<RegulatedAuthorizationCase>? _application;

  /// [application] A regulatory submission from an organization to a regulator, as part of an assessing case. Multiple applications may occur over time, with more or different information to support or modify the submission or the authorization. The applications can be considered as steps within the longer running case or procedure for this authorization process.
  @override
  List<RegulatedAuthorizationCase>? get application {
    final value = _application;
    if (value == null) return null;
    if (_application is EqualUnmodifiableListView) return _application;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'RegulatedAuthorizationCase(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, type: $type, status: $status, datePeriod: $datePeriod, dateDateTime: $dateDateTime, dateDateTimeElement: $dateDateTimeElement, application: $application)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_RegulatedAuthorizationCase &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.datePeriod, datePeriod) ||
                other.datePeriod == datePeriod) &&
            (identical(other.dateDateTime, dateDateTime) ||
                other.dateDateTime == dateDateTime) &&
            (identical(other.dateDateTimeElement, dateDateTimeElement) ||
                other.dateDateTimeElement == dateDateTimeElement) &&
            const DeepCollectionEquality()
                .equals(other._application, _application));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      identifier,
      type,
      status,
      datePeriod,
      dateDateTime,
      dateDateTimeElement,
      const DeepCollectionEquality().hash(_application));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_RegulatedAuthorizationCaseCopyWith<_$_RegulatedAuthorizationCase>
      get copyWith => __$$_RegulatedAuthorizationCaseCopyWithImpl<
          _$_RegulatedAuthorizationCase>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_RegulatedAuthorizationCaseToJson(
      this,
    );
  }
}

abstract class _RegulatedAuthorizationCase extends RegulatedAuthorizationCase {
  factory _RegulatedAuthorizationCase(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final Identifier? identifier,
          final CodeableConcept? type,
          final CodeableConcept? status,
          final Period? datePeriod,
          final FhirDateTime? dateDateTime,
          @JsonKey(name: '_dateDateTime') final Element? dateDateTimeElement,
          final List<RegulatedAuthorizationCase>? application}) =
      _$_RegulatedAuthorizationCase;
  _RegulatedAuthorizationCase._() : super._();

  factory _RegulatedAuthorizationCase.fromJson(Map<String, dynamic> json) =
      _$_RegulatedAuthorizationCase.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] Identifier by which this case can be referenced.
  Identifier? get identifier;
  @override

  /// [type] The defining type of case.
  CodeableConcept? get type;
  @override

  /// [status] The status associated with the case.
  CodeableConcept? get status;
  @override

  /// [datePeriod] Relevant date for this case.
  Period? get datePeriod;
  @override

  /// [dateDateTime] Relevant date for this case.
  FhirDateTime? get dateDateTime;
  @override

  /// [dateDateTimeElement] ("_dateDateTime") Extensions for dateDateTime
  @JsonKey(name: '_dateDateTime')
  Element? get dateDateTimeElement;
  @override

  /// [application] A regulatory submission from an organization to a regulator, as part of an assessing case. Multiple applications may occur over time, with more or different information to support or modify the submission or the authorization. The applications can be considered as steps within the longer running case or procedure for this authorization process.
  List<RegulatedAuthorizationCase>? get application;
  @override
  @JsonKey(ignore: true)
  _$$_RegulatedAuthorizationCaseCopyWith<_$_RegulatedAuthorizationCase>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinition _$SubstanceDefinitionFromJson(Map<String, dynamic> json) {
  return _SubstanceDefinition.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinition {
  /// [resourceType] This is a SubstanceDefinition resource
  @JsonKey(unknownEnumValue: R5ResourceType.SubstanceDefinition)
  R5ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] Identifier by which this substance is known.
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [version] A business level version identifier of the substance.
  String? get version => throw _privateConstructorUsedError;

  /// [versionElement] ("_version") Extensions for version
  @JsonKey(name: '_version')
  Element? get versionElement => throw _privateConstructorUsedError;

  /// [status] Status of substance within the catalogue e.g. active, retired.
  CodeableConcept? get status => throw _privateConstructorUsedError;

  /// [classification] A high level categorization, e.g. polymer or nucleic acid, or food, chemical, biological, or a lower level such as the general types of polymer (linear or branch chain) or type of impurity (process related or contaminant).
  List<CodeableConcept>? get classification =>
      throw _privateConstructorUsedError;

  /// [domain] If the substance applies to human or veterinary use.
  CodeableConcept? get domain => throw _privateConstructorUsedError;

  /// [grade] The quality standard, established benchmark, to which substance complies (e.g. USP/NF, Ph. Eur, JP, BP, Company Standard).
  List<CodeableConcept>? get grade => throw _privateConstructorUsedError;

  /// [description] Textual description of the substance.
  Markdown? get description => throw _privateConstructorUsedError;

  /// [descriptionElement] ("_description") Extensions for description
  @JsonKey(name: '_description')
  Element? get descriptionElement => throw _privateConstructorUsedError;

  /// [informationSource] Supporting literature.
  List<Reference>? get informationSource => throw _privateConstructorUsedError;

  /// [note] Textual comment about the substance's catalogue or registry record.
  List<Annotation>? get note => throw _privateConstructorUsedError;

  /// [manufacturer] The entity that creates, makes, produces or fabricates the substance. This is a set of potential manufacturers but is not necessarily comprehensive.
  List<Reference>? get manufacturer => throw _privateConstructorUsedError;

  /// [supplier] An entity that is the source for the substance. It may be different from the manufacturer. Supplier is synonymous to a distributor.
  List<Reference>? get supplier => throw _privateConstructorUsedError;

  /// [moiety] Moiety, for structural modifications.
  List<SubstanceDefinitionMoiety>? get moiety =>
      throw _privateConstructorUsedError;

  /// [characterization] General specifications for this substance.
  List<SubstanceDefinitionCharacterization>? get characterization =>
      throw _privateConstructorUsedError;

  /// [property] General specifications for this substance.
  List<SubstanceDefinitionProperty>? get property =>
      throw _privateConstructorUsedError;

  /// [referenceInformation] General information detailing this substance.
  Reference? get referenceInformation => throw _privateConstructorUsedError;

  /// [molecularWeight] The average mass of a molecule of a compound compared to 1/12 the mass of carbon 12 and calculated as the sum of the atomic weights of the constituent atoms.
  List<SubstanceDefinitionMolecularWeight>? get molecularWeight =>
      throw _privateConstructorUsedError;

  /// [structure] Structural information.
  SubstanceDefinitionStructure? get structure =>
      throw _privateConstructorUsedError;

  /// [code] Codes associated with the substance.
  List<SubstanceDefinitionCode>? get code => throw _privateConstructorUsedError;

  /// [name] Names applicable to this substance.
  List<SubstanceDefinitionName>? get name => throw _privateConstructorUsedError;

  /// [relationship] A link between this substance and another, with details of the relationship.
  List<SubstanceDefinitionRelationship>? get relationship =>
      throw _privateConstructorUsedError;

  /// [nucleicAcid] Data items specific to nucleic acids.
  Reference? get nucleicAcid => throw _privateConstructorUsedError;

  /// [polymer] Data items specific to polymers.
  Reference? get polymer => throw _privateConstructorUsedError;

  /// [protein] Data items specific to proteins.
  Reference? get protein => throw _privateConstructorUsedError;

  /// [sourceMaterial] Material or taxonomic/anatomical source for the substance.
  SubstanceDefinitionSourceMaterial? get sourceMaterial =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionCopyWith<SubstanceDefinition> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionCopyWith<$Res> {
  factory $SubstanceDefinitionCopyWith(
          SubstanceDefinition value, $Res Function(SubstanceDefinition) then) =
      _$SubstanceDefinitionCopyWithImpl<$Res, SubstanceDefinition>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceDefinition)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      String? version,
      @JsonKey(name: '_version')
          Element? versionElement,
      CodeableConcept? status,
      List<CodeableConcept>? classification,
      CodeableConcept? domain,
      List<CodeableConcept>? grade,
      Markdown? description,
      @JsonKey(name: '_description')
          Element? descriptionElement,
      List<Reference>? informationSource,
      List<Annotation>? note,
      List<Reference>? manufacturer,
      List<Reference>? supplier,
      List<SubstanceDefinitionMoiety>? moiety,
      List<SubstanceDefinitionCharacterization>? characterization,
      List<SubstanceDefinitionProperty>? property,
      Reference? referenceInformation,
      List<SubstanceDefinitionMolecularWeight>? molecularWeight,
      SubstanceDefinitionStructure? structure,
      List<SubstanceDefinitionCode>? code,
      List<SubstanceDefinitionName>? name,
      List<SubstanceDefinitionRelationship>? relationship,
      Reference? nucleicAcid,
      Reference? polymer,
      Reference? protein,
      SubstanceDefinitionSourceMaterial? sourceMaterial});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $ElementCopyWith<$Res>? get versionElement;
  $CodeableConceptCopyWith<$Res>? get status;
  $CodeableConceptCopyWith<$Res>? get domain;
  $ElementCopyWith<$Res>? get descriptionElement;
  $ReferenceCopyWith<$Res>? get referenceInformation;
  $SubstanceDefinitionStructureCopyWith<$Res>? get structure;
  $ReferenceCopyWith<$Res>? get nucleicAcid;
  $ReferenceCopyWith<$Res>? get polymer;
  $ReferenceCopyWith<$Res>? get protein;
  $SubstanceDefinitionSourceMaterialCopyWith<$Res>? get sourceMaterial;
}

/// @nodoc
class _$SubstanceDefinitionCopyWithImpl<$Res, $Val extends SubstanceDefinition>
    implements $SubstanceDefinitionCopyWith<$Res> {
  _$SubstanceDefinitionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? version = freezed,
    Object? versionElement = freezed,
    Object? status = freezed,
    Object? classification = freezed,
    Object? domain = freezed,
    Object? grade = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? informationSource = freezed,
    Object? note = freezed,
    Object? manufacturer = freezed,
    Object? supplier = freezed,
    Object? moiety = freezed,
    Object? characterization = freezed,
    Object? property = freezed,
    Object? referenceInformation = freezed,
    Object? molecularWeight = freezed,
    Object? structure = freezed,
    Object? code = freezed,
    Object? name = freezed,
    Object? relationship = freezed,
    Object? nucleicAcid = freezed,
    Object? polymer = freezed,
    Object? protein = freezed,
    Object? sourceMaterial = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      version: freezed == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String?,
      versionElement: freezed == versionElement
          ? _value.versionElement
          : versionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      classification: freezed == classification
          ? _value.classification
          : classification // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      domain: freezed == domain
          ? _value.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      grade: freezed == grade
          ? _value.grade
          : grade // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      informationSource: freezed == informationSource
          ? _value.informationSource
          : informationSource // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      note: freezed == note
          ? _value.note
          : note // ignore: cast_nullable_to_non_nullable
              as List<Annotation>?,
      manufacturer: freezed == manufacturer
          ? _value.manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      supplier: freezed == supplier
          ? _value.supplier
          : supplier // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      moiety: freezed == moiety
          ? _value.moiety
          : moiety // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionMoiety>?,
      characterization: freezed == characterization
          ? _value.characterization
          : characterization // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionCharacterization>?,
      property: freezed == property
          ? _value.property
          : property // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionProperty>?,
      referenceInformation: freezed == referenceInformation
          ? _value.referenceInformation
          : referenceInformation // ignore: cast_nullable_to_non_nullable
              as Reference?,
      molecularWeight: freezed == molecularWeight
          ? _value.molecularWeight
          : molecularWeight // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionMolecularWeight>?,
      structure: freezed == structure
          ? _value.structure
          : structure // ignore: cast_nullable_to_non_nullable
              as SubstanceDefinitionStructure?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionCode>?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionName>?,
      relationship: freezed == relationship
          ? _value.relationship
          : relationship // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionRelationship>?,
      nucleicAcid: freezed == nucleicAcid
          ? _value.nucleicAcid
          : nucleicAcid // ignore: cast_nullable_to_non_nullable
              as Reference?,
      polymer: freezed == polymer
          ? _value.polymer
          : polymer // ignore: cast_nullable_to_non_nullable
              as Reference?,
      protein: freezed == protein
          ? _value.protein
          : protein // ignore: cast_nullable_to_non_nullable
              as Reference?,
      sourceMaterial: freezed == sourceMaterial
          ? _value.sourceMaterial
          : sourceMaterial // ignore: cast_nullable_to_non_nullable
              as SubstanceDefinitionSourceMaterial?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get versionElement {
    if (_value.versionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.versionElement!, (value) {
      return _then(_value.copyWith(versionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get domain {
    if (_value.domain == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.domain!, (value) {
      return _then(_value.copyWith(domain: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get descriptionElement {
    if (_value.descriptionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.descriptionElement!, (value) {
      return _then(_value.copyWith(descriptionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get referenceInformation {
    if (_value.referenceInformation == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.referenceInformation!, (value) {
      return _then(_value.copyWith(referenceInformation: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SubstanceDefinitionStructureCopyWith<$Res>? get structure {
    if (_value.structure == null) {
      return null;
    }

    return $SubstanceDefinitionStructureCopyWith<$Res>(_value.structure!,
        (value) {
      return _then(_value.copyWith(structure: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get nucleicAcid {
    if (_value.nucleicAcid == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.nucleicAcid!, (value) {
      return _then(_value.copyWith(nucleicAcid: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get polymer {
    if (_value.polymer == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.polymer!, (value) {
      return _then(_value.copyWith(polymer: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get protein {
    if (_value.protein == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.protein!, (value) {
      return _then(_value.copyWith(protein: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SubstanceDefinitionSourceMaterialCopyWith<$Res>? get sourceMaterial {
    if (_value.sourceMaterial == null) {
      return null;
    }

    return $SubstanceDefinitionSourceMaterialCopyWith<$Res>(
        _value.sourceMaterial!, (value) {
      return _then(_value.copyWith(sourceMaterial: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionCopyWith<$Res>
    implements $SubstanceDefinitionCopyWith<$Res> {
  factory _$$_SubstanceDefinitionCopyWith(_$_SubstanceDefinition value,
          $Res Function(_$_SubstanceDefinition) then) =
      __$$_SubstanceDefinitionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceDefinition)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      String? version,
      @JsonKey(name: '_version')
          Element? versionElement,
      CodeableConcept? status,
      List<CodeableConcept>? classification,
      CodeableConcept? domain,
      List<CodeableConcept>? grade,
      Markdown? description,
      @JsonKey(name: '_description')
          Element? descriptionElement,
      List<Reference>? informationSource,
      List<Annotation>? note,
      List<Reference>? manufacturer,
      List<Reference>? supplier,
      List<SubstanceDefinitionMoiety>? moiety,
      List<SubstanceDefinitionCharacterization>? characterization,
      List<SubstanceDefinitionProperty>? property,
      Reference? referenceInformation,
      List<SubstanceDefinitionMolecularWeight>? molecularWeight,
      SubstanceDefinitionStructure? structure,
      List<SubstanceDefinitionCode>? code,
      List<SubstanceDefinitionName>? name,
      List<SubstanceDefinitionRelationship>? relationship,
      Reference? nucleicAcid,
      Reference? polymer,
      Reference? protein,
      SubstanceDefinitionSourceMaterial? sourceMaterial});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $ElementCopyWith<$Res>? get versionElement;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
  @override
  $CodeableConceptCopyWith<$Res>? get domain;
  @override
  $ElementCopyWith<$Res>? get descriptionElement;
  @override
  $ReferenceCopyWith<$Res>? get referenceInformation;
  @override
  $SubstanceDefinitionStructureCopyWith<$Res>? get structure;
  @override
  $ReferenceCopyWith<$Res>? get nucleicAcid;
  @override
  $ReferenceCopyWith<$Res>? get polymer;
  @override
  $ReferenceCopyWith<$Res>? get protein;
  @override
  $SubstanceDefinitionSourceMaterialCopyWith<$Res>? get sourceMaterial;
}

/// @nodoc
class __$$_SubstanceDefinitionCopyWithImpl<$Res>
    extends _$SubstanceDefinitionCopyWithImpl<$Res, _$_SubstanceDefinition>
    implements _$$_SubstanceDefinitionCopyWith<$Res> {
  __$$_SubstanceDefinitionCopyWithImpl(_$_SubstanceDefinition _value,
      $Res Function(_$_SubstanceDefinition) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? version = freezed,
    Object? versionElement = freezed,
    Object? status = freezed,
    Object? classification = freezed,
    Object? domain = freezed,
    Object? grade = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? informationSource = freezed,
    Object? note = freezed,
    Object? manufacturer = freezed,
    Object? supplier = freezed,
    Object? moiety = freezed,
    Object? characterization = freezed,
    Object? property = freezed,
    Object? referenceInformation = freezed,
    Object? molecularWeight = freezed,
    Object? structure = freezed,
    Object? code = freezed,
    Object? name = freezed,
    Object? relationship = freezed,
    Object? nucleicAcid = freezed,
    Object? polymer = freezed,
    Object? protein = freezed,
    Object? sourceMaterial = freezed,
  }) {
    return _then(_$_SubstanceDefinition(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      version: freezed == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String?,
      versionElement: freezed == versionElement
          ? _value.versionElement
          : versionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      classification: freezed == classification
          ? _value._classification
          : classification // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      domain: freezed == domain
          ? _value.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      grade: freezed == grade
          ? _value._grade
          : grade // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      informationSource: freezed == informationSource
          ? _value._informationSource
          : informationSource // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      note: freezed == note
          ? _value._note
          : note // ignore: cast_nullable_to_non_nullable
              as List<Annotation>?,
      manufacturer: freezed == manufacturer
          ? _value._manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      supplier: freezed == supplier
          ? _value._supplier
          : supplier // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      moiety: freezed == moiety
          ? _value._moiety
          : moiety // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionMoiety>?,
      characterization: freezed == characterization
          ? _value._characterization
          : characterization // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionCharacterization>?,
      property: freezed == property
          ? _value._property
          : property // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionProperty>?,
      referenceInformation: freezed == referenceInformation
          ? _value.referenceInformation
          : referenceInformation // ignore: cast_nullable_to_non_nullable
              as Reference?,
      molecularWeight: freezed == molecularWeight
          ? _value._molecularWeight
          : molecularWeight // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionMolecularWeight>?,
      structure: freezed == structure
          ? _value.structure
          : structure // ignore: cast_nullable_to_non_nullable
              as SubstanceDefinitionStructure?,
      code: freezed == code
          ? _value._code
          : code // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionCode>?,
      name: freezed == name
          ? _value._name
          : name // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionName>?,
      relationship: freezed == relationship
          ? _value._relationship
          : relationship // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionRelationship>?,
      nucleicAcid: freezed == nucleicAcid
          ? _value.nucleicAcid
          : nucleicAcid // ignore: cast_nullable_to_non_nullable
              as Reference?,
      polymer: freezed == polymer
          ? _value.polymer
          : polymer // ignore: cast_nullable_to_non_nullable
              as Reference?,
      protein: freezed == protein
          ? _value.protein
          : protein // ignore: cast_nullable_to_non_nullable
              as Reference?,
      sourceMaterial: freezed == sourceMaterial
          ? _value.sourceMaterial
          : sourceMaterial // ignore: cast_nullable_to_non_nullable
              as SubstanceDefinitionSourceMaterial?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinition extends _SubstanceDefinition {
  _$_SubstanceDefinition(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceDefinition)
          this.resourceType = R5ResourceType.SubstanceDefinition,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules')
          this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language')
          this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      this.version,
      @JsonKey(name: '_version')
          this.versionElement,
      this.status,
      final List<CodeableConcept>? classification,
      this.domain,
      final List<CodeableConcept>? grade,
      this.description,
      @JsonKey(name: '_description')
          this.descriptionElement,
      final List<Reference>? informationSource,
      final List<Annotation>? note,
      final List<Reference>? manufacturer,
      final List<Reference>? supplier,
      final List<SubstanceDefinitionMoiety>? moiety,
      final List<SubstanceDefinitionCharacterization>? characterization,
      final List<SubstanceDefinitionProperty>? property,
      this.referenceInformation,
      final List<SubstanceDefinitionMolecularWeight>? molecularWeight,
      this.structure,
      final List<SubstanceDefinitionCode>? code,
      final List<SubstanceDefinitionName>? name,
      final List<SubstanceDefinitionRelationship>? relationship,
      this.nucleicAcid,
      this.polymer,
      this.protein,
      this.sourceMaterial})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _classification = classification,
        _grade = grade,
        _informationSource = informationSource,
        _note = note,
        _manufacturer = manufacturer,
        _supplier = supplier,
        _moiety = moiety,
        _characterization = characterization,
        _property = property,
        _molecularWeight = molecularWeight,
        _code = code,
        _name = name,
        _relationship = relationship,
        super._();

  factory _$_SubstanceDefinition.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionFromJson(json);

  /// [resourceType] This is a SubstanceDefinition resource
  @override
  @JsonKey(unknownEnumValue: R5ResourceType.SubstanceDefinition)
  final R5ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.
  @override
  final Code? language;

  /// [languageElement] ("_language") Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] Identifier by which this substance is known.
  final List<Identifier>? _identifier;

  /// [identifier] Identifier by which this substance is known.
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [version] A business level version identifier of the substance.
  @override
  final String? version;

  /// [versionElement] ("_version") Extensions for version
  @override
  @JsonKey(name: '_version')
  final Element? versionElement;

  /// [status] Status of substance within the catalogue e.g. active, retired.
  @override
  final CodeableConcept? status;

  /// [classification] A high level categorization, e.g. polymer or nucleic acid, or food, chemical, biological, or a lower level such as the general types of polymer (linear or branch chain) or type of impurity (process related or contaminant).
  final List<CodeableConcept>? _classification;

  /// [classification] A high level categorization, e.g. polymer or nucleic acid, or food, chemical, biological, or a lower level such as the general types of polymer (linear or branch chain) or type of impurity (process related or contaminant).
  @override
  List<CodeableConcept>? get classification {
    final value = _classification;
    if (value == null) return null;
    if (_classification is EqualUnmodifiableListView) return _classification;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [domain] If the substance applies to human or veterinary use.
  @override
  final CodeableConcept? domain;

  /// [grade] The quality standard, established benchmark, to which substance complies (e.g. USP/NF, Ph. Eur, JP, BP, Company Standard).
  final List<CodeableConcept>? _grade;

  /// [grade] The quality standard, established benchmark, to which substance complies (e.g. USP/NF, Ph. Eur, JP, BP, Company Standard).
  @override
  List<CodeableConcept>? get grade {
    final value = _grade;
    if (value == null) return null;
    if (_grade is EqualUnmodifiableListView) return _grade;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [description] Textual description of the substance.
  @override
  final Markdown? description;

  /// [descriptionElement] ("_description") Extensions for description
  @override
  @JsonKey(name: '_description')
  final Element? descriptionElement;

  /// [informationSource] Supporting literature.
  final List<Reference>? _informationSource;

  /// [informationSource] Supporting literature.
  @override
  List<Reference>? get informationSource {
    final value = _informationSource;
    if (value == null) return null;
    if (_informationSource is EqualUnmodifiableListView)
      return _informationSource;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [note] Textual comment about the substance's catalogue or registry record.
  final List<Annotation>? _note;

  /// [note] Textual comment about the substance's catalogue or registry record.
  @override
  List<Annotation>? get note {
    final value = _note;
    if (value == null) return null;
    if (_note is EqualUnmodifiableListView) return _note;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [manufacturer] The entity that creates, makes, produces or fabricates the substance. This is a set of potential manufacturers but is not necessarily comprehensive.
  final List<Reference>? _manufacturer;

  /// [manufacturer] The entity that creates, makes, produces or fabricates the substance. This is a set of potential manufacturers but is not necessarily comprehensive.
  @override
  List<Reference>? get manufacturer {
    final value = _manufacturer;
    if (value == null) return null;
    if (_manufacturer is EqualUnmodifiableListView) return _manufacturer;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [supplier] An entity that is the source for the substance. It may be different from the manufacturer. Supplier is synonymous to a distributor.
  final List<Reference>? _supplier;

  /// [supplier] An entity that is the source for the substance. It may be different from the manufacturer. Supplier is synonymous to a distributor.
  @override
  List<Reference>? get supplier {
    final value = _supplier;
    if (value == null) return null;
    if (_supplier is EqualUnmodifiableListView) return _supplier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [moiety] Moiety, for structural modifications.
  final List<SubstanceDefinitionMoiety>? _moiety;

  /// [moiety] Moiety, for structural modifications.
  @override
  List<SubstanceDefinitionMoiety>? get moiety {
    final value = _moiety;
    if (value == null) return null;
    if (_moiety is EqualUnmodifiableListView) return _moiety;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [characterization] General specifications for this substance.
  final List<SubstanceDefinitionCharacterization>? _characterization;

  /// [characterization] General specifications for this substance.
  @override
  List<SubstanceDefinitionCharacterization>? get characterization {
    final value = _characterization;
    if (value == null) return null;
    if (_characterization is EqualUnmodifiableListView)
      return _characterization;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [property] General specifications for this substance.
  final List<SubstanceDefinitionProperty>? _property;

  /// [property] General specifications for this substance.
  @override
  List<SubstanceDefinitionProperty>? get property {
    final value = _property;
    if (value == null) return null;
    if (_property is EqualUnmodifiableListView) return _property;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [referenceInformation] General information detailing this substance.
  @override
  final Reference? referenceInformation;

  /// [molecularWeight] The average mass of a molecule of a compound compared to 1/12 the mass of carbon 12 and calculated as the sum of the atomic weights of the constituent atoms.
  final List<SubstanceDefinitionMolecularWeight>? _molecularWeight;

  /// [molecularWeight] The average mass of a molecule of a compound compared to 1/12 the mass of carbon 12 and calculated as the sum of the atomic weights of the constituent atoms.
  @override
  List<SubstanceDefinitionMolecularWeight>? get molecularWeight {
    final value = _molecularWeight;
    if (value == null) return null;
    if (_molecularWeight is EqualUnmodifiableListView) return _molecularWeight;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [structure] Structural information.
  @override
  final SubstanceDefinitionStructure? structure;

  /// [code] Codes associated with the substance.
  final List<SubstanceDefinitionCode>? _code;

  /// [code] Codes associated with the substance.
  @override
  List<SubstanceDefinitionCode>? get code {
    final value = _code;
    if (value == null) return null;
    if (_code is EqualUnmodifiableListView) return _code;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [name] Names applicable to this substance.
  final List<SubstanceDefinitionName>? _name;

  /// [name] Names applicable to this substance.
  @override
  List<SubstanceDefinitionName>? get name {
    final value = _name;
    if (value == null) return null;
    if (_name is EqualUnmodifiableListView) return _name;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [relationship] A link between this substance and another, with details of the relationship.
  final List<SubstanceDefinitionRelationship>? _relationship;

  /// [relationship] A link between this substance and another, with details of the relationship.
  @override
  List<SubstanceDefinitionRelationship>? get relationship {
    final value = _relationship;
    if (value == null) return null;
    if (_relationship is EqualUnmodifiableListView) return _relationship;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [nucleicAcid] Data items specific to nucleic acids.
  @override
  final Reference? nucleicAcid;

  /// [polymer] Data items specific to polymers.
  @override
  final Reference? polymer;

  /// [protein] Data items specific to proteins.
  @override
  final Reference? protein;

  /// [sourceMaterial] Material or taxonomic/anatomical source for the substance.
  @override
  final SubstanceDefinitionSourceMaterial? sourceMaterial;

  @override
  String toString() {
    return 'SubstanceDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, version: $version, versionElement: $versionElement, status: $status, classification: $classification, domain: $domain, grade: $grade, description: $description, descriptionElement: $descriptionElement, informationSource: $informationSource, note: $note, manufacturer: $manufacturer, supplier: $supplier, moiety: $moiety, characterization: $characterization, property: $property, referenceInformation: $referenceInformation, molecularWeight: $molecularWeight, structure: $structure, code: $code, name: $name, relationship: $relationship, nucleicAcid: $nucleicAcid, polymer: $polymer, protein: $protein, sourceMaterial: $sourceMaterial)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinition &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            (identical(other.version, version) || other.version == version) &&
            (identical(other.versionElement, versionElement) ||
                other.versionElement == versionElement) &&
            (identical(other.status, status) || other.status == status) &&
            const DeepCollectionEquality()
                .equals(other._classification, _classification) &&
            (identical(other.domain, domain) || other.domain == domain) &&
            const DeepCollectionEquality().equals(other._grade, _grade) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.descriptionElement, descriptionElement) ||
                other.descriptionElement == descriptionElement) &&
            const DeepCollectionEquality()
                .equals(other._informationSource, _informationSource) &&
            const DeepCollectionEquality().equals(other._note, _note) &&
            const DeepCollectionEquality()
                .equals(other._manufacturer, _manufacturer) &&
            const DeepCollectionEquality().equals(other._supplier, _supplier) &&
            const DeepCollectionEquality().equals(other._moiety, _moiety) &&
            const DeepCollectionEquality()
                .equals(other._characterization, _characterization) &&
            const DeepCollectionEquality().equals(other._property, _property) &&
            (identical(other.referenceInformation, referenceInformation) ||
                other.referenceInformation == referenceInformation) &&
            const DeepCollectionEquality()
                .equals(other._molecularWeight, _molecularWeight) &&
            (identical(other.structure, structure) ||
                other.structure == structure) &&
            const DeepCollectionEquality().equals(other._code, _code) &&
            const DeepCollectionEquality().equals(other._name, _name) &&
            const DeepCollectionEquality()
                .equals(other._relationship, _relationship) &&
            (identical(other.nucleicAcid, nucleicAcid) ||
                other.nucleicAcid == nucleicAcid) &&
            (identical(other.polymer, polymer) || other.polymer == polymer) &&
            (identical(other.protein, protein) || other.protein == protein) &&
            (identical(other.sourceMaterial, sourceMaterial) ||
                other.sourceMaterial == sourceMaterial));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_identifier),
        version,
        versionElement,
        status,
        const DeepCollectionEquality().hash(_classification),
        domain,
        const DeepCollectionEquality().hash(_grade),
        description,
        descriptionElement,
        const DeepCollectionEquality().hash(_informationSource),
        const DeepCollectionEquality().hash(_note),
        const DeepCollectionEquality().hash(_manufacturer),
        const DeepCollectionEquality().hash(_supplier),
        const DeepCollectionEquality().hash(_moiety),
        const DeepCollectionEquality().hash(_characterization),
        const DeepCollectionEquality().hash(_property),
        referenceInformation,
        const DeepCollectionEquality().hash(_molecularWeight),
        structure,
        const DeepCollectionEquality().hash(_code),
        const DeepCollectionEquality().hash(_name),
        const DeepCollectionEquality().hash(_relationship),
        nucleicAcid,
        polymer,
        protein,
        sourceMaterial
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionCopyWith<_$_SubstanceDefinition> get copyWith =>
      __$$_SubstanceDefinitionCopyWithImpl<_$_SubstanceDefinition>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinition extends SubstanceDefinition {
  factory _SubstanceDefinition(
          {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceDefinition)
              final R5ResourceType resourceType,
          final FhirId? id,
          final Meta? meta,
          final FhirUri? implicitRules,
          @JsonKey(name: '_implicitRules')
              final Element? implicitRulesElement,
          final Code? language,
          @JsonKey(name: '_language')
              final Element? languageElement,
          final Narrative? text,
          final List<Resource>? contained,
          @JsonKey(name: 'extension')
              final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final List<Identifier>? identifier,
          final String? version,
          @JsonKey(name: '_version')
              final Element? versionElement,
          final CodeableConcept? status,
          final List<CodeableConcept>? classification,
          final CodeableConcept? domain,
          final List<CodeableConcept>? grade,
          final Markdown? description,
          @JsonKey(name: '_description')
              final Element? descriptionElement,
          final List<Reference>? informationSource,
          final List<Annotation>? note,
          final List<Reference>? manufacturer,
          final List<Reference>? supplier,
          final List<SubstanceDefinitionMoiety>? moiety,
          final List<SubstanceDefinitionCharacterization>? characterization,
          final List<SubstanceDefinitionProperty>? property,
          final Reference? referenceInformation,
          final List<SubstanceDefinitionMolecularWeight>? molecularWeight,
          final SubstanceDefinitionStructure? structure,
          final List<SubstanceDefinitionCode>? code,
          final List<SubstanceDefinitionName>? name,
          final List<SubstanceDefinitionRelationship>? relationship,
          final Reference? nucleicAcid,
          final Reference? polymer,
          final Reference? protein,
          final SubstanceDefinitionSourceMaterial? sourceMaterial}) =
      _$_SubstanceDefinition;
  _SubstanceDefinition._() : super._();

  factory _SubstanceDefinition.fromJson(Map<String, dynamic> json) =
      _$_SubstanceDefinition.fromJson;

  @override

  /// [resourceType] This is a SubstanceDefinition resource
  @JsonKey(unknownEnumValue: R5ResourceType.SubstanceDefinition)
  R5ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.
  Code? get language;
  @override

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained;
  @override

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] Identifier by which this substance is known.
  List<Identifier>? get identifier;
  @override

  /// [version] A business level version identifier of the substance.
  String? get version;
  @override

  /// [versionElement] ("_version") Extensions for version
  @JsonKey(name: '_version')
  Element? get versionElement;
  @override

  /// [status] Status of substance within the catalogue e.g. active, retired.
  CodeableConcept? get status;
  @override

  /// [classification] A high level categorization, e.g. polymer or nucleic acid, or food, chemical, biological, or a lower level such as the general types of polymer (linear or branch chain) or type of impurity (process related or contaminant).
  List<CodeableConcept>? get classification;
  @override

  /// [domain] If the substance applies to human or veterinary use.
  CodeableConcept? get domain;
  @override

  /// [grade] The quality standard, established benchmark, to which substance complies (e.g. USP/NF, Ph. Eur, JP, BP, Company Standard).
  List<CodeableConcept>? get grade;
  @override

  /// [description] Textual description of the substance.
  Markdown? get description;
  @override

  /// [descriptionElement] ("_description") Extensions for description
  @JsonKey(name: '_description')
  Element? get descriptionElement;
  @override

  /// [informationSource] Supporting literature.
  List<Reference>? get informationSource;
  @override

  /// [note] Textual comment about the substance's catalogue or registry record.
  List<Annotation>? get note;
  @override

  /// [manufacturer] The entity that creates, makes, produces or fabricates the substance. This is a set of potential manufacturers but is not necessarily comprehensive.
  List<Reference>? get manufacturer;
  @override

  /// [supplier] An entity that is the source for the substance. It may be different from the manufacturer. Supplier is synonymous to a distributor.
  List<Reference>? get supplier;
  @override

  /// [moiety] Moiety, for structural modifications.
  List<SubstanceDefinitionMoiety>? get moiety;
  @override

  /// [characterization] General specifications for this substance.
  List<SubstanceDefinitionCharacterization>? get characterization;
  @override

  /// [property] General specifications for this substance.
  List<SubstanceDefinitionProperty>? get property;
  @override

  /// [referenceInformation] General information detailing this substance.
  Reference? get referenceInformation;
  @override

  /// [molecularWeight] The average mass of a molecule of a compound compared to 1/12 the mass of carbon 12 and calculated as the sum of the atomic weights of the constituent atoms.
  List<SubstanceDefinitionMolecularWeight>? get molecularWeight;
  @override

  /// [structure] Structural information.
  SubstanceDefinitionStructure? get structure;
  @override

  /// [code] Codes associated with the substance.
  List<SubstanceDefinitionCode>? get code;
  @override

  /// [name] Names applicable to this substance.
  List<SubstanceDefinitionName>? get name;
  @override

  /// [relationship] A link between this substance and another, with details of the relationship.
  List<SubstanceDefinitionRelationship>? get relationship;
  @override

  /// [nucleicAcid] Data items specific to nucleic acids.
  Reference? get nucleicAcid;
  @override

  /// [polymer] Data items specific to polymers.
  Reference? get polymer;
  @override

  /// [protein] Data items specific to proteins.
  Reference? get protein;
  @override

  /// [sourceMaterial] Material or taxonomic/anatomical source for the substance.
  SubstanceDefinitionSourceMaterial? get sourceMaterial;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionCopyWith<_$_SubstanceDefinition> get copyWith =>
      throw _privateConstructorUsedError;
}

SubstanceDefinitionMoiety _$SubstanceDefinitionMoietyFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionMoiety.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionMoiety {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [role] Role that the moiety is playing.
  CodeableConcept? get role => throw _privateConstructorUsedError;

  /// [identifier] Identifier by which this moiety substance is known.
  Identifier? get identifier => throw _privateConstructorUsedError;

  /// [name] Textual name for this moiety substance.
  String? get name => throw _privateConstructorUsedError;

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement => throw _privateConstructorUsedError;

  /// [stereochemistry] Stereochemistry type.
  CodeableConcept? get stereochemistry => throw _privateConstructorUsedError;

  /// [opticalActivity] Optical activity type.
  CodeableConcept? get opticalActivity => throw _privateConstructorUsedError;

  /// [molecularFormula] Molecular formula for this moiety of this substance, typically using the Hill system.
  String? get molecularFormula => throw _privateConstructorUsedError;

  /// [molecularFormulaElement] ("_molecularFormula") Extensions for molecularFormula
  @JsonKey(name: '_molecularFormula')
  Element? get molecularFormulaElement => throw _privateConstructorUsedError;

  /// [amountQuantity] Quantitative value for this moiety.
  Quantity? get amountQuantity => throw _privateConstructorUsedError;

  /// [amountString] Quantitative value for this moiety.
  String? get amountString => throw _privateConstructorUsedError;

  /// [amountStringElement] ("_amountString") Extensions for amountString
  @JsonKey(name: '_amountString')
  Element? get amountStringElement => throw _privateConstructorUsedError;

  /// [measurementType] The measurement type of the quantitative value. In capturing the actual relative amounts of substances or molecular fragments it may be necessary to indicate whether the amount refers to, for example, a mole ratio or weight ratio.
  CodeableConcept? get measurementType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionMoietyCopyWith<SubstanceDefinitionMoiety> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionMoietyCopyWith<$Res> {
  factory $SubstanceDefinitionMoietyCopyWith(SubstanceDefinitionMoiety value,
          $Res Function(SubstanceDefinitionMoiety) then) =
      _$SubstanceDefinitionMoietyCopyWithImpl<$Res, SubstanceDefinitionMoiety>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? role,
      Identifier? identifier,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      CodeableConcept? stereochemistry,
      CodeableConcept? opticalActivity,
      String? molecularFormula,
      @JsonKey(name: '_molecularFormula') Element? molecularFormulaElement,
      Quantity? amountQuantity,
      String? amountString,
      @JsonKey(name: '_amountString') Element? amountStringElement,
      CodeableConcept? measurementType});

  $CodeableConceptCopyWith<$Res>? get role;
  $IdentifierCopyWith<$Res>? get identifier;
  $ElementCopyWith<$Res>? get nameElement;
  $CodeableConceptCopyWith<$Res>? get stereochemistry;
  $CodeableConceptCopyWith<$Res>? get opticalActivity;
  $ElementCopyWith<$Res>? get molecularFormulaElement;
  $QuantityCopyWith<$Res>? get amountQuantity;
  $ElementCopyWith<$Res>? get amountStringElement;
  $CodeableConceptCopyWith<$Res>? get measurementType;
}

/// @nodoc
class _$SubstanceDefinitionMoietyCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionMoiety>
    implements $SubstanceDefinitionMoietyCopyWith<$Res> {
  _$SubstanceDefinitionMoietyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? role = freezed,
    Object? identifier = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? stereochemistry = freezed,
    Object? opticalActivity = freezed,
    Object? molecularFormula = freezed,
    Object? molecularFormulaElement = freezed,
    Object? amountQuantity = freezed,
    Object? amountString = freezed,
    Object? amountStringElement = freezed,
    Object? measurementType = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      stereochemistry: freezed == stereochemistry
          ? _value.stereochemistry
          : stereochemistry // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      opticalActivity: freezed == opticalActivity
          ? _value.opticalActivity
          : opticalActivity // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      molecularFormula: freezed == molecularFormula
          ? _value.molecularFormula
          : molecularFormula // ignore: cast_nullable_to_non_nullable
              as String?,
      molecularFormulaElement: freezed == molecularFormulaElement
          ? _value.molecularFormulaElement
          : molecularFormulaElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      amountQuantity: freezed == amountQuantity
          ? _value.amountQuantity
          : amountQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      amountString: freezed == amountString
          ? _value.amountString
          : amountString // ignore: cast_nullable_to_non_nullable
              as String?,
      amountStringElement: freezed == amountStringElement
          ? _value.amountStringElement
          : amountStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      measurementType: freezed == measurementType
          ? _value.measurementType
          : measurementType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get role {
    if (_value.role == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.role!, (value) {
      return _then(_value.copyWith(role: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get identifier {
    if (_value.identifier == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.identifier!, (value) {
      return _then(_value.copyWith(identifier: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get nameElement {
    if (_value.nameElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.nameElement!, (value) {
      return _then(_value.copyWith(nameElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get stereochemistry {
    if (_value.stereochemistry == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.stereochemistry!, (value) {
      return _then(_value.copyWith(stereochemistry: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get opticalActivity {
    if (_value.opticalActivity == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.opticalActivity!, (value) {
      return _then(_value.copyWith(opticalActivity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get molecularFormulaElement {
    if (_value.molecularFormulaElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.molecularFormulaElement!, (value) {
      return _then(_value.copyWith(molecularFormulaElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get amountQuantity {
    if (_value.amountQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.amountQuantity!, (value) {
      return _then(_value.copyWith(amountQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get amountStringElement {
    if (_value.amountStringElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.amountStringElement!, (value) {
      return _then(_value.copyWith(amountStringElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get measurementType {
    if (_value.measurementType == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.measurementType!, (value) {
      return _then(_value.copyWith(measurementType: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionMoietyCopyWith<$Res>
    implements $SubstanceDefinitionMoietyCopyWith<$Res> {
  factory _$$_SubstanceDefinitionMoietyCopyWith(
          _$_SubstanceDefinitionMoiety value,
          $Res Function(_$_SubstanceDefinitionMoiety) then) =
      __$$_SubstanceDefinitionMoietyCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? role,
      Identifier? identifier,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      CodeableConcept? stereochemistry,
      CodeableConcept? opticalActivity,
      String? molecularFormula,
      @JsonKey(name: '_molecularFormula') Element? molecularFormulaElement,
      Quantity? amountQuantity,
      String? amountString,
      @JsonKey(name: '_amountString') Element? amountStringElement,
      CodeableConcept? measurementType});

  @override
  $CodeableConceptCopyWith<$Res>? get role;
  @override
  $IdentifierCopyWith<$Res>? get identifier;
  @override
  $ElementCopyWith<$Res>? get nameElement;
  @override
  $CodeableConceptCopyWith<$Res>? get stereochemistry;
  @override
  $CodeableConceptCopyWith<$Res>? get opticalActivity;
  @override
  $ElementCopyWith<$Res>? get molecularFormulaElement;
  @override
  $QuantityCopyWith<$Res>? get amountQuantity;
  @override
  $ElementCopyWith<$Res>? get amountStringElement;
  @override
  $CodeableConceptCopyWith<$Res>? get measurementType;
}

/// @nodoc
class __$$_SubstanceDefinitionMoietyCopyWithImpl<$Res>
    extends _$SubstanceDefinitionMoietyCopyWithImpl<$Res,
        _$_SubstanceDefinitionMoiety>
    implements _$$_SubstanceDefinitionMoietyCopyWith<$Res> {
  __$$_SubstanceDefinitionMoietyCopyWithImpl(
      _$_SubstanceDefinitionMoiety _value,
      $Res Function(_$_SubstanceDefinitionMoiety) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? role = freezed,
    Object? identifier = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? stereochemistry = freezed,
    Object? opticalActivity = freezed,
    Object? molecularFormula = freezed,
    Object? molecularFormulaElement = freezed,
    Object? amountQuantity = freezed,
    Object? amountString = freezed,
    Object? amountStringElement = freezed,
    Object? measurementType = freezed,
  }) {
    return _then(_$_SubstanceDefinitionMoiety(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      stereochemistry: freezed == stereochemistry
          ? _value.stereochemistry
          : stereochemistry // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      opticalActivity: freezed == opticalActivity
          ? _value.opticalActivity
          : opticalActivity // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      molecularFormula: freezed == molecularFormula
          ? _value.molecularFormula
          : molecularFormula // ignore: cast_nullable_to_non_nullable
              as String?,
      molecularFormulaElement: freezed == molecularFormulaElement
          ? _value.molecularFormulaElement
          : molecularFormulaElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      amountQuantity: freezed == amountQuantity
          ? _value.amountQuantity
          : amountQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      amountString: freezed == amountString
          ? _value.amountString
          : amountString // ignore: cast_nullable_to_non_nullable
              as String?,
      amountStringElement: freezed == amountStringElement
          ? _value.amountStringElement
          : amountStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      measurementType: freezed == measurementType
          ? _value.measurementType
          : measurementType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionMoiety extends _SubstanceDefinitionMoiety {
  _$_SubstanceDefinitionMoiety(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.role,
      this.identifier,
      this.name,
      @JsonKey(name: '_name') this.nameElement,
      this.stereochemistry,
      this.opticalActivity,
      this.molecularFormula,
      @JsonKey(name: '_molecularFormula') this.molecularFormulaElement,
      this.amountQuantity,
      this.amountString,
      @JsonKey(name: '_amountString') this.amountStringElement,
      this.measurementType})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstanceDefinitionMoiety.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionMoietyFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [role] Role that the moiety is playing.
  @override
  final CodeableConcept? role;

  /// [identifier] Identifier by which this moiety substance is known.
  @override
  final Identifier? identifier;

  /// [name] Textual name for this moiety substance.
  @override
  final String? name;

  /// [nameElement] ("_name") Extensions for name
  @override
  @JsonKey(name: '_name')
  final Element? nameElement;

  /// [stereochemistry] Stereochemistry type.
  @override
  final CodeableConcept? stereochemistry;

  /// [opticalActivity] Optical activity type.
  @override
  final CodeableConcept? opticalActivity;

  /// [molecularFormula] Molecular formula for this moiety of this substance, typically using the Hill system.
  @override
  final String? molecularFormula;

  /// [molecularFormulaElement] ("_molecularFormula") Extensions for molecularFormula
  @override
  @JsonKey(name: '_molecularFormula')
  final Element? molecularFormulaElement;

  /// [amountQuantity] Quantitative value for this moiety.
  @override
  final Quantity? amountQuantity;

  /// [amountString] Quantitative value for this moiety.
  @override
  final String? amountString;

  /// [amountStringElement] ("_amountString") Extensions for amountString
  @override
  @JsonKey(name: '_amountString')
  final Element? amountStringElement;

  /// [measurementType] The measurement type of the quantitative value. In capturing the actual relative amounts of substances or molecular fragments it may be necessary to indicate whether the amount refers to, for example, a mole ratio or weight ratio.
  @override
  final CodeableConcept? measurementType;

  @override
  String toString() {
    return 'SubstanceDefinitionMoiety(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, role: $role, identifier: $identifier, name: $name, nameElement: $nameElement, stereochemistry: $stereochemistry, opticalActivity: $opticalActivity, molecularFormula: $molecularFormula, molecularFormulaElement: $molecularFormulaElement, amountQuantity: $amountQuantity, amountString: $amountString, amountStringElement: $amountStringElement, measurementType: $measurementType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionMoiety &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.nameElement, nameElement) ||
                other.nameElement == nameElement) &&
            (identical(other.stereochemistry, stereochemistry) ||
                other.stereochemistry == stereochemistry) &&
            (identical(other.opticalActivity, opticalActivity) ||
                other.opticalActivity == opticalActivity) &&
            (identical(other.molecularFormula, molecularFormula) ||
                other.molecularFormula == molecularFormula) &&
            (identical(
                    other.molecularFormulaElement, molecularFormulaElement) ||
                other.molecularFormulaElement == molecularFormulaElement) &&
            (identical(other.amountQuantity, amountQuantity) ||
                other.amountQuantity == amountQuantity) &&
            (identical(other.amountString, amountString) ||
                other.amountString == amountString) &&
            (identical(other.amountStringElement, amountStringElement) ||
                other.amountStringElement == amountStringElement) &&
            (identical(other.measurementType, measurementType) ||
                other.measurementType == measurementType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      role,
      identifier,
      name,
      nameElement,
      stereochemistry,
      opticalActivity,
      molecularFormula,
      molecularFormulaElement,
      amountQuantity,
      amountString,
      amountStringElement,
      measurementType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionMoietyCopyWith<_$_SubstanceDefinitionMoiety>
      get copyWith => __$$_SubstanceDefinitionMoietyCopyWithImpl<
          _$_SubstanceDefinitionMoiety>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionMoietyToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionMoiety extends SubstanceDefinitionMoiety {
  factory _SubstanceDefinitionMoiety(
      {final String? id,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? role,
      final Identifier? identifier,
      final String? name,
      @JsonKey(name: '_name')
          final Element? nameElement,
      final CodeableConcept? stereochemistry,
      final CodeableConcept? opticalActivity,
      final String? molecularFormula,
      @JsonKey(name: '_molecularFormula')
          final Element? molecularFormulaElement,
      final Quantity? amountQuantity,
      final String? amountString,
      @JsonKey(name: '_amountString')
          final Element? amountStringElement,
      final CodeableConcept? measurementType}) = _$_SubstanceDefinitionMoiety;
  _SubstanceDefinitionMoiety._() : super._();

  factory _SubstanceDefinitionMoiety.fromJson(Map<String, dynamic> json) =
      _$_SubstanceDefinitionMoiety.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [role] Role that the moiety is playing.
  CodeableConcept? get role;
  @override

  /// [identifier] Identifier by which this moiety substance is known.
  Identifier? get identifier;
  @override

  /// [name] Textual name for this moiety substance.
  String? get name;
  @override

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement;
  @override

  /// [stereochemistry] Stereochemistry type.
  CodeableConcept? get stereochemistry;
  @override

  /// [opticalActivity] Optical activity type.
  CodeableConcept? get opticalActivity;
  @override

  /// [molecularFormula] Molecular formula for this moiety of this substance, typically using the Hill system.
  String? get molecularFormula;
  @override

  /// [molecularFormulaElement] ("_molecularFormula") Extensions for molecularFormula
  @JsonKey(name: '_molecularFormula')
  Element? get molecularFormulaElement;
  @override

  /// [amountQuantity] Quantitative value for this moiety.
  Quantity? get amountQuantity;
  @override

  /// [amountString] Quantitative value for this moiety.
  String? get amountString;
  @override

  /// [amountStringElement] ("_amountString") Extensions for amountString
  @JsonKey(name: '_amountString')
  Element? get amountStringElement;
  @override

  /// [measurementType] The measurement type of the quantitative value. In capturing the actual relative amounts of substances or molecular fragments it may be necessary to indicate whether the amount refers to, for example, a mole ratio or weight ratio.
  CodeableConcept? get measurementType;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionMoietyCopyWith<_$_SubstanceDefinitionMoiety>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinitionCharacterization
    _$SubstanceDefinitionCharacterizationFromJson(Map<String, dynamic> json) {
  return _SubstanceDefinitionCharacterization.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionCharacterization {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [technique] The method used to elucidate the characterization of the drug substance. Example: HPLC.
  CodeableConcept? get technique => throw _privateConstructorUsedError;

  /// [form] The specific chemical entity of the substance being characterized, to distinguish for example salt or base.
  CodeableConcept? get form => throw _privateConstructorUsedError;

  /// [description] Narrative text, data, tables about the characterization.
  Markdown? get description => throw _privateConstructorUsedError;

  /// [descriptionElement] ("_description") Extensions for description
  @JsonKey(name: '_description')
  Element? get descriptionElement => throw _privateConstructorUsedError;

  /// [file] An image or data file that characterizes this substance.
  List<Attachment>? get file => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionCharacterizationCopyWith<
          SubstanceDefinitionCharacterization>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionCharacterizationCopyWith<$Res> {
  factory $SubstanceDefinitionCharacterizationCopyWith(
          SubstanceDefinitionCharacterization value,
          $Res Function(SubstanceDefinitionCharacterization) then) =
      _$SubstanceDefinitionCharacterizationCopyWithImpl<$Res,
          SubstanceDefinitionCharacterization>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? technique,
      CodeableConcept? form,
      Markdown? description,
      @JsonKey(name: '_description') Element? descriptionElement,
      List<Attachment>? file});

  $CodeableConceptCopyWith<$Res>? get technique;
  $CodeableConceptCopyWith<$Res>? get form;
  $ElementCopyWith<$Res>? get descriptionElement;
}

/// @nodoc
class _$SubstanceDefinitionCharacterizationCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionCharacterization>
    implements $SubstanceDefinitionCharacterizationCopyWith<$Res> {
  _$SubstanceDefinitionCharacterizationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? technique = freezed,
    Object? form = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? file = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      technique: freezed == technique
          ? _value.technique
          : technique // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      form: freezed == form
          ? _value.form
          : form // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      file: freezed == file
          ? _value.file
          : file // ignore: cast_nullable_to_non_nullable
              as List<Attachment>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get technique {
    if (_value.technique == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.technique!, (value) {
      return _then(_value.copyWith(technique: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get form {
    if (_value.form == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.form!, (value) {
      return _then(_value.copyWith(form: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get descriptionElement {
    if (_value.descriptionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.descriptionElement!, (value) {
      return _then(_value.copyWith(descriptionElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionCharacterizationCopyWith<$Res>
    implements $SubstanceDefinitionCharacterizationCopyWith<$Res> {
  factory _$$_SubstanceDefinitionCharacterizationCopyWith(
          _$_SubstanceDefinitionCharacterization value,
          $Res Function(_$_SubstanceDefinitionCharacterization) then) =
      __$$_SubstanceDefinitionCharacterizationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? technique,
      CodeableConcept? form,
      Markdown? description,
      @JsonKey(name: '_description') Element? descriptionElement,
      List<Attachment>? file});

  @override
  $CodeableConceptCopyWith<$Res>? get technique;
  @override
  $CodeableConceptCopyWith<$Res>? get form;
  @override
  $ElementCopyWith<$Res>? get descriptionElement;
}

/// @nodoc
class __$$_SubstanceDefinitionCharacterizationCopyWithImpl<$Res>
    extends _$SubstanceDefinitionCharacterizationCopyWithImpl<$Res,
        _$_SubstanceDefinitionCharacterization>
    implements _$$_SubstanceDefinitionCharacterizationCopyWith<$Res> {
  __$$_SubstanceDefinitionCharacterizationCopyWithImpl(
      _$_SubstanceDefinitionCharacterization _value,
      $Res Function(_$_SubstanceDefinitionCharacterization) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? technique = freezed,
    Object? form = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? file = freezed,
  }) {
    return _then(_$_SubstanceDefinitionCharacterization(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      technique: freezed == technique
          ? _value.technique
          : technique // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      form: freezed == form
          ? _value.form
          : form // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      file: freezed == file
          ? _value._file
          : file // ignore: cast_nullable_to_non_nullable
              as List<Attachment>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionCharacterization
    extends _SubstanceDefinitionCharacterization {
  _$_SubstanceDefinitionCharacterization(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.technique,
      this.form,
      this.description,
      @JsonKey(name: '_description') this.descriptionElement,
      final List<Attachment>? file})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _file = file,
        super._();

  factory _$_SubstanceDefinitionCharacterization.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionCharacterizationFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [technique] The method used to elucidate the characterization of the drug substance. Example: HPLC.
  @override
  final CodeableConcept? technique;

  /// [form] The specific chemical entity of the substance being characterized, to distinguish for example salt or base.
  @override
  final CodeableConcept? form;

  /// [description] Narrative text, data, tables about the characterization.
  @override
  final Markdown? description;

  /// [descriptionElement] ("_description") Extensions for description
  @override
  @JsonKey(name: '_description')
  final Element? descriptionElement;

  /// [file] An image or data file that characterizes this substance.
  final List<Attachment>? _file;

  /// [file] An image or data file that characterizes this substance.
  @override
  List<Attachment>? get file {
    final value = _file;
    if (value == null) return null;
    if (_file is EqualUnmodifiableListView) return _file;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstanceDefinitionCharacterization(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, technique: $technique, form: $form, description: $description, descriptionElement: $descriptionElement, file: $file)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionCharacterization &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.technique, technique) ||
                other.technique == technique) &&
            (identical(other.form, form) || other.form == form) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.descriptionElement, descriptionElement) ||
                other.descriptionElement == descriptionElement) &&
            const DeepCollectionEquality().equals(other._file, _file));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      technique,
      form,
      description,
      descriptionElement,
      const DeepCollectionEquality().hash(_file));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionCharacterizationCopyWith<
          _$_SubstanceDefinitionCharacterization>
      get copyWith => __$$_SubstanceDefinitionCharacterizationCopyWithImpl<
          _$_SubstanceDefinitionCharacterization>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionCharacterizationToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionCharacterization
    extends SubstanceDefinitionCharacterization {
  factory _SubstanceDefinitionCharacterization(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? technique,
      final CodeableConcept? form,
      final Markdown? description,
      @JsonKey(name: '_description') final Element? descriptionElement,
      final List<Attachment>? file}) = _$_SubstanceDefinitionCharacterization;
  _SubstanceDefinitionCharacterization._() : super._();

  factory _SubstanceDefinitionCharacterization.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceDefinitionCharacterization.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [technique] The method used to elucidate the characterization of the drug substance. Example: HPLC.
  CodeableConcept? get technique;
  @override

  /// [form] The specific chemical entity of the substance being characterized, to distinguish for example salt or base.
  CodeableConcept? get form;
  @override

  /// [description] Narrative text, data, tables about the characterization.
  Markdown? get description;
  @override

  /// [descriptionElement] ("_description") Extensions for description
  @JsonKey(name: '_description')
  Element? get descriptionElement;
  @override

  /// [file] An image or data file that characterizes this substance.
  List<Attachment>? get file;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionCharacterizationCopyWith<
          _$_SubstanceDefinitionCharacterization>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinitionProperty _$SubstanceDefinitionPropertyFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionProperty.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionProperty {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] A code expressing the type of property.
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [valueCodeableConcept] A value for the property.
  CodeableConcept? get valueCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [valueQuantity] A value for the property.
  Quantity? get valueQuantity => throw _privateConstructorUsedError;

  /// [valueDate] A value for the property.
  Date? get valueDate => throw _privateConstructorUsedError;

  /// [valueDateElement] ("_valueDate") Extensions for valueDate
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement => throw _privateConstructorUsedError;

  /// [valueBoolean] A value for the property.
  Boolean? get valueBoolean => throw _privateConstructorUsedError;

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement => throw _privateConstructorUsedError;

  /// [valueAttachment] A value for the property.
  Attachment? get valueAttachment => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionPropertyCopyWith<SubstanceDefinitionProperty>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionPropertyCopyWith<$Res> {
  factory $SubstanceDefinitionPropertyCopyWith(
          SubstanceDefinitionProperty value,
          $Res Function(SubstanceDefinitionProperty) then) =
      _$SubstanceDefinitionPropertyCopyWithImpl<$Res,
          SubstanceDefinitionProperty>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      Quantity? valueQuantity,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment});

  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  $QuantityCopyWith<$Res>? get valueQuantity;
  $ElementCopyWith<$Res>? get valueDateElement;
  $ElementCopyWith<$Res>? get valueBooleanElement;
  $AttachmentCopyWith<$Res>? get valueAttachment;
}

/// @nodoc
class _$SubstanceDefinitionPropertyCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionProperty>
    implements $SubstanceDefinitionPropertyCopyWith<$Res> {
  _$SubstanceDefinitionPropertyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueQuantity = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept {
    if (_value.valueCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.valueCodeableConcept!,
        (value) {
      return _then(_value.copyWith(valueCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get valueQuantity {
    if (_value.valueQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.valueQuantity!, (value) {
      return _then(_value.copyWith(valueQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueDateElement {
    if (_value.valueDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueDateElement!, (value) {
      return _then(_value.copyWith(valueDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueBooleanElement {
    if (_value.valueBooleanElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueBooleanElement!, (value) {
      return _then(_value.copyWith(valueBooleanElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get valueAttachment {
    if (_value.valueAttachment == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.valueAttachment!, (value) {
      return _then(_value.copyWith(valueAttachment: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionPropertyCopyWith<$Res>
    implements $SubstanceDefinitionPropertyCopyWith<$Res> {
  factory _$$_SubstanceDefinitionPropertyCopyWith(
          _$_SubstanceDefinitionProperty value,
          $Res Function(_$_SubstanceDefinitionProperty) then) =
      __$$_SubstanceDefinitionPropertyCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      Quantity? valueQuantity,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  @override
  $QuantityCopyWith<$Res>? get valueQuantity;
  @override
  $ElementCopyWith<$Res>? get valueDateElement;
  @override
  $ElementCopyWith<$Res>? get valueBooleanElement;
  @override
  $AttachmentCopyWith<$Res>? get valueAttachment;
}

/// @nodoc
class __$$_SubstanceDefinitionPropertyCopyWithImpl<$Res>
    extends _$SubstanceDefinitionPropertyCopyWithImpl<$Res,
        _$_SubstanceDefinitionProperty>
    implements _$$_SubstanceDefinitionPropertyCopyWith<$Res> {
  __$$_SubstanceDefinitionPropertyCopyWithImpl(
      _$_SubstanceDefinitionProperty _value,
      $Res Function(_$_SubstanceDefinitionProperty) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueQuantity = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
  }) {
    return _then(_$_SubstanceDefinitionProperty(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionProperty extends _SubstanceDefinitionProperty {
  _$_SubstanceDefinitionProperty(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.type,
      this.valueCodeableConcept,
      this.valueQuantity,
      this.valueDate,
      @JsonKey(name: '_valueDate') this.valueDateElement,
      this.valueBoolean,
      @JsonKey(name: '_valueBoolean') this.valueBooleanElement,
      this.valueAttachment})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstanceDefinitionProperty.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionPropertyFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] A code expressing the type of property.
  @override
  final CodeableConcept type;

  /// [valueCodeableConcept] A value for the property.
  @override
  final CodeableConcept? valueCodeableConcept;

  /// [valueQuantity] A value for the property.
  @override
  final Quantity? valueQuantity;

  /// [valueDate] A value for the property.
  @override
  final Date? valueDate;

  /// [valueDateElement] ("_valueDate") Extensions for valueDate
  @override
  @JsonKey(name: '_valueDate')
  final Element? valueDateElement;

  /// [valueBoolean] A value for the property.
  @override
  final Boolean? valueBoolean;

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @override
  @JsonKey(name: '_valueBoolean')
  final Element? valueBooleanElement;

  /// [valueAttachment] A value for the property.
  @override
  final Attachment? valueAttachment;

  @override
  String toString() {
    return 'SubstanceDefinitionProperty(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, valueCodeableConcept: $valueCodeableConcept, valueQuantity: $valueQuantity, valueDate: $valueDate, valueDateElement: $valueDateElement, valueBoolean: $valueBoolean, valueBooleanElement: $valueBooleanElement, valueAttachment: $valueAttachment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionProperty &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.valueCodeableConcept, valueCodeableConcept) ||
                other.valueCodeableConcept == valueCodeableConcept) &&
            (identical(other.valueQuantity, valueQuantity) ||
                other.valueQuantity == valueQuantity) &&
            (identical(other.valueDate, valueDate) ||
                other.valueDate == valueDate) &&
            (identical(other.valueDateElement, valueDateElement) ||
                other.valueDateElement == valueDateElement) &&
            (identical(other.valueBoolean, valueBoolean) ||
                other.valueBoolean == valueBoolean) &&
            (identical(other.valueBooleanElement, valueBooleanElement) ||
                other.valueBooleanElement == valueBooleanElement) &&
            (identical(other.valueAttachment, valueAttachment) ||
                other.valueAttachment == valueAttachment));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      valueCodeableConcept,
      valueQuantity,
      valueDate,
      valueDateElement,
      valueBoolean,
      valueBooleanElement,
      valueAttachment);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionPropertyCopyWith<_$_SubstanceDefinitionProperty>
      get copyWith => __$$_SubstanceDefinitionPropertyCopyWithImpl<
          _$_SubstanceDefinitionProperty>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionPropertyToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionProperty
    extends SubstanceDefinitionProperty {
  factory _SubstanceDefinitionProperty(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final CodeableConcept type,
      final CodeableConcept? valueCodeableConcept,
      final Quantity? valueQuantity,
      final Date? valueDate,
      @JsonKey(name: '_valueDate') final Element? valueDateElement,
      final Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') final Element? valueBooleanElement,
      final Attachment? valueAttachment}) = _$_SubstanceDefinitionProperty;
  _SubstanceDefinitionProperty._() : super._();

  factory _SubstanceDefinitionProperty.fromJson(Map<String, dynamic> json) =
      _$_SubstanceDefinitionProperty.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] A code expressing the type of property.
  CodeableConcept get type;
  @override

  /// [valueCodeableConcept] A value for the property.
  CodeableConcept? get valueCodeableConcept;
  @override

  /// [valueQuantity] A value for the property.
  Quantity? get valueQuantity;
  @override

  /// [valueDate] A value for the property.
  Date? get valueDate;
  @override

  /// [valueDateElement] ("_valueDate") Extensions for valueDate
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement;
  @override

  /// [valueBoolean] A value for the property.
  Boolean? get valueBoolean;
  @override

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement;
  @override

  /// [valueAttachment] A value for the property.
  Attachment? get valueAttachment;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionPropertyCopyWith<_$_SubstanceDefinitionProperty>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinitionMolecularWeight _$SubstanceDefinitionMolecularWeightFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionMolecularWeight.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionMolecularWeight {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [method] The method by which the molecular weight was determined.
  CodeableConcept? get method => throw _privateConstructorUsedError;

  /// [type] Type of molecular weight such as exact, average (also known as. number average), weight average.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [amount] Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.
  Quantity get amount => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionMolecularWeightCopyWith<
          SubstanceDefinitionMolecularWeight>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionMolecularWeightCopyWith<$Res> {
  factory $SubstanceDefinitionMolecularWeightCopyWith(
          SubstanceDefinitionMolecularWeight value,
          $Res Function(SubstanceDefinitionMolecularWeight) then) =
      _$SubstanceDefinitionMolecularWeightCopyWithImpl<$Res,
          SubstanceDefinitionMolecularWeight>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? method,
      CodeableConcept? type,
      Quantity amount});

  $CodeableConceptCopyWith<$Res>? get method;
  $CodeableConceptCopyWith<$Res>? get type;
  $QuantityCopyWith<$Res> get amount;
}

/// @nodoc
class _$SubstanceDefinitionMolecularWeightCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionMolecularWeight>
    implements $SubstanceDefinitionMolecularWeightCopyWith<$Res> {
  _$SubstanceDefinitionMolecularWeightCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? method = freezed,
    Object? type = freezed,
    Object? amount = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      method: freezed == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Quantity,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get method {
    if (_value.method == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.method!, (value) {
      return _then(_value.copyWith(method: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res> get amount {
    return $QuantityCopyWith<$Res>(_value.amount, (value) {
      return _then(_value.copyWith(amount: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionMolecularWeightCopyWith<$Res>
    implements $SubstanceDefinitionMolecularWeightCopyWith<$Res> {
  factory _$$_SubstanceDefinitionMolecularWeightCopyWith(
          _$_SubstanceDefinitionMolecularWeight value,
          $Res Function(_$_SubstanceDefinitionMolecularWeight) then) =
      __$$_SubstanceDefinitionMolecularWeightCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? method,
      CodeableConcept? type,
      Quantity amount});

  @override
  $CodeableConceptCopyWith<$Res>? get method;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $QuantityCopyWith<$Res> get amount;
}

/// @nodoc
class __$$_SubstanceDefinitionMolecularWeightCopyWithImpl<$Res>
    extends _$SubstanceDefinitionMolecularWeightCopyWithImpl<$Res,
        _$_SubstanceDefinitionMolecularWeight>
    implements _$$_SubstanceDefinitionMolecularWeightCopyWith<$Res> {
  __$$_SubstanceDefinitionMolecularWeightCopyWithImpl(
      _$_SubstanceDefinitionMolecularWeight _value,
      $Res Function(_$_SubstanceDefinitionMolecularWeight) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? method = freezed,
    Object? type = freezed,
    Object? amount = null,
  }) {
    return _then(_$_SubstanceDefinitionMolecularWeight(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      method: freezed == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Quantity,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionMolecularWeight
    extends _SubstanceDefinitionMolecularWeight {
  _$_SubstanceDefinitionMolecularWeight(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.method,
      this.type,
      required this.amount})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstanceDefinitionMolecularWeight.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionMolecularWeightFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [method] The method by which the molecular weight was determined.
  @override
  final CodeableConcept? method;

  /// [type] Type of molecular weight such as exact, average (also known as. number average), weight average.
  @override
  final CodeableConcept? type;

  /// [amount] Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.
  @override
  final Quantity amount;

  @override
  String toString() {
    return 'SubstanceDefinitionMolecularWeight(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, method: $method, type: $type, amount: $amount)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionMolecularWeight &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.method, method) || other.method == method) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.amount, amount) || other.amount == amount));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      method,
      type,
      amount);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionMolecularWeightCopyWith<
          _$_SubstanceDefinitionMolecularWeight>
      get copyWith => __$$_SubstanceDefinitionMolecularWeightCopyWithImpl<
          _$_SubstanceDefinitionMolecularWeight>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionMolecularWeightToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionMolecularWeight
    extends SubstanceDefinitionMolecularWeight {
  factory _SubstanceDefinitionMolecularWeight(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? method,
      final CodeableConcept? type,
      required final Quantity amount}) = _$_SubstanceDefinitionMolecularWeight;
  _SubstanceDefinitionMolecularWeight._() : super._();

  factory _SubstanceDefinitionMolecularWeight.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceDefinitionMolecularWeight.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [method] The method by which the molecular weight was determined.
  CodeableConcept? get method;
  @override

  /// [type] Type of molecular weight such as exact, average (also known as. number average), weight average.
  CodeableConcept? get type;
  @override

  /// [amount] Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.
  Quantity get amount;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionMolecularWeightCopyWith<
          _$_SubstanceDefinitionMolecularWeight>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinitionStructure _$SubstanceDefinitionStructureFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionStructure.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionStructure {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [stereochemistry] Stereochemistry type.
  CodeableConcept? get stereochemistry => throw _privateConstructorUsedError;

  /// [opticalActivity] Optical activity type.
  CodeableConcept? get opticalActivity => throw _privateConstructorUsedError;

  /// [molecularFormula] An expression which states the number and type of atoms present in a molecule of a substance.
  String? get molecularFormula => throw _privateConstructorUsedError;

  /// [molecularFormulaElement] ("_molecularFormula") Extensions for molecularFormula
  @JsonKey(name: '_molecularFormula')
  Element? get molecularFormulaElement => throw _privateConstructorUsedError;

  /// [molecularFormulaByMoiety] Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.
  String? get molecularFormulaByMoiety => throw _privateConstructorUsedError;

  /// [molecularFormulaByMoietyElement] ("_molecularFormulaByMoiety") Extensions for molecularFormulaByMoiety
  @JsonKey(name: '_molecularFormulaByMoiety')
  Element? get molecularFormulaByMoietyElement =>
      throw _privateConstructorUsedError;

  /// [molecularWeight] The molecular weight or weight range (for proteins, polymers or nucleic acids).
  SubstanceDefinitionMolecularWeight? get molecularWeight =>
      throw _privateConstructorUsedError;

  /// [technique] The method used to elucidate the structure of the drug substance. Examples: X-ray, NMR, Peptide mapping, Ligand binding assay.
  List<CodeableConcept>? get technique => throw _privateConstructorUsedError;

  /// [sourceDocument] The source of information about the structure.
  List<Reference>? get sourceDocument => throw _privateConstructorUsedError;

  /// [representation] A depiction of the structure of the substance.
  List<SubstanceDefinitionRepresentation>? get representation =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionStructureCopyWith<SubstanceDefinitionStructure>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionStructureCopyWith<$Res> {
  factory $SubstanceDefinitionStructureCopyWith(
          SubstanceDefinitionStructure value,
          $Res Function(SubstanceDefinitionStructure) then) =
      _$SubstanceDefinitionStructureCopyWithImpl<$Res,
          SubstanceDefinitionStructure>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? stereochemistry,
      CodeableConcept? opticalActivity,
      String? molecularFormula,
      @JsonKey(name: '_molecularFormula')
          Element? molecularFormulaElement,
      String? molecularFormulaByMoiety,
      @JsonKey(name: '_molecularFormulaByMoiety')
          Element? molecularFormulaByMoietyElement,
      SubstanceDefinitionMolecularWeight? molecularWeight,
      List<CodeableConcept>? technique,
      List<Reference>? sourceDocument,
      List<SubstanceDefinitionRepresentation>? representation});

  $CodeableConceptCopyWith<$Res>? get stereochemistry;
  $CodeableConceptCopyWith<$Res>? get opticalActivity;
  $ElementCopyWith<$Res>? get molecularFormulaElement;
  $ElementCopyWith<$Res>? get molecularFormulaByMoietyElement;
  $SubstanceDefinitionMolecularWeightCopyWith<$Res>? get molecularWeight;
}

/// @nodoc
class _$SubstanceDefinitionStructureCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionStructure>
    implements $SubstanceDefinitionStructureCopyWith<$Res> {
  _$SubstanceDefinitionStructureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? stereochemistry = freezed,
    Object? opticalActivity = freezed,
    Object? molecularFormula = freezed,
    Object? molecularFormulaElement = freezed,
    Object? molecularFormulaByMoiety = freezed,
    Object? molecularFormulaByMoietyElement = freezed,
    Object? molecularWeight = freezed,
    Object? technique = freezed,
    Object? sourceDocument = freezed,
    Object? representation = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      stereochemistry: freezed == stereochemistry
          ? _value.stereochemistry
          : stereochemistry // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      opticalActivity: freezed == opticalActivity
          ? _value.opticalActivity
          : opticalActivity // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      molecularFormula: freezed == molecularFormula
          ? _value.molecularFormula
          : molecularFormula // ignore: cast_nullable_to_non_nullable
              as String?,
      molecularFormulaElement: freezed == molecularFormulaElement
          ? _value.molecularFormulaElement
          : molecularFormulaElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      molecularFormulaByMoiety: freezed == molecularFormulaByMoiety
          ? _value.molecularFormulaByMoiety
          : molecularFormulaByMoiety // ignore: cast_nullable_to_non_nullable
              as String?,
      molecularFormulaByMoietyElement: freezed ==
              molecularFormulaByMoietyElement
          ? _value.molecularFormulaByMoietyElement
          : molecularFormulaByMoietyElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      molecularWeight: freezed == molecularWeight
          ? _value.molecularWeight
          : molecularWeight // ignore: cast_nullable_to_non_nullable
              as SubstanceDefinitionMolecularWeight?,
      technique: freezed == technique
          ? _value.technique
          : technique // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      sourceDocument: freezed == sourceDocument
          ? _value.sourceDocument
          : sourceDocument // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      representation: freezed == representation
          ? _value.representation
          : representation // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionRepresentation>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get stereochemistry {
    if (_value.stereochemistry == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.stereochemistry!, (value) {
      return _then(_value.copyWith(stereochemistry: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get opticalActivity {
    if (_value.opticalActivity == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.opticalActivity!, (value) {
      return _then(_value.copyWith(opticalActivity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get molecularFormulaElement {
    if (_value.molecularFormulaElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.molecularFormulaElement!, (value) {
      return _then(_value.copyWith(molecularFormulaElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get molecularFormulaByMoietyElement {
    if (_value.molecularFormulaByMoietyElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.molecularFormulaByMoietyElement!,
        (value) {
      return _then(
          _value.copyWith(molecularFormulaByMoietyElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SubstanceDefinitionMolecularWeightCopyWith<$Res>? get molecularWeight {
    if (_value.molecularWeight == null) {
      return null;
    }

    return $SubstanceDefinitionMolecularWeightCopyWith<$Res>(
        _value.molecularWeight!, (value) {
      return _then(_value.copyWith(molecularWeight: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionStructureCopyWith<$Res>
    implements $SubstanceDefinitionStructureCopyWith<$Res> {
  factory _$$_SubstanceDefinitionStructureCopyWith(
          _$_SubstanceDefinitionStructure value,
          $Res Function(_$_SubstanceDefinitionStructure) then) =
      __$$_SubstanceDefinitionStructureCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? stereochemistry,
      CodeableConcept? opticalActivity,
      String? molecularFormula,
      @JsonKey(name: '_molecularFormula')
          Element? molecularFormulaElement,
      String? molecularFormulaByMoiety,
      @JsonKey(name: '_molecularFormulaByMoiety')
          Element? molecularFormulaByMoietyElement,
      SubstanceDefinitionMolecularWeight? molecularWeight,
      List<CodeableConcept>? technique,
      List<Reference>? sourceDocument,
      List<SubstanceDefinitionRepresentation>? representation});

  @override
  $CodeableConceptCopyWith<$Res>? get stereochemistry;
  @override
  $CodeableConceptCopyWith<$Res>? get opticalActivity;
  @override
  $ElementCopyWith<$Res>? get molecularFormulaElement;
  @override
  $ElementCopyWith<$Res>? get molecularFormulaByMoietyElement;
  @override
  $SubstanceDefinitionMolecularWeightCopyWith<$Res>? get molecularWeight;
}

/// @nodoc
class __$$_SubstanceDefinitionStructureCopyWithImpl<$Res>
    extends _$SubstanceDefinitionStructureCopyWithImpl<$Res,
        _$_SubstanceDefinitionStructure>
    implements _$$_SubstanceDefinitionStructureCopyWith<$Res> {
  __$$_SubstanceDefinitionStructureCopyWithImpl(
      _$_SubstanceDefinitionStructure _value,
      $Res Function(_$_SubstanceDefinitionStructure) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? stereochemistry = freezed,
    Object? opticalActivity = freezed,
    Object? molecularFormula = freezed,
    Object? molecularFormulaElement = freezed,
    Object? molecularFormulaByMoiety = freezed,
    Object? molecularFormulaByMoietyElement = freezed,
    Object? molecularWeight = freezed,
    Object? technique = freezed,
    Object? sourceDocument = freezed,
    Object? representation = freezed,
  }) {
    return _then(_$_SubstanceDefinitionStructure(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      stereochemistry: freezed == stereochemistry
          ? _value.stereochemistry
          : stereochemistry // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      opticalActivity: freezed == opticalActivity
          ? _value.opticalActivity
          : opticalActivity // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      molecularFormula: freezed == molecularFormula
          ? _value.molecularFormula
          : molecularFormula // ignore: cast_nullable_to_non_nullable
              as String?,
      molecularFormulaElement: freezed == molecularFormulaElement
          ? _value.molecularFormulaElement
          : molecularFormulaElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      molecularFormulaByMoiety: freezed == molecularFormulaByMoiety
          ? _value.molecularFormulaByMoiety
          : molecularFormulaByMoiety // ignore: cast_nullable_to_non_nullable
              as String?,
      molecularFormulaByMoietyElement: freezed ==
              molecularFormulaByMoietyElement
          ? _value.molecularFormulaByMoietyElement
          : molecularFormulaByMoietyElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      molecularWeight: freezed == molecularWeight
          ? _value.molecularWeight
          : molecularWeight // ignore: cast_nullable_to_non_nullable
              as SubstanceDefinitionMolecularWeight?,
      technique: freezed == technique
          ? _value._technique
          : technique // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      sourceDocument: freezed == sourceDocument
          ? _value._sourceDocument
          : sourceDocument // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      representation: freezed == representation
          ? _value._representation
          : representation // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionRepresentation>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionStructure extends _SubstanceDefinitionStructure {
  _$_SubstanceDefinitionStructure(
      {this.id,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.stereochemistry,
      this.opticalActivity,
      this.molecularFormula,
      @JsonKey(name: '_molecularFormula')
          this.molecularFormulaElement,
      this.molecularFormulaByMoiety,
      @JsonKey(name: '_molecularFormulaByMoiety')
          this.molecularFormulaByMoietyElement,
      this.molecularWeight,
      final List<CodeableConcept>? technique,
      final List<Reference>? sourceDocument,
      final List<SubstanceDefinitionRepresentation>? representation})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _technique = technique,
        _sourceDocument = sourceDocument,
        _representation = representation,
        super._();

  factory _$_SubstanceDefinitionStructure.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionStructureFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [stereochemistry] Stereochemistry type.
  @override
  final CodeableConcept? stereochemistry;

  /// [opticalActivity] Optical activity type.
  @override
  final CodeableConcept? opticalActivity;

  /// [molecularFormula] An expression which states the number and type of atoms present in a molecule of a substance.
  @override
  final String? molecularFormula;

  /// [molecularFormulaElement] ("_molecularFormula") Extensions for molecularFormula
  @override
  @JsonKey(name: '_molecularFormula')
  final Element? molecularFormulaElement;

  /// [molecularFormulaByMoiety] Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.
  @override
  final String? molecularFormulaByMoiety;

  /// [molecularFormulaByMoietyElement] ("_molecularFormulaByMoiety") Extensions for molecularFormulaByMoiety
  @override
  @JsonKey(name: '_molecularFormulaByMoiety')
  final Element? molecularFormulaByMoietyElement;

  /// [molecularWeight] The molecular weight or weight range (for proteins, polymers or nucleic acids).
  @override
  final SubstanceDefinitionMolecularWeight? molecularWeight;

  /// [technique] The method used to elucidate the structure of the drug substance. Examples: X-ray, NMR, Peptide mapping, Ligand binding assay.
  final List<CodeableConcept>? _technique;

  /// [technique] The method used to elucidate the structure of the drug substance. Examples: X-ray, NMR, Peptide mapping, Ligand binding assay.
  @override
  List<CodeableConcept>? get technique {
    final value = _technique;
    if (value == null) return null;
    if (_technique is EqualUnmodifiableListView) return _technique;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [sourceDocument] The source of information about the structure.
  final List<Reference>? _sourceDocument;

  /// [sourceDocument] The source of information about the structure.
  @override
  List<Reference>? get sourceDocument {
    final value = _sourceDocument;
    if (value == null) return null;
    if (_sourceDocument is EqualUnmodifiableListView) return _sourceDocument;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [representation] A depiction of the structure of the substance.
  final List<SubstanceDefinitionRepresentation>? _representation;

  /// [representation] A depiction of the structure of the substance.
  @override
  List<SubstanceDefinitionRepresentation>? get representation {
    final value = _representation;
    if (value == null) return null;
    if (_representation is EqualUnmodifiableListView) return _representation;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstanceDefinitionStructure(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, stereochemistry: $stereochemistry, opticalActivity: $opticalActivity, molecularFormula: $molecularFormula, molecularFormulaElement: $molecularFormulaElement, molecularFormulaByMoiety: $molecularFormulaByMoiety, molecularFormulaByMoietyElement: $molecularFormulaByMoietyElement, molecularWeight: $molecularWeight, technique: $technique, sourceDocument: $sourceDocument, representation: $representation)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionStructure &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.stereochemistry, stereochemistry) ||
                other.stereochemistry == stereochemistry) &&
            (identical(other.opticalActivity, opticalActivity) ||
                other.opticalActivity == opticalActivity) &&
            (identical(other.molecularFormula, molecularFormula) ||
                other.molecularFormula == molecularFormula) &&
            (identical(
                    other.molecularFormulaElement, molecularFormulaElement) ||
                other.molecularFormulaElement == molecularFormulaElement) &&
            (identical(
                    other.molecularFormulaByMoiety, molecularFormulaByMoiety) ||
                other.molecularFormulaByMoiety == molecularFormulaByMoiety) &&
            (identical(other.molecularFormulaByMoietyElement,
                    molecularFormulaByMoietyElement) ||
                other.molecularFormulaByMoietyElement ==
                    molecularFormulaByMoietyElement) &&
            (identical(other.molecularWeight, molecularWeight) ||
                other.molecularWeight == molecularWeight) &&
            const DeepCollectionEquality()
                .equals(other._technique, _technique) &&
            const DeepCollectionEquality()
                .equals(other._sourceDocument, _sourceDocument) &&
            const DeepCollectionEquality()
                .equals(other._representation, _representation));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      stereochemistry,
      opticalActivity,
      molecularFormula,
      molecularFormulaElement,
      molecularFormulaByMoiety,
      molecularFormulaByMoietyElement,
      molecularWeight,
      const DeepCollectionEquality().hash(_technique),
      const DeepCollectionEquality().hash(_sourceDocument),
      const DeepCollectionEquality().hash(_representation));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionStructureCopyWith<_$_SubstanceDefinitionStructure>
      get copyWith => __$$_SubstanceDefinitionStructureCopyWithImpl<
          _$_SubstanceDefinitionStructure>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionStructureToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionStructure
    extends SubstanceDefinitionStructure {
  factory _SubstanceDefinitionStructure(
          {final String? id,
          @JsonKey(name: 'extension')
              final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableConcept? stereochemistry,
          final CodeableConcept? opticalActivity,
          final String? molecularFormula,
          @JsonKey(name: '_molecularFormula')
              final Element? molecularFormulaElement,
          final String? molecularFormulaByMoiety,
          @JsonKey(name: '_molecularFormulaByMoiety')
              final Element? molecularFormulaByMoietyElement,
          final SubstanceDefinitionMolecularWeight? molecularWeight,
          final List<CodeableConcept>? technique,
          final List<Reference>? sourceDocument,
          final List<SubstanceDefinitionRepresentation>? representation}) =
      _$_SubstanceDefinitionStructure;
  _SubstanceDefinitionStructure._() : super._();

  factory _SubstanceDefinitionStructure.fromJson(Map<String, dynamic> json) =
      _$_SubstanceDefinitionStructure.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [stereochemistry] Stereochemistry type.
  CodeableConcept? get stereochemistry;
  @override

  /// [opticalActivity] Optical activity type.
  CodeableConcept? get opticalActivity;
  @override

  /// [molecularFormula] An expression which states the number and type of atoms present in a molecule of a substance.
  String? get molecularFormula;
  @override

  /// [molecularFormulaElement] ("_molecularFormula") Extensions for molecularFormula
  @JsonKey(name: '_molecularFormula')
  Element? get molecularFormulaElement;
  @override

  /// [molecularFormulaByMoiety] Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.
  String? get molecularFormulaByMoiety;
  @override

  /// [molecularFormulaByMoietyElement] ("_molecularFormulaByMoiety") Extensions for molecularFormulaByMoiety
  @JsonKey(name: '_molecularFormulaByMoiety')
  Element? get molecularFormulaByMoietyElement;
  @override

  /// [molecularWeight] The molecular weight or weight range (for proteins, polymers or nucleic acids).
  SubstanceDefinitionMolecularWeight? get molecularWeight;
  @override

  /// [technique] The method used to elucidate the structure of the drug substance. Examples: X-ray, NMR, Peptide mapping, Ligand binding assay.
  List<CodeableConcept>? get technique;
  @override

  /// [sourceDocument] The source of information about the structure.
  List<Reference>? get sourceDocument;
  @override

  /// [representation] A depiction of the structure of the substance.
  List<SubstanceDefinitionRepresentation>? get representation;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionStructureCopyWith<_$_SubstanceDefinitionStructure>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinitionRepresentation _$SubstanceDefinitionRepresentationFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionRepresentation.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionRepresentation {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] The kind of structural representation (e.g. full, partial).
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [representation] The structural representation as a text string in a standard format.
  String? get representation => throw _privateConstructorUsedError;

  /// [representationElement] ("_representation") Extensions for representation
  @JsonKey(name: '_representation')
  Element? get representationElement => throw _privateConstructorUsedError;

  /// [format] The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF. The logical content type rather than the physical file format of a document.
  CodeableConcept? get format => throw _privateConstructorUsedError;

  /// [document] An attached file with the structural representation e.g. a molecular structure graphic of the substance, a JCAMP or AnIML file.
  Reference? get document => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionRepresentationCopyWith<SubstanceDefinitionRepresentation>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionRepresentationCopyWith<$Res> {
  factory $SubstanceDefinitionRepresentationCopyWith(
          SubstanceDefinitionRepresentation value,
          $Res Function(SubstanceDefinitionRepresentation) then) =
      _$SubstanceDefinitionRepresentationCopyWithImpl<$Res,
          SubstanceDefinitionRepresentation>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      String? representation,
      @JsonKey(name: '_representation') Element? representationElement,
      CodeableConcept? format,
      Reference? document});

  $CodeableConceptCopyWith<$Res>? get type;
  $ElementCopyWith<$Res>? get representationElement;
  $CodeableConceptCopyWith<$Res>? get format;
  $ReferenceCopyWith<$Res>? get document;
}

/// @nodoc
class _$SubstanceDefinitionRepresentationCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionRepresentation>
    implements $SubstanceDefinitionRepresentationCopyWith<$Res> {
  _$SubstanceDefinitionRepresentationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? representation = freezed,
    Object? representationElement = freezed,
    Object? format = freezed,
    Object? document = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      representation: freezed == representation
          ? _value.representation
          : representation // ignore: cast_nullable_to_non_nullable
              as String?,
      representationElement: freezed == representationElement
          ? _value.representationElement
          : representationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      format: freezed == format
          ? _value.format
          : format // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      document: freezed == document
          ? _value.document
          : document // ignore: cast_nullable_to_non_nullable
              as Reference?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get representationElement {
    if (_value.representationElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.representationElement!, (value) {
      return _then(_value.copyWith(representationElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get format {
    if (_value.format == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.format!, (value) {
      return _then(_value.copyWith(format: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get document {
    if (_value.document == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.document!, (value) {
      return _then(_value.copyWith(document: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionRepresentationCopyWith<$Res>
    implements $SubstanceDefinitionRepresentationCopyWith<$Res> {
  factory _$$_SubstanceDefinitionRepresentationCopyWith(
          _$_SubstanceDefinitionRepresentation value,
          $Res Function(_$_SubstanceDefinitionRepresentation) then) =
      __$$_SubstanceDefinitionRepresentationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      String? representation,
      @JsonKey(name: '_representation') Element? representationElement,
      CodeableConcept? format,
      Reference? document});

  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $ElementCopyWith<$Res>? get representationElement;
  @override
  $CodeableConceptCopyWith<$Res>? get format;
  @override
  $ReferenceCopyWith<$Res>? get document;
}

/// @nodoc
class __$$_SubstanceDefinitionRepresentationCopyWithImpl<$Res>
    extends _$SubstanceDefinitionRepresentationCopyWithImpl<$Res,
        _$_SubstanceDefinitionRepresentation>
    implements _$$_SubstanceDefinitionRepresentationCopyWith<$Res> {
  __$$_SubstanceDefinitionRepresentationCopyWithImpl(
      _$_SubstanceDefinitionRepresentation _value,
      $Res Function(_$_SubstanceDefinitionRepresentation) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? representation = freezed,
    Object? representationElement = freezed,
    Object? format = freezed,
    Object? document = freezed,
  }) {
    return _then(_$_SubstanceDefinitionRepresentation(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      representation: freezed == representation
          ? _value.representation
          : representation // ignore: cast_nullable_to_non_nullable
              as String?,
      representationElement: freezed == representationElement
          ? _value.representationElement
          : representationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      format: freezed == format
          ? _value.format
          : format // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      document: freezed == document
          ? _value.document
          : document // ignore: cast_nullable_to_non_nullable
              as Reference?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionRepresentation
    extends _SubstanceDefinitionRepresentation {
  _$_SubstanceDefinitionRepresentation(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.type,
      this.representation,
      @JsonKey(name: '_representation') this.representationElement,
      this.format,
      this.document})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstanceDefinitionRepresentation.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionRepresentationFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] The kind of structural representation (e.g. full, partial).
  @override
  final CodeableConcept? type;

  /// [representation] The structural representation as a text string in a standard format.
  @override
  final String? representation;

  /// [representationElement] ("_representation") Extensions for representation
  @override
  @JsonKey(name: '_representation')
  final Element? representationElement;

  /// [format] The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF. The logical content type rather than the physical file format of a document.
  @override
  final CodeableConcept? format;

  /// [document] An attached file with the structural representation e.g. a molecular structure graphic of the substance, a JCAMP or AnIML file.
  @override
  final Reference? document;

  @override
  String toString() {
    return 'SubstanceDefinitionRepresentation(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, representation: $representation, representationElement: $representationElement, format: $format, document: $document)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionRepresentation &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.representation, representation) ||
                other.representation == representation) &&
            (identical(other.representationElement, representationElement) ||
                other.representationElement == representationElement) &&
            (identical(other.format, format) || other.format == format) &&
            (identical(other.document, document) ||
                other.document == document));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      representation,
      representationElement,
      format,
      document);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionRepresentationCopyWith<
          _$_SubstanceDefinitionRepresentation>
      get copyWith => __$$_SubstanceDefinitionRepresentationCopyWithImpl<
          _$_SubstanceDefinitionRepresentation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionRepresentationToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionRepresentation
    extends SubstanceDefinitionRepresentation {
  factory _SubstanceDefinitionRepresentation(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? type,
      final String? representation,
      @JsonKey(name: '_representation') final Element? representationElement,
      final CodeableConcept? format,
      final Reference? document}) = _$_SubstanceDefinitionRepresentation;
  _SubstanceDefinitionRepresentation._() : super._();

  factory _SubstanceDefinitionRepresentation.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceDefinitionRepresentation.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] The kind of structural representation (e.g. full, partial).
  CodeableConcept? get type;
  @override

  /// [representation] The structural representation as a text string in a standard format.
  String? get representation;
  @override

  /// [representationElement] ("_representation") Extensions for representation
  @JsonKey(name: '_representation')
  Element? get representationElement;
  @override

  /// [format] The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF. The logical content type rather than the physical file format of a document.
  CodeableConcept? get format;
  @override

  /// [document] An attached file with the structural representation e.g. a molecular structure graphic of the substance, a JCAMP or AnIML file.
  Reference? get document;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionRepresentationCopyWith<
          _$_SubstanceDefinitionRepresentation>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinitionCode _$SubstanceDefinitionCodeFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionCode.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionCode {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [code] The specific code.
  CodeableConcept? get code => throw _privateConstructorUsedError;

  /// [status] Status of the code assignment, for example 'provisional', 'approved'.
  CodeableConcept? get status => throw _privateConstructorUsedError;

  /// [statusDate] The date at which the code status was changed as part of the terminology maintenance.
  FhirDateTime? get statusDate => throw _privateConstructorUsedError;

  /// [statusDateElement] ("_statusDate") Extensions for statusDate
  @JsonKey(name: '_statusDate')
  Element? get statusDateElement => throw _privateConstructorUsedError;

  /// [note] Any comment can be provided in this field, if necessary.
  List<Annotation>? get note => throw _privateConstructorUsedError;

  /// [source] Supporting literature.
  List<Reference>? get source => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionCodeCopyWith<SubstanceDefinitionCode> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionCodeCopyWith<$Res> {
  factory $SubstanceDefinitionCodeCopyWith(SubstanceDefinitionCode value,
          $Res Function(SubstanceDefinitionCode) then) =
      _$SubstanceDefinitionCodeCopyWithImpl<$Res, SubstanceDefinitionCode>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? code,
      CodeableConcept? status,
      FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate') Element? statusDateElement,
      List<Annotation>? note,
      List<Reference>? source});

  $CodeableConceptCopyWith<$Res>? get code;
  $CodeableConceptCopyWith<$Res>? get status;
  $ElementCopyWith<$Res>? get statusDateElement;
}

/// @nodoc
class _$SubstanceDefinitionCodeCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionCode>
    implements $SubstanceDefinitionCodeCopyWith<$Res> {
  _$SubstanceDefinitionCodeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = freezed,
    Object? status = freezed,
    Object? statusDate = freezed,
    Object? statusDateElement = freezed,
    Object? note = freezed,
    Object? source = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      statusDate: freezed == statusDate
          ? _value.statusDate
          : statusDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      statusDateElement: freezed == statusDateElement
          ? _value.statusDateElement
          : statusDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      note: freezed == note
          ? _value.note
          : note // ignore: cast_nullable_to_non_nullable
              as List<Annotation>?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get code {
    if (_value.code == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.code!, (value) {
      return _then(_value.copyWith(code: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusDateElement {
    if (_value.statusDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusDateElement!, (value) {
      return _then(_value.copyWith(statusDateElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionCodeCopyWith<$Res>
    implements $SubstanceDefinitionCodeCopyWith<$Res> {
  factory _$$_SubstanceDefinitionCodeCopyWith(_$_SubstanceDefinitionCode value,
          $Res Function(_$_SubstanceDefinitionCode) then) =
      __$$_SubstanceDefinitionCodeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? code,
      CodeableConcept? status,
      FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate') Element? statusDateElement,
      List<Annotation>? note,
      List<Reference>? source});

  @override
  $CodeableConceptCopyWith<$Res>? get code;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
  @override
  $ElementCopyWith<$Res>? get statusDateElement;
}

/// @nodoc
class __$$_SubstanceDefinitionCodeCopyWithImpl<$Res>
    extends _$SubstanceDefinitionCodeCopyWithImpl<$Res,
        _$_SubstanceDefinitionCode>
    implements _$$_SubstanceDefinitionCodeCopyWith<$Res> {
  __$$_SubstanceDefinitionCodeCopyWithImpl(_$_SubstanceDefinitionCode _value,
      $Res Function(_$_SubstanceDefinitionCode) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = freezed,
    Object? status = freezed,
    Object? statusDate = freezed,
    Object? statusDateElement = freezed,
    Object? note = freezed,
    Object? source = freezed,
  }) {
    return _then(_$_SubstanceDefinitionCode(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      statusDate: freezed == statusDate
          ? _value.statusDate
          : statusDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      statusDateElement: freezed == statusDateElement
          ? _value.statusDateElement
          : statusDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      note: freezed == note
          ? _value._note
          : note // ignore: cast_nullable_to_non_nullable
              as List<Annotation>?,
      source: freezed == source
          ? _value._source
          : source // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionCode extends _SubstanceDefinitionCode {
  _$_SubstanceDefinitionCode(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.code,
      this.status,
      this.statusDate,
      @JsonKey(name: '_statusDate') this.statusDateElement,
      final List<Annotation>? note,
      final List<Reference>? source})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _note = note,
        _source = source,
        super._();

  factory _$_SubstanceDefinitionCode.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionCodeFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [code] The specific code.
  @override
  final CodeableConcept? code;

  /// [status] Status of the code assignment, for example 'provisional', 'approved'.
  @override
  final CodeableConcept? status;

  /// [statusDate] The date at which the code status was changed as part of the terminology maintenance.
  @override
  final FhirDateTime? statusDate;

  /// [statusDateElement] ("_statusDate") Extensions for statusDate
  @override
  @JsonKey(name: '_statusDate')
  final Element? statusDateElement;

  /// [note] Any comment can be provided in this field, if necessary.
  final List<Annotation>? _note;

  /// [note] Any comment can be provided in this field, if necessary.
  @override
  List<Annotation>? get note {
    final value = _note;
    if (value == null) return null;
    if (_note is EqualUnmodifiableListView) return _note;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [source] Supporting literature.
  final List<Reference>? _source;

  /// [source] Supporting literature.
  @override
  List<Reference>? get source {
    final value = _source;
    if (value == null) return null;
    if (_source is EqualUnmodifiableListView) return _source;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstanceDefinitionCode(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, status: $status, statusDate: $statusDate, statusDateElement: $statusDateElement, note: $note, source: $source)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionCode &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusDate, statusDate) ||
                other.statusDate == statusDate) &&
            (identical(other.statusDateElement, statusDateElement) ||
                other.statusDateElement == statusDateElement) &&
            const DeepCollectionEquality().equals(other._note, _note) &&
            const DeepCollectionEquality().equals(other._source, _source));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      code,
      status,
      statusDate,
      statusDateElement,
      const DeepCollectionEquality().hash(_note),
      const DeepCollectionEquality().hash(_source));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionCodeCopyWith<_$_SubstanceDefinitionCode>
      get copyWith =>
          __$$_SubstanceDefinitionCodeCopyWithImpl<_$_SubstanceDefinitionCode>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionCodeToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionCode extends SubstanceDefinitionCode {
  factory _SubstanceDefinitionCode(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? code,
      final CodeableConcept? status,
      final FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate') final Element? statusDateElement,
      final List<Annotation>? note,
      final List<Reference>? source}) = _$_SubstanceDefinitionCode;
  _SubstanceDefinitionCode._() : super._();

  factory _SubstanceDefinitionCode.fromJson(Map<String, dynamic> json) =
      _$_SubstanceDefinitionCode.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [code] The specific code.
  CodeableConcept? get code;
  @override

  /// [status] Status of the code assignment, for example 'provisional', 'approved'.
  CodeableConcept? get status;
  @override

  /// [statusDate] The date at which the code status was changed as part of the terminology maintenance.
  FhirDateTime? get statusDate;
  @override

  /// [statusDateElement] ("_statusDate") Extensions for statusDate
  @JsonKey(name: '_statusDate')
  Element? get statusDateElement;
  @override

  /// [note] Any comment can be provided in this field, if necessary.
  List<Annotation>? get note;
  @override

  /// [source] Supporting literature.
  List<Reference>? get source;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionCodeCopyWith<_$_SubstanceDefinitionCode>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinitionName _$SubstanceDefinitionNameFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionName.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionName {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [name] The actual name.
  String? get name => throw _privateConstructorUsedError;

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement => throw _privateConstructorUsedError;

  /// [type] Name type, for example 'systematic',  'scientific, 'brand'.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [status] The status of the name, for example 'current', 'proposed'.
  CodeableConcept? get status => throw _privateConstructorUsedError;

  /// [preferred] If this is the preferred name for this substance.
  Boolean? get preferred => throw _privateConstructorUsedError;

  /// [preferredElement] ("_preferred") Extensions for preferred
  @JsonKey(name: '_preferred')
  Element? get preferredElement => throw _privateConstructorUsedError;

  /// [language] Human language that the name is written in.
  List<CodeableConcept>? get language => throw _privateConstructorUsedError;

  /// [domain] The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive.
  List<CodeableConcept>? get domain => throw _privateConstructorUsedError;

  /// [jurisdiction] The jurisdiction where this name applies.
  List<CodeableConcept>? get jurisdiction => throw _privateConstructorUsedError;

  /// [synonym] A synonym of this particular name, by which the substance is also known.
  List<SubstanceDefinitionName>? get synonym =>
      throw _privateConstructorUsedError;

  /// [translation] A translation for this name into another human language.
  List<SubstanceDefinitionName>? get translation =>
      throw _privateConstructorUsedError;

  /// [official] Details of the official nature of this name.
  List<SubstanceDefinitionOfficial>? get official =>
      throw _privateConstructorUsedError;

  /// [source] Supporting literature.
  List<Reference>? get source => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionNameCopyWith<SubstanceDefinitionName> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionNameCopyWith<$Res> {
  factory $SubstanceDefinitionNameCopyWith(SubstanceDefinitionName value,
          $Res Function(SubstanceDefinitionName) then) =
      _$SubstanceDefinitionNameCopyWithImpl<$Res, SubstanceDefinitionName>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      CodeableConcept? type,
      CodeableConcept? status,
      Boolean? preferred,
      @JsonKey(name: '_preferred') Element? preferredElement,
      List<CodeableConcept>? language,
      List<CodeableConcept>? domain,
      List<CodeableConcept>? jurisdiction,
      List<SubstanceDefinitionName>? synonym,
      List<SubstanceDefinitionName>? translation,
      List<SubstanceDefinitionOfficial>? official,
      List<Reference>? source});

  $ElementCopyWith<$Res>? get nameElement;
  $CodeableConceptCopyWith<$Res>? get type;
  $CodeableConceptCopyWith<$Res>? get status;
  $ElementCopyWith<$Res>? get preferredElement;
}

/// @nodoc
class _$SubstanceDefinitionNameCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionName>
    implements $SubstanceDefinitionNameCopyWith<$Res> {
  _$SubstanceDefinitionNameCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? type = freezed,
    Object? status = freezed,
    Object? preferred = freezed,
    Object? preferredElement = freezed,
    Object? language = freezed,
    Object? domain = freezed,
    Object? jurisdiction = freezed,
    Object? synonym = freezed,
    Object? translation = freezed,
    Object? official = freezed,
    Object? source = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      preferred: freezed == preferred
          ? _value.preferred
          : preferred // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      preferredElement: freezed == preferredElement
          ? _value.preferredElement
          : preferredElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      domain: freezed == domain
          ? _value.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      jurisdiction: freezed == jurisdiction
          ? _value.jurisdiction
          : jurisdiction // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      synonym: freezed == synonym
          ? _value.synonym
          : synonym // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionName>?,
      translation: freezed == translation
          ? _value.translation
          : translation // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionName>?,
      official: freezed == official
          ? _value.official
          : official // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionOfficial>?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get nameElement {
    if (_value.nameElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.nameElement!, (value) {
      return _then(_value.copyWith(nameElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get preferredElement {
    if (_value.preferredElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.preferredElement!, (value) {
      return _then(_value.copyWith(preferredElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionNameCopyWith<$Res>
    implements $SubstanceDefinitionNameCopyWith<$Res> {
  factory _$$_SubstanceDefinitionNameCopyWith(_$_SubstanceDefinitionName value,
          $Res Function(_$_SubstanceDefinitionName) then) =
      __$$_SubstanceDefinitionNameCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      CodeableConcept? type,
      CodeableConcept? status,
      Boolean? preferred,
      @JsonKey(name: '_preferred') Element? preferredElement,
      List<CodeableConcept>? language,
      List<CodeableConcept>? domain,
      List<CodeableConcept>? jurisdiction,
      List<SubstanceDefinitionName>? synonym,
      List<SubstanceDefinitionName>? translation,
      List<SubstanceDefinitionOfficial>? official,
      List<Reference>? source});

  @override
  $ElementCopyWith<$Res>? get nameElement;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
  @override
  $ElementCopyWith<$Res>? get preferredElement;
}

/// @nodoc
class __$$_SubstanceDefinitionNameCopyWithImpl<$Res>
    extends _$SubstanceDefinitionNameCopyWithImpl<$Res,
        _$_SubstanceDefinitionName>
    implements _$$_SubstanceDefinitionNameCopyWith<$Res> {
  __$$_SubstanceDefinitionNameCopyWithImpl(_$_SubstanceDefinitionName _value,
      $Res Function(_$_SubstanceDefinitionName) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? type = freezed,
    Object? status = freezed,
    Object? preferred = freezed,
    Object? preferredElement = freezed,
    Object? language = freezed,
    Object? domain = freezed,
    Object? jurisdiction = freezed,
    Object? synonym = freezed,
    Object? translation = freezed,
    Object? official = freezed,
    Object? source = freezed,
  }) {
    return _then(_$_SubstanceDefinitionName(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      preferred: freezed == preferred
          ? _value.preferred
          : preferred // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      preferredElement: freezed == preferredElement
          ? _value.preferredElement
          : preferredElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value._language
          : language // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      domain: freezed == domain
          ? _value._domain
          : domain // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      jurisdiction: freezed == jurisdiction
          ? _value._jurisdiction
          : jurisdiction // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      synonym: freezed == synonym
          ? _value._synonym
          : synonym // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionName>?,
      translation: freezed == translation
          ? _value._translation
          : translation // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionName>?,
      official: freezed == official
          ? _value._official
          : official // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionOfficial>?,
      source: freezed == source
          ? _value._source
          : source // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionName extends _SubstanceDefinitionName {
  _$_SubstanceDefinitionName(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.name,
      @JsonKey(name: '_name') this.nameElement,
      this.type,
      this.status,
      this.preferred,
      @JsonKey(name: '_preferred') this.preferredElement,
      final List<CodeableConcept>? language,
      final List<CodeableConcept>? domain,
      final List<CodeableConcept>? jurisdiction,
      final List<SubstanceDefinitionName>? synonym,
      final List<SubstanceDefinitionName>? translation,
      final List<SubstanceDefinitionOfficial>? official,
      final List<Reference>? source})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _language = language,
        _domain = domain,
        _jurisdiction = jurisdiction,
        _synonym = synonym,
        _translation = translation,
        _official = official,
        _source = source,
        super._();

  factory _$_SubstanceDefinitionName.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionNameFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [name] The actual name.
  @override
  final String? name;

  /// [nameElement] ("_name") Extensions for name
  @override
  @JsonKey(name: '_name')
  final Element? nameElement;

  /// [type] Name type, for example 'systematic',  'scientific, 'brand'.
  @override
  final CodeableConcept? type;

  /// [status] The status of the name, for example 'current', 'proposed'.
  @override
  final CodeableConcept? status;

  /// [preferred] If this is the preferred name for this substance.
  @override
  final Boolean? preferred;

  /// [preferredElement] ("_preferred") Extensions for preferred
  @override
  @JsonKey(name: '_preferred')
  final Element? preferredElement;

  /// [language] Human language that the name is written in.
  final List<CodeableConcept>? _language;

  /// [language] Human language that the name is written in.
  @override
  List<CodeableConcept>? get language {
    final value = _language;
    if (value == null) return null;
    if (_language is EqualUnmodifiableListView) return _language;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [domain] The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive.
  final List<CodeableConcept>? _domain;

  /// [domain] The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive.
  @override
  List<CodeableConcept>? get domain {
    final value = _domain;
    if (value == null) return null;
    if (_domain is EqualUnmodifiableListView) return _domain;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [jurisdiction] The jurisdiction where this name applies.
  final List<CodeableConcept>? _jurisdiction;

  /// [jurisdiction] The jurisdiction where this name applies.
  @override
  List<CodeableConcept>? get jurisdiction {
    final value = _jurisdiction;
    if (value == null) return null;
    if (_jurisdiction is EqualUnmodifiableListView) return _jurisdiction;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [synonym] A synonym of this particular name, by which the substance is also known.
  final List<SubstanceDefinitionName>? _synonym;

  /// [synonym] A synonym of this particular name, by which the substance is also known.
  @override
  List<SubstanceDefinitionName>? get synonym {
    final value = _synonym;
    if (value == null) return null;
    if (_synonym is EqualUnmodifiableListView) return _synonym;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [translation] A translation for this name into another human language.
  final List<SubstanceDefinitionName>? _translation;

  /// [translation] A translation for this name into another human language.
  @override
  List<SubstanceDefinitionName>? get translation {
    final value = _translation;
    if (value == null) return null;
    if (_translation is EqualUnmodifiableListView) return _translation;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [official] Details of the official nature of this name.
  final List<SubstanceDefinitionOfficial>? _official;

  /// [official] Details of the official nature of this name.
  @override
  List<SubstanceDefinitionOfficial>? get official {
    final value = _official;
    if (value == null) return null;
    if (_official is EqualUnmodifiableListView) return _official;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [source] Supporting literature.
  final List<Reference>? _source;

  /// [source] Supporting literature.
  @override
  List<Reference>? get source {
    final value = _source;
    if (value == null) return null;
    if (_source is EqualUnmodifiableListView) return _source;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstanceDefinitionName(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, name: $name, nameElement: $nameElement, type: $type, status: $status, preferred: $preferred, preferredElement: $preferredElement, language: $language, domain: $domain, jurisdiction: $jurisdiction, synonym: $synonym, translation: $translation, official: $official, source: $source)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionName &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.nameElement, nameElement) ||
                other.nameElement == nameElement) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.preferred, preferred) ||
                other.preferred == preferred) &&
            (identical(other.preferredElement, preferredElement) ||
                other.preferredElement == preferredElement) &&
            const DeepCollectionEquality().equals(other._language, _language) &&
            const DeepCollectionEquality().equals(other._domain, _domain) &&
            const DeepCollectionEquality()
                .equals(other._jurisdiction, _jurisdiction) &&
            const DeepCollectionEquality().equals(other._synonym, _synonym) &&
            const DeepCollectionEquality()
                .equals(other._translation, _translation) &&
            const DeepCollectionEquality().equals(other._official, _official) &&
            const DeepCollectionEquality().equals(other._source, _source));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      name,
      nameElement,
      type,
      status,
      preferred,
      preferredElement,
      const DeepCollectionEquality().hash(_language),
      const DeepCollectionEquality().hash(_domain),
      const DeepCollectionEquality().hash(_jurisdiction),
      const DeepCollectionEquality().hash(_synonym),
      const DeepCollectionEquality().hash(_translation),
      const DeepCollectionEquality().hash(_official),
      const DeepCollectionEquality().hash(_source));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionNameCopyWith<_$_SubstanceDefinitionName>
      get copyWith =>
          __$$_SubstanceDefinitionNameCopyWithImpl<_$_SubstanceDefinitionName>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionNameToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionName extends SubstanceDefinitionName {
  factory _SubstanceDefinitionName(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final String? name,
      @JsonKey(name: '_name') final Element? nameElement,
      final CodeableConcept? type,
      final CodeableConcept? status,
      final Boolean? preferred,
      @JsonKey(name: '_preferred') final Element? preferredElement,
      final List<CodeableConcept>? language,
      final List<CodeableConcept>? domain,
      final List<CodeableConcept>? jurisdiction,
      final List<SubstanceDefinitionName>? synonym,
      final List<SubstanceDefinitionName>? translation,
      final List<SubstanceDefinitionOfficial>? official,
      final List<Reference>? source}) = _$_SubstanceDefinitionName;
  _SubstanceDefinitionName._() : super._();

  factory _SubstanceDefinitionName.fromJson(Map<String, dynamic> json) =
      _$_SubstanceDefinitionName.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [name] The actual name.
  String? get name;
  @override

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement;
  @override

  /// [type] Name type, for example 'systematic',  'scientific, 'brand'.
  CodeableConcept? get type;
  @override

  /// [status] The status of the name, for example 'current', 'proposed'.
  CodeableConcept? get status;
  @override

  /// [preferred] If this is the preferred name for this substance.
  Boolean? get preferred;
  @override

  /// [preferredElement] ("_preferred") Extensions for preferred
  @JsonKey(name: '_preferred')
  Element? get preferredElement;
  @override

  /// [language] Human language that the name is written in.
  List<CodeableConcept>? get language;
  @override

  /// [domain] The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive.
  List<CodeableConcept>? get domain;
  @override

  /// [jurisdiction] The jurisdiction where this name applies.
  List<CodeableConcept>? get jurisdiction;
  @override

  /// [synonym] A synonym of this particular name, by which the substance is also known.
  List<SubstanceDefinitionName>? get synonym;
  @override

  /// [translation] A translation for this name into another human language.
  List<SubstanceDefinitionName>? get translation;
  @override

  /// [official] Details of the official nature of this name.
  List<SubstanceDefinitionOfficial>? get official;
  @override

  /// [source] Supporting literature.
  List<Reference>? get source;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionNameCopyWith<_$_SubstanceDefinitionName>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinitionOfficial _$SubstanceDefinitionOfficialFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionOfficial.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionOfficial {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [authority] Which authority uses this official name.
  CodeableConcept? get authority => throw _privateConstructorUsedError;

  /// [status] The status of the official name, for example 'draft', 'active', 'retired'.
  CodeableConcept? get status => throw _privateConstructorUsedError;

  /// [date] Date of the official name change.
  FhirDateTime? get date => throw _privateConstructorUsedError;

  /// [dateElement] ("_date") Extensions for date
  @JsonKey(name: '_date')
  Element? get dateElement => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionOfficialCopyWith<SubstanceDefinitionOfficial>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionOfficialCopyWith<$Res> {
  factory $SubstanceDefinitionOfficialCopyWith(
          SubstanceDefinitionOfficial value,
          $Res Function(SubstanceDefinitionOfficial) then) =
      _$SubstanceDefinitionOfficialCopyWithImpl<$Res,
          SubstanceDefinitionOfficial>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? authority,
      CodeableConcept? status,
      FhirDateTime? date,
      @JsonKey(name: '_date') Element? dateElement});

  $CodeableConceptCopyWith<$Res>? get authority;
  $CodeableConceptCopyWith<$Res>? get status;
  $ElementCopyWith<$Res>? get dateElement;
}

/// @nodoc
class _$SubstanceDefinitionOfficialCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionOfficial>
    implements $SubstanceDefinitionOfficialCopyWith<$Res> {
  _$SubstanceDefinitionOfficialCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? authority = freezed,
    Object? status = freezed,
    Object? date = freezed,
    Object? dateElement = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      authority: freezed == authority
          ? _value.authority
          : authority // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      date: freezed == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      dateElement: freezed == dateElement
          ? _value.dateElement
          : dateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get authority {
    if (_value.authority == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.authority!, (value) {
      return _then(_value.copyWith(authority: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get dateElement {
    if (_value.dateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.dateElement!, (value) {
      return _then(_value.copyWith(dateElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionOfficialCopyWith<$Res>
    implements $SubstanceDefinitionOfficialCopyWith<$Res> {
  factory _$$_SubstanceDefinitionOfficialCopyWith(
          _$_SubstanceDefinitionOfficial value,
          $Res Function(_$_SubstanceDefinitionOfficial) then) =
      __$$_SubstanceDefinitionOfficialCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? authority,
      CodeableConcept? status,
      FhirDateTime? date,
      @JsonKey(name: '_date') Element? dateElement});

  @override
  $CodeableConceptCopyWith<$Res>? get authority;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
  @override
  $ElementCopyWith<$Res>? get dateElement;
}

/// @nodoc
class __$$_SubstanceDefinitionOfficialCopyWithImpl<$Res>
    extends _$SubstanceDefinitionOfficialCopyWithImpl<$Res,
        _$_SubstanceDefinitionOfficial>
    implements _$$_SubstanceDefinitionOfficialCopyWith<$Res> {
  __$$_SubstanceDefinitionOfficialCopyWithImpl(
      _$_SubstanceDefinitionOfficial _value,
      $Res Function(_$_SubstanceDefinitionOfficial) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? authority = freezed,
    Object? status = freezed,
    Object? date = freezed,
    Object? dateElement = freezed,
  }) {
    return _then(_$_SubstanceDefinitionOfficial(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      authority: freezed == authority
          ? _value.authority
          : authority // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      date: freezed == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      dateElement: freezed == dateElement
          ? _value.dateElement
          : dateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionOfficial extends _SubstanceDefinitionOfficial {
  _$_SubstanceDefinitionOfficial(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.authority,
      this.status,
      this.date,
      @JsonKey(name: '_date') this.dateElement})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstanceDefinitionOfficial.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionOfficialFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [authority] Which authority uses this official name.
  @override
  final CodeableConcept? authority;

  /// [status] The status of the official name, for example 'draft', 'active', 'retired'.
  @override
  final CodeableConcept? status;

  /// [date] Date of the official name change.
  @override
  final FhirDateTime? date;

  /// [dateElement] ("_date") Extensions for date
  @override
  @JsonKey(name: '_date')
  final Element? dateElement;

  @override
  String toString() {
    return 'SubstanceDefinitionOfficial(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, authority: $authority, status: $status, date: $date, dateElement: $dateElement)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionOfficial &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.authority, authority) ||
                other.authority == authority) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.dateElement, dateElement) ||
                other.dateElement == dateElement));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      authority,
      status,
      date,
      dateElement);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionOfficialCopyWith<_$_SubstanceDefinitionOfficial>
      get copyWith => __$$_SubstanceDefinitionOfficialCopyWithImpl<
          _$_SubstanceDefinitionOfficial>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionOfficialToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionOfficial
    extends SubstanceDefinitionOfficial {
  factory _SubstanceDefinitionOfficial(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableConcept? authority,
          final CodeableConcept? status,
          final FhirDateTime? date,
          @JsonKey(name: '_date') final Element? dateElement}) =
      _$_SubstanceDefinitionOfficial;
  _SubstanceDefinitionOfficial._() : super._();

  factory _SubstanceDefinitionOfficial.fromJson(Map<String, dynamic> json) =
      _$_SubstanceDefinitionOfficial.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [authority] Which authority uses this official name.
  CodeableConcept? get authority;
  @override

  /// [status] The status of the official name, for example 'draft', 'active', 'retired'.
  CodeableConcept? get status;
  @override

  /// [date] Date of the official name change.
  FhirDateTime? get date;
  @override

  /// [dateElement] ("_date") Extensions for date
  @JsonKey(name: '_date')
  Element? get dateElement;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionOfficialCopyWith<_$_SubstanceDefinitionOfficial>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinitionRelationship _$SubstanceDefinitionRelationshipFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionRelationship.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionRelationship {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [substanceDefinitionReference] A pointer to another substance, as a resource or just a representational code.
  Reference? get substanceDefinitionReference =>
      throw _privateConstructorUsedError;

  /// [substanceDefinitionCodeableConcept] A pointer to another substance, as a resource or just a representational code.
  CodeableConcept? get substanceDefinitionCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [type] For example "salt to parent", "active moiety", "starting material", "polymorph", "impurity of".
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [isDefining] For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.
  Boolean? get isDefining => throw _privateConstructorUsedError;

  /// [isDefiningElement] ("_isDefining") Extensions for isDefining
  @JsonKey(name: '_isDefining')
  Element? get isDefiningElement => throw _privateConstructorUsedError;

  /// [amountQuantity] A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
  Quantity? get amountQuantity => throw _privateConstructorUsedError;

  /// [amountRatio] A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
  Ratio? get amountRatio => throw _privateConstructorUsedError;

  /// [amountString] A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
  String? get amountString => throw _privateConstructorUsedError;

  /// [amountStringElement] ("_amountString") Extensions for amountString
  @JsonKey(name: '_amountString')
  Element? get amountStringElement => throw _privateConstructorUsedError;

  /// [ratioHighLimitAmount] For use when the numeric has an uncertain range.
  Ratio? get ratioHighLimitAmount => throw _privateConstructorUsedError;

  /// [comparator] An operator for the amount, for example "average", "approximately", "less than".
  CodeableConcept? get comparator => throw _privateConstructorUsedError;

  /// [source] Supporting literature.
  List<Reference>? get source => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionRelationshipCopyWith<SubstanceDefinitionRelationship>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionRelationshipCopyWith<$Res> {
  factory $SubstanceDefinitionRelationshipCopyWith(
          SubstanceDefinitionRelationship value,
          $Res Function(SubstanceDefinitionRelationship) then) =
      _$SubstanceDefinitionRelationshipCopyWithImpl<$Res,
          SubstanceDefinitionRelationship>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Reference? substanceDefinitionReference,
      CodeableConcept? substanceDefinitionCodeableConcept,
      CodeableConcept type,
      Boolean? isDefining,
      @JsonKey(name: '_isDefining') Element? isDefiningElement,
      Quantity? amountQuantity,
      Ratio? amountRatio,
      String? amountString,
      @JsonKey(name: '_amountString') Element? amountStringElement,
      Ratio? ratioHighLimitAmount,
      CodeableConcept? comparator,
      List<Reference>? source});

  $ReferenceCopyWith<$Res>? get substanceDefinitionReference;
  $CodeableConceptCopyWith<$Res>? get substanceDefinitionCodeableConcept;
  $CodeableConceptCopyWith<$Res> get type;
  $ElementCopyWith<$Res>? get isDefiningElement;
  $QuantityCopyWith<$Res>? get amountQuantity;
  $RatioCopyWith<$Res>? get amountRatio;
  $ElementCopyWith<$Res>? get amountStringElement;
  $RatioCopyWith<$Res>? get ratioHighLimitAmount;
  $CodeableConceptCopyWith<$Res>? get comparator;
}

/// @nodoc
class _$SubstanceDefinitionRelationshipCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionRelationship>
    implements $SubstanceDefinitionRelationshipCopyWith<$Res> {
  _$SubstanceDefinitionRelationshipCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? substanceDefinitionReference = freezed,
    Object? substanceDefinitionCodeableConcept = freezed,
    Object? type = null,
    Object? isDefining = freezed,
    Object? isDefiningElement = freezed,
    Object? amountQuantity = freezed,
    Object? amountRatio = freezed,
    Object? amountString = freezed,
    Object? amountStringElement = freezed,
    Object? ratioHighLimitAmount = freezed,
    Object? comparator = freezed,
    Object? source = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      substanceDefinitionReference: freezed == substanceDefinitionReference
          ? _value.substanceDefinitionReference
          : substanceDefinitionReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      substanceDefinitionCodeableConcept: freezed ==
              substanceDefinitionCodeableConcept
          ? _value.substanceDefinitionCodeableConcept
          : substanceDefinitionCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      isDefining: freezed == isDefining
          ? _value.isDefining
          : isDefining // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      isDefiningElement: freezed == isDefiningElement
          ? _value.isDefiningElement
          : isDefiningElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      amountQuantity: freezed == amountQuantity
          ? _value.amountQuantity
          : amountQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      amountRatio: freezed == amountRatio
          ? _value.amountRatio
          : amountRatio // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      amountString: freezed == amountString
          ? _value.amountString
          : amountString // ignore: cast_nullable_to_non_nullable
              as String?,
      amountStringElement: freezed == amountStringElement
          ? _value.amountStringElement
          : amountStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      ratioHighLimitAmount: freezed == ratioHighLimitAmount
          ? _value.ratioHighLimitAmount
          : ratioHighLimitAmount // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      comparator: freezed == comparator
          ? _value.comparator
          : comparator // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get substanceDefinitionReference {
    if (_value.substanceDefinitionReference == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.substanceDefinitionReference!,
        (value) {
      return _then(
          _value.copyWith(substanceDefinitionReference: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get substanceDefinitionCodeableConcept {
    if (_value.substanceDefinitionCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(
        _value.substanceDefinitionCodeableConcept!, (value) {
      return _then(
          _value.copyWith(substanceDefinitionCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get isDefiningElement {
    if (_value.isDefiningElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.isDefiningElement!, (value) {
      return _then(_value.copyWith(isDefiningElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get amountQuantity {
    if (_value.amountQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.amountQuantity!, (value) {
      return _then(_value.copyWith(amountQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RatioCopyWith<$Res>? get amountRatio {
    if (_value.amountRatio == null) {
      return null;
    }

    return $RatioCopyWith<$Res>(_value.amountRatio!, (value) {
      return _then(_value.copyWith(amountRatio: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get amountStringElement {
    if (_value.amountStringElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.amountStringElement!, (value) {
      return _then(_value.copyWith(amountStringElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RatioCopyWith<$Res>? get ratioHighLimitAmount {
    if (_value.ratioHighLimitAmount == null) {
      return null;
    }

    return $RatioCopyWith<$Res>(_value.ratioHighLimitAmount!, (value) {
      return _then(_value.copyWith(ratioHighLimitAmount: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get comparator {
    if (_value.comparator == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.comparator!, (value) {
      return _then(_value.copyWith(comparator: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionRelationshipCopyWith<$Res>
    implements $SubstanceDefinitionRelationshipCopyWith<$Res> {
  factory _$$_SubstanceDefinitionRelationshipCopyWith(
          _$_SubstanceDefinitionRelationship value,
          $Res Function(_$_SubstanceDefinitionRelationship) then) =
      __$$_SubstanceDefinitionRelationshipCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Reference? substanceDefinitionReference,
      CodeableConcept? substanceDefinitionCodeableConcept,
      CodeableConcept type,
      Boolean? isDefining,
      @JsonKey(name: '_isDefining') Element? isDefiningElement,
      Quantity? amountQuantity,
      Ratio? amountRatio,
      String? amountString,
      @JsonKey(name: '_amountString') Element? amountStringElement,
      Ratio? ratioHighLimitAmount,
      CodeableConcept? comparator,
      List<Reference>? source});

  @override
  $ReferenceCopyWith<$Res>? get substanceDefinitionReference;
  @override
  $CodeableConceptCopyWith<$Res>? get substanceDefinitionCodeableConcept;
  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $ElementCopyWith<$Res>? get isDefiningElement;
  @override
  $QuantityCopyWith<$Res>? get amountQuantity;
  @override
  $RatioCopyWith<$Res>? get amountRatio;
  @override
  $ElementCopyWith<$Res>? get amountStringElement;
  @override
  $RatioCopyWith<$Res>? get ratioHighLimitAmount;
  @override
  $CodeableConceptCopyWith<$Res>? get comparator;
}

/// @nodoc
class __$$_SubstanceDefinitionRelationshipCopyWithImpl<$Res>
    extends _$SubstanceDefinitionRelationshipCopyWithImpl<$Res,
        _$_SubstanceDefinitionRelationship>
    implements _$$_SubstanceDefinitionRelationshipCopyWith<$Res> {
  __$$_SubstanceDefinitionRelationshipCopyWithImpl(
      _$_SubstanceDefinitionRelationship _value,
      $Res Function(_$_SubstanceDefinitionRelationship) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? substanceDefinitionReference = freezed,
    Object? substanceDefinitionCodeableConcept = freezed,
    Object? type = null,
    Object? isDefining = freezed,
    Object? isDefiningElement = freezed,
    Object? amountQuantity = freezed,
    Object? amountRatio = freezed,
    Object? amountString = freezed,
    Object? amountStringElement = freezed,
    Object? ratioHighLimitAmount = freezed,
    Object? comparator = freezed,
    Object? source = freezed,
  }) {
    return _then(_$_SubstanceDefinitionRelationship(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      substanceDefinitionReference: freezed == substanceDefinitionReference
          ? _value.substanceDefinitionReference
          : substanceDefinitionReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      substanceDefinitionCodeableConcept: freezed ==
              substanceDefinitionCodeableConcept
          ? _value.substanceDefinitionCodeableConcept
          : substanceDefinitionCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      isDefining: freezed == isDefining
          ? _value.isDefining
          : isDefining // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      isDefiningElement: freezed == isDefiningElement
          ? _value.isDefiningElement
          : isDefiningElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      amountQuantity: freezed == amountQuantity
          ? _value.amountQuantity
          : amountQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      amountRatio: freezed == amountRatio
          ? _value.amountRatio
          : amountRatio // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      amountString: freezed == amountString
          ? _value.amountString
          : amountString // ignore: cast_nullable_to_non_nullable
              as String?,
      amountStringElement: freezed == amountStringElement
          ? _value.amountStringElement
          : amountStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      ratioHighLimitAmount: freezed == ratioHighLimitAmount
          ? _value.ratioHighLimitAmount
          : ratioHighLimitAmount // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      comparator: freezed == comparator
          ? _value.comparator
          : comparator // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      source: freezed == source
          ? _value._source
          : source // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionRelationship
    extends _SubstanceDefinitionRelationship {
  _$_SubstanceDefinitionRelationship(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.substanceDefinitionReference,
      this.substanceDefinitionCodeableConcept,
      required this.type,
      this.isDefining,
      @JsonKey(name: '_isDefining') this.isDefiningElement,
      this.amountQuantity,
      this.amountRatio,
      this.amountString,
      @JsonKey(name: '_amountString') this.amountStringElement,
      this.ratioHighLimitAmount,
      this.comparator,
      final List<Reference>? source})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _source = source,
        super._();

  factory _$_SubstanceDefinitionRelationship.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionRelationshipFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [substanceDefinitionReference] A pointer to another substance, as a resource or just a representational code.
  @override
  final Reference? substanceDefinitionReference;

  /// [substanceDefinitionCodeableConcept] A pointer to another substance, as a resource or just a representational code.
  @override
  final CodeableConcept? substanceDefinitionCodeableConcept;

  /// [type] For example "salt to parent", "active moiety", "starting material", "polymorph", "impurity of".
  @override
  final CodeableConcept type;

  /// [isDefining] For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.
  @override
  final Boolean? isDefining;

  /// [isDefiningElement] ("_isDefining") Extensions for isDefining
  @override
  @JsonKey(name: '_isDefining')
  final Element? isDefiningElement;

  /// [amountQuantity] A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
  @override
  final Quantity? amountQuantity;

  /// [amountRatio] A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
  @override
  final Ratio? amountRatio;

  /// [amountString] A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
  @override
  final String? amountString;

  /// [amountStringElement] ("_amountString") Extensions for amountString
  @override
  @JsonKey(name: '_amountString')
  final Element? amountStringElement;

  /// [ratioHighLimitAmount] For use when the numeric has an uncertain range.
  @override
  final Ratio? ratioHighLimitAmount;

  /// [comparator] An operator for the amount, for example "average", "approximately", "less than".
  @override
  final CodeableConcept? comparator;

  /// [source] Supporting literature.
  final List<Reference>? _source;

  /// [source] Supporting literature.
  @override
  List<Reference>? get source {
    final value = _source;
    if (value == null) return null;
    if (_source is EqualUnmodifiableListView) return _source;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstanceDefinitionRelationship(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, substanceDefinitionReference: $substanceDefinitionReference, substanceDefinitionCodeableConcept: $substanceDefinitionCodeableConcept, type: $type, isDefining: $isDefining, isDefiningElement: $isDefiningElement, amountQuantity: $amountQuantity, amountRatio: $amountRatio, amountString: $amountString, amountStringElement: $amountStringElement, ratioHighLimitAmount: $ratioHighLimitAmount, comparator: $comparator, source: $source)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionRelationship &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.substanceDefinitionReference,
                    substanceDefinitionReference) ||
                other.substanceDefinitionReference ==
                    substanceDefinitionReference) &&
            (identical(other.substanceDefinitionCodeableConcept,
                    substanceDefinitionCodeableConcept) ||
                other.substanceDefinitionCodeableConcept ==
                    substanceDefinitionCodeableConcept) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.isDefining, isDefining) ||
                other.isDefining == isDefining) &&
            (identical(other.isDefiningElement, isDefiningElement) ||
                other.isDefiningElement == isDefiningElement) &&
            (identical(other.amountQuantity, amountQuantity) ||
                other.amountQuantity == amountQuantity) &&
            (identical(other.amountRatio, amountRatio) ||
                other.amountRatio == amountRatio) &&
            (identical(other.amountString, amountString) ||
                other.amountString == amountString) &&
            (identical(other.amountStringElement, amountStringElement) ||
                other.amountStringElement == amountStringElement) &&
            (identical(other.ratioHighLimitAmount, ratioHighLimitAmount) ||
                other.ratioHighLimitAmount == ratioHighLimitAmount) &&
            (identical(other.comparator, comparator) ||
                other.comparator == comparator) &&
            const DeepCollectionEquality().equals(other._source, _source));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      substanceDefinitionReference,
      substanceDefinitionCodeableConcept,
      type,
      isDefining,
      isDefiningElement,
      amountQuantity,
      amountRatio,
      amountString,
      amountStringElement,
      ratioHighLimitAmount,
      comparator,
      const DeepCollectionEquality().hash(_source));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionRelationshipCopyWith<
          _$_SubstanceDefinitionRelationship>
      get copyWith => __$$_SubstanceDefinitionRelationshipCopyWithImpl<
          _$_SubstanceDefinitionRelationship>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionRelationshipToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionRelationship
    extends SubstanceDefinitionRelationship {
  factory _SubstanceDefinitionRelationship(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final Reference? substanceDefinitionReference,
      final CodeableConcept? substanceDefinitionCodeableConcept,
      required final CodeableConcept type,
      final Boolean? isDefining,
      @JsonKey(name: '_isDefining') final Element? isDefiningElement,
      final Quantity? amountQuantity,
      final Ratio? amountRatio,
      final String? amountString,
      @JsonKey(name: '_amountString') final Element? amountStringElement,
      final Ratio? ratioHighLimitAmount,
      final CodeableConcept? comparator,
      final List<Reference>? source}) = _$_SubstanceDefinitionRelationship;
  _SubstanceDefinitionRelationship._() : super._();

  factory _SubstanceDefinitionRelationship.fromJson(Map<String, dynamic> json) =
      _$_SubstanceDefinitionRelationship.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [substanceDefinitionReference] A pointer to another substance, as a resource or just a representational code.
  Reference? get substanceDefinitionReference;
  @override

  /// [substanceDefinitionCodeableConcept] A pointer to another substance, as a resource or just a representational code.
  CodeableConcept? get substanceDefinitionCodeableConcept;
  @override

  /// [type] For example "salt to parent", "active moiety", "starting material", "polymorph", "impurity of".
  CodeableConcept get type;
  @override

  /// [isDefining] For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.
  Boolean? get isDefining;
  @override

  /// [isDefiningElement] ("_isDefining") Extensions for isDefining
  @JsonKey(name: '_isDefining')
  Element? get isDefiningElement;
  @override

  /// [amountQuantity] A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
  Quantity? get amountQuantity;
  @override

  /// [amountRatio] A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
  Ratio? get amountRatio;
  @override

  /// [amountString] A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
  String? get amountString;
  @override

  /// [amountStringElement] ("_amountString") Extensions for amountString
  @JsonKey(name: '_amountString')
  Element? get amountStringElement;
  @override

  /// [ratioHighLimitAmount] For use when the numeric has an uncertain range.
  Ratio? get ratioHighLimitAmount;
  @override

  /// [comparator] An operator for the amount, for example "average", "approximately", "less than".
  CodeableConcept? get comparator;
  @override

  /// [source] Supporting literature.
  List<Reference>? get source;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionRelationshipCopyWith<
          _$_SubstanceDefinitionRelationship>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinitionSourceMaterial _$SubstanceDefinitionSourceMaterialFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionSourceMaterial.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionSourceMaterial {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] A classification that provides the origin of the raw material. Example: cat hair would be an Animal source type.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [genus] The genus of an organism, typically referring to the Latin epithet of the genus element of the plant/animal scientific name.
  CodeableConcept? get genus => throw _privateConstructorUsedError;

  /// [species] The species of an organism, typically referring to the Latin epithet of the species of the plant/animal.
  CodeableConcept? get species => throw _privateConstructorUsedError;

  /// [part_] ("part") An anatomical origin of the source material within an organism.
  @JsonKey(name: 'part')
  CodeableConcept? get part_ => throw _privateConstructorUsedError;

  /// [countryOfOrigin] The country or countries where the material is harvested.
  List<CodeableConcept>? get countryOfOrigin =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionSourceMaterialCopyWith<SubstanceDefinitionSourceMaterial>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionSourceMaterialCopyWith<$Res> {
  factory $SubstanceDefinitionSourceMaterialCopyWith(
          SubstanceDefinitionSourceMaterial value,
          $Res Function(SubstanceDefinitionSourceMaterial) then) =
      _$SubstanceDefinitionSourceMaterialCopyWithImpl<$Res,
          SubstanceDefinitionSourceMaterial>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      CodeableConcept? genus,
      CodeableConcept? species,
      @JsonKey(name: 'part') CodeableConcept? part_,
      List<CodeableConcept>? countryOfOrigin});

  $CodeableConceptCopyWith<$Res>? get type;
  $CodeableConceptCopyWith<$Res>? get genus;
  $CodeableConceptCopyWith<$Res>? get species;
  $CodeableConceptCopyWith<$Res>? get part_;
}

/// @nodoc
class _$SubstanceDefinitionSourceMaterialCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionSourceMaterial>
    implements $SubstanceDefinitionSourceMaterialCopyWith<$Res> {
  _$SubstanceDefinitionSourceMaterialCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? genus = freezed,
    Object? species = freezed,
    Object? part_ = freezed,
    Object? countryOfOrigin = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      genus: freezed == genus
          ? _value.genus
          : genus // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      species: freezed == species
          ? _value.species
          : species // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      part_: freezed == part_
          ? _value.part_
          : part_ // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      countryOfOrigin: freezed == countryOfOrigin
          ? _value.countryOfOrigin
          : countryOfOrigin // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get genus {
    if (_value.genus == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.genus!, (value) {
      return _then(_value.copyWith(genus: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get species {
    if (_value.species == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.species!, (value) {
      return _then(_value.copyWith(species: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get part_ {
    if (_value.part_ == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.part_!, (value) {
      return _then(_value.copyWith(part_: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionSourceMaterialCopyWith<$Res>
    implements $SubstanceDefinitionSourceMaterialCopyWith<$Res> {
  factory _$$_SubstanceDefinitionSourceMaterialCopyWith(
          _$_SubstanceDefinitionSourceMaterial value,
          $Res Function(_$_SubstanceDefinitionSourceMaterial) then) =
      __$$_SubstanceDefinitionSourceMaterialCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      CodeableConcept? genus,
      CodeableConcept? species,
      @JsonKey(name: 'part') CodeableConcept? part_,
      List<CodeableConcept>? countryOfOrigin});

  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $CodeableConceptCopyWith<$Res>? get genus;
  @override
  $CodeableConceptCopyWith<$Res>? get species;
  @override
  $CodeableConceptCopyWith<$Res>? get part_;
}

/// @nodoc
class __$$_SubstanceDefinitionSourceMaterialCopyWithImpl<$Res>
    extends _$SubstanceDefinitionSourceMaterialCopyWithImpl<$Res,
        _$_SubstanceDefinitionSourceMaterial>
    implements _$$_SubstanceDefinitionSourceMaterialCopyWith<$Res> {
  __$$_SubstanceDefinitionSourceMaterialCopyWithImpl(
      _$_SubstanceDefinitionSourceMaterial _value,
      $Res Function(_$_SubstanceDefinitionSourceMaterial) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? genus = freezed,
    Object? species = freezed,
    Object? part_ = freezed,
    Object? countryOfOrigin = freezed,
  }) {
    return _then(_$_SubstanceDefinitionSourceMaterial(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      genus: freezed == genus
          ? _value.genus
          : genus // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      species: freezed == species
          ? _value.species
          : species // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      part_: freezed == part_
          ? _value.part_
          : part_ // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      countryOfOrigin: freezed == countryOfOrigin
          ? _value._countryOfOrigin
          : countryOfOrigin // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionSourceMaterial
    extends _SubstanceDefinitionSourceMaterial {
  _$_SubstanceDefinitionSourceMaterial(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.type,
      this.genus,
      this.species,
      @JsonKey(name: 'part') this.part_,
      final List<CodeableConcept>? countryOfOrigin})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _countryOfOrigin = countryOfOrigin,
        super._();

  factory _$_SubstanceDefinitionSourceMaterial.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionSourceMaterialFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] A classification that provides the origin of the raw material. Example: cat hair would be an Animal source type.
  @override
  final CodeableConcept? type;

  /// [genus] The genus of an organism, typically referring to the Latin epithet of the genus element of the plant/animal scientific name.
  @override
  final CodeableConcept? genus;

  /// [species] The species of an organism, typically referring to the Latin epithet of the species of the plant/animal.
  @override
  final CodeableConcept? species;

  /// [part_] ("part") An anatomical origin of the source material within an organism.
  @override
  @JsonKey(name: 'part')
  final CodeableConcept? part_;

  /// [countryOfOrigin] The country or countries where the material is harvested.
  final List<CodeableConcept>? _countryOfOrigin;

  /// [countryOfOrigin] The country or countries where the material is harvested.
  @override
  List<CodeableConcept>? get countryOfOrigin {
    final value = _countryOfOrigin;
    if (value == null) return null;
    if (_countryOfOrigin is EqualUnmodifiableListView) return _countryOfOrigin;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstanceDefinitionSourceMaterial(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, genus: $genus, species: $species, part_: $part_, countryOfOrigin: $countryOfOrigin)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionSourceMaterial &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.genus, genus) || other.genus == genus) &&
            (identical(other.species, species) || other.species == species) &&
            (identical(other.part_, part_) || other.part_ == part_) &&
            const DeepCollectionEquality()
                .equals(other._countryOfOrigin, _countryOfOrigin));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      genus,
      species,
      part_,
      const DeepCollectionEquality().hash(_countryOfOrigin));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionSourceMaterialCopyWith<
          _$_SubstanceDefinitionSourceMaterial>
      get copyWith => __$$_SubstanceDefinitionSourceMaterialCopyWithImpl<
          _$_SubstanceDefinitionSourceMaterial>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionSourceMaterialToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionSourceMaterial
    extends SubstanceDefinitionSourceMaterial {
  factory _SubstanceDefinitionSourceMaterial(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableConcept? type,
          final CodeableConcept? genus,
          final CodeableConcept? species,
          @JsonKey(name: 'part') final CodeableConcept? part_,
          final List<CodeableConcept>? countryOfOrigin}) =
      _$_SubstanceDefinitionSourceMaterial;
  _SubstanceDefinitionSourceMaterial._() : super._();

  factory _SubstanceDefinitionSourceMaterial.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceDefinitionSourceMaterial.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] A classification that provides the origin of the raw material. Example: cat hair would be an Animal source type.
  CodeableConcept? get type;
  @override

  /// [genus] The genus of an organism, typically referring to the Latin epithet of the genus element of the plant/animal scientific name.
  CodeableConcept? get genus;
  @override

  /// [species] The species of an organism, typically referring to the Latin epithet of the species of the plant/animal.
  CodeableConcept? get species;
  @override

  /// [part_] ("part") An anatomical origin of the source material within an organism.
  @JsonKey(name: 'part')
  CodeableConcept? get part_;
  @override

  /// [countryOfOrigin] The country or countries where the material is harvested.
  List<CodeableConcept>? get countryOfOrigin;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionSourceMaterialCopyWith<
          _$_SubstanceDefinitionSourceMaterial>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceNucleicAcid _$SubstanceNucleicAcidFromJson(Map<String, dynamic> json) {
  return _SubstanceNucleicAcid.fromJson(json);
}

/// @nodoc
mixin _$SubstanceNucleicAcid {
  /// [resourceType] This is a SubstanceNucleicAcid resource
  @JsonKey(unknownEnumValue: R5ResourceType.SubstanceNucleicAcid)
  R5ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [sequenceType] The type of the sequence shall be specified based on a controlled vocabulary.
  CodeableConcept? get sequenceType => throw _privateConstructorUsedError;

  /// [numberOfSubunits] The number of linear sequences of nucleotides linked through phosphodiester bonds shall be described. Subunits would be strands of nucleic acids that are tightly associated typically through Watson-Crick base pairing. NOTE: If not specified in the reference source, the assumption is that there is 1 subunit.
  Integer? get numberOfSubunits => throw _privateConstructorUsedError;

  /// [numberOfSubunitsElement] ("_numberOfSubunits") Extensions for numberOfSubunits
  @JsonKey(name: '_numberOfSubunits')
  Element? get numberOfSubunitsElement => throw _privateConstructorUsedError;

  /// [areaOfHybridisation] The area of hybridisation shall be described if applicable for double stranded RNA or DNA. The number associated with the subunit followed by the number associated to the residue shall be specified in increasing order. The underscore  shall be used as separator as follows: Subunitnumber Residue.
  String? get areaOfHybridisation => throw _privateConstructorUsedError;

  /// [areaOfHybridisationElement] ("_areaOfHybridisation") Extensions for areaOfHybridisation
  @JsonKey(name: '_areaOfHybridisation')
  Element? get areaOfHybridisationElement => throw _privateConstructorUsedError;

  /// [oligoNucleotideType] (TBC).
  CodeableConcept? get oligoNucleotideType =>
      throw _privateConstructorUsedError;

  /// [subunit] Subunits are listed in order of decreasing length; sequences of the same length will be ordered by molecular weight; subunits that have identical sequences will be repeated multiple times.
  List<SubstanceNucleicAcidSubunit>? get subunit =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceNucleicAcidCopyWith<SubstanceNucleicAcid> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceNucleicAcidCopyWith<$Res> {
  factory $SubstanceNucleicAcidCopyWith(SubstanceNucleicAcid value,
          $Res Function(SubstanceNucleicAcid) then) =
      _$SubstanceNucleicAcidCopyWithImpl<$Res, SubstanceNucleicAcid>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceNucleicAcid)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? sequenceType,
      Integer? numberOfSubunits,
      @JsonKey(name: '_numberOfSubunits')
          Element? numberOfSubunitsElement,
      String? areaOfHybridisation,
      @JsonKey(name: '_areaOfHybridisation')
          Element? areaOfHybridisationElement,
      CodeableConcept? oligoNucleotideType,
      List<SubstanceNucleicAcidSubunit>? subunit});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $CodeableConceptCopyWith<$Res>? get sequenceType;
  $ElementCopyWith<$Res>? get numberOfSubunitsElement;
  $ElementCopyWith<$Res>? get areaOfHybridisationElement;
  $CodeableConceptCopyWith<$Res>? get oligoNucleotideType;
}

/// @nodoc
class _$SubstanceNucleicAcidCopyWithImpl<$Res,
        $Val extends SubstanceNucleicAcid>
    implements $SubstanceNucleicAcidCopyWith<$Res> {
  _$SubstanceNucleicAcidCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequenceType = freezed,
    Object? numberOfSubunits = freezed,
    Object? numberOfSubunitsElement = freezed,
    Object? areaOfHybridisation = freezed,
    Object? areaOfHybridisationElement = freezed,
    Object? oligoNucleotideType = freezed,
    Object? subunit = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequenceType: freezed == sequenceType
          ? _value.sequenceType
          : sequenceType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      numberOfSubunits: freezed == numberOfSubunits
          ? _value.numberOfSubunits
          : numberOfSubunits // ignore: cast_nullable_to_non_nullable
              as Integer?,
      numberOfSubunitsElement: freezed == numberOfSubunitsElement
          ? _value.numberOfSubunitsElement
          : numberOfSubunitsElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      areaOfHybridisation: freezed == areaOfHybridisation
          ? _value.areaOfHybridisation
          : areaOfHybridisation // ignore: cast_nullable_to_non_nullable
              as String?,
      areaOfHybridisationElement: freezed == areaOfHybridisationElement
          ? _value.areaOfHybridisationElement
          : areaOfHybridisationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      oligoNucleotideType: freezed == oligoNucleotideType
          ? _value.oligoNucleotideType
          : oligoNucleotideType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      subunit: freezed == subunit
          ? _value.subunit
          : subunit // ignore: cast_nullable_to_non_nullable
              as List<SubstanceNucleicAcidSubunit>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get sequenceType {
    if (_value.sequenceType == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.sequenceType!, (value) {
      return _then(_value.copyWith(sequenceType: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get numberOfSubunitsElement {
    if (_value.numberOfSubunitsElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.numberOfSubunitsElement!, (value) {
      return _then(_value.copyWith(numberOfSubunitsElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get areaOfHybridisationElement {
    if (_value.areaOfHybridisationElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.areaOfHybridisationElement!, (value) {
      return _then(_value.copyWith(areaOfHybridisationElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get oligoNucleotideType {
    if (_value.oligoNucleotideType == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.oligoNucleotideType!, (value) {
      return _then(_value.copyWith(oligoNucleotideType: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceNucleicAcidCopyWith<$Res>
    implements $SubstanceNucleicAcidCopyWith<$Res> {
  factory _$$_SubstanceNucleicAcidCopyWith(_$_SubstanceNucleicAcid value,
          $Res Function(_$_SubstanceNucleicAcid) then) =
      __$$_SubstanceNucleicAcidCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceNucleicAcid)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? sequenceType,
      Integer? numberOfSubunits,
      @JsonKey(name: '_numberOfSubunits')
          Element? numberOfSubunitsElement,
      String? areaOfHybridisation,
      @JsonKey(name: '_areaOfHybridisation')
          Element? areaOfHybridisationElement,
      CodeableConcept? oligoNucleotideType,
      List<SubstanceNucleicAcidSubunit>? subunit});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $CodeableConceptCopyWith<$Res>? get sequenceType;
  @override
  $ElementCopyWith<$Res>? get numberOfSubunitsElement;
  @override
  $ElementCopyWith<$Res>? get areaOfHybridisationElement;
  @override
  $CodeableConceptCopyWith<$Res>? get oligoNucleotideType;
}

/// @nodoc
class __$$_SubstanceNucleicAcidCopyWithImpl<$Res>
    extends _$SubstanceNucleicAcidCopyWithImpl<$Res, _$_SubstanceNucleicAcid>
    implements _$$_SubstanceNucleicAcidCopyWith<$Res> {
  __$$_SubstanceNucleicAcidCopyWithImpl(_$_SubstanceNucleicAcid _value,
      $Res Function(_$_SubstanceNucleicAcid) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequenceType = freezed,
    Object? numberOfSubunits = freezed,
    Object? numberOfSubunitsElement = freezed,
    Object? areaOfHybridisation = freezed,
    Object? areaOfHybridisationElement = freezed,
    Object? oligoNucleotideType = freezed,
    Object? subunit = freezed,
  }) {
    return _then(_$_SubstanceNucleicAcid(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequenceType: freezed == sequenceType
          ? _value.sequenceType
          : sequenceType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      numberOfSubunits: freezed == numberOfSubunits
          ? _value.numberOfSubunits
          : numberOfSubunits // ignore: cast_nullable_to_non_nullable
              as Integer?,
      numberOfSubunitsElement: freezed == numberOfSubunitsElement
          ? _value.numberOfSubunitsElement
          : numberOfSubunitsElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      areaOfHybridisation: freezed == areaOfHybridisation
          ? _value.areaOfHybridisation
          : areaOfHybridisation // ignore: cast_nullable_to_non_nullable
              as String?,
      areaOfHybridisationElement: freezed == areaOfHybridisationElement
          ? _value.areaOfHybridisationElement
          : areaOfHybridisationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      oligoNucleotideType: freezed == oligoNucleotideType
          ? _value.oligoNucleotideType
          : oligoNucleotideType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      subunit: freezed == subunit
          ? _value._subunit
          : subunit // ignore: cast_nullable_to_non_nullable
              as List<SubstanceNucleicAcidSubunit>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceNucleicAcid extends _SubstanceNucleicAcid {
  _$_SubstanceNucleicAcid(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceNucleicAcid)
          this.resourceType = R5ResourceType.SubstanceNucleicAcid,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules')
          this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language')
          this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.sequenceType,
      this.numberOfSubunits,
      @JsonKey(name: '_numberOfSubunits')
          this.numberOfSubunitsElement,
      this.areaOfHybridisation,
      @JsonKey(name: '_areaOfHybridisation')
          this.areaOfHybridisationElement,
      this.oligoNucleotideType,
      final List<SubstanceNucleicAcidSubunit>? subunit})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _subunit = subunit,
        super._();

  factory _$_SubstanceNucleicAcid.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceNucleicAcidFromJson(json);

  /// [resourceType] This is a SubstanceNucleicAcid resource
  @override
  @JsonKey(unknownEnumValue: R5ResourceType.SubstanceNucleicAcid)
  final R5ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.
  @override
  final Code? language;

  /// [languageElement] ("_language") Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [sequenceType] The type of the sequence shall be specified based on a controlled vocabulary.
  @override
  final CodeableConcept? sequenceType;

  /// [numberOfSubunits] The number of linear sequences of nucleotides linked through phosphodiester bonds shall be described. Subunits would be strands of nucleic acids that are tightly associated typically through Watson-Crick base pairing. NOTE: If not specified in the reference source, the assumption is that there is 1 subunit.
  @override
  final Integer? numberOfSubunits;

  /// [numberOfSubunitsElement] ("_numberOfSubunits") Extensions for numberOfSubunits
  @override
  @JsonKey(name: '_numberOfSubunits')
  final Element? numberOfSubunitsElement;

  /// [areaOfHybridisation] The area of hybridisation shall be described if applicable for double stranded RNA or DNA. The number associated with the subunit followed by the number associated to the residue shall be specified in increasing order. The underscore  shall be used as separator as follows: Subunitnumber Residue.
  @override
  final String? areaOfHybridisation;

  /// [areaOfHybridisationElement] ("_areaOfHybridisation") Extensions for areaOfHybridisation
  @override
  @JsonKey(name: '_areaOfHybridisation')
  final Element? areaOfHybridisationElement;

  /// [oligoNucleotideType] (TBC).
  @override
  final CodeableConcept? oligoNucleotideType;

  /// [subunit] Subunits are listed in order of decreasing length; sequences of the same length will be ordered by molecular weight; subunits that have identical sequences will be repeated multiple times.
  final List<SubstanceNucleicAcidSubunit>? _subunit;

  /// [subunit] Subunits are listed in order of decreasing length; sequences of the same length will be ordered by molecular weight; subunits that have identical sequences will be repeated multiple times.
  @override
  List<SubstanceNucleicAcidSubunit>? get subunit {
    final value = _subunit;
    if (value == null) return null;
    if (_subunit is EqualUnmodifiableListView) return _subunit;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstanceNucleicAcid(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, sequenceType: $sequenceType, numberOfSubunits: $numberOfSubunits, numberOfSubunitsElement: $numberOfSubunitsElement, areaOfHybridisation: $areaOfHybridisation, areaOfHybridisationElement: $areaOfHybridisationElement, oligoNucleotideType: $oligoNucleotideType, subunit: $subunit)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceNucleicAcid &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.sequenceType, sequenceType) ||
                other.sequenceType == sequenceType) &&
            (identical(other.numberOfSubunits, numberOfSubunits) ||
                other.numberOfSubunits == numberOfSubunits) &&
            (identical(
                    other.numberOfSubunitsElement, numberOfSubunitsElement) ||
                other.numberOfSubunitsElement == numberOfSubunitsElement) &&
            (identical(other.areaOfHybridisation, areaOfHybridisation) ||
                other.areaOfHybridisation == areaOfHybridisation) &&
            (identical(other.areaOfHybridisationElement,
                    areaOfHybridisationElement) ||
                other.areaOfHybridisationElement ==
                    areaOfHybridisationElement) &&
            (identical(other.oligoNucleotideType, oligoNucleotideType) ||
                other.oligoNucleotideType == oligoNucleotideType) &&
            const DeepCollectionEquality().equals(other._subunit, _subunit));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      resourceType,
      id,
      meta,
      implicitRules,
      implicitRulesElement,
      language,
      languageElement,
      text,
      const DeepCollectionEquality().hash(_contained),
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      sequenceType,
      numberOfSubunits,
      numberOfSubunitsElement,
      areaOfHybridisation,
      areaOfHybridisationElement,
      oligoNucleotideType,
      const DeepCollectionEquality().hash(_subunit));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceNucleicAcidCopyWith<_$_SubstanceNucleicAcid> get copyWith =>
      __$$_SubstanceNucleicAcidCopyWithImpl<_$_SubstanceNucleicAcid>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceNucleicAcidToJson(
      this,
    );
  }
}

abstract class _SubstanceNucleicAcid extends SubstanceNucleicAcid {
  factory _SubstanceNucleicAcid(
          {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceNucleicAcid)
              final R5ResourceType resourceType,
          final FhirId? id,
          final Meta? meta,
          final FhirUri? implicitRules,
          @JsonKey(name: '_implicitRules')
              final Element? implicitRulesElement,
          final Code? language,
          @JsonKey(name: '_language')
              final Element? languageElement,
          final Narrative? text,
          final List<Resource>? contained,
          @JsonKey(name: 'extension')
              final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableConcept? sequenceType,
          final Integer? numberOfSubunits,
          @JsonKey(name: '_numberOfSubunits')
              final Element? numberOfSubunitsElement,
          final String? areaOfHybridisation,
          @JsonKey(name: '_areaOfHybridisation')
              final Element? areaOfHybridisationElement,
          final CodeableConcept? oligoNucleotideType,
          final List<SubstanceNucleicAcidSubunit>? subunit}) =
      _$_SubstanceNucleicAcid;
  _SubstanceNucleicAcid._() : super._();

  factory _SubstanceNucleicAcid.fromJson(Map<String, dynamic> json) =
      _$_SubstanceNucleicAcid.fromJson;

  @override

  /// [resourceType] This is a SubstanceNucleicAcid resource
  @JsonKey(unknownEnumValue: R5ResourceType.SubstanceNucleicAcid)
  R5ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.
  Code? get language;
  @override

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained;
  @override

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [sequenceType] The type of the sequence shall be specified based on a controlled vocabulary.
  CodeableConcept? get sequenceType;
  @override

  /// [numberOfSubunits] The number of linear sequences of nucleotides linked through phosphodiester bonds shall be described. Subunits would be strands of nucleic acids that are tightly associated typically through Watson-Crick base pairing. NOTE: If not specified in the reference source, the assumption is that there is 1 subunit.
  Integer? get numberOfSubunits;
  @override

  /// [numberOfSubunitsElement] ("_numberOfSubunits") Extensions for numberOfSubunits
  @JsonKey(name: '_numberOfSubunits')
  Element? get numberOfSubunitsElement;
  @override

  /// [areaOfHybridisation] The area of hybridisation shall be described if applicable for double stranded RNA or DNA. The number associated with the subunit followed by the number associated to the residue shall be specified in increasing order. The underscore  shall be used as separator as follows: Subunitnumber Residue.
  String? get areaOfHybridisation;
  @override

  /// [areaOfHybridisationElement] ("_areaOfHybridisation") Extensions for areaOfHybridisation
  @JsonKey(name: '_areaOfHybridisation')
  Element? get areaOfHybridisationElement;
  @override

  /// [oligoNucleotideType] (TBC).
  CodeableConcept? get oligoNucleotideType;
  @override

  /// [subunit] Subunits are listed in order of decreasing length; sequences of the same length will be ordered by molecular weight; subunits that have identical sequences will be repeated multiple times.
  List<SubstanceNucleicAcidSubunit>? get subunit;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceNucleicAcidCopyWith<_$_SubstanceNucleicAcid> get copyWith =>
      throw _privateConstructorUsedError;
}

SubstanceNucleicAcidSubunit _$SubstanceNucleicAcidSubunitFromJson(
    Map<String, dynamic> json) {
  return _SubstanceNucleicAcidSubunit.fromJson(json);
}

/// @nodoc
mixin _$SubstanceNucleicAcidSubunit {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [subunit] Index of linear sequences of nucleic acids in order of decreasing length. Sequences of the same length will be ordered by molecular weight. Subunits that have identical sequences will be repeated and have sequential subscripts.
  Integer? get subunit => throw _privateConstructorUsedError;

  /// [subunitElement] ("_subunit") Extensions for subunit
  @JsonKey(name: '_subunit')
  Element? get subunitElement => throw _privateConstructorUsedError;

  /// [sequence] Actual nucleotide sequence notation from 5' to 3' end using standard single letter codes. In addition to the base sequence, sugar and type of phosphate or non-phosphate linkage should also be captured.
  String? get sequence => throw _privateConstructorUsedError;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement => throw _privateConstructorUsedError;

  /// [length] The length of the sequence shall be captured.
  Integer? get length => throw _privateConstructorUsedError;

  /// [lengthElement] ("_length") Extensions for length
  @JsonKey(name: '_length')
  Element? get lengthElement => throw _privateConstructorUsedError;

  /// [sequenceAttachment] (TBC).
  Attachment? get sequenceAttachment => throw _privateConstructorUsedError;

  /// [fivePrime] The nucleotide present at the 5 terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5 prime nucleotide is the letter at the first position in the sequence. A separate representation would be redundant.
  CodeableConcept? get fivePrime => throw _privateConstructorUsedError;

  /// [threePrime] The nucleotide present at the 3 terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5 prime nucleotide is the letter at the last position in the sequence. A separate representation would be redundant.
  CodeableConcept? get threePrime => throw _privateConstructorUsedError;

  /// [linkage] The linkages between sugar residues will also be captured.
  List<SubstanceNucleicAcidLinkage>? get linkage =>
      throw _privateConstructorUsedError;

  /// [sugar] 5.3.6.8.1 Sugar ID (Mandatory).
  List<SubstanceNucleicAcidSugar>? get sugar =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceNucleicAcidSubunitCopyWith<SubstanceNucleicAcidSubunit>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceNucleicAcidSubunitCopyWith<$Res> {
  factory $SubstanceNucleicAcidSubunitCopyWith(
          SubstanceNucleicAcidSubunit value,
          $Res Function(SubstanceNucleicAcidSubunit) then) =
      _$SubstanceNucleicAcidSubunitCopyWithImpl<$Res,
          SubstanceNucleicAcidSubunit>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Integer? subunit,
      @JsonKey(name: '_subunit') Element? subunitElement,
      String? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      Integer? length,
      @JsonKey(name: '_length') Element? lengthElement,
      Attachment? sequenceAttachment,
      CodeableConcept? fivePrime,
      CodeableConcept? threePrime,
      List<SubstanceNucleicAcidLinkage>? linkage,
      List<SubstanceNucleicAcidSugar>? sugar});

  $ElementCopyWith<$Res>? get subunitElement;
  $ElementCopyWith<$Res>? get sequenceElement;
  $ElementCopyWith<$Res>? get lengthElement;
  $AttachmentCopyWith<$Res>? get sequenceAttachment;
  $CodeableConceptCopyWith<$Res>? get fivePrime;
  $CodeableConceptCopyWith<$Res>? get threePrime;
}

/// @nodoc
class _$SubstanceNucleicAcidSubunitCopyWithImpl<$Res,
        $Val extends SubstanceNucleicAcidSubunit>
    implements $SubstanceNucleicAcidSubunitCopyWith<$Res> {
  _$SubstanceNucleicAcidSubunitCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? subunit = freezed,
    Object? subunitElement = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? length = freezed,
    Object? lengthElement = freezed,
    Object? sequenceAttachment = freezed,
    Object? fivePrime = freezed,
    Object? threePrime = freezed,
    Object? linkage = freezed,
    Object? sugar = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      subunit: freezed == subunit
          ? _value.subunit
          : subunit // ignore: cast_nullable_to_non_nullable
              as Integer?,
      subunitElement: freezed == subunitElement
          ? _value.subunitElement
          : subunitElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as String?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      length: freezed == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as Integer?,
      lengthElement: freezed == lengthElement
          ? _value.lengthElement
          : lengthElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      sequenceAttachment: freezed == sequenceAttachment
          ? _value.sequenceAttachment
          : sequenceAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      fivePrime: freezed == fivePrime
          ? _value.fivePrime
          : fivePrime // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      threePrime: freezed == threePrime
          ? _value.threePrime
          : threePrime // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      linkage: freezed == linkage
          ? _value.linkage
          : linkage // ignore: cast_nullable_to_non_nullable
              as List<SubstanceNucleicAcidLinkage>?,
      sugar: freezed == sugar
          ? _value.sugar
          : sugar // ignore: cast_nullable_to_non_nullable
              as List<SubstanceNucleicAcidSugar>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get subunitElement {
    if (_value.subunitElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.subunitElement!, (value) {
      return _then(_value.copyWith(subunitElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get sequenceElement {
    if (_value.sequenceElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.sequenceElement!, (value) {
      return _then(_value.copyWith(sequenceElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get lengthElement {
    if (_value.lengthElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.lengthElement!, (value) {
      return _then(_value.copyWith(lengthElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get sequenceAttachment {
    if (_value.sequenceAttachment == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.sequenceAttachment!, (value) {
      return _then(_value.copyWith(sequenceAttachment: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get fivePrime {
    if (_value.fivePrime == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.fivePrime!, (value) {
      return _then(_value.copyWith(fivePrime: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get threePrime {
    if (_value.threePrime == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.threePrime!, (value) {
      return _then(_value.copyWith(threePrime: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceNucleicAcidSubunitCopyWith<$Res>
    implements $SubstanceNucleicAcidSubunitCopyWith<$Res> {
  factory _$$_SubstanceNucleicAcidSubunitCopyWith(
          _$_SubstanceNucleicAcidSubunit value,
          $Res Function(_$_SubstanceNucleicAcidSubunit) then) =
      __$$_SubstanceNucleicAcidSubunitCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Integer? subunit,
      @JsonKey(name: '_subunit') Element? subunitElement,
      String? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      Integer? length,
      @JsonKey(name: '_length') Element? lengthElement,
      Attachment? sequenceAttachment,
      CodeableConcept? fivePrime,
      CodeableConcept? threePrime,
      List<SubstanceNucleicAcidLinkage>? linkage,
      List<SubstanceNucleicAcidSugar>? sugar});

  @override
  $ElementCopyWith<$Res>? get subunitElement;
  @override
  $ElementCopyWith<$Res>? get sequenceElement;
  @override
  $ElementCopyWith<$Res>? get lengthElement;
  @override
  $AttachmentCopyWith<$Res>? get sequenceAttachment;
  @override
  $CodeableConceptCopyWith<$Res>? get fivePrime;
  @override
  $CodeableConceptCopyWith<$Res>? get threePrime;
}

/// @nodoc
class __$$_SubstanceNucleicAcidSubunitCopyWithImpl<$Res>
    extends _$SubstanceNucleicAcidSubunitCopyWithImpl<$Res,
        _$_SubstanceNucleicAcidSubunit>
    implements _$$_SubstanceNucleicAcidSubunitCopyWith<$Res> {
  __$$_SubstanceNucleicAcidSubunitCopyWithImpl(
      _$_SubstanceNucleicAcidSubunit _value,
      $Res Function(_$_SubstanceNucleicAcidSubunit) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? subunit = freezed,
    Object? subunitElement = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? length = freezed,
    Object? lengthElement = freezed,
    Object? sequenceAttachment = freezed,
    Object? fivePrime = freezed,
    Object? threePrime = freezed,
    Object? linkage = freezed,
    Object? sugar = freezed,
  }) {
    return _then(_$_SubstanceNucleicAcidSubunit(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      subunit: freezed == subunit
          ? _value.subunit
          : subunit // ignore: cast_nullable_to_non_nullable
              as Integer?,
      subunitElement: freezed == subunitElement
          ? _value.subunitElement
          : subunitElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as String?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      length: freezed == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as Integer?,
      lengthElement: freezed == lengthElement
          ? _value.lengthElement
          : lengthElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      sequenceAttachment: freezed == sequenceAttachment
          ? _value.sequenceAttachment
          : sequenceAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      fivePrime: freezed == fivePrime
          ? _value.fivePrime
          : fivePrime // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      threePrime: freezed == threePrime
          ? _value.threePrime
          : threePrime // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      linkage: freezed == linkage
          ? _value._linkage
          : linkage // ignore: cast_nullable_to_non_nullable
              as List<SubstanceNucleicAcidLinkage>?,
      sugar: freezed == sugar
          ? _value._sugar
          : sugar // ignore: cast_nullable_to_non_nullable
              as List<SubstanceNucleicAcidSugar>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceNucleicAcidSubunit extends _SubstanceNucleicAcidSubunit {
  _$_SubstanceNucleicAcidSubunit(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.subunit,
      @JsonKey(name: '_subunit') this.subunitElement,
      this.sequence,
      @JsonKey(name: '_sequence') this.sequenceElement,
      this.length,
      @JsonKey(name: '_length') this.lengthElement,
      this.sequenceAttachment,
      this.fivePrime,
      this.threePrime,
      final List<SubstanceNucleicAcidLinkage>? linkage,
      final List<SubstanceNucleicAcidSugar>? sugar})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _linkage = linkage,
        _sugar = sugar,
        super._();

  factory _$_SubstanceNucleicAcidSubunit.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceNucleicAcidSubunitFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [subunit] Index of linear sequences of nucleic acids in order of decreasing length. Sequences of the same length will be ordered by molecular weight. Subunits that have identical sequences will be repeated and have sequential subscripts.
  @override
  final Integer? subunit;

  /// [subunitElement] ("_subunit") Extensions for subunit
  @override
  @JsonKey(name: '_subunit')
  final Element? subunitElement;

  /// [sequence] Actual nucleotide sequence notation from 5' to 3' end using standard single letter codes. In addition to the base sequence, sugar and type of phosphate or non-phosphate linkage should also be captured.
  @override
  final String? sequence;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @override
  @JsonKey(name: '_sequence')
  final Element? sequenceElement;

  /// [length] The length of the sequence shall be captured.
  @override
  final Integer? length;

  /// [lengthElement] ("_length") Extensions for length
  @override
  @JsonKey(name: '_length')
  final Element? lengthElement;

  /// [sequenceAttachment] (TBC).
  @override
  final Attachment? sequenceAttachment;

  /// [fivePrime] The nucleotide present at the 5 terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5 prime nucleotide is the letter at the first position in the sequence. A separate representation would be redundant.
  @override
  final CodeableConcept? fivePrime;

  /// [threePrime] The nucleotide present at the 3 terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5 prime nucleotide is the letter at the last position in the sequence. A separate representation would be redundant.
  @override
  final CodeableConcept? threePrime;

  /// [linkage] The linkages between sugar residues will also be captured.
  final List<SubstanceNucleicAcidLinkage>? _linkage;

  /// [linkage] The linkages between sugar residues will also be captured.
  @override
  List<SubstanceNucleicAcidLinkage>? get linkage {
    final value = _linkage;
    if (value == null) return null;
    if (_linkage is EqualUnmodifiableListView) return _linkage;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [sugar] 5.3.6.8.1 Sugar ID (Mandatory).
  final List<SubstanceNucleicAcidSugar>? _sugar;

  /// [sugar] 5.3.6.8.1 Sugar ID (Mandatory).
  @override
  List<SubstanceNucleicAcidSugar>? get sugar {
    final value = _sugar;
    if (value == null) return null;
    if (_sugar is EqualUnmodifiableListView) return _sugar;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstanceNucleicAcidSubunit(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, subunit: $subunit, subunitElement: $subunitElement, sequence: $sequence, sequenceElement: $sequenceElement, length: $length, lengthElement: $lengthElement, sequenceAttachment: $sequenceAttachment, fivePrime: $fivePrime, threePrime: $threePrime, linkage: $linkage, sugar: $sugar)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceNucleicAcidSubunit &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.subunit, subunit) || other.subunit == subunit) &&
            (identical(other.subunitElement, subunitElement) ||
                other.subunitElement == subunitElement) &&
            (identical(other.sequence, sequence) ||
                other.sequence == sequence) &&
            (identical(other.sequenceElement, sequenceElement) ||
                other.sequenceElement == sequenceElement) &&
            (identical(other.length, length) || other.length == length) &&
            (identical(other.lengthElement, lengthElement) ||
                other.lengthElement == lengthElement) &&
            (identical(other.sequenceAttachment, sequenceAttachment) ||
                other.sequenceAttachment == sequenceAttachment) &&
            (identical(other.fivePrime, fivePrime) ||
                other.fivePrime == fivePrime) &&
            (identical(other.threePrime, threePrime) ||
                other.threePrime == threePrime) &&
            const DeepCollectionEquality().equals(other._linkage, _linkage) &&
            const DeepCollectionEquality().equals(other._sugar, _sugar));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      subunit,
      subunitElement,
      sequence,
      sequenceElement,
      length,
      lengthElement,
      sequenceAttachment,
      fivePrime,
      threePrime,
      const DeepCollectionEquality().hash(_linkage),
      const DeepCollectionEquality().hash(_sugar));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceNucleicAcidSubunitCopyWith<_$_SubstanceNucleicAcidSubunit>
      get copyWith => __$$_SubstanceNucleicAcidSubunitCopyWithImpl<
          _$_SubstanceNucleicAcidSubunit>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceNucleicAcidSubunitToJson(
      this,
    );
  }
}

abstract class _SubstanceNucleicAcidSubunit
    extends SubstanceNucleicAcidSubunit {
  factory _SubstanceNucleicAcidSubunit(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final Integer? subunit,
          @JsonKey(name: '_subunit') final Element? subunitElement,
          final String? sequence,
          @JsonKey(name: '_sequence') final Element? sequenceElement,
          final Integer? length,
          @JsonKey(name: '_length') final Element? lengthElement,
          final Attachment? sequenceAttachment,
          final CodeableConcept? fivePrime,
          final CodeableConcept? threePrime,
          final List<SubstanceNucleicAcidLinkage>? linkage,
          final List<SubstanceNucleicAcidSugar>? sugar}) =
      _$_SubstanceNucleicAcidSubunit;
  _SubstanceNucleicAcidSubunit._() : super._();

  factory _SubstanceNucleicAcidSubunit.fromJson(Map<String, dynamic> json) =
      _$_SubstanceNucleicAcidSubunit.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [subunit] Index of linear sequences of nucleic acids in order of decreasing length. Sequences of the same length will be ordered by molecular weight. Subunits that have identical sequences will be repeated and have sequential subscripts.
  Integer? get subunit;
  @override

  /// [subunitElement] ("_subunit") Extensions for subunit
  @JsonKey(name: '_subunit')
  Element? get subunitElement;
  @override

  /// [sequence] Actual nucleotide sequence notation from 5' to 3' end using standard single letter codes. In addition to the base sequence, sugar and type of phosphate or non-phosphate linkage should also be captured.
  String? get sequence;
  @override

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement;
  @override

  /// [length] The length of the sequence shall be captured.
  Integer? get length;
  @override

  /// [lengthElement] ("_length") Extensions for length
  @JsonKey(name: '_length')
  Element? get lengthElement;
  @override

  /// [sequenceAttachment] (TBC).
  Attachment? get sequenceAttachment;
  @override

  /// [fivePrime] The nucleotide present at the 5 terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5 prime nucleotide is the letter at the first position in the sequence. A separate representation would be redundant.
  CodeableConcept? get fivePrime;
  @override

  /// [threePrime] The nucleotide present at the 3 terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5 prime nucleotide is the letter at the last position in the sequence. A separate representation would be redundant.
  CodeableConcept? get threePrime;
  @override

  /// [linkage] The linkages between sugar residues will also be captured.
  List<SubstanceNucleicAcidLinkage>? get linkage;
  @override

  /// [sugar] 5.3.6.8.1 Sugar ID (Mandatory).
  List<SubstanceNucleicAcidSugar>? get sugar;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceNucleicAcidSubunitCopyWith<_$_SubstanceNucleicAcidSubunit>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceNucleicAcidLinkage _$SubstanceNucleicAcidLinkageFromJson(
    Map<String, dynamic> json) {
  return _SubstanceNucleicAcidLinkage.fromJson(json);
}

/// @nodoc
mixin _$SubstanceNucleicAcidLinkage {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [connectivity] The entity that links the sugar residues together should also be captured for nearly all naturally occurring nucleic acid the linkage is a phosphate group. For many synthetic oligonucleotides phosphorothioate linkages are often seen. Linkage connectivity is assumed to be 3-5. If the linkage is either 3-3 or 5-5 this should be specified.
  String? get connectivity => throw _privateConstructorUsedError;

  /// [connectivityElement] ("_connectivity") Extensions for connectivity
  @JsonKey(name: '_connectivity')
  Element? get connectivityElement => throw _privateConstructorUsedError;

  /// [identifier] Each linkage will be registered as a fragment and have an ID.
  Identifier? get identifier => throw _privateConstructorUsedError;

  /// [name] Each linkage will be registered as a fragment and have at least one name. A single name shall be assigned to each linkage.
  String? get name => throw _privateConstructorUsedError;

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement => throw _privateConstructorUsedError;

  /// [residueSite] Residues shall be captured as described in 5.3.6.8.3.
  String? get residueSite => throw _privateConstructorUsedError;

  /// [residueSiteElement] ("_residueSite") Extensions for residueSite
  @JsonKey(name: '_residueSite')
  Element? get residueSiteElement => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceNucleicAcidLinkageCopyWith<SubstanceNucleicAcidLinkage>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceNucleicAcidLinkageCopyWith<$Res> {
  factory $SubstanceNucleicAcidLinkageCopyWith(
          SubstanceNucleicAcidLinkage value,
          $Res Function(SubstanceNucleicAcidLinkage) then) =
      _$SubstanceNucleicAcidLinkageCopyWithImpl<$Res,
          SubstanceNucleicAcidLinkage>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? connectivity,
      @JsonKey(name: '_connectivity') Element? connectivityElement,
      Identifier? identifier,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      String? residueSite,
      @JsonKey(name: '_residueSite') Element? residueSiteElement});

  $ElementCopyWith<$Res>? get connectivityElement;
  $IdentifierCopyWith<$Res>? get identifier;
  $ElementCopyWith<$Res>? get nameElement;
  $ElementCopyWith<$Res>? get residueSiteElement;
}

/// @nodoc
class _$SubstanceNucleicAcidLinkageCopyWithImpl<$Res,
        $Val extends SubstanceNucleicAcidLinkage>
    implements $SubstanceNucleicAcidLinkageCopyWith<$Res> {
  _$SubstanceNucleicAcidLinkageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? connectivity = freezed,
    Object? connectivityElement = freezed,
    Object? identifier = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? residueSite = freezed,
    Object? residueSiteElement = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      connectivity: freezed == connectivity
          ? _value.connectivity
          : connectivity // ignore: cast_nullable_to_non_nullable
              as String?,
      connectivityElement: freezed == connectivityElement
          ? _value.connectivityElement
          : connectivityElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      residueSite: freezed == residueSite
          ? _value.residueSite
          : residueSite // ignore: cast_nullable_to_non_nullable
              as String?,
      residueSiteElement: freezed == residueSiteElement
          ? _value.residueSiteElement
          : residueSiteElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get connectivityElement {
    if (_value.connectivityElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.connectivityElement!, (value) {
      return _then(_value.copyWith(connectivityElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get identifier {
    if (_value.identifier == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.identifier!, (value) {
      return _then(_value.copyWith(identifier: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get nameElement {
    if (_value.nameElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.nameElement!, (value) {
      return _then(_value.copyWith(nameElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get residueSiteElement {
    if (_value.residueSiteElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.residueSiteElement!, (value) {
      return _then(_value.copyWith(residueSiteElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceNucleicAcidLinkageCopyWith<$Res>
    implements $SubstanceNucleicAcidLinkageCopyWith<$Res> {
  factory _$$_SubstanceNucleicAcidLinkageCopyWith(
          _$_SubstanceNucleicAcidLinkage value,
          $Res Function(_$_SubstanceNucleicAcidLinkage) then) =
      __$$_SubstanceNucleicAcidLinkageCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? connectivity,
      @JsonKey(name: '_connectivity') Element? connectivityElement,
      Identifier? identifier,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      String? residueSite,
      @JsonKey(name: '_residueSite') Element? residueSiteElement});

  @override
  $ElementCopyWith<$Res>? get connectivityElement;
  @override
  $IdentifierCopyWith<$Res>? get identifier;
  @override
  $ElementCopyWith<$Res>? get nameElement;
  @override
  $ElementCopyWith<$Res>? get residueSiteElement;
}

/// @nodoc
class __$$_SubstanceNucleicAcidLinkageCopyWithImpl<$Res>
    extends _$SubstanceNucleicAcidLinkageCopyWithImpl<$Res,
        _$_SubstanceNucleicAcidLinkage>
    implements _$$_SubstanceNucleicAcidLinkageCopyWith<$Res> {
  __$$_SubstanceNucleicAcidLinkageCopyWithImpl(
      _$_SubstanceNucleicAcidLinkage _value,
      $Res Function(_$_SubstanceNucleicAcidLinkage) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? connectivity = freezed,
    Object? connectivityElement = freezed,
    Object? identifier = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? residueSite = freezed,
    Object? residueSiteElement = freezed,
  }) {
    return _then(_$_SubstanceNucleicAcidLinkage(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      connectivity: freezed == connectivity
          ? _value.connectivity
          : connectivity // ignore: cast_nullable_to_non_nullable
              as String?,
      connectivityElement: freezed == connectivityElement
          ? _value.connectivityElement
          : connectivityElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      residueSite: freezed == residueSite
          ? _value.residueSite
          : residueSite // ignore: cast_nullable_to_non_nullable
              as String?,
      residueSiteElement: freezed == residueSiteElement
          ? _value.residueSiteElement
          : residueSiteElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceNucleicAcidLinkage extends _SubstanceNucleicAcidLinkage {
  _$_SubstanceNucleicAcidLinkage(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.connectivity,
      @JsonKey(name: '_connectivity') this.connectivityElement,
      this.identifier,
      this.name,
      @JsonKey(name: '_name') this.nameElement,
      this.residueSite,
      @JsonKey(name: '_residueSite') this.residueSiteElement})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstanceNucleicAcidLinkage.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceNucleicAcidLinkageFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [connectivity] The entity that links the sugar residues together should also be captured for nearly all naturally occurring nucleic acid the linkage is a phosphate group. For many synthetic oligonucleotides phosphorothioate linkages are often seen. Linkage connectivity is assumed to be 3-5. If the linkage is either 3-3 or 5-5 this should be specified.
  @override
  final String? connectivity;

  /// [connectivityElement] ("_connectivity") Extensions for connectivity
  @override
  @JsonKey(name: '_connectivity')
  final Element? connectivityElement;

  /// [identifier] Each linkage will be registered as a fragment and have an ID.
  @override
  final Identifier? identifier;

  /// [name] Each linkage will be registered as a fragment and have at least one name. A single name shall be assigned to each linkage.
  @override
  final String? name;

  /// [nameElement] ("_name") Extensions for name
  @override
  @JsonKey(name: '_name')
  final Element? nameElement;

  /// [residueSite] Residues shall be captured as described in 5.3.6.8.3.
  @override
  final String? residueSite;

  /// [residueSiteElement] ("_residueSite") Extensions for residueSite
  @override
  @JsonKey(name: '_residueSite')
  final Element? residueSiteElement;

  @override
  String toString() {
    return 'SubstanceNucleicAcidLinkage(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, connectivity: $connectivity, connectivityElement: $connectivityElement, identifier: $identifier, name: $name, nameElement: $nameElement, residueSite: $residueSite, residueSiteElement: $residueSiteElement)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceNucleicAcidLinkage &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.connectivity, connectivity) ||
                other.connectivity == connectivity) &&
            (identical(other.connectivityElement, connectivityElement) ||
                other.connectivityElement == connectivityElement) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.nameElement, nameElement) ||
                other.nameElement == nameElement) &&
            (identical(other.residueSite, residueSite) ||
                other.residueSite == residueSite) &&
            (identical(other.residueSiteElement, residueSiteElement) ||
                other.residueSiteElement == residueSiteElement));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      connectivity,
      connectivityElement,
      identifier,
      name,
      nameElement,
      residueSite,
      residueSiteElement);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceNucleicAcidLinkageCopyWith<_$_SubstanceNucleicAcidLinkage>
      get copyWith => __$$_SubstanceNucleicAcidLinkageCopyWithImpl<
          _$_SubstanceNucleicAcidLinkage>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceNucleicAcidLinkageToJson(
      this,
    );
  }
}

abstract class _SubstanceNucleicAcidLinkage
    extends SubstanceNucleicAcidLinkage {
  factory _SubstanceNucleicAcidLinkage(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final String? connectivity,
          @JsonKey(name: '_connectivity') final Element? connectivityElement,
          final Identifier? identifier,
          final String? name,
          @JsonKey(name: '_name') final Element? nameElement,
          final String? residueSite,
          @JsonKey(name: '_residueSite') final Element? residueSiteElement}) =
      _$_SubstanceNucleicAcidLinkage;
  _SubstanceNucleicAcidLinkage._() : super._();

  factory _SubstanceNucleicAcidLinkage.fromJson(Map<String, dynamic> json) =
      _$_SubstanceNucleicAcidLinkage.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [connectivity] The entity that links the sugar residues together should also be captured for nearly all naturally occurring nucleic acid the linkage is a phosphate group. For many synthetic oligonucleotides phosphorothioate linkages are often seen. Linkage connectivity is assumed to be 3-5. If the linkage is either 3-3 or 5-5 this should be specified.
  String? get connectivity;
  @override

  /// [connectivityElement] ("_connectivity") Extensions for connectivity
  @JsonKey(name: '_connectivity')
  Element? get connectivityElement;
  @override

  /// [identifier] Each linkage will be registered as a fragment and have an ID.
  Identifier? get identifier;
  @override

  /// [name] Each linkage will be registered as a fragment and have at least one name. A single name shall be assigned to each linkage.
  String? get name;
  @override

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement;
  @override

  /// [residueSite] Residues shall be captured as described in 5.3.6.8.3.
  String? get residueSite;
  @override

  /// [residueSiteElement] ("_residueSite") Extensions for residueSite
  @JsonKey(name: '_residueSite')
  Element? get residueSiteElement;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceNucleicAcidLinkageCopyWith<_$_SubstanceNucleicAcidLinkage>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceNucleicAcidSugar _$SubstanceNucleicAcidSugarFromJson(
    Map<String, dynamic> json) {
  return _SubstanceNucleicAcidSugar.fromJson(json);
}

/// @nodoc
mixin _$SubstanceNucleicAcidSugar {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] The Substance ID of the sugar or sugar-like component that make up the nucleotide.
  Identifier? get identifier => throw _privateConstructorUsedError;

  /// [name] The name of the sugar or sugar-like component that make up the nucleotide.
  String? get name => throw _privateConstructorUsedError;

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement => throw _privateConstructorUsedError;

  /// [residueSite] The residues that contain a given sugar will be captured. The order of given residues will be captured in the 5-3direction consistent with the base sequences listed above.
  String? get residueSite => throw _privateConstructorUsedError;

  /// [residueSiteElement] ("_residueSite") Extensions for residueSite
  @JsonKey(name: '_residueSite')
  Element? get residueSiteElement => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceNucleicAcidSugarCopyWith<SubstanceNucleicAcidSugar> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceNucleicAcidSugarCopyWith<$Res> {
  factory $SubstanceNucleicAcidSugarCopyWith(SubstanceNucleicAcidSugar value,
          $Res Function(SubstanceNucleicAcidSugar) then) =
      _$SubstanceNucleicAcidSugarCopyWithImpl<$Res, SubstanceNucleicAcidSugar>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Identifier? identifier,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      String? residueSite,
      @JsonKey(name: '_residueSite') Element? residueSiteElement});

  $IdentifierCopyWith<$Res>? get identifier;
  $ElementCopyWith<$Res>? get nameElement;
  $ElementCopyWith<$Res>? get residueSiteElement;
}

/// @nodoc
class _$SubstanceNucleicAcidSugarCopyWithImpl<$Res,
        $Val extends SubstanceNucleicAcidSugar>
    implements $SubstanceNucleicAcidSugarCopyWith<$Res> {
  _$SubstanceNucleicAcidSugarCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? residueSite = freezed,
    Object? residueSiteElement = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      residueSite: freezed == residueSite
          ? _value.residueSite
          : residueSite // ignore: cast_nullable_to_non_nullable
              as String?,
      residueSiteElement: freezed == residueSiteElement
          ? _value.residueSiteElement
          : residueSiteElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get identifier {
    if (_value.identifier == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.identifier!, (value) {
      return _then(_value.copyWith(identifier: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get nameElement {
    if (_value.nameElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.nameElement!, (value) {
      return _then(_value.copyWith(nameElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get residueSiteElement {
    if (_value.residueSiteElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.residueSiteElement!, (value) {
      return _then(_value.copyWith(residueSiteElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceNucleicAcidSugarCopyWith<$Res>
    implements $SubstanceNucleicAcidSugarCopyWith<$Res> {
  factory _$$_SubstanceNucleicAcidSugarCopyWith(
          _$_SubstanceNucleicAcidSugar value,
          $Res Function(_$_SubstanceNucleicAcidSugar) then) =
      __$$_SubstanceNucleicAcidSugarCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Identifier? identifier,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      String? residueSite,
      @JsonKey(name: '_residueSite') Element? residueSiteElement});

  @override
  $IdentifierCopyWith<$Res>? get identifier;
  @override
  $ElementCopyWith<$Res>? get nameElement;
  @override
  $ElementCopyWith<$Res>? get residueSiteElement;
}

/// @nodoc
class __$$_SubstanceNucleicAcidSugarCopyWithImpl<$Res>
    extends _$SubstanceNucleicAcidSugarCopyWithImpl<$Res,
        _$_SubstanceNucleicAcidSugar>
    implements _$$_SubstanceNucleicAcidSugarCopyWith<$Res> {
  __$$_SubstanceNucleicAcidSugarCopyWithImpl(
      _$_SubstanceNucleicAcidSugar _value,
      $Res Function(_$_SubstanceNucleicAcidSugar) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? residueSite = freezed,
    Object? residueSiteElement = freezed,
  }) {
    return _then(_$_SubstanceNucleicAcidSugar(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      residueSite: freezed == residueSite
          ? _value.residueSite
          : residueSite // ignore: cast_nullable_to_non_nullable
              as String?,
      residueSiteElement: freezed == residueSiteElement
          ? _value.residueSiteElement
          : residueSiteElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceNucleicAcidSugar extends _SubstanceNucleicAcidSugar {
  _$_SubstanceNucleicAcidSugar(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.identifier,
      this.name,
      @JsonKey(name: '_name') this.nameElement,
      this.residueSite,
      @JsonKey(name: '_residueSite') this.residueSiteElement})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstanceNucleicAcidSugar.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceNucleicAcidSugarFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] The Substance ID of the sugar or sugar-like component that make up the nucleotide.
  @override
  final Identifier? identifier;

  /// [name] The name of the sugar or sugar-like component that make up the nucleotide.
  @override
  final String? name;

  /// [nameElement] ("_name") Extensions for name
  @override
  @JsonKey(name: '_name')
  final Element? nameElement;

  /// [residueSite] The residues that contain a given sugar will be captured. The order of given residues will be captured in the 5-3direction consistent with the base sequences listed above.
  @override
  final String? residueSite;

  /// [residueSiteElement] ("_residueSite") Extensions for residueSite
  @override
  @JsonKey(name: '_residueSite')
  final Element? residueSiteElement;

  @override
  String toString() {
    return 'SubstanceNucleicAcidSugar(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, name: $name, nameElement: $nameElement, residueSite: $residueSite, residueSiteElement: $residueSiteElement)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceNucleicAcidSugar &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.nameElement, nameElement) ||
                other.nameElement == nameElement) &&
            (identical(other.residueSite, residueSite) ||
                other.residueSite == residueSite) &&
            (identical(other.residueSiteElement, residueSiteElement) ||
                other.residueSiteElement == residueSiteElement));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      identifier,
      name,
      nameElement,
      residueSite,
      residueSiteElement);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceNucleicAcidSugarCopyWith<_$_SubstanceNucleicAcidSugar>
      get copyWith => __$$_SubstanceNucleicAcidSugarCopyWithImpl<
          _$_SubstanceNucleicAcidSugar>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceNucleicAcidSugarToJson(
      this,
    );
  }
}

abstract class _SubstanceNucleicAcidSugar extends SubstanceNucleicAcidSugar {
  factory _SubstanceNucleicAcidSugar(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final Identifier? identifier,
          final String? name,
          @JsonKey(name: '_name') final Element? nameElement,
          final String? residueSite,
          @JsonKey(name: '_residueSite') final Element? residueSiteElement}) =
      _$_SubstanceNucleicAcidSugar;
  _SubstanceNucleicAcidSugar._() : super._();

  factory _SubstanceNucleicAcidSugar.fromJson(Map<String, dynamic> json) =
      _$_SubstanceNucleicAcidSugar.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] The Substance ID of the sugar or sugar-like component that make up the nucleotide.
  Identifier? get identifier;
  @override

  /// [name] The name of the sugar or sugar-like component that make up the nucleotide.
  String? get name;
  @override

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement;
  @override

  /// [residueSite] The residues that contain a given sugar will be captured. The order of given residues will be captured in the 5-3direction consistent with the base sequences listed above.
  String? get residueSite;
  @override

  /// [residueSiteElement] ("_residueSite") Extensions for residueSite
  @JsonKey(name: '_residueSite')
  Element? get residueSiteElement;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceNucleicAcidSugarCopyWith<_$_SubstanceNucleicAcidSugar>
      get copyWith => throw _privateConstructorUsedError;
}

SubstancePolymer _$SubstancePolymerFromJson(Map<String, dynamic> json) {
  return _SubstancePolymer.fromJson(json);
}

/// @nodoc
mixin _$SubstancePolymer {
  /// [resourceType] This is a SubstancePolymer resource
  @JsonKey(unknownEnumValue: R5ResourceType.SubstancePolymer)
  R5ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] A business idenfier for this polymer, but typically this is handled by a SubstanceDefinition identifier.
  Identifier? get identifier => throw _privateConstructorUsedError;

  /// [class_] ("class") Overall type of the polymer.
  @JsonKey(name: 'class')
  CodeableConcept? get class_ => throw _privateConstructorUsedError;

  /// [geometry] Polymer geometry, e.g. linear, branched, cross-linked, network or dendritic.
  CodeableConcept? get geometry => throw _privateConstructorUsedError;

  /// [copolymerConnectivity] Descrtibes the copolymer sequence type (polymer connectivity).
  List<CodeableConcept>? get copolymerConnectivity =>
      throw _privateConstructorUsedError;

  /// [modification] Todo - this is intended to connect to a repeating full modification structure, also used by Protein and Nucleic Acid . String is just a placeholder.
  String? get modification => throw _privateConstructorUsedError;

  /// [modificationElement] ("_modification") Extensions for modification
  @JsonKey(name: '_modification')
  Element? get modificationElement => throw _privateConstructorUsedError;

  /// [monomerSet] Todo.
  List<SubstancePolymerMonomerSet>? get monomerSet =>
      throw _privateConstructorUsedError;

  /// [repeat] Specifies and quantifies the repeated units and their configuration.
  List<SubstancePolymerRepeat>? get repeat =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstancePolymerCopyWith<SubstancePolymer> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstancePolymerCopyWith<$Res> {
  factory $SubstancePolymerCopyWith(
          SubstancePolymer value, $Res Function(SubstancePolymer) then) =
      _$SubstancePolymerCopyWithImpl<$Res, SubstancePolymer>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstancePolymer)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Identifier? identifier,
      @JsonKey(name: 'class')
          CodeableConcept? class_,
      CodeableConcept? geometry,
      List<CodeableConcept>? copolymerConnectivity,
      String? modification,
      @JsonKey(name: '_modification')
          Element? modificationElement,
      List<SubstancePolymerMonomerSet>? monomerSet,
      List<SubstancePolymerRepeat>? repeat});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $IdentifierCopyWith<$Res>? get identifier;
  $CodeableConceptCopyWith<$Res>? get class_;
  $CodeableConceptCopyWith<$Res>? get geometry;
  $ElementCopyWith<$Res>? get modificationElement;
}

/// @nodoc
class _$SubstancePolymerCopyWithImpl<$Res, $Val extends SubstancePolymer>
    implements $SubstancePolymerCopyWith<$Res> {
  _$SubstancePolymerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? class_ = freezed,
    Object? geometry = freezed,
    Object? copolymerConnectivity = freezed,
    Object? modification = freezed,
    Object? modificationElement = freezed,
    Object? monomerSet = freezed,
    Object? repeat = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      class_: freezed == class_
          ? _value.class_
          : class_ // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      geometry: freezed == geometry
          ? _value.geometry
          : geometry // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      copolymerConnectivity: freezed == copolymerConnectivity
          ? _value.copolymerConnectivity
          : copolymerConnectivity // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      modification: freezed == modification
          ? _value.modification
          : modification // ignore: cast_nullable_to_non_nullable
              as String?,
      modificationElement: freezed == modificationElement
          ? _value.modificationElement
          : modificationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      monomerSet: freezed == monomerSet
          ? _value.monomerSet
          : monomerSet // ignore: cast_nullable_to_non_nullable
              as List<SubstancePolymerMonomerSet>?,
      repeat: freezed == repeat
          ? _value.repeat
          : repeat // ignore: cast_nullable_to_non_nullable
              as List<SubstancePolymerRepeat>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get identifier {
    if (_value.identifier == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.identifier!, (value) {
      return _then(_value.copyWith(identifier: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get class_ {
    if (_value.class_ == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.class_!, (value) {
      return _then(_value.copyWith(class_: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get geometry {
    if (_value.geometry == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.geometry!, (value) {
      return _then(_value.copyWith(geometry: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get modificationElement {
    if (_value.modificationElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.modificationElement!, (value) {
      return _then(_value.copyWith(modificationElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstancePolymerCopyWith<$Res>
    implements $SubstancePolymerCopyWith<$Res> {
  factory _$$_SubstancePolymerCopyWith(
          _$_SubstancePolymer value, $Res Function(_$_SubstancePolymer) then) =
      __$$_SubstancePolymerCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstancePolymer)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Identifier? identifier,
      @JsonKey(name: 'class')
          CodeableConcept? class_,
      CodeableConcept? geometry,
      List<CodeableConcept>? copolymerConnectivity,
      String? modification,
      @JsonKey(name: '_modification')
          Element? modificationElement,
      List<SubstancePolymerMonomerSet>? monomerSet,
      List<SubstancePolymerRepeat>? repeat});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $IdentifierCopyWith<$Res>? get identifier;
  @override
  $CodeableConceptCopyWith<$Res>? get class_;
  @override
  $CodeableConceptCopyWith<$Res>? get geometry;
  @override
  $ElementCopyWith<$Res>? get modificationElement;
}

/// @nodoc
class __$$_SubstancePolymerCopyWithImpl<$Res>
    extends _$SubstancePolymerCopyWithImpl<$Res, _$_SubstancePolymer>
    implements _$$_SubstancePolymerCopyWith<$Res> {
  __$$_SubstancePolymerCopyWithImpl(
      _$_SubstancePolymer _value, $Res Function(_$_SubstancePolymer) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? class_ = freezed,
    Object? geometry = freezed,
    Object? copolymerConnectivity = freezed,
    Object? modification = freezed,
    Object? modificationElement = freezed,
    Object? monomerSet = freezed,
    Object? repeat = freezed,
  }) {
    return _then(_$_SubstancePolymer(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      class_: freezed == class_
          ? _value.class_
          : class_ // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      geometry: freezed == geometry
          ? _value.geometry
          : geometry // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      copolymerConnectivity: freezed == copolymerConnectivity
          ? _value._copolymerConnectivity
          : copolymerConnectivity // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      modification: freezed == modification
          ? _value.modification
          : modification // ignore: cast_nullable_to_non_nullable
              as String?,
      modificationElement: freezed == modificationElement
          ? _value.modificationElement
          : modificationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      monomerSet: freezed == monomerSet
          ? _value._monomerSet
          : monomerSet // ignore: cast_nullable_to_non_nullable
              as List<SubstancePolymerMonomerSet>?,
      repeat: freezed == repeat
          ? _value._repeat
          : repeat // ignore: cast_nullable_to_non_nullable
              as List<SubstancePolymerRepeat>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstancePolymer extends _SubstancePolymer {
  _$_SubstancePolymer(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstancePolymer)
          this.resourceType = R5ResourceType.SubstancePolymer,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules')
          this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language')
          this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.identifier,
      @JsonKey(name: 'class')
          this.class_,
      this.geometry,
      final List<CodeableConcept>? copolymerConnectivity,
      this.modification,
      @JsonKey(name: '_modification')
          this.modificationElement,
      final List<SubstancePolymerMonomerSet>? monomerSet,
      final List<SubstancePolymerRepeat>? repeat})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _copolymerConnectivity = copolymerConnectivity,
        _monomerSet = monomerSet,
        _repeat = repeat,
        super._();

  factory _$_SubstancePolymer.fromJson(Map<String, dynamic> json) =>
      _$$_SubstancePolymerFromJson(json);

  /// [resourceType] This is a SubstancePolymer resource
  @override
  @JsonKey(unknownEnumValue: R5ResourceType.SubstancePolymer)
  final R5ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.
  @override
  final Code? language;

  /// [languageElement] ("_language") Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] A business idenfier for this polymer, but typically this is handled by a SubstanceDefinition identifier.
  @override
  final Identifier? identifier;

  /// [class_] ("class") Overall type of the polymer.
  @override
  @JsonKey(name: 'class')
  final CodeableConcept? class_;

  /// [geometry] Polymer geometry, e.g. linear, branched, cross-linked, network or dendritic.
  @override
  final CodeableConcept? geometry;

  /// [copolymerConnectivity] Descrtibes the copolymer sequence type (polymer connectivity).
  final List<CodeableConcept>? _copolymerConnectivity;

  /// [copolymerConnectivity] Descrtibes the copolymer sequence type (polymer connectivity).
  @override
  List<CodeableConcept>? get copolymerConnectivity {
    final value = _copolymerConnectivity;
    if (value == null) return null;
    if (_copolymerConnectivity is EqualUnmodifiableListView)
      return _copolymerConnectivity;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modification] Todo - this is intended to connect to a repeating full modification structure, also used by Protein and Nucleic Acid . String is just a placeholder.
  @override
  final String? modification;

  /// [modificationElement] ("_modification") Extensions for modification
  @override
  @JsonKey(name: '_modification')
  final Element? modificationElement;

  /// [monomerSet] Todo.
  final List<SubstancePolymerMonomerSet>? _monomerSet;

  /// [monomerSet] Todo.
  @override
  List<SubstancePolymerMonomerSet>? get monomerSet {
    final value = _monomerSet;
    if (value == null) return null;
    if (_monomerSet is EqualUnmodifiableListView) return _monomerSet;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [repeat] Specifies and quantifies the repeated units and their configuration.
  final List<SubstancePolymerRepeat>? _repeat;

  /// [repeat] Specifies and quantifies the repeated units and their configuration.
  @override
  List<SubstancePolymerRepeat>? get repeat {
    final value = _repeat;
    if (value == null) return null;
    if (_repeat is EqualUnmodifiableListView) return _repeat;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstancePolymer(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, class_: $class_, geometry: $geometry, copolymerConnectivity: $copolymerConnectivity, modification: $modification, modificationElement: $modificationElement, monomerSet: $monomerSet, repeat: $repeat)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstancePolymer &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.class_, class_) || other.class_ == class_) &&
            (identical(other.geometry, geometry) ||
                other.geometry == geometry) &&
            const DeepCollectionEquality()
                .equals(other._copolymerConnectivity, _copolymerConnectivity) &&
            (identical(other.modification, modification) ||
                other.modification == modification) &&
            (identical(other.modificationElement, modificationElement) ||
                other.modificationElement == modificationElement) &&
            const DeepCollectionEquality()
                .equals(other._monomerSet, _monomerSet) &&
            const DeepCollectionEquality().equals(other._repeat, _repeat));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        identifier,
        class_,
        geometry,
        const DeepCollectionEquality().hash(_copolymerConnectivity),
        modification,
        modificationElement,
        const DeepCollectionEquality().hash(_monomerSet),
        const DeepCollectionEquality().hash(_repeat)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstancePolymerCopyWith<_$_SubstancePolymer> get copyWith =>
      __$$_SubstancePolymerCopyWithImpl<_$_SubstancePolymer>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstancePolymerToJson(
      this,
    );
  }
}

abstract class _SubstancePolymer extends SubstancePolymer {
  factory _SubstancePolymer(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstancePolymer)
          final R5ResourceType resourceType,
      final FhirId? id,
      final Meta? meta,
      final FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          final Element? implicitRulesElement,
      final Code? language,
      @JsonKey(name: '_language')
          final Element? languageElement,
      final Narrative? text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final Identifier? identifier,
      @JsonKey(name: 'class')
          final CodeableConcept? class_,
      final CodeableConcept? geometry,
      final List<CodeableConcept>? copolymerConnectivity,
      final String? modification,
      @JsonKey(name: '_modification')
          final Element? modificationElement,
      final List<SubstancePolymerMonomerSet>? monomerSet,
      final List<SubstancePolymerRepeat>? repeat}) = _$_SubstancePolymer;
  _SubstancePolymer._() : super._();

  factory _SubstancePolymer.fromJson(Map<String, dynamic> json) =
      _$_SubstancePolymer.fromJson;

  @override

  /// [resourceType] This is a SubstancePolymer resource
  @JsonKey(unknownEnumValue: R5ResourceType.SubstancePolymer)
  R5ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.
  Code? get language;
  @override

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained;
  @override

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] A business idenfier for this polymer, but typically this is handled by a SubstanceDefinition identifier.
  Identifier? get identifier;
  @override

  /// [class_] ("class") Overall type of the polymer.
  @JsonKey(name: 'class')
  CodeableConcept? get class_;
  @override

  /// [geometry] Polymer geometry, e.g. linear, branched, cross-linked, network or dendritic.
  CodeableConcept? get geometry;
  @override

  /// [copolymerConnectivity] Descrtibes the copolymer sequence type (polymer connectivity).
  List<CodeableConcept>? get copolymerConnectivity;
  @override

  /// [modification] Todo - this is intended to connect to a repeating full modification structure, also used by Protein and Nucleic Acid . String is just a placeholder.
  String? get modification;
  @override

  /// [modificationElement] ("_modification") Extensions for modification
  @JsonKey(name: '_modification')
  Element? get modificationElement;
  @override

  /// [monomerSet] Todo.
  List<SubstancePolymerMonomerSet>? get monomerSet;
  @override

  /// [repeat] Specifies and quantifies the repeated units and their configuration.
  List<SubstancePolymerRepeat>? get repeat;
  @override
  @JsonKey(ignore: true)
  _$$_SubstancePolymerCopyWith<_$_SubstancePolymer> get copyWith =>
      throw _privateConstructorUsedError;
}

SubstancePolymerMonomerSet _$SubstancePolymerMonomerSetFromJson(
    Map<String, dynamic> json) {
  return _SubstancePolymerMonomerSet.fromJson(json);
}

/// @nodoc
mixin _$SubstancePolymerMonomerSet {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [ratioType] Captures the type of ratio to the entire polymer, e.g. Monomer/Polymer ratio, SRU/Polymer Ratio.
  CodeableConcept? get ratioType => throw _privateConstructorUsedError;

  /// [startingMaterial] The starting materials - monomer(s) used in the synthesis of the polymer.
  List<SubstancePolymerStartingMaterial>? get startingMaterial =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstancePolymerMonomerSetCopyWith<SubstancePolymerMonomerSet>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstancePolymerMonomerSetCopyWith<$Res> {
  factory $SubstancePolymerMonomerSetCopyWith(SubstancePolymerMonomerSet value,
          $Res Function(SubstancePolymerMonomerSet) then) =
      _$SubstancePolymerMonomerSetCopyWithImpl<$Res,
          SubstancePolymerMonomerSet>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? ratioType,
      List<SubstancePolymerStartingMaterial>? startingMaterial});

  $CodeableConceptCopyWith<$Res>? get ratioType;
}

/// @nodoc
class _$SubstancePolymerMonomerSetCopyWithImpl<$Res,
        $Val extends SubstancePolymerMonomerSet>
    implements $SubstancePolymerMonomerSetCopyWith<$Res> {
  _$SubstancePolymerMonomerSetCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? ratioType = freezed,
    Object? startingMaterial = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      ratioType: freezed == ratioType
          ? _value.ratioType
          : ratioType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      startingMaterial: freezed == startingMaterial
          ? _value.startingMaterial
          : startingMaterial // ignore: cast_nullable_to_non_nullable
              as List<SubstancePolymerStartingMaterial>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get ratioType {
    if (_value.ratioType == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.ratioType!, (value) {
      return _then(_value.copyWith(ratioType: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstancePolymerMonomerSetCopyWith<$Res>
    implements $SubstancePolymerMonomerSetCopyWith<$Res> {
  factory _$$_SubstancePolymerMonomerSetCopyWith(
          _$_SubstancePolymerMonomerSet value,
          $Res Function(_$_SubstancePolymerMonomerSet) then) =
      __$$_SubstancePolymerMonomerSetCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? ratioType,
      List<SubstancePolymerStartingMaterial>? startingMaterial});

  @override
  $CodeableConceptCopyWith<$Res>? get ratioType;
}

/// @nodoc
class __$$_SubstancePolymerMonomerSetCopyWithImpl<$Res>
    extends _$SubstancePolymerMonomerSetCopyWithImpl<$Res,
        _$_SubstancePolymerMonomerSet>
    implements _$$_SubstancePolymerMonomerSetCopyWith<$Res> {
  __$$_SubstancePolymerMonomerSetCopyWithImpl(
      _$_SubstancePolymerMonomerSet _value,
      $Res Function(_$_SubstancePolymerMonomerSet) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? ratioType = freezed,
    Object? startingMaterial = freezed,
  }) {
    return _then(_$_SubstancePolymerMonomerSet(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      ratioType: freezed == ratioType
          ? _value.ratioType
          : ratioType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      startingMaterial: freezed == startingMaterial
          ? _value._startingMaterial
          : startingMaterial // ignore: cast_nullable_to_non_nullable
              as List<SubstancePolymerStartingMaterial>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstancePolymerMonomerSet extends _SubstancePolymerMonomerSet {
  _$_SubstancePolymerMonomerSet(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.ratioType,
      final List<SubstancePolymerStartingMaterial>? startingMaterial})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _startingMaterial = startingMaterial,
        super._();

  factory _$_SubstancePolymerMonomerSet.fromJson(Map<String, dynamic> json) =>
      _$$_SubstancePolymerMonomerSetFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [ratioType] Captures the type of ratio to the entire polymer, e.g. Monomer/Polymer ratio, SRU/Polymer Ratio.
  @override
  final CodeableConcept? ratioType;

  /// [startingMaterial] The starting materials - monomer(s) used in the synthesis of the polymer.
  final List<SubstancePolymerStartingMaterial>? _startingMaterial;

  /// [startingMaterial] The starting materials - monomer(s) used in the synthesis of the polymer.
  @override
  List<SubstancePolymerStartingMaterial>? get startingMaterial {
    final value = _startingMaterial;
    if (value == null) return null;
    if (_startingMaterial is EqualUnmodifiableListView)
      return _startingMaterial;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstancePolymerMonomerSet(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, ratioType: $ratioType, startingMaterial: $startingMaterial)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstancePolymerMonomerSet &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.ratioType, ratioType) ||
                other.ratioType == ratioType) &&
            const DeepCollectionEquality()
                .equals(other._startingMaterial, _startingMaterial));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      ratioType,
      const DeepCollectionEquality().hash(_startingMaterial));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstancePolymerMonomerSetCopyWith<_$_SubstancePolymerMonomerSet>
      get copyWith => __$$_SubstancePolymerMonomerSetCopyWithImpl<
          _$_SubstancePolymerMonomerSet>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstancePolymerMonomerSetToJson(
      this,
    );
  }
}

abstract class _SubstancePolymerMonomerSet extends SubstancePolymerMonomerSet {
  factory _SubstancePolymerMonomerSet(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableConcept? ratioType,
          final List<SubstancePolymerStartingMaterial>? startingMaterial}) =
      _$_SubstancePolymerMonomerSet;
  _SubstancePolymerMonomerSet._() : super._();

  factory _SubstancePolymerMonomerSet.fromJson(Map<String, dynamic> json) =
      _$_SubstancePolymerMonomerSet.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [ratioType] Captures the type of ratio to the entire polymer, e.g. Monomer/Polymer ratio, SRU/Polymer Ratio.
  CodeableConcept? get ratioType;
  @override

  /// [startingMaterial] The starting materials - monomer(s) used in the synthesis of the polymer.
  List<SubstancePolymerStartingMaterial>? get startingMaterial;
  @override
  @JsonKey(ignore: true)
  _$$_SubstancePolymerMonomerSetCopyWith<_$_SubstancePolymerMonomerSet>
      get copyWith => throw _privateConstructorUsedError;
}

SubstancePolymerStartingMaterial _$SubstancePolymerStartingMaterialFromJson(
    Map<String, dynamic> json) {
  return _SubstancePolymerStartingMaterial.fromJson(json);
}

/// @nodoc
mixin _$SubstancePolymerStartingMaterial {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [code] The type of substance for this starting material.
  CodeableConcept? get code => throw _privateConstructorUsedError;

  /// [category] Substance high level category, e.g. chemical substance.
  CodeableConcept? get category => throw _privateConstructorUsedError;

  /// [isDefining] Used to specify whether the attribute described is a defining element for the unique identification of the polymer.
  Boolean? get isDefining => throw _privateConstructorUsedError;

  /// [isDefiningElement] ("_isDefining") Extensions for isDefining
  @JsonKey(name: '_isDefining')
  Element? get isDefiningElement => throw _privateConstructorUsedError;

  /// [amount] A percentage.
  Quantity? get amount => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstancePolymerStartingMaterialCopyWith<SubstancePolymerStartingMaterial>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstancePolymerStartingMaterialCopyWith<$Res> {
  factory $SubstancePolymerStartingMaterialCopyWith(
          SubstancePolymerStartingMaterial value,
          $Res Function(SubstancePolymerStartingMaterial) then) =
      _$SubstancePolymerStartingMaterialCopyWithImpl<$Res,
          SubstancePolymerStartingMaterial>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? code,
      CodeableConcept? category,
      Boolean? isDefining,
      @JsonKey(name: '_isDefining') Element? isDefiningElement,
      Quantity? amount});

  $CodeableConceptCopyWith<$Res>? get code;
  $CodeableConceptCopyWith<$Res>? get category;
  $ElementCopyWith<$Res>? get isDefiningElement;
  $QuantityCopyWith<$Res>? get amount;
}

/// @nodoc
class _$SubstancePolymerStartingMaterialCopyWithImpl<$Res,
        $Val extends SubstancePolymerStartingMaterial>
    implements $SubstancePolymerStartingMaterialCopyWith<$Res> {
  _$SubstancePolymerStartingMaterialCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = freezed,
    Object? category = freezed,
    Object? isDefining = freezed,
    Object? isDefiningElement = freezed,
    Object? amount = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      isDefining: freezed == isDefining
          ? _value.isDefining
          : isDefining // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      isDefiningElement: freezed == isDefiningElement
          ? _value.isDefiningElement
          : isDefiningElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Quantity?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get code {
    if (_value.code == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.code!, (value) {
      return _then(_value.copyWith(code: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get category {
    if (_value.category == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.category!, (value) {
      return _then(_value.copyWith(category: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get isDefiningElement {
    if (_value.isDefiningElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.isDefiningElement!, (value) {
      return _then(_value.copyWith(isDefiningElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get amount {
    if (_value.amount == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.amount!, (value) {
      return _then(_value.copyWith(amount: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstancePolymerStartingMaterialCopyWith<$Res>
    implements $SubstancePolymerStartingMaterialCopyWith<$Res> {
  factory _$$_SubstancePolymerStartingMaterialCopyWith(
          _$_SubstancePolymerStartingMaterial value,
          $Res Function(_$_SubstancePolymerStartingMaterial) then) =
      __$$_SubstancePolymerStartingMaterialCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? code,
      CodeableConcept? category,
      Boolean? isDefining,
      @JsonKey(name: '_isDefining') Element? isDefiningElement,
      Quantity? amount});

  @override
  $CodeableConceptCopyWith<$Res>? get code;
  @override
  $CodeableConceptCopyWith<$Res>? get category;
  @override
  $ElementCopyWith<$Res>? get isDefiningElement;
  @override
  $QuantityCopyWith<$Res>? get amount;
}

/// @nodoc
class __$$_SubstancePolymerStartingMaterialCopyWithImpl<$Res>
    extends _$SubstancePolymerStartingMaterialCopyWithImpl<$Res,
        _$_SubstancePolymerStartingMaterial>
    implements _$$_SubstancePolymerStartingMaterialCopyWith<$Res> {
  __$$_SubstancePolymerStartingMaterialCopyWithImpl(
      _$_SubstancePolymerStartingMaterial _value,
      $Res Function(_$_SubstancePolymerStartingMaterial) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = freezed,
    Object? category = freezed,
    Object? isDefining = freezed,
    Object? isDefiningElement = freezed,
    Object? amount = freezed,
  }) {
    return _then(_$_SubstancePolymerStartingMaterial(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      isDefining: freezed == isDefining
          ? _value.isDefining
          : isDefining // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      isDefiningElement: freezed == isDefiningElement
          ? _value.isDefiningElement
          : isDefiningElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Quantity?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstancePolymerStartingMaterial
    extends _SubstancePolymerStartingMaterial {
  _$_SubstancePolymerStartingMaterial(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.code,
      this.category,
      this.isDefining,
      @JsonKey(name: '_isDefining') this.isDefiningElement,
      this.amount})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstancePolymerStartingMaterial.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstancePolymerStartingMaterialFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [code] The type of substance for this starting material.
  @override
  final CodeableConcept? code;

  /// [category] Substance high level category, e.g. chemical substance.
  @override
  final CodeableConcept? category;

  /// [isDefining] Used to specify whether the attribute described is a defining element for the unique identification of the polymer.
  @override
  final Boolean? isDefining;

  /// [isDefiningElement] ("_isDefining") Extensions for isDefining
  @override
  @JsonKey(name: '_isDefining')
  final Element? isDefiningElement;

  /// [amount] A percentage.
  @override
  final Quantity? amount;

  @override
  String toString() {
    return 'SubstancePolymerStartingMaterial(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, category: $category, isDefining: $isDefining, isDefiningElement: $isDefiningElement, amount: $amount)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstancePolymerStartingMaterial &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.isDefining, isDefining) ||
                other.isDefining == isDefining) &&
            (identical(other.isDefiningElement, isDefiningElement) ||
                other.isDefiningElement == isDefiningElement) &&
            (identical(other.amount, amount) || other.amount == amount));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      code,
      category,
      isDefining,
      isDefiningElement,
      amount);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstancePolymerStartingMaterialCopyWith<
          _$_SubstancePolymerStartingMaterial>
      get copyWith => __$$_SubstancePolymerStartingMaterialCopyWithImpl<
          _$_SubstancePolymerStartingMaterial>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstancePolymerStartingMaterialToJson(
      this,
    );
  }
}

abstract class _SubstancePolymerStartingMaterial
    extends SubstancePolymerStartingMaterial {
  factory _SubstancePolymerStartingMaterial(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? code,
      final CodeableConcept? category,
      final Boolean? isDefining,
      @JsonKey(name: '_isDefining') final Element? isDefiningElement,
      final Quantity? amount}) = _$_SubstancePolymerStartingMaterial;
  _SubstancePolymerStartingMaterial._() : super._();

  factory _SubstancePolymerStartingMaterial.fromJson(
      Map<String, dynamic> json) = _$_SubstancePolymerStartingMaterial.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [code] The type of substance for this starting material.
  CodeableConcept? get code;
  @override

  /// [category] Substance high level category, e.g. chemical substance.
  CodeableConcept? get category;
  @override

  /// [isDefining] Used to specify whether the attribute described is a defining element for the unique identification of the polymer.
  Boolean? get isDefining;
  @override

  /// [isDefiningElement] ("_isDefining") Extensions for isDefining
  @JsonKey(name: '_isDefining')
  Element? get isDefiningElement;
  @override

  /// [amount] A percentage.
  Quantity? get amount;
  @override
  @JsonKey(ignore: true)
  _$$_SubstancePolymerStartingMaterialCopyWith<
          _$_SubstancePolymerStartingMaterial>
      get copyWith => throw _privateConstructorUsedError;
}

SubstancePolymerRepeat _$SubstancePolymerRepeatFromJson(
    Map<String, dynamic> json) {
  return _SubstancePolymerRepeat.fromJson(json);
}

/// @nodoc
mixin _$SubstancePolymerRepeat {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [averageMolecularFormula] A representation of an (average) molecular formula from a polymer.
  String? get averageMolecularFormula => throw _privateConstructorUsedError;

  /// [averageMolecularFormulaElement] ("_averageMolecularFormula") Extensions for averageMolecularFormula
  @JsonKey(name: '_averageMolecularFormula')
  Element? get averageMolecularFormulaElement =>
      throw _privateConstructorUsedError;

  /// [repeatUnitAmountType] How the quantitative amount of Structural Repeat Units is captured (e.g. Exact, Numeric, Average).
  CodeableConcept? get repeatUnitAmountType =>
      throw _privateConstructorUsedError;

  /// [repeatUnit] An SRU - Structural Repeat Unit.
  List<SubstancePolymerRepeatUnit>? get repeatUnit =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstancePolymerRepeatCopyWith<SubstancePolymerRepeat> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstancePolymerRepeatCopyWith<$Res> {
  factory $SubstancePolymerRepeatCopyWith(SubstancePolymerRepeat value,
          $Res Function(SubstancePolymerRepeat) then) =
      _$SubstancePolymerRepeatCopyWithImpl<$Res, SubstancePolymerRepeat>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? averageMolecularFormula,
      @JsonKey(name: '_averageMolecularFormula')
          Element? averageMolecularFormulaElement,
      CodeableConcept? repeatUnitAmountType,
      List<SubstancePolymerRepeatUnit>? repeatUnit});

  $ElementCopyWith<$Res>? get averageMolecularFormulaElement;
  $CodeableConceptCopyWith<$Res>? get repeatUnitAmountType;
}

/// @nodoc
class _$SubstancePolymerRepeatCopyWithImpl<$Res,
        $Val extends SubstancePolymerRepeat>
    implements $SubstancePolymerRepeatCopyWith<$Res> {
  _$SubstancePolymerRepeatCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? averageMolecularFormula = freezed,
    Object? averageMolecularFormulaElement = freezed,
    Object? repeatUnitAmountType = freezed,
    Object? repeatUnit = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      averageMolecularFormula: freezed == averageMolecularFormula
          ? _value.averageMolecularFormula
          : averageMolecularFormula // ignore: cast_nullable_to_non_nullable
              as String?,
      averageMolecularFormulaElement: freezed == averageMolecularFormulaElement
          ? _value.averageMolecularFormulaElement
          : averageMolecularFormulaElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      repeatUnitAmountType: freezed == repeatUnitAmountType
          ? _value.repeatUnitAmountType
          : repeatUnitAmountType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      repeatUnit: freezed == repeatUnit
          ? _value.repeatUnit
          : repeatUnit // ignore: cast_nullable_to_non_nullable
              as List<SubstancePolymerRepeatUnit>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get averageMolecularFormulaElement {
    if (_value.averageMolecularFormulaElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.averageMolecularFormulaElement!,
        (value) {
      return _then(
          _value.copyWith(averageMolecularFormulaElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get repeatUnitAmountType {
    if (_value.repeatUnitAmountType == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.repeatUnitAmountType!,
        (value) {
      return _then(_value.copyWith(repeatUnitAmountType: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstancePolymerRepeatCopyWith<$Res>
    implements $SubstancePolymerRepeatCopyWith<$Res> {
  factory _$$_SubstancePolymerRepeatCopyWith(_$_SubstancePolymerRepeat value,
          $Res Function(_$_SubstancePolymerRepeat) then) =
      __$$_SubstancePolymerRepeatCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? averageMolecularFormula,
      @JsonKey(name: '_averageMolecularFormula')
          Element? averageMolecularFormulaElement,
      CodeableConcept? repeatUnitAmountType,
      List<SubstancePolymerRepeatUnit>? repeatUnit});

  @override
  $ElementCopyWith<$Res>? get averageMolecularFormulaElement;
  @override
  $CodeableConceptCopyWith<$Res>? get repeatUnitAmountType;
}

/// @nodoc
class __$$_SubstancePolymerRepeatCopyWithImpl<$Res>
    extends _$SubstancePolymerRepeatCopyWithImpl<$Res,
        _$_SubstancePolymerRepeat>
    implements _$$_SubstancePolymerRepeatCopyWith<$Res> {
  __$$_SubstancePolymerRepeatCopyWithImpl(_$_SubstancePolymerRepeat _value,
      $Res Function(_$_SubstancePolymerRepeat) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? averageMolecularFormula = freezed,
    Object? averageMolecularFormulaElement = freezed,
    Object? repeatUnitAmountType = freezed,
    Object? repeatUnit = freezed,
  }) {
    return _then(_$_SubstancePolymerRepeat(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      averageMolecularFormula: freezed == averageMolecularFormula
          ? _value.averageMolecularFormula
          : averageMolecularFormula // ignore: cast_nullable_to_non_nullable
              as String?,
      averageMolecularFormulaElement: freezed == averageMolecularFormulaElement
          ? _value.averageMolecularFormulaElement
          : averageMolecularFormulaElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      repeatUnitAmountType: freezed == repeatUnitAmountType
          ? _value.repeatUnitAmountType
          : repeatUnitAmountType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      repeatUnit: freezed == repeatUnit
          ? _value._repeatUnit
          : repeatUnit // ignore: cast_nullable_to_non_nullable
              as List<SubstancePolymerRepeatUnit>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstancePolymerRepeat extends _SubstancePolymerRepeat {
  _$_SubstancePolymerRepeat(
      {this.id,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.averageMolecularFormula,
      @JsonKey(name: '_averageMolecularFormula')
          this.averageMolecularFormulaElement,
      this.repeatUnitAmountType,
      final List<SubstancePolymerRepeatUnit>? repeatUnit})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _repeatUnit = repeatUnit,
        super._();

  factory _$_SubstancePolymerRepeat.fromJson(Map<String, dynamic> json) =>
      _$$_SubstancePolymerRepeatFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [averageMolecularFormula] A representation of an (average) molecular formula from a polymer.
  @override
  final String? averageMolecularFormula;

  /// [averageMolecularFormulaElement] ("_averageMolecularFormula") Extensions for averageMolecularFormula
  @override
  @JsonKey(name: '_averageMolecularFormula')
  final Element? averageMolecularFormulaElement;

  /// [repeatUnitAmountType] How the quantitative amount of Structural Repeat Units is captured (e.g. Exact, Numeric, Average).
  @override
  final CodeableConcept? repeatUnitAmountType;

  /// [repeatUnit] An SRU - Structural Repeat Unit.
  final List<SubstancePolymerRepeatUnit>? _repeatUnit;

  /// [repeatUnit] An SRU - Structural Repeat Unit.
  @override
  List<SubstancePolymerRepeatUnit>? get repeatUnit {
    final value = _repeatUnit;
    if (value == null) return null;
    if (_repeatUnit is EqualUnmodifiableListView) return _repeatUnit;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstancePolymerRepeat(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, averageMolecularFormula: $averageMolecularFormula, averageMolecularFormulaElement: $averageMolecularFormulaElement, repeatUnitAmountType: $repeatUnitAmountType, repeatUnit: $repeatUnit)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstancePolymerRepeat &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(
                    other.averageMolecularFormula, averageMolecularFormula) ||
                other.averageMolecularFormula == averageMolecularFormula) &&
            (identical(other.averageMolecularFormulaElement,
                    averageMolecularFormulaElement) ||
                other.averageMolecularFormulaElement ==
                    averageMolecularFormulaElement) &&
            (identical(other.repeatUnitAmountType, repeatUnitAmountType) ||
                other.repeatUnitAmountType == repeatUnitAmountType) &&
            const DeepCollectionEquality()
                .equals(other._repeatUnit, _repeatUnit));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      averageMolecularFormula,
      averageMolecularFormulaElement,
      repeatUnitAmountType,
      const DeepCollectionEquality().hash(_repeatUnit));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstancePolymerRepeatCopyWith<_$_SubstancePolymerRepeat> get copyWith =>
      __$$_SubstancePolymerRepeatCopyWithImpl<_$_SubstancePolymerRepeat>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstancePolymerRepeatToJson(
      this,
    );
  }
}

abstract class _SubstancePolymerRepeat extends SubstancePolymerRepeat {
  factory _SubstancePolymerRepeat(
          {final String? id,
          @JsonKey(name: 'extension')
              final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final String? averageMolecularFormula,
          @JsonKey(name: '_averageMolecularFormula')
              final Element? averageMolecularFormulaElement,
          final CodeableConcept? repeatUnitAmountType,
          final List<SubstancePolymerRepeatUnit>? repeatUnit}) =
      _$_SubstancePolymerRepeat;
  _SubstancePolymerRepeat._() : super._();

  factory _SubstancePolymerRepeat.fromJson(Map<String, dynamic> json) =
      _$_SubstancePolymerRepeat.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [averageMolecularFormula] A representation of an (average) molecular formula from a polymer.
  String? get averageMolecularFormula;
  @override

  /// [averageMolecularFormulaElement] ("_averageMolecularFormula") Extensions for averageMolecularFormula
  @JsonKey(name: '_averageMolecularFormula')
  Element? get averageMolecularFormulaElement;
  @override

  /// [repeatUnitAmountType] How the quantitative amount of Structural Repeat Units is captured (e.g. Exact, Numeric, Average).
  CodeableConcept? get repeatUnitAmountType;
  @override

  /// [repeatUnit] An SRU - Structural Repeat Unit.
  List<SubstancePolymerRepeatUnit>? get repeatUnit;
  @override
  @JsonKey(ignore: true)
  _$$_SubstancePolymerRepeatCopyWith<_$_SubstancePolymerRepeat> get copyWith =>
      throw _privateConstructorUsedError;
}

SubstancePolymerRepeatUnit _$SubstancePolymerRepeatUnitFromJson(
    Map<String, dynamic> json) {
  return _SubstancePolymerRepeatUnit.fromJson(json);
}

/// @nodoc
mixin _$SubstancePolymerRepeatUnit {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [unit] Structural repeat units are essential elements for defining polymers.
  String? get unit => throw _privateConstructorUsedError;

  /// [unitElement] ("_unit") Extensions for unit
  @JsonKey(name: '_unit')
  Element? get unitElement => throw _privateConstructorUsedError;

  /// [orientation] The orientation of the polymerisation, e.g. head-tail, head-head, random.
  CodeableConcept? get orientation => throw _privateConstructorUsedError;

  /// [amount] Number of repeats of this unit.
  Integer? get amount => throw _privateConstructorUsedError;

  /// [amountElement] ("_amount") Extensions for amount
  @JsonKey(name: '_amount')
  Element? get amountElement => throw _privateConstructorUsedError;

  /// [degreeOfPolymerisation] Applies to homopolymer and block co-polymers where the degree of polymerisation within a block can be described.
  List<SubstancePolymerDegreeOfPolymerisation>? get degreeOfPolymerisation =>
      throw _privateConstructorUsedError;

  /// [structuralRepresentation] A graphical structure for this SRU.
  List<SubstancePolymerStructuralRepresentation>?
      get structuralRepresentation => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstancePolymerRepeatUnitCopyWith<SubstancePolymerRepeatUnit>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstancePolymerRepeatUnitCopyWith<$Res> {
  factory $SubstancePolymerRepeatUnitCopyWith(SubstancePolymerRepeatUnit value,
          $Res Function(SubstancePolymerRepeatUnit) then) =
      _$SubstancePolymerRepeatUnitCopyWithImpl<$Res,
          SubstancePolymerRepeatUnit>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? unit,
      @JsonKey(name: '_unit') Element? unitElement,
      CodeableConcept? orientation,
      Integer? amount,
      @JsonKey(name: '_amount') Element? amountElement,
      List<SubstancePolymerDegreeOfPolymerisation>? degreeOfPolymerisation,
      List<SubstancePolymerStructuralRepresentation>?
          structuralRepresentation});

  $ElementCopyWith<$Res>? get unitElement;
  $CodeableConceptCopyWith<$Res>? get orientation;
  $ElementCopyWith<$Res>? get amountElement;
}

/// @nodoc
class _$SubstancePolymerRepeatUnitCopyWithImpl<$Res,
        $Val extends SubstancePolymerRepeatUnit>
    implements $SubstancePolymerRepeatUnitCopyWith<$Res> {
  _$SubstancePolymerRepeatUnitCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? unit = freezed,
    Object? unitElement = freezed,
    Object? orientation = freezed,
    Object? amount = freezed,
    Object? amountElement = freezed,
    Object? degreeOfPolymerisation = freezed,
    Object? structuralRepresentation = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      unit: freezed == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String?,
      unitElement: freezed == unitElement
          ? _value.unitElement
          : unitElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      orientation: freezed == orientation
          ? _value.orientation
          : orientation // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Integer?,
      amountElement: freezed == amountElement
          ? _value.amountElement
          : amountElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      degreeOfPolymerisation: freezed == degreeOfPolymerisation
          ? _value.degreeOfPolymerisation
          : degreeOfPolymerisation // ignore: cast_nullable_to_non_nullable
              as List<SubstancePolymerDegreeOfPolymerisation>?,
      structuralRepresentation: freezed == structuralRepresentation
          ? _value.structuralRepresentation
          : structuralRepresentation // ignore: cast_nullable_to_non_nullable
              as List<SubstancePolymerStructuralRepresentation>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get unitElement {
    if (_value.unitElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.unitElement!, (value) {
      return _then(_value.copyWith(unitElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get orientation {
    if (_value.orientation == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.orientation!, (value) {
      return _then(_value.copyWith(orientation: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get amountElement {
    if (_value.amountElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.amountElement!, (value) {
      return _then(_value.copyWith(amountElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstancePolymerRepeatUnitCopyWith<$Res>
    implements $SubstancePolymerRepeatUnitCopyWith<$Res> {
  factory _$$_SubstancePolymerRepeatUnitCopyWith(
          _$_SubstancePolymerRepeatUnit value,
          $Res Function(_$_SubstancePolymerRepeatUnit) then) =
      __$$_SubstancePolymerRepeatUnitCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? unit,
      @JsonKey(name: '_unit') Element? unitElement,
      CodeableConcept? orientation,
      Integer? amount,
      @JsonKey(name: '_amount') Element? amountElement,
      List<SubstancePolymerDegreeOfPolymerisation>? degreeOfPolymerisation,
      List<SubstancePolymerStructuralRepresentation>?
          structuralRepresentation});

  @override
  $ElementCopyWith<$Res>? get unitElement;
  @override
  $CodeableConceptCopyWith<$Res>? get orientation;
  @override
  $ElementCopyWith<$Res>? get amountElement;
}

/// @nodoc
class __$$_SubstancePolymerRepeatUnitCopyWithImpl<$Res>
    extends _$SubstancePolymerRepeatUnitCopyWithImpl<$Res,
        _$_SubstancePolymerRepeatUnit>
    implements _$$_SubstancePolymerRepeatUnitCopyWith<$Res> {
  __$$_SubstancePolymerRepeatUnitCopyWithImpl(
      _$_SubstancePolymerRepeatUnit _value,
      $Res Function(_$_SubstancePolymerRepeatUnit) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? unit = freezed,
    Object? unitElement = freezed,
    Object? orientation = freezed,
    Object? amount = freezed,
    Object? amountElement = freezed,
    Object? degreeOfPolymerisation = freezed,
    Object? structuralRepresentation = freezed,
  }) {
    return _then(_$_SubstancePolymerRepeatUnit(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      unit: freezed == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String?,
      unitElement: freezed == unitElement
          ? _value.unitElement
          : unitElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      orientation: freezed == orientation
          ? _value.orientation
          : orientation // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Integer?,
      amountElement: freezed == amountElement
          ? _value.amountElement
          : amountElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      degreeOfPolymerisation: freezed == degreeOfPolymerisation
          ? _value._degreeOfPolymerisation
          : degreeOfPolymerisation // ignore: cast_nullable_to_non_nullable
              as List<SubstancePolymerDegreeOfPolymerisation>?,
      structuralRepresentation: freezed == structuralRepresentation
          ? _value._structuralRepresentation
          : structuralRepresentation // ignore: cast_nullable_to_non_nullable
              as List<SubstancePolymerStructuralRepresentation>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstancePolymerRepeatUnit extends _SubstancePolymerRepeatUnit {
  _$_SubstancePolymerRepeatUnit(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.unit,
      @JsonKey(name: '_unit') this.unitElement,
      this.orientation,
      this.amount,
      @JsonKey(name: '_amount') this.amountElement,
      final List<SubstancePolymerDegreeOfPolymerisation>?
          degreeOfPolymerisation,
      final List<SubstancePolymerStructuralRepresentation>?
          structuralRepresentation})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _degreeOfPolymerisation = degreeOfPolymerisation,
        _structuralRepresentation = structuralRepresentation,
        super._();

  factory _$_SubstancePolymerRepeatUnit.fromJson(Map<String, dynamic> json) =>
      _$$_SubstancePolymerRepeatUnitFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [unit] Structural repeat units are essential elements for defining polymers.
  @override
  final String? unit;

  /// [unitElement] ("_unit") Extensions for unit
  @override
  @JsonKey(name: '_unit')
  final Element? unitElement;

  /// [orientation] The orientation of the polymerisation, e.g. head-tail, head-head, random.
  @override
  final CodeableConcept? orientation;

  /// [amount] Number of repeats of this unit.
  @override
  final Integer? amount;

  /// [amountElement] ("_amount") Extensions for amount
  @override
  @JsonKey(name: '_amount')
  final Element? amountElement;

  /// [degreeOfPolymerisation] Applies to homopolymer and block co-polymers where the degree of polymerisation within a block can be described.
  final List<SubstancePolymerDegreeOfPolymerisation>? _degreeOfPolymerisation;

  /// [degreeOfPolymerisation] Applies to homopolymer and block co-polymers where the degree of polymerisation within a block can be described.
  @override
  List<SubstancePolymerDegreeOfPolymerisation>? get degreeOfPolymerisation {
    final value = _degreeOfPolymerisation;
    if (value == null) return null;
    if (_degreeOfPolymerisation is EqualUnmodifiableListView)
      return _degreeOfPolymerisation;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [structuralRepresentation] A graphical structure for this SRU.
  final List<SubstancePolymerStructuralRepresentation>?
      _structuralRepresentation;

  /// [structuralRepresentation] A graphical structure for this SRU.
  @override
  List<SubstancePolymerStructuralRepresentation>? get structuralRepresentation {
    final value = _structuralRepresentation;
    if (value == null) return null;
    if (_structuralRepresentation is EqualUnmodifiableListView)
      return _structuralRepresentation;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstancePolymerRepeatUnit(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, unit: $unit, unitElement: $unitElement, orientation: $orientation, amount: $amount, amountElement: $amountElement, degreeOfPolymerisation: $degreeOfPolymerisation, structuralRepresentation: $structuralRepresentation)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstancePolymerRepeatUnit &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.unit, unit) || other.unit == unit) &&
            (identical(other.unitElement, unitElement) ||
                other.unitElement == unitElement) &&
            (identical(other.orientation, orientation) ||
                other.orientation == orientation) &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.amountElement, amountElement) ||
                other.amountElement == amountElement) &&
            const DeepCollectionEquality().equals(
                other._degreeOfPolymerisation, _degreeOfPolymerisation) &&
            const DeepCollectionEquality().equals(
                other._structuralRepresentation, _structuralRepresentation));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      unit,
      unitElement,
      orientation,
      amount,
      amountElement,
      const DeepCollectionEquality().hash(_degreeOfPolymerisation),
      const DeepCollectionEquality().hash(_structuralRepresentation));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstancePolymerRepeatUnitCopyWith<_$_SubstancePolymerRepeatUnit>
      get copyWith => __$$_SubstancePolymerRepeatUnitCopyWithImpl<
          _$_SubstancePolymerRepeatUnit>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstancePolymerRepeatUnitToJson(
      this,
    );
  }
}

abstract class _SubstancePolymerRepeatUnit extends SubstancePolymerRepeatUnit {
  factory _SubstancePolymerRepeatUnit(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final String? unit,
      @JsonKey(name: '_unit') final Element? unitElement,
      final CodeableConcept? orientation,
      final Integer? amount,
      @JsonKey(name: '_amount') final Element? amountElement,
      final List<SubstancePolymerDegreeOfPolymerisation>?
          degreeOfPolymerisation,
      final List<SubstancePolymerStructuralRepresentation>?
          structuralRepresentation}) = _$_SubstancePolymerRepeatUnit;
  _SubstancePolymerRepeatUnit._() : super._();

  factory _SubstancePolymerRepeatUnit.fromJson(Map<String, dynamic> json) =
      _$_SubstancePolymerRepeatUnit.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [unit] Structural repeat units are essential elements for defining polymers.
  String? get unit;
  @override

  /// [unitElement] ("_unit") Extensions for unit
  @JsonKey(name: '_unit')
  Element? get unitElement;
  @override

  /// [orientation] The orientation of the polymerisation, e.g. head-tail, head-head, random.
  CodeableConcept? get orientation;
  @override

  /// [amount] Number of repeats of this unit.
  Integer? get amount;
  @override

  /// [amountElement] ("_amount") Extensions for amount
  @JsonKey(name: '_amount')
  Element? get amountElement;
  @override

  /// [degreeOfPolymerisation] Applies to homopolymer and block co-polymers where the degree of polymerisation within a block can be described.
  List<SubstancePolymerDegreeOfPolymerisation>? get degreeOfPolymerisation;
  @override

  /// [structuralRepresentation] A graphical structure for this SRU.
  List<SubstancePolymerStructuralRepresentation>? get structuralRepresentation;
  @override
  @JsonKey(ignore: true)
  _$$_SubstancePolymerRepeatUnitCopyWith<_$_SubstancePolymerRepeatUnit>
      get copyWith => throw _privateConstructorUsedError;
}

SubstancePolymerDegreeOfPolymerisation
    _$SubstancePolymerDegreeOfPolymerisationFromJson(
        Map<String, dynamic> json) {
  return _SubstancePolymerDegreeOfPolymerisation.fromJson(json);
}

/// @nodoc
mixin _$SubstancePolymerDegreeOfPolymerisation {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] The type of the degree of polymerisation shall be described, e.g. SRU/Polymer Ratio.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [average] An average amount of polymerisation.
  Integer? get average => throw _privateConstructorUsedError;

  /// [averageElement] ("_average") Extensions for average
  @JsonKey(name: '_average')
  Element? get averageElement => throw _privateConstructorUsedError;

  /// [low] A low expected limit of the amount.
  Integer? get low => throw _privateConstructorUsedError;

  /// [lowElement] ("_low") Extensions for low
  @JsonKey(name: '_low')
  Element? get lowElement => throw _privateConstructorUsedError;

  /// [high] A high expected limit of the amount.
  Integer? get high => throw _privateConstructorUsedError;

  /// [highElement] ("_high") Extensions for high
  @JsonKey(name: '_high')
  Element? get highElement => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstancePolymerDegreeOfPolymerisationCopyWith<
          SubstancePolymerDegreeOfPolymerisation>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstancePolymerDegreeOfPolymerisationCopyWith<$Res> {
  factory $SubstancePolymerDegreeOfPolymerisationCopyWith(
          SubstancePolymerDegreeOfPolymerisation value,
          $Res Function(SubstancePolymerDegreeOfPolymerisation) then) =
      _$SubstancePolymerDegreeOfPolymerisationCopyWithImpl<$Res,
          SubstancePolymerDegreeOfPolymerisation>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      Integer? average,
      @JsonKey(name: '_average') Element? averageElement,
      Integer? low,
      @JsonKey(name: '_low') Element? lowElement,
      Integer? high,
      @JsonKey(name: '_high') Element? highElement});

  $CodeableConceptCopyWith<$Res>? get type;
  $ElementCopyWith<$Res>? get averageElement;
  $ElementCopyWith<$Res>? get lowElement;
  $ElementCopyWith<$Res>? get highElement;
}

/// @nodoc
class _$SubstancePolymerDegreeOfPolymerisationCopyWithImpl<$Res,
        $Val extends SubstancePolymerDegreeOfPolymerisation>
    implements $SubstancePolymerDegreeOfPolymerisationCopyWith<$Res> {
  _$SubstancePolymerDegreeOfPolymerisationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? average = freezed,
    Object? averageElement = freezed,
    Object? low = freezed,
    Object? lowElement = freezed,
    Object? high = freezed,
    Object? highElement = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      average: freezed == average
          ? _value.average
          : average // ignore: cast_nullable_to_non_nullable
              as Integer?,
      averageElement: freezed == averageElement
          ? _value.averageElement
          : averageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      low: freezed == low
          ? _value.low
          : low // ignore: cast_nullable_to_non_nullable
              as Integer?,
      lowElement: freezed == lowElement
          ? _value.lowElement
          : lowElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      high: freezed == high
          ? _value.high
          : high // ignore: cast_nullable_to_non_nullable
              as Integer?,
      highElement: freezed == highElement
          ? _value.highElement
          : highElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get averageElement {
    if (_value.averageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.averageElement!, (value) {
      return _then(_value.copyWith(averageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get lowElement {
    if (_value.lowElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.lowElement!, (value) {
      return _then(_value.copyWith(lowElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get highElement {
    if (_value.highElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.highElement!, (value) {
      return _then(_value.copyWith(highElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstancePolymerDegreeOfPolymerisationCopyWith<$Res>
    implements $SubstancePolymerDegreeOfPolymerisationCopyWith<$Res> {
  factory _$$_SubstancePolymerDegreeOfPolymerisationCopyWith(
          _$_SubstancePolymerDegreeOfPolymerisation value,
          $Res Function(_$_SubstancePolymerDegreeOfPolymerisation) then) =
      __$$_SubstancePolymerDegreeOfPolymerisationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      Integer? average,
      @JsonKey(name: '_average') Element? averageElement,
      Integer? low,
      @JsonKey(name: '_low') Element? lowElement,
      Integer? high,
      @JsonKey(name: '_high') Element? highElement});

  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $ElementCopyWith<$Res>? get averageElement;
  @override
  $ElementCopyWith<$Res>? get lowElement;
  @override
  $ElementCopyWith<$Res>? get highElement;
}

/// @nodoc
class __$$_SubstancePolymerDegreeOfPolymerisationCopyWithImpl<$Res>
    extends _$SubstancePolymerDegreeOfPolymerisationCopyWithImpl<$Res,
        _$_SubstancePolymerDegreeOfPolymerisation>
    implements _$$_SubstancePolymerDegreeOfPolymerisationCopyWith<$Res> {
  __$$_SubstancePolymerDegreeOfPolymerisationCopyWithImpl(
      _$_SubstancePolymerDegreeOfPolymerisation _value,
      $Res Function(_$_SubstancePolymerDegreeOfPolymerisation) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? average = freezed,
    Object? averageElement = freezed,
    Object? low = freezed,
    Object? lowElement = freezed,
    Object? high = freezed,
    Object? highElement = freezed,
  }) {
    return _then(_$_SubstancePolymerDegreeOfPolymerisation(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      average: freezed == average
          ? _value.average
          : average // ignore: cast_nullable_to_non_nullable
              as Integer?,
      averageElement: freezed == averageElement
          ? _value.averageElement
          : averageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      low: freezed == low
          ? _value.low
          : low // ignore: cast_nullable_to_non_nullable
              as Integer?,
      lowElement: freezed == lowElement
          ? _value.lowElement
          : lowElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      high: freezed == high
          ? _value.high
          : high // ignore: cast_nullable_to_non_nullable
              as Integer?,
      highElement: freezed == highElement
          ? _value.highElement
          : highElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstancePolymerDegreeOfPolymerisation
    extends _SubstancePolymerDegreeOfPolymerisation {
  _$_SubstancePolymerDegreeOfPolymerisation(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.type,
      this.average,
      @JsonKey(name: '_average') this.averageElement,
      this.low,
      @JsonKey(name: '_low') this.lowElement,
      this.high,
      @JsonKey(name: '_high') this.highElement})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstancePolymerDegreeOfPolymerisation.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstancePolymerDegreeOfPolymerisationFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] The type of the degree of polymerisation shall be described, e.g. SRU/Polymer Ratio.
  @override
  final CodeableConcept? type;

  /// [average] An average amount of polymerisation.
  @override
  final Integer? average;

  /// [averageElement] ("_average") Extensions for average
  @override
  @JsonKey(name: '_average')
  final Element? averageElement;

  /// [low] A low expected limit of the amount.
  @override
  final Integer? low;

  /// [lowElement] ("_low") Extensions for low
  @override
  @JsonKey(name: '_low')
  final Element? lowElement;

  /// [high] A high expected limit of the amount.
  @override
  final Integer? high;

  /// [highElement] ("_high") Extensions for high
  @override
  @JsonKey(name: '_high')
  final Element? highElement;

  @override
  String toString() {
    return 'SubstancePolymerDegreeOfPolymerisation(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, average: $average, averageElement: $averageElement, low: $low, lowElement: $lowElement, high: $high, highElement: $highElement)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstancePolymerDegreeOfPolymerisation &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.average, average) || other.average == average) &&
            (identical(other.averageElement, averageElement) ||
                other.averageElement == averageElement) &&
            (identical(other.low, low) || other.low == low) &&
            (identical(other.lowElement, lowElement) ||
                other.lowElement == lowElement) &&
            (identical(other.high, high) || other.high == high) &&
            (identical(other.highElement, highElement) ||
                other.highElement == highElement));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      average,
      averageElement,
      low,
      lowElement,
      high,
      highElement);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstancePolymerDegreeOfPolymerisationCopyWith<
          _$_SubstancePolymerDegreeOfPolymerisation>
      get copyWith => __$$_SubstancePolymerDegreeOfPolymerisationCopyWithImpl<
          _$_SubstancePolymerDegreeOfPolymerisation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstancePolymerDegreeOfPolymerisationToJson(
      this,
    );
  }
}

abstract class _SubstancePolymerDegreeOfPolymerisation
    extends SubstancePolymerDegreeOfPolymerisation {
  factory _SubstancePolymerDegreeOfPolymerisation(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableConcept? type,
          final Integer? average,
          @JsonKey(name: '_average') final Element? averageElement,
          final Integer? low,
          @JsonKey(name: '_low') final Element? lowElement,
          final Integer? high,
          @JsonKey(name: '_high') final Element? highElement}) =
      _$_SubstancePolymerDegreeOfPolymerisation;
  _SubstancePolymerDegreeOfPolymerisation._() : super._();

  factory _SubstancePolymerDegreeOfPolymerisation.fromJson(
          Map<String, dynamic> json) =
      _$_SubstancePolymerDegreeOfPolymerisation.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] The type of the degree of polymerisation shall be described, e.g. SRU/Polymer Ratio.
  CodeableConcept? get type;
  @override

  /// [average] An average amount of polymerisation.
  Integer? get average;
  @override

  /// [averageElement] ("_average") Extensions for average
  @JsonKey(name: '_average')
  Element? get averageElement;
  @override

  /// [low] A low expected limit of the amount.
  Integer? get low;
  @override

  /// [lowElement] ("_low") Extensions for low
  @JsonKey(name: '_low')
  Element? get lowElement;
  @override

  /// [high] A high expected limit of the amount.
  Integer? get high;
  @override

  /// [highElement] ("_high") Extensions for high
  @JsonKey(name: '_high')
  Element? get highElement;
  @override
  @JsonKey(ignore: true)
  _$$_SubstancePolymerDegreeOfPolymerisationCopyWith<
          _$_SubstancePolymerDegreeOfPolymerisation>
      get copyWith => throw _privateConstructorUsedError;
}

SubstancePolymerStructuralRepresentation
    _$SubstancePolymerStructuralRepresentationFromJson(
        Map<String, dynamic> json) {
  return _SubstancePolymerStructuralRepresentation.fromJson(json);
}

/// @nodoc
mixin _$SubstancePolymerStructuralRepresentation {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] The type of structure (e.g. Full, Partial, Representative).
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [representation] The structural representation as text string in a standard format e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF.
  String? get representation => throw _privateConstructorUsedError;

  /// [representationElement] ("_representation") Extensions for representation
  @JsonKey(name: '_representation')
  Element? get representationElement => throw _privateConstructorUsedError;

  /// [format] The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF.
  CodeableConcept? get format => throw _privateConstructorUsedError;

  /// [attachment] An attached file with the structural representation.
  Attachment? get attachment => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstancePolymerStructuralRepresentationCopyWith<
          SubstancePolymerStructuralRepresentation>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstancePolymerStructuralRepresentationCopyWith<$Res> {
  factory $SubstancePolymerStructuralRepresentationCopyWith(
          SubstancePolymerStructuralRepresentation value,
          $Res Function(SubstancePolymerStructuralRepresentation) then) =
      _$SubstancePolymerStructuralRepresentationCopyWithImpl<$Res,
          SubstancePolymerStructuralRepresentation>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      String? representation,
      @JsonKey(name: '_representation') Element? representationElement,
      CodeableConcept? format,
      Attachment? attachment});

  $CodeableConceptCopyWith<$Res>? get type;
  $ElementCopyWith<$Res>? get representationElement;
  $CodeableConceptCopyWith<$Res>? get format;
  $AttachmentCopyWith<$Res>? get attachment;
}

/// @nodoc
class _$SubstancePolymerStructuralRepresentationCopyWithImpl<$Res,
        $Val extends SubstancePolymerStructuralRepresentation>
    implements $SubstancePolymerStructuralRepresentationCopyWith<$Res> {
  _$SubstancePolymerStructuralRepresentationCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? representation = freezed,
    Object? representationElement = freezed,
    Object? format = freezed,
    Object? attachment = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      representation: freezed == representation
          ? _value.representation
          : representation // ignore: cast_nullable_to_non_nullable
              as String?,
      representationElement: freezed == representationElement
          ? _value.representationElement
          : representationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      format: freezed == format
          ? _value.format
          : format // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      attachment: freezed == attachment
          ? _value.attachment
          : attachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get representationElement {
    if (_value.representationElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.representationElement!, (value) {
      return _then(_value.copyWith(representationElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get format {
    if (_value.format == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.format!, (value) {
      return _then(_value.copyWith(format: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get attachment {
    if (_value.attachment == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.attachment!, (value) {
      return _then(_value.copyWith(attachment: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstancePolymerStructuralRepresentationCopyWith<$Res>
    implements $SubstancePolymerStructuralRepresentationCopyWith<$Res> {
  factory _$$_SubstancePolymerStructuralRepresentationCopyWith(
          _$_SubstancePolymerStructuralRepresentation value,
          $Res Function(_$_SubstancePolymerStructuralRepresentation) then) =
      __$$_SubstancePolymerStructuralRepresentationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      String? representation,
      @JsonKey(name: '_representation') Element? representationElement,
      CodeableConcept? format,
      Attachment? attachment});

  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $ElementCopyWith<$Res>? get representationElement;
  @override
  $CodeableConceptCopyWith<$Res>? get format;
  @override
  $AttachmentCopyWith<$Res>? get attachment;
}

/// @nodoc
class __$$_SubstancePolymerStructuralRepresentationCopyWithImpl<$Res>
    extends _$SubstancePolymerStructuralRepresentationCopyWithImpl<$Res,
        _$_SubstancePolymerStructuralRepresentation>
    implements _$$_SubstancePolymerStructuralRepresentationCopyWith<$Res> {
  __$$_SubstancePolymerStructuralRepresentationCopyWithImpl(
      _$_SubstancePolymerStructuralRepresentation _value,
      $Res Function(_$_SubstancePolymerStructuralRepresentation) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? representation = freezed,
    Object? representationElement = freezed,
    Object? format = freezed,
    Object? attachment = freezed,
  }) {
    return _then(_$_SubstancePolymerStructuralRepresentation(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      representation: freezed == representation
          ? _value.representation
          : representation // ignore: cast_nullable_to_non_nullable
              as String?,
      representationElement: freezed == representationElement
          ? _value.representationElement
          : representationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      format: freezed == format
          ? _value.format
          : format // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      attachment: freezed == attachment
          ? _value.attachment
          : attachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstancePolymerStructuralRepresentation
    extends _SubstancePolymerStructuralRepresentation {
  _$_SubstancePolymerStructuralRepresentation(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.type,
      this.representation,
      @JsonKey(name: '_representation') this.representationElement,
      this.format,
      this.attachment})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstancePolymerStructuralRepresentation.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstancePolymerStructuralRepresentationFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] The type of structure (e.g. Full, Partial, Representative).
  @override
  final CodeableConcept? type;

  /// [representation] The structural representation as text string in a standard format e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF.
  @override
  final String? representation;

  /// [representationElement] ("_representation") Extensions for representation
  @override
  @JsonKey(name: '_representation')
  final Element? representationElement;

  /// [format] The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF.
  @override
  final CodeableConcept? format;

  /// [attachment] An attached file with the structural representation.
  @override
  final Attachment? attachment;

  @override
  String toString() {
    return 'SubstancePolymerStructuralRepresentation(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, representation: $representation, representationElement: $representationElement, format: $format, attachment: $attachment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstancePolymerStructuralRepresentation &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.representation, representation) ||
                other.representation == representation) &&
            (identical(other.representationElement, representationElement) ||
                other.representationElement == representationElement) &&
            (identical(other.format, format) || other.format == format) &&
            (identical(other.attachment, attachment) ||
                other.attachment == attachment));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      representation,
      representationElement,
      format,
      attachment);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstancePolymerStructuralRepresentationCopyWith<
          _$_SubstancePolymerStructuralRepresentation>
      get copyWith => __$$_SubstancePolymerStructuralRepresentationCopyWithImpl<
          _$_SubstancePolymerStructuralRepresentation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstancePolymerStructuralRepresentationToJson(
      this,
    );
  }
}

abstract class _SubstancePolymerStructuralRepresentation
    extends SubstancePolymerStructuralRepresentation {
  factory _SubstancePolymerStructuralRepresentation(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? type,
      final String? representation,
      @JsonKey(name: '_representation') final Element? representationElement,
      final CodeableConcept? format,
      final Attachment?
          attachment}) = _$_SubstancePolymerStructuralRepresentation;
  _SubstancePolymerStructuralRepresentation._() : super._();

  factory _SubstancePolymerStructuralRepresentation.fromJson(
          Map<String, dynamic> json) =
      _$_SubstancePolymerStructuralRepresentation.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] The type of structure (e.g. Full, Partial, Representative).
  CodeableConcept? get type;
  @override

  /// [representation] The structural representation as text string in a standard format e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF.
  String? get representation;
  @override

  /// [representationElement] ("_representation") Extensions for representation
  @JsonKey(name: '_representation')
  Element? get representationElement;
  @override

  /// [format] The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF.
  CodeableConcept? get format;
  @override

  /// [attachment] An attached file with the structural representation.
  Attachment? get attachment;
  @override
  @JsonKey(ignore: true)
  _$$_SubstancePolymerStructuralRepresentationCopyWith<
          _$_SubstancePolymerStructuralRepresentation>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceProtein _$SubstanceProteinFromJson(Map<String, dynamic> json) {
  return _SubstanceProtein.fromJson(json);
}

/// @nodoc
mixin _$SubstanceProtein {
  /// [resourceType] This is a SubstanceProtein resource
  @JsonKey(unknownEnumValue: R5ResourceType.SubstanceProtein)
  R5ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [sequenceType] The SubstanceProtein descriptive elements will only be used when a complete or partial amino acid sequence is available or derivable from a nucleic acid sequence.
  CodeableConcept? get sequenceType => throw _privateConstructorUsedError;

  /// [numberOfSubunits] Number of linear sequences of amino acids linked through peptide bonds. The number of subunits constituting the SubstanceProtein shall be described. It is possible that the number of subunits can be variable.
  Integer? get numberOfSubunits => throw _privateConstructorUsedError;

  /// [numberOfSubunitsElement] ("_numberOfSubunits") Extensions for numberOfSubunits
  @JsonKey(name: '_numberOfSubunits')
  Element? get numberOfSubunitsElement => throw _privateConstructorUsedError;

  /// [disulfideLinkage] The disulphide bond between two cysteine residues either on the same subunit or on two different subunits shall be described. The position of the disulfide bonds in the SubstanceProtein shall be listed in increasing order of subunit number and position within subunit followed by the abbreviation of the amino acids involved. The disulfide linkage positions shall actually contain the amino acid Cysteine at the respective positions.
  List<String>? get disulfideLinkage => throw _privateConstructorUsedError;

  /// [disulfideLinkageElement] ("_disulfideLinkage") Extensions for disulfideLinkage
  @JsonKey(name: '_disulfideLinkage')
  List<Element>? get disulfideLinkageElement =>
      throw _privateConstructorUsedError;

  /// [subunit] This subclause refers to the description of each subunit constituting the SubstanceProtein. A subunit is a linear sequence of amino acids linked through peptide bonds. The Subunit information shall be provided when the finished SubstanceProtein is a complex of multiple sequences; subunits are not used to delineate domains within a single sequence. Subunits are listed in order of decreasing length; sequences of the same length will be ordered by decreasing molecular weight; subunits that have identical sequences will be repeated multiple times.
  List<SubstanceProteinSubunit>? get subunit =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceProteinCopyWith<SubstanceProtein> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceProteinCopyWith<$Res> {
  factory $SubstanceProteinCopyWith(
          SubstanceProtein value, $Res Function(SubstanceProtein) then) =
      _$SubstanceProteinCopyWithImpl<$Res, SubstanceProtein>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceProtein)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? sequenceType,
      Integer? numberOfSubunits,
      @JsonKey(name: '_numberOfSubunits')
          Element? numberOfSubunitsElement,
      List<String>? disulfideLinkage,
      @JsonKey(name: '_disulfideLinkage')
          List<Element>? disulfideLinkageElement,
      List<SubstanceProteinSubunit>? subunit});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $CodeableConceptCopyWith<$Res>? get sequenceType;
  $ElementCopyWith<$Res>? get numberOfSubunitsElement;
}

/// @nodoc
class _$SubstanceProteinCopyWithImpl<$Res, $Val extends SubstanceProtein>
    implements $SubstanceProteinCopyWith<$Res> {
  _$SubstanceProteinCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequenceType = freezed,
    Object? numberOfSubunits = freezed,
    Object? numberOfSubunitsElement = freezed,
    Object? disulfideLinkage = freezed,
    Object? disulfideLinkageElement = freezed,
    Object? subunit = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequenceType: freezed == sequenceType
          ? _value.sequenceType
          : sequenceType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      numberOfSubunits: freezed == numberOfSubunits
          ? _value.numberOfSubunits
          : numberOfSubunits // ignore: cast_nullable_to_non_nullable
              as Integer?,
      numberOfSubunitsElement: freezed == numberOfSubunitsElement
          ? _value.numberOfSubunitsElement
          : numberOfSubunitsElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      disulfideLinkage: freezed == disulfideLinkage
          ? _value.disulfideLinkage
          : disulfideLinkage // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      disulfideLinkageElement: freezed == disulfideLinkageElement
          ? _value.disulfideLinkageElement
          : disulfideLinkageElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      subunit: freezed == subunit
          ? _value.subunit
          : subunit // ignore: cast_nullable_to_non_nullable
              as List<SubstanceProteinSubunit>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get sequenceType {
    if (_value.sequenceType == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.sequenceType!, (value) {
      return _then(_value.copyWith(sequenceType: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get numberOfSubunitsElement {
    if (_value.numberOfSubunitsElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.numberOfSubunitsElement!, (value) {
      return _then(_value.copyWith(numberOfSubunitsElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceProteinCopyWith<$Res>
    implements $SubstanceProteinCopyWith<$Res> {
  factory _$$_SubstanceProteinCopyWith(
          _$_SubstanceProtein value, $Res Function(_$_SubstanceProtein) then) =
      __$$_SubstanceProteinCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceProtein)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? sequenceType,
      Integer? numberOfSubunits,
      @JsonKey(name: '_numberOfSubunits')
          Element? numberOfSubunitsElement,
      List<String>? disulfideLinkage,
      @JsonKey(name: '_disulfideLinkage')
          List<Element>? disulfideLinkageElement,
      List<SubstanceProteinSubunit>? subunit});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $CodeableConceptCopyWith<$Res>? get sequenceType;
  @override
  $ElementCopyWith<$Res>? get numberOfSubunitsElement;
}

/// @nodoc
class __$$_SubstanceProteinCopyWithImpl<$Res>
    extends _$SubstanceProteinCopyWithImpl<$Res, _$_SubstanceProtein>
    implements _$$_SubstanceProteinCopyWith<$Res> {
  __$$_SubstanceProteinCopyWithImpl(
      _$_SubstanceProtein _value, $Res Function(_$_SubstanceProtein) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequenceType = freezed,
    Object? numberOfSubunits = freezed,
    Object? numberOfSubunitsElement = freezed,
    Object? disulfideLinkage = freezed,
    Object? disulfideLinkageElement = freezed,
    Object? subunit = freezed,
  }) {
    return _then(_$_SubstanceProtein(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequenceType: freezed == sequenceType
          ? _value.sequenceType
          : sequenceType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      numberOfSubunits: freezed == numberOfSubunits
          ? _value.numberOfSubunits
          : numberOfSubunits // ignore: cast_nullable_to_non_nullable
              as Integer?,
      numberOfSubunitsElement: freezed == numberOfSubunitsElement
          ? _value.numberOfSubunitsElement
          : numberOfSubunitsElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      disulfideLinkage: freezed == disulfideLinkage
          ? _value._disulfideLinkage
          : disulfideLinkage // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      disulfideLinkageElement: freezed == disulfideLinkageElement
          ? _value._disulfideLinkageElement
          : disulfideLinkageElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      subunit: freezed == subunit
          ? _value._subunit
          : subunit // ignore: cast_nullable_to_non_nullable
              as List<SubstanceProteinSubunit>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceProtein extends _SubstanceProtein {
  _$_SubstanceProtein(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceProtein)
          this.resourceType = R5ResourceType.SubstanceProtein,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules')
          this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language')
          this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.sequenceType,
      this.numberOfSubunits,
      @JsonKey(name: '_numberOfSubunits')
          this.numberOfSubunitsElement,
      final List<String>? disulfideLinkage,
      @JsonKey(name: '_disulfideLinkage')
          final List<Element>? disulfideLinkageElement,
      final List<SubstanceProteinSubunit>? subunit})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _disulfideLinkage = disulfideLinkage,
        _disulfideLinkageElement = disulfideLinkageElement,
        _subunit = subunit,
        super._();

  factory _$_SubstanceProtein.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceProteinFromJson(json);

  /// [resourceType] This is a SubstanceProtein resource
  @override
  @JsonKey(unknownEnumValue: R5ResourceType.SubstanceProtein)
  final R5ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.
  @override
  final Code? language;

  /// [languageElement] ("_language") Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [sequenceType] The SubstanceProtein descriptive elements will only be used when a complete or partial amino acid sequence is available or derivable from a nucleic acid sequence.
  @override
  final CodeableConcept? sequenceType;

  /// [numberOfSubunits] Number of linear sequences of amino acids linked through peptide bonds. The number of subunits constituting the SubstanceProtein shall be described. It is possible that the number of subunits can be variable.
  @override
  final Integer? numberOfSubunits;

  /// [numberOfSubunitsElement] ("_numberOfSubunits") Extensions for numberOfSubunits
  @override
  @JsonKey(name: '_numberOfSubunits')
  final Element? numberOfSubunitsElement;

  /// [disulfideLinkage] The disulphide bond between two cysteine residues either on the same subunit or on two different subunits shall be described. The position of the disulfide bonds in the SubstanceProtein shall be listed in increasing order of subunit number and position within subunit followed by the abbreviation of the amino acids involved. The disulfide linkage positions shall actually contain the amino acid Cysteine at the respective positions.
  final List<String>? _disulfideLinkage;

  /// [disulfideLinkage] The disulphide bond between two cysteine residues either on the same subunit or on two different subunits shall be described. The position of the disulfide bonds in the SubstanceProtein shall be listed in increasing order of subunit number and position within subunit followed by the abbreviation of the amino acids involved. The disulfide linkage positions shall actually contain the amino acid Cysteine at the respective positions.
  @override
  List<String>? get disulfideLinkage {
    final value = _disulfideLinkage;
    if (value == null) return null;
    if (_disulfideLinkage is EqualUnmodifiableListView)
      return _disulfideLinkage;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [disulfideLinkageElement] ("_disulfideLinkage") Extensions for disulfideLinkage
  final List<Element>? _disulfideLinkageElement;

  /// [disulfideLinkageElement] ("_disulfideLinkage") Extensions for disulfideLinkage
  @override
  @JsonKey(name: '_disulfideLinkage')
  List<Element>? get disulfideLinkageElement {
    final value = _disulfideLinkageElement;
    if (value == null) return null;
    if (_disulfideLinkageElement is EqualUnmodifiableListView)
      return _disulfideLinkageElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [subunit] This subclause refers to the description of each subunit constituting the SubstanceProtein. A subunit is a linear sequence of amino acids linked through peptide bonds. The Subunit information shall be provided when the finished SubstanceProtein is a complex of multiple sequences; subunits are not used to delineate domains within a single sequence. Subunits are listed in order of decreasing length; sequences of the same length will be ordered by decreasing molecular weight; subunits that have identical sequences will be repeated multiple times.
  final List<SubstanceProteinSubunit>? _subunit;

  /// [subunit] This subclause refers to the description of each subunit constituting the SubstanceProtein. A subunit is a linear sequence of amino acids linked through peptide bonds. The Subunit information shall be provided when the finished SubstanceProtein is a complex of multiple sequences; subunits are not used to delineate domains within a single sequence. Subunits are listed in order of decreasing length; sequences of the same length will be ordered by decreasing molecular weight; subunits that have identical sequences will be repeated multiple times.
  @override
  List<SubstanceProteinSubunit>? get subunit {
    final value = _subunit;
    if (value == null) return null;
    if (_subunit is EqualUnmodifiableListView) return _subunit;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstanceProtein(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, sequenceType: $sequenceType, numberOfSubunits: $numberOfSubunits, numberOfSubunitsElement: $numberOfSubunitsElement, disulfideLinkage: $disulfideLinkage, disulfideLinkageElement: $disulfideLinkageElement, subunit: $subunit)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceProtein &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.sequenceType, sequenceType) ||
                other.sequenceType == sequenceType) &&
            (identical(other.numberOfSubunits, numberOfSubunits) ||
                other.numberOfSubunits == numberOfSubunits) &&
            (identical(
                    other.numberOfSubunitsElement, numberOfSubunitsElement) ||
                other.numberOfSubunitsElement == numberOfSubunitsElement) &&
            const DeepCollectionEquality()
                .equals(other._disulfideLinkage, _disulfideLinkage) &&
            const DeepCollectionEquality().equals(
                other._disulfideLinkageElement, _disulfideLinkageElement) &&
            const DeepCollectionEquality().equals(other._subunit, _subunit));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      resourceType,
      id,
      meta,
      implicitRules,
      implicitRulesElement,
      language,
      languageElement,
      text,
      const DeepCollectionEquality().hash(_contained),
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      sequenceType,
      numberOfSubunits,
      numberOfSubunitsElement,
      const DeepCollectionEquality().hash(_disulfideLinkage),
      const DeepCollectionEquality().hash(_disulfideLinkageElement),
      const DeepCollectionEquality().hash(_subunit));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceProteinCopyWith<_$_SubstanceProtein> get copyWith =>
      __$$_SubstanceProteinCopyWithImpl<_$_SubstanceProtein>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceProteinToJson(
      this,
    );
  }
}

abstract class _SubstanceProtein extends SubstanceProtein {
  factory _SubstanceProtein(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceProtein)
          final R5ResourceType resourceType,
      final FhirId? id,
      final Meta? meta,
      final FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          final Element? implicitRulesElement,
      final Code? language,
      @JsonKey(name: '_language')
          final Element? languageElement,
      final Narrative? text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? sequenceType,
      final Integer? numberOfSubunits,
      @JsonKey(name: '_numberOfSubunits')
          final Element? numberOfSubunitsElement,
      final List<String>? disulfideLinkage,
      @JsonKey(name: '_disulfideLinkage')
          final List<Element>? disulfideLinkageElement,
      final List<SubstanceProteinSubunit>? subunit}) = _$_SubstanceProtein;
  _SubstanceProtein._() : super._();

  factory _SubstanceProtein.fromJson(Map<String, dynamic> json) =
      _$_SubstanceProtein.fromJson;

  @override

  /// [resourceType] This is a SubstanceProtein resource
  @JsonKey(unknownEnumValue: R5ResourceType.SubstanceProtein)
  R5ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.
  Code? get language;
  @override

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained;
  @override

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [sequenceType] The SubstanceProtein descriptive elements will only be used when a complete or partial amino acid sequence is available or derivable from a nucleic acid sequence.
  CodeableConcept? get sequenceType;
  @override

  /// [numberOfSubunits] Number of linear sequences of amino acids linked through peptide bonds. The number of subunits constituting the SubstanceProtein shall be described. It is possible that the number of subunits can be variable.
  Integer? get numberOfSubunits;
  @override

  /// [numberOfSubunitsElement] ("_numberOfSubunits") Extensions for numberOfSubunits
  @JsonKey(name: '_numberOfSubunits')
  Element? get numberOfSubunitsElement;
  @override

  /// [disulfideLinkage] The disulphide bond between two cysteine residues either on the same subunit or on two different subunits shall be described. The position of the disulfide bonds in the SubstanceProtein shall be listed in increasing order of subunit number and position within subunit followed by the abbreviation of the amino acids involved. The disulfide linkage positions shall actually contain the amino acid Cysteine at the respective positions.
  List<String>? get disulfideLinkage;
  @override

  /// [disulfideLinkageElement] ("_disulfideLinkage") Extensions for disulfideLinkage
  @JsonKey(name: '_disulfideLinkage')
  List<Element>? get disulfideLinkageElement;
  @override

  /// [subunit] This subclause refers to the description of each subunit constituting the SubstanceProtein. A subunit is a linear sequence of amino acids linked through peptide bonds. The Subunit information shall be provided when the finished SubstanceProtein is a complex of multiple sequences; subunits are not used to delineate domains within a single sequence. Subunits are listed in order of decreasing length; sequences of the same length will be ordered by decreasing molecular weight; subunits that have identical sequences will be repeated multiple times.
  List<SubstanceProteinSubunit>? get subunit;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceProteinCopyWith<_$_SubstanceProtein> get copyWith =>
      throw _privateConstructorUsedError;
}

SubstanceProteinSubunit _$SubstanceProteinSubunitFromJson(
    Map<String, dynamic> json) {
  return _SubstanceProteinSubunit.fromJson(json);
}

/// @nodoc
mixin _$SubstanceProteinSubunit {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [subunit] Index of primary sequences of amino acids linked through peptide bonds in order of decreasing length. Sequences of the same length will be ordered by molecular weight. Subunits that have identical sequences will be repeated and have sequential subscripts.
  Integer? get subunit => throw _privateConstructorUsedError;

  /// [subunitElement] ("_subunit") Extensions for subunit
  @JsonKey(name: '_subunit')
  Element? get subunitElement => throw _privateConstructorUsedError;

  /// [sequence] The sequence information shall be provided enumerating the amino acids from N- to C-terminal end using standard single-letter amino acid codes. Uppercase shall be used for L-amino acids and lowercase for D-amino acids. Transcribed SubstanceProteins will always be described using the translated sequence; for synthetic peptide containing amino acids that are not represented with a single letter code an X should be used within the sequence. The modified amino acids will be distinguished by their position in the sequence.
  String? get sequence => throw _privateConstructorUsedError;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement => throw _privateConstructorUsedError;

  /// [length] Length of linear sequences of amino acids contained in the subunit.
  Integer? get length => throw _privateConstructorUsedError;

  /// [lengthElement] ("_length") Extensions for length
  @JsonKey(name: '_length')
  Element? get lengthElement => throw _privateConstructorUsedError;

  /// [sequenceAttachment] The sequence information shall be provided enumerating the amino acids from N- to C-terminal end using standard single-letter amino acid codes. Uppercase shall be used for L-amino acids and lowercase for D-amino acids. Transcribed SubstanceProteins will always be described using the translated sequence; for synthetic peptide containing amino acids that are not represented with a single letter code an X should be used within the sequence. The modified amino acids will be distinguished by their position in the sequence.
  Attachment? get sequenceAttachment => throw _privateConstructorUsedError;

  /// [nTerminalModificationId] Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID.
  Identifier? get nTerminalModificationId => throw _privateConstructorUsedError;

  /// [nTerminalModification] The name of the fragment modified at the N-terminal of the SubstanceProtein shall be specified.
  String? get nTerminalModification => throw _privateConstructorUsedError;

  /// [nTerminalModificationElement] ("_nTerminalModification") Extensions for nTerminalModification
  @JsonKey(name: '_nTerminalModification')
  Element? get nTerminalModificationElement =>
      throw _privateConstructorUsedError;

  /// [cTerminalModificationId] Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID.
  Identifier? get cTerminalModificationId => throw _privateConstructorUsedError;

  /// [cTerminalModification] The modification at the C-terminal shall be specified.
  String? get cTerminalModification => throw _privateConstructorUsedError;

  /// [cTerminalModificationElement] ("_cTerminalModification") Extensions for cTerminalModification
  @JsonKey(name: '_cTerminalModification')
  Element? get cTerminalModificationElement =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceProteinSubunitCopyWith<SubstanceProteinSubunit> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceProteinSubunitCopyWith<$Res> {
  factory $SubstanceProteinSubunitCopyWith(SubstanceProteinSubunit value,
          $Res Function(SubstanceProteinSubunit) then) =
      _$SubstanceProteinSubunitCopyWithImpl<$Res, SubstanceProteinSubunit>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Integer? subunit,
      @JsonKey(name: '_subunit')
          Element? subunitElement,
      String? sequence,
      @JsonKey(name: '_sequence')
          Element? sequenceElement,
      Integer? length,
      @JsonKey(name: '_length')
          Element? lengthElement,
      Attachment? sequenceAttachment,
      Identifier? nTerminalModificationId,
      String? nTerminalModification,
      @JsonKey(name: '_nTerminalModification')
          Element? nTerminalModificationElement,
      Identifier? cTerminalModificationId,
      String? cTerminalModification,
      @JsonKey(name: '_cTerminalModification')
          Element? cTerminalModificationElement});

  $ElementCopyWith<$Res>? get subunitElement;
  $ElementCopyWith<$Res>? get sequenceElement;
  $ElementCopyWith<$Res>? get lengthElement;
  $AttachmentCopyWith<$Res>? get sequenceAttachment;
  $IdentifierCopyWith<$Res>? get nTerminalModificationId;
  $ElementCopyWith<$Res>? get nTerminalModificationElement;
  $IdentifierCopyWith<$Res>? get cTerminalModificationId;
  $ElementCopyWith<$Res>? get cTerminalModificationElement;
}

/// @nodoc
class _$SubstanceProteinSubunitCopyWithImpl<$Res,
        $Val extends SubstanceProteinSubunit>
    implements $SubstanceProteinSubunitCopyWith<$Res> {
  _$SubstanceProteinSubunitCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? subunit = freezed,
    Object? subunitElement = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? length = freezed,
    Object? lengthElement = freezed,
    Object? sequenceAttachment = freezed,
    Object? nTerminalModificationId = freezed,
    Object? nTerminalModification = freezed,
    Object? nTerminalModificationElement = freezed,
    Object? cTerminalModificationId = freezed,
    Object? cTerminalModification = freezed,
    Object? cTerminalModificationElement = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      subunit: freezed == subunit
          ? _value.subunit
          : subunit // ignore: cast_nullable_to_non_nullable
              as Integer?,
      subunitElement: freezed == subunitElement
          ? _value.subunitElement
          : subunitElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as String?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      length: freezed == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as Integer?,
      lengthElement: freezed == lengthElement
          ? _value.lengthElement
          : lengthElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      sequenceAttachment: freezed == sequenceAttachment
          ? _value.sequenceAttachment
          : sequenceAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      nTerminalModificationId: freezed == nTerminalModificationId
          ? _value.nTerminalModificationId
          : nTerminalModificationId // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      nTerminalModification: freezed == nTerminalModification
          ? _value.nTerminalModification
          : nTerminalModification // ignore: cast_nullable_to_non_nullable
              as String?,
      nTerminalModificationElement: freezed == nTerminalModificationElement
          ? _value.nTerminalModificationElement
          : nTerminalModificationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      cTerminalModificationId: freezed == cTerminalModificationId
          ? _value.cTerminalModificationId
          : cTerminalModificationId // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      cTerminalModification: freezed == cTerminalModification
          ? _value.cTerminalModification
          : cTerminalModification // ignore: cast_nullable_to_non_nullable
              as String?,
      cTerminalModificationElement: freezed == cTerminalModificationElement
          ? _value.cTerminalModificationElement
          : cTerminalModificationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get subunitElement {
    if (_value.subunitElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.subunitElement!, (value) {
      return _then(_value.copyWith(subunitElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get sequenceElement {
    if (_value.sequenceElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.sequenceElement!, (value) {
      return _then(_value.copyWith(sequenceElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get lengthElement {
    if (_value.lengthElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.lengthElement!, (value) {
      return _then(_value.copyWith(lengthElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get sequenceAttachment {
    if (_value.sequenceAttachment == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.sequenceAttachment!, (value) {
      return _then(_value.copyWith(sequenceAttachment: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get nTerminalModificationId {
    if (_value.nTerminalModificationId == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.nTerminalModificationId!, (value) {
      return _then(_value.copyWith(nTerminalModificationId: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get nTerminalModificationElement {
    if (_value.nTerminalModificationElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.nTerminalModificationElement!,
        (value) {
      return _then(
          _value.copyWith(nTerminalModificationElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get cTerminalModificationId {
    if (_value.cTerminalModificationId == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.cTerminalModificationId!, (value) {
      return _then(_value.copyWith(cTerminalModificationId: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get cTerminalModificationElement {
    if (_value.cTerminalModificationElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.cTerminalModificationElement!,
        (value) {
      return _then(
          _value.copyWith(cTerminalModificationElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceProteinSubunitCopyWith<$Res>
    implements $SubstanceProteinSubunitCopyWith<$Res> {
  factory _$$_SubstanceProteinSubunitCopyWith(_$_SubstanceProteinSubunit value,
          $Res Function(_$_SubstanceProteinSubunit) then) =
      __$$_SubstanceProteinSubunitCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Integer? subunit,
      @JsonKey(name: '_subunit')
          Element? subunitElement,
      String? sequence,
      @JsonKey(name: '_sequence')
          Element? sequenceElement,
      Integer? length,
      @JsonKey(name: '_length')
          Element? lengthElement,
      Attachment? sequenceAttachment,
      Identifier? nTerminalModificationId,
      String? nTerminalModification,
      @JsonKey(name: '_nTerminalModification')
          Element? nTerminalModificationElement,
      Identifier? cTerminalModificationId,
      String? cTerminalModification,
      @JsonKey(name: '_cTerminalModification')
          Element? cTerminalModificationElement});

  @override
  $ElementCopyWith<$Res>? get subunitElement;
  @override
  $ElementCopyWith<$Res>? get sequenceElement;
  @override
  $ElementCopyWith<$Res>? get lengthElement;
  @override
  $AttachmentCopyWith<$Res>? get sequenceAttachment;
  @override
  $IdentifierCopyWith<$Res>? get nTerminalModificationId;
  @override
  $ElementCopyWith<$Res>? get nTerminalModificationElement;
  @override
  $IdentifierCopyWith<$Res>? get cTerminalModificationId;
  @override
  $ElementCopyWith<$Res>? get cTerminalModificationElement;
}

/// @nodoc
class __$$_SubstanceProteinSubunitCopyWithImpl<$Res>
    extends _$SubstanceProteinSubunitCopyWithImpl<$Res,
        _$_SubstanceProteinSubunit>
    implements _$$_SubstanceProteinSubunitCopyWith<$Res> {
  __$$_SubstanceProteinSubunitCopyWithImpl(_$_SubstanceProteinSubunit _value,
      $Res Function(_$_SubstanceProteinSubunit) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? subunit = freezed,
    Object? subunitElement = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? length = freezed,
    Object? lengthElement = freezed,
    Object? sequenceAttachment = freezed,
    Object? nTerminalModificationId = freezed,
    Object? nTerminalModification = freezed,
    Object? nTerminalModificationElement = freezed,
    Object? cTerminalModificationId = freezed,
    Object? cTerminalModification = freezed,
    Object? cTerminalModificationElement = freezed,
  }) {
    return _then(_$_SubstanceProteinSubunit(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      subunit: freezed == subunit
          ? _value.subunit
          : subunit // ignore: cast_nullable_to_non_nullable
              as Integer?,
      subunitElement: freezed == subunitElement
          ? _value.subunitElement
          : subunitElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as String?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      length: freezed == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as Integer?,
      lengthElement: freezed == lengthElement
          ? _value.lengthElement
          : lengthElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      sequenceAttachment: freezed == sequenceAttachment
          ? _value.sequenceAttachment
          : sequenceAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      nTerminalModificationId: freezed == nTerminalModificationId
          ? _value.nTerminalModificationId
          : nTerminalModificationId // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      nTerminalModification: freezed == nTerminalModification
          ? _value.nTerminalModification
          : nTerminalModification // ignore: cast_nullable_to_non_nullable
              as String?,
      nTerminalModificationElement: freezed == nTerminalModificationElement
          ? _value.nTerminalModificationElement
          : nTerminalModificationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      cTerminalModificationId: freezed == cTerminalModificationId
          ? _value.cTerminalModificationId
          : cTerminalModificationId // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      cTerminalModification: freezed == cTerminalModification
          ? _value.cTerminalModification
          : cTerminalModification // ignore: cast_nullable_to_non_nullable
              as String?,
      cTerminalModificationElement: freezed == cTerminalModificationElement
          ? _value.cTerminalModificationElement
          : cTerminalModificationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceProteinSubunit extends _SubstanceProteinSubunit {
  _$_SubstanceProteinSubunit(
      {this.id,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.subunit,
      @JsonKey(name: '_subunit')
          this.subunitElement,
      this.sequence,
      @JsonKey(name: '_sequence')
          this.sequenceElement,
      this.length,
      @JsonKey(name: '_length')
          this.lengthElement,
      this.sequenceAttachment,
      this.nTerminalModificationId,
      this.nTerminalModification,
      @JsonKey(name: '_nTerminalModification')
          this.nTerminalModificationElement,
      this.cTerminalModificationId,
      this.cTerminalModification,
      @JsonKey(name: '_cTerminalModification')
          this.cTerminalModificationElement})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstanceProteinSubunit.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceProteinSubunitFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [subunit] Index of primary sequences of amino acids linked through peptide bonds in order of decreasing length. Sequences of the same length will be ordered by molecular weight. Subunits that have identical sequences will be repeated and have sequential subscripts.
  @override
  final Integer? subunit;

  /// [subunitElement] ("_subunit") Extensions for subunit
  @override
  @JsonKey(name: '_subunit')
  final Element? subunitElement;

  /// [sequence] The sequence information shall be provided enumerating the amino acids from N- to C-terminal end using standard single-letter amino acid codes. Uppercase shall be used for L-amino acids and lowercase for D-amino acids. Transcribed SubstanceProteins will always be described using the translated sequence; for synthetic peptide containing amino acids that are not represented with a single letter code an X should be used within the sequence. The modified amino acids will be distinguished by their position in the sequence.
  @override
  final String? sequence;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @override
  @JsonKey(name: '_sequence')
  final Element? sequenceElement;

  /// [length] Length of linear sequences of amino acids contained in the subunit.
  @override
  final Integer? length;

  /// [lengthElement] ("_length") Extensions for length
  @override
  @JsonKey(name: '_length')
  final Element? lengthElement;

  /// [sequenceAttachment] The sequence information shall be provided enumerating the amino acids from N- to C-terminal end using standard single-letter amino acid codes. Uppercase shall be used for L-amino acids and lowercase for D-amino acids. Transcribed SubstanceProteins will always be described using the translated sequence; for synthetic peptide containing amino acids that are not represented with a single letter code an X should be used within the sequence. The modified amino acids will be distinguished by their position in the sequence.
  @override
  final Attachment? sequenceAttachment;

  /// [nTerminalModificationId] Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID.
  @override
  final Identifier? nTerminalModificationId;

  /// [nTerminalModification] The name of the fragment modified at the N-terminal of the SubstanceProtein shall be specified.
  @override
  final String? nTerminalModification;

  /// [nTerminalModificationElement] ("_nTerminalModification") Extensions for nTerminalModification
  @override
  @JsonKey(name: '_nTerminalModification')
  final Element? nTerminalModificationElement;

  /// [cTerminalModificationId] Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID.
  @override
  final Identifier? cTerminalModificationId;

  /// [cTerminalModification] The modification at the C-terminal shall be specified.
  @override
  final String? cTerminalModification;

  /// [cTerminalModificationElement] ("_cTerminalModification") Extensions for cTerminalModification
  @override
  @JsonKey(name: '_cTerminalModification')
  final Element? cTerminalModificationElement;

  @override
  String toString() {
    return 'SubstanceProteinSubunit(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, subunit: $subunit, subunitElement: $subunitElement, sequence: $sequence, sequenceElement: $sequenceElement, length: $length, lengthElement: $lengthElement, sequenceAttachment: $sequenceAttachment, nTerminalModificationId: $nTerminalModificationId, nTerminalModification: $nTerminalModification, nTerminalModificationElement: $nTerminalModificationElement, cTerminalModificationId: $cTerminalModificationId, cTerminalModification: $cTerminalModification, cTerminalModificationElement: $cTerminalModificationElement)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceProteinSubunit &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.subunit, subunit) || other.subunit == subunit) &&
            (identical(other.subunitElement, subunitElement) ||
                other.subunitElement == subunitElement) &&
            (identical(other.sequence, sequence) ||
                other.sequence == sequence) &&
            (identical(other.sequenceElement, sequenceElement) ||
                other.sequenceElement == sequenceElement) &&
            (identical(other.length, length) || other.length == length) &&
            (identical(other.lengthElement, lengthElement) ||
                other.lengthElement == lengthElement) &&
            (identical(other.sequenceAttachment, sequenceAttachment) ||
                other.sequenceAttachment == sequenceAttachment) &&
            (identical(
                    other.nTerminalModificationId, nTerminalModificationId) ||
                other.nTerminalModificationId == nTerminalModificationId) &&
            (identical(other.nTerminalModification, nTerminalModification) ||
                other.nTerminalModification == nTerminalModification) &&
            (identical(other.nTerminalModificationElement,
                    nTerminalModificationElement) ||
                other.nTerminalModificationElement ==
                    nTerminalModificationElement) &&
            (identical(
                    other.cTerminalModificationId, cTerminalModificationId) ||
                other.cTerminalModificationId == cTerminalModificationId) &&
            (identical(other.cTerminalModification, cTerminalModification) ||
                other.cTerminalModification == cTerminalModification) &&
            (identical(other.cTerminalModificationElement,
                    cTerminalModificationElement) ||
                other.cTerminalModificationElement ==
                    cTerminalModificationElement));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      subunit,
      subunitElement,
      sequence,
      sequenceElement,
      length,
      lengthElement,
      sequenceAttachment,
      nTerminalModificationId,
      nTerminalModification,
      nTerminalModificationElement,
      cTerminalModificationId,
      cTerminalModification,
      cTerminalModificationElement);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceProteinSubunitCopyWith<_$_SubstanceProteinSubunit>
      get copyWith =>
          __$$_SubstanceProteinSubunitCopyWithImpl<_$_SubstanceProteinSubunit>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceProteinSubunitToJson(
      this,
    );
  }
}

abstract class _SubstanceProteinSubunit extends SubstanceProteinSubunit {
  factory _SubstanceProteinSubunit(
          {final String? id,
          @JsonKey(name: 'extension')
              final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final Integer? subunit,
          @JsonKey(name: '_subunit')
              final Element? subunitElement,
          final String? sequence,
          @JsonKey(name: '_sequence')
              final Element? sequenceElement,
          final Integer? length,
          @JsonKey(name: '_length')
              final Element? lengthElement,
          final Attachment? sequenceAttachment,
          final Identifier? nTerminalModificationId,
          final String? nTerminalModification,
          @JsonKey(name: '_nTerminalModification')
              final Element? nTerminalModificationElement,
          final Identifier? cTerminalModificationId,
          final String? cTerminalModification,
          @JsonKey(name: '_cTerminalModification')
              final Element? cTerminalModificationElement}) =
      _$_SubstanceProteinSubunit;
  _SubstanceProteinSubunit._() : super._();

  factory _SubstanceProteinSubunit.fromJson(Map<String, dynamic> json) =
      _$_SubstanceProteinSubunit.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [subunit] Index of primary sequences of amino acids linked through peptide bonds in order of decreasing length. Sequences of the same length will be ordered by molecular weight. Subunits that have identical sequences will be repeated and have sequential subscripts.
  Integer? get subunit;
  @override

  /// [subunitElement] ("_subunit") Extensions for subunit
  @JsonKey(name: '_subunit')
  Element? get subunitElement;
  @override

  /// [sequence] The sequence information shall be provided enumerating the amino acids from N- to C-terminal end using standard single-letter amino acid codes. Uppercase shall be used for L-amino acids and lowercase for D-amino acids. Transcribed SubstanceProteins will always be described using the translated sequence; for synthetic peptide containing amino acids that are not represented with a single letter code an X should be used within the sequence. The modified amino acids will be distinguished by their position in the sequence.
  String? get sequence;
  @override

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement;
  @override

  /// [length] Length of linear sequences of amino acids contained in the subunit.
  Integer? get length;
  @override

  /// [lengthElement] ("_length") Extensions for length
  @JsonKey(name: '_length')
  Element? get lengthElement;
  @override

  /// [sequenceAttachment] The sequence information shall be provided enumerating the amino acids from N- to C-terminal end using standard single-letter amino acid codes. Uppercase shall be used for L-amino acids and lowercase for D-amino acids. Transcribed SubstanceProteins will always be described using the translated sequence; for synthetic peptide containing amino acids that are not represented with a single letter code an X should be used within the sequence. The modified amino acids will be distinguished by their position in the sequence.
  Attachment? get sequenceAttachment;
  @override

  /// [nTerminalModificationId] Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID.
  Identifier? get nTerminalModificationId;
  @override

  /// [nTerminalModification] The name of the fragment modified at the N-terminal of the SubstanceProtein shall be specified.
  String? get nTerminalModification;
  @override

  /// [nTerminalModificationElement] ("_nTerminalModification") Extensions for nTerminalModification
  @JsonKey(name: '_nTerminalModification')
  Element? get nTerminalModificationElement;
  @override

  /// [cTerminalModificationId] Unique identifier for molecular fragment modification based on the ISO 11238 Substance ID.
  Identifier? get cTerminalModificationId;
  @override

  /// [cTerminalModification] The modification at the C-terminal shall be specified.
  String? get cTerminalModification;
  @override

  /// [cTerminalModificationElement] ("_cTerminalModification") Extensions for cTerminalModification
  @JsonKey(name: '_cTerminalModification')
  Element? get cTerminalModificationElement;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceProteinSubunitCopyWith<_$_SubstanceProteinSubunit>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceReferenceInformation _$SubstanceReferenceInformationFromJson(
    Map<String, dynamic> json) {
  return _SubstanceReferenceInformation.fromJson(json);
}

/// @nodoc
mixin _$SubstanceReferenceInformation {
  /// [resourceType] This is a SubstanceReferenceInformation resource
  @JsonKey(unknownEnumValue: R5ResourceType.SubstanceReferenceInformation)
  R5ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [comment] Todo.
  String? get comment => throw _privateConstructorUsedError;

  /// [commentElement] ("_comment") Extensions for comment
  @JsonKey(name: '_comment')
  Element? get commentElement => throw _privateConstructorUsedError;

  /// [gene] Todo.
  List<SubstanceReferenceInformationGene>? get gene =>
      throw _privateConstructorUsedError;

  /// [geneElement] Todo.
  List<SubstanceReferenceInformationGeneElement>? get geneElement =>
      throw _privateConstructorUsedError;

  /// [target] Todo.
  List<SubstanceReferenceInformationTarget>? get target =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceReferenceInformationCopyWith<SubstanceReferenceInformation>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceReferenceInformationCopyWith<$Res> {
  factory $SubstanceReferenceInformationCopyWith(
          SubstanceReferenceInformation value,
          $Res Function(SubstanceReferenceInformation) then) =
      _$SubstanceReferenceInformationCopyWithImpl<$Res,
          SubstanceReferenceInformation>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceReferenceInformation)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? comment,
      @JsonKey(name: '_comment')
          Element? commentElement,
      List<SubstanceReferenceInformationGene>? gene,
      List<SubstanceReferenceInformationGeneElement>? geneElement,
      List<SubstanceReferenceInformationTarget>? target});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $ElementCopyWith<$Res>? get commentElement;
}

/// @nodoc
class _$SubstanceReferenceInformationCopyWithImpl<$Res,
        $Val extends SubstanceReferenceInformation>
    implements $SubstanceReferenceInformationCopyWith<$Res> {
  _$SubstanceReferenceInformationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? comment = freezed,
    Object? commentElement = freezed,
    Object? gene = freezed,
    Object? geneElement = freezed,
    Object? target = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as String?,
      commentElement: freezed == commentElement
          ? _value.commentElement
          : commentElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      gene: freezed == gene
          ? _value.gene
          : gene // ignore: cast_nullable_to_non_nullable
              as List<SubstanceReferenceInformationGene>?,
      geneElement: freezed == geneElement
          ? _value.geneElement
          : geneElement // ignore: cast_nullable_to_non_nullable
              as List<SubstanceReferenceInformationGeneElement>?,
      target: freezed == target
          ? _value.target
          : target // ignore: cast_nullable_to_non_nullable
              as List<SubstanceReferenceInformationTarget>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get commentElement {
    if (_value.commentElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.commentElement!, (value) {
      return _then(_value.copyWith(commentElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceReferenceInformationCopyWith<$Res>
    implements $SubstanceReferenceInformationCopyWith<$Res> {
  factory _$$_SubstanceReferenceInformationCopyWith(
          _$_SubstanceReferenceInformation value,
          $Res Function(_$_SubstanceReferenceInformation) then) =
      __$$_SubstanceReferenceInformationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceReferenceInformation)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? comment,
      @JsonKey(name: '_comment')
          Element? commentElement,
      List<SubstanceReferenceInformationGene>? gene,
      List<SubstanceReferenceInformationGeneElement>? geneElement,
      List<SubstanceReferenceInformationTarget>? target});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $ElementCopyWith<$Res>? get commentElement;
}

/// @nodoc
class __$$_SubstanceReferenceInformationCopyWithImpl<$Res>
    extends _$SubstanceReferenceInformationCopyWithImpl<$Res,
        _$_SubstanceReferenceInformation>
    implements _$$_SubstanceReferenceInformationCopyWith<$Res> {
  __$$_SubstanceReferenceInformationCopyWithImpl(
      _$_SubstanceReferenceInformation _value,
      $Res Function(_$_SubstanceReferenceInformation) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? comment = freezed,
    Object? commentElement = freezed,
    Object? gene = freezed,
    Object? geneElement = freezed,
    Object? target = freezed,
  }) {
    return _then(_$_SubstanceReferenceInformation(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as String?,
      commentElement: freezed == commentElement
          ? _value.commentElement
          : commentElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      gene: freezed == gene
          ? _value._gene
          : gene // ignore: cast_nullable_to_non_nullable
              as List<SubstanceReferenceInformationGene>?,
      geneElement: freezed == geneElement
          ? _value._geneElement
          : geneElement // ignore: cast_nullable_to_non_nullable
              as List<SubstanceReferenceInformationGeneElement>?,
      target: freezed == target
          ? _value._target
          : target // ignore: cast_nullable_to_non_nullable
              as List<SubstanceReferenceInformationTarget>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceReferenceInformation extends _SubstanceReferenceInformation {
  _$_SubstanceReferenceInformation(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceReferenceInformation)
          this.resourceType = R5ResourceType.SubstanceReferenceInformation,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules')
          this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language')
          this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.comment,
      @JsonKey(name: '_comment')
          this.commentElement,
      final List<SubstanceReferenceInformationGene>? gene,
      final List<SubstanceReferenceInformationGeneElement>? geneElement,
      final List<SubstanceReferenceInformationTarget>? target})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _gene = gene,
        _geneElement = geneElement,
        _target = target,
        super._();

  factory _$_SubstanceReferenceInformation.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstanceReferenceInformationFromJson(json);

  /// [resourceType] This is a SubstanceReferenceInformation resource
  @override
  @JsonKey(unknownEnumValue: R5ResourceType.SubstanceReferenceInformation)
  final R5ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.
  @override
  final Code? language;

  /// [languageElement] ("_language") Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [comment] Todo.
  @override
  final String? comment;

  /// [commentElement] ("_comment") Extensions for comment
  @override
  @JsonKey(name: '_comment')
  final Element? commentElement;

  /// [gene] Todo.
  final List<SubstanceReferenceInformationGene>? _gene;

  /// [gene] Todo.
  @override
  List<SubstanceReferenceInformationGene>? get gene {
    final value = _gene;
    if (value == null) return null;
    if (_gene is EqualUnmodifiableListView) return _gene;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [geneElement] Todo.
  final List<SubstanceReferenceInformationGeneElement>? _geneElement;

  /// [geneElement] Todo.
  @override
  List<SubstanceReferenceInformationGeneElement>? get geneElement {
    final value = _geneElement;
    if (value == null) return null;
    if (_geneElement is EqualUnmodifiableListView) return _geneElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [target] Todo.
  final List<SubstanceReferenceInformationTarget>? _target;

  /// [target] Todo.
  @override
  List<SubstanceReferenceInformationTarget>? get target {
    final value = _target;
    if (value == null) return null;
    if (_target is EqualUnmodifiableListView) return _target;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstanceReferenceInformation(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, comment: $comment, commentElement: $commentElement, gene: $gene, geneElement: $geneElement, target: $target)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceReferenceInformation &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.comment, comment) || other.comment == comment) &&
            (identical(other.commentElement, commentElement) ||
                other.commentElement == commentElement) &&
            const DeepCollectionEquality().equals(other._gene, _gene) &&
            const DeepCollectionEquality()
                .equals(other._geneElement, _geneElement) &&
            const DeepCollectionEquality().equals(other._target, _target));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      resourceType,
      id,
      meta,
      implicitRules,
      implicitRulesElement,
      language,
      languageElement,
      text,
      const DeepCollectionEquality().hash(_contained),
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      comment,
      commentElement,
      const DeepCollectionEquality().hash(_gene),
      const DeepCollectionEquality().hash(_geneElement),
      const DeepCollectionEquality().hash(_target));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceReferenceInformationCopyWith<_$_SubstanceReferenceInformation>
      get copyWith => __$$_SubstanceReferenceInformationCopyWithImpl<
          _$_SubstanceReferenceInformation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceReferenceInformationToJson(
      this,
    );
  }
}

abstract class _SubstanceReferenceInformation
    extends SubstanceReferenceInformation {
  factory _SubstanceReferenceInformation(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceReferenceInformation)
          final R5ResourceType resourceType,
      final FhirId? id,
      final Meta? meta,
      final FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          final Element? implicitRulesElement,
      final Code? language,
      @JsonKey(name: '_language')
          final Element? languageElement,
      final Narrative? text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final String? comment,
      @JsonKey(name: '_comment')
          final Element? commentElement,
      final List<SubstanceReferenceInformationGene>? gene,
      final List<SubstanceReferenceInformationGeneElement>? geneElement,
      final List<SubstanceReferenceInformationTarget>?
          target}) = _$_SubstanceReferenceInformation;
  _SubstanceReferenceInformation._() : super._();

  factory _SubstanceReferenceInformation.fromJson(Map<String, dynamic> json) =
      _$_SubstanceReferenceInformation.fromJson;

  @override

  /// [resourceType] This is a SubstanceReferenceInformation resource
  @JsonKey(unknownEnumValue: R5ResourceType.SubstanceReferenceInformation)
  R5ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.
  Code? get language;
  @override

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained;
  @override

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [comment] Todo.
  String? get comment;
  @override

  /// [commentElement] ("_comment") Extensions for comment
  @JsonKey(name: '_comment')
  Element? get commentElement;
  @override

  /// [gene] Todo.
  List<SubstanceReferenceInformationGene>? get gene;
  @override

  /// [geneElement] Todo.
  List<SubstanceReferenceInformationGeneElement>? get geneElement;
  @override

  /// [target] Todo.
  List<SubstanceReferenceInformationTarget>? get target;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceReferenceInformationCopyWith<_$_SubstanceReferenceInformation>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceReferenceInformationGene _$SubstanceReferenceInformationGeneFromJson(
    Map<String, dynamic> json) {
  return _SubstanceReferenceInformationGene.fromJson(json);
}

/// @nodoc
mixin _$SubstanceReferenceInformationGene {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [geneSequenceOrigin] Todo.
  CodeableConcept? get geneSequenceOrigin => throw _privateConstructorUsedError;

  /// [gene] Todo.
  CodeableConcept? get gene => throw _privateConstructorUsedError;

  /// [source] Todo.
  List<Reference>? get source => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceReferenceInformationGeneCopyWith<SubstanceReferenceInformationGene>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceReferenceInformationGeneCopyWith<$Res> {
  factory $SubstanceReferenceInformationGeneCopyWith(
          SubstanceReferenceInformationGene value,
          $Res Function(SubstanceReferenceInformationGene) then) =
      _$SubstanceReferenceInformationGeneCopyWithImpl<$Res,
          SubstanceReferenceInformationGene>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? geneSequenceOrigin,
      CodeableConcept? gene,
      List<Reference>? source});

  $CodeableConceptCopyWith<$Res>? get geneSequenceOrigin;
  $CodeableConceptCopyWith<$Res>? get gene;
}

/// @nodoc
class _$SubstanceReferenceInformationGeneCopyWithImpl<$Res,
        $Val extends SubstanceReferenceInformationGene>
    implements $SubstanceReferenceInformationGeneCopyWith<$Res> {
  _$SubstanceReferenceInformationGeneCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? geneSequenceOrigin = freezed,
    Object? gene = freezed,
    Object? source = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      geneSequenceOrigin: freezed == geneSequenceOrigin
          ? _value.geneSequenceOrigin
          : geneSequenceOrigin // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      gene: freezed == gene
          ? _value.gene
          : gene // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get geneSequenceOrigin {
    if (_value.geneSequenceOrigin == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.geneSequenceOrigin!, (value) {
      return _then(_value.copyWith(geneSequenceOrigin: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get gene {
    if (_value.gene == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.gene!, (value) {
      return _then(_value.copyWith(gene: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceReferenceInformationGeneCopyWith<$Res>
    implements $SubstanceReferenceInformationGeneCopyWith<$Res> {
  factory _$$_SubstanceReferenceInformationGeneCopyWith(
          _$_SubstanceReferenceInformationGene value,
          $Res Function(_$_SubstanceReferenceInformationGene) then) =
      __$$_SubstanceReferenceInformationGeneCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? geneSequenceOrigin,
      CodeableConcept? gene,
      List<Reference>? source});

  @override
  $CodeableConceptCopyWith<$Res>? get geneSequenceOrigin;
  @override
  $CodeableConceptCopyWith<$Res>? get gene;
}

/// @nodoc
class __$$_SubstanceReferenceInformationGeneCopyWithImpl<$Res>
    extends _$SubstanceReferenceInformationGeneCopyWithImpl<$Res,
        _$_SubstanceReferenceInformationGene>
    implements _$$_SubstanceReferenceInformationGeneCopyWith<$Res> {
  __$$_SubstanceReferenceInformationGeneCopyWithImpl(
      _$_SubstanceReferenceInformationGene _value,
      $Res Function(_$_SubstanceReferenceInformationGene) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? geneSequenceOrigin = freezed,
    Object? gene = freezed,
    Object? source = freezed,
  }) {
    return _then(_$_SubstanceReferenceInformationGene(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      geneSequenceOrigin: freezed == geneSequenceOrigin
          ? _value.geneSequenceOrigin
          : geneSequenceOrigin // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      gene: freezed == gene
          ? _value.gene
          : gene // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      source: freezed == source
          ? _value._source
          : source // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceReferenceInformationGene
    extends _SubstanceReferenceInformationGene {
  _$_SubstanceReferenceInformationGene(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.geneSequenceOrigin,
      this.gene,
      final List<Reference>? source})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _source = source,
        super._();

  factory _$_SubstanceReferenceInformationGene.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstanceReferenceInformationGeneFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [geneSequenceOrigin] Todo.
  @override
  final CodeableConcept? geneSequenceOrigin;

  /// [gene] Todo.
  @override
  final CodeableConcept? gene;

  /// [source] Todo.
  final List<Reference>? _source;

  /// [source] Todo.
  @override
  List<Reference>? get source {
    final value = _source;
    if (value == null) return null;
    if (_source is EqualUnmodifiableListView) return _source;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstanceReferenceInformationGene(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, geneSequenceOrigin: $geneSequenceOrigin, gene: $gene, source: $source)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceReferenceInformationGene &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.geneSequenceOrigin, geneSequenceOrigin) ||
                other.geneSequenceOrigin == geneSequenceOrigin) &&
            (identical(other.gene, gene) || other.gene == gene) &&
            const DeepCollectionEquality().equals(other._source, _source));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      geneSequenceOrigin,
      gene,
      const DeepCollectionEquality().hash(_source));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceReferenceInformationGeneCopyWith<
          _$_SubstanceReferenceInformationGene>
      get copyWith => __$$_SubstanceReferenceInformationGeneCopyWithImpl<
          _$_SubstanceReferenceInformationGene>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceReferenceInformationGeneToJson(
      this,
    );
  }
}

abstract class _SubstanceReferenceInformationGene
    extends SubstanceReferenceInformationGene {
  factory _SubstanceReferenceInformationGene(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? geneSequenceOrigin,
      final CodeableConcept? gene,
      final List<Reference>? source}) = _$_SubstanceReferenceInformationGene;
  _SubstanceReferenceInformationGene._() : super._();

  factory _SubstanceReferenceInformationGene.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceReferenceInformationGene.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [geneSequenceOrigin] Todo.
  CodeableConcept? get geneSequenceOrigin;
  @override

  /// [gene] Todo.
  CodeableConcept? get gene;
  @override

  /// [source] Todo.
  List<Reference>? get source;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceReferenceInformationGeneCopyWith<
          _$_SubstanceReferenceInformationGene>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceReferenceInformationGeneElement
    _$SubstanceReferenceInformationGeneElementFromJson(
        Map<String, dynamic> json) {
  return _SubstanceReferenceInformationGeneElement.fromJson(json);
}

/// @nodoc
mixin _$SubstanceReferenceInformationGeneElement {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] Todo.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [element] Todo.
  Identifier? get element => throw _privateConstructorUsedError;

  /// [source] Todo.
  List<Reference>? get source => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceReferenceInformationGeneElementCopyWith<
          SubstanceReferenceInformationGeneElement>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceReferenceInformationGeneElementCopyWith<$Res> {
  factory $SubstanceReferenceInformationGeneElementCopyWith(
          SubstanceReferenceInformationGeneElement value,
          $Res Function(SubstanceReferenceInformationGeneElement) then) =
      _$SubstanceReferenceInformationGeneElementCopyWithImpl<$Res,
          SubstanceReferenceInformationGeneElement>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      Identifier? element,
      List<Reference>? source});

  $CodeableConceptCopyWith<$Res>? get type;
  $IdentifierCopyWith<$Res>? get element;
}

/// @nodoc
class _$SubstanceReferenceInformationGeneElementCopyWithImpl<$Res,
        $Val extends SubstanceReferenceInformationGeneElement>
    implements $SubstanceReferenceInformationGeneElementCopyWith<$Res> {
  _$SubstanceReferenceInformationGeneElementCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? element = freezed,
    Object? source = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      element: freezed == element
          ? _value.element
          : element // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get element {
    if (_value.element == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.element!, (value) {
      return _then(_value.copyWith(element: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceReferenceInformationGeneElementCopyWith<$Res>
    implements $SubstanceReferenceInformationGeneElementCopyWith<$Res> {
  factory _$$_SubstanceReferenceInformationGeneElementCopyWith(
          _$_SubstanceReferenceInformationGeneElement value,
          $Res Function(_$_SubstanceReferenceInformationGeneElement) then) =
      __$$_SubstanceReferenceInformationGeneElementCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      Identifier? element,
      List<Reference>? source});

  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $IdentifierCopyWith<$Res>? get element;
}

/// @nodoc
class __$$_SubstanceReferenceInformationGeneElementCopyWithImpl<$Res>
    extends _$SubstanceReferenceInformationGeneElementCopyWithImpl<$Res,
        _$_SubstanceReferenceInformationGeneElement>
    implements _$$_SubstanceReferenceInformationGeneElementCopyWith<$Res> {
  __$$_SubstanceReferenceInformationGeneElementCopyWithImpl(
      _$_SubstanceReferenceInformationGeneElement _value,
      $Res Function(_$_SubstanceReferenceInformationGeneElement) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? element = freezed,
    Object? source = freezed,
  }) {
    return _then(_$_SubstanceReferenceInformationGeneElement(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      element: freezed == element
          ? _value.element
          : element // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      source: freezed == source
          ? _value._source
          : source // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceReferenceInformationGeneElement
    extends _SubstanceReferenceInformationGeneElement {
  _$_SubstanceReferenceInformationGeneElement(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.type,
      this.element,
      final List<Reference>? source})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _source = source,
        super._();

  factory _$_SubstanceReferenceInformationGeneElement.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstanceReferenceInformationGeneElementFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] Todo.
  @override
  final CodeableConcept? type;

  /// [element] Todo.
  @override
  final Identifier? element;

  /// [source] Todo.
  final List<Reference>? _source;

  /// [source] Todo.
  @override
  List<Reference>? get source {
    final value = _source;
    if (value == null) return null;
    if (_source is EqualUnmodifiableListView) return _source;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstanceReferenceInformationGeneElement(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, element: $element, source: $source)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceReferenceInformationGeneElement &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.element, element) || other.element == element) &&
            const DeepCollectionEquality().equals(other._source, _source));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      element,
      const DeepCollectionEquality().hash(_source));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceReferenceInformationGeneElementCopyWith<
          _$_SubstanceReferenceInformationGeneElement>
      get copyWith => __$$_SubstanceReferenceInformationGeneElementCopyWithImpl<
          _$_SubstanceReferenceInformationGeneElement>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceReferenceInformationGeneElementToJson(
      this,
    );
  }
}

abstract class _SubstanceReferenceInformationGeneElement
    extends SubstanceReferenceInformationGeneElement {
  factory _SubstanceReferenceInformationGeneElement(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableConcept? type,
          final Identifier? element,
          final List<Reference>? source}) =
      _$_SubstanceReferenceInformationGeneElement;
  _SubstanceReferenceInformationGeneElement._() : super._();

  factory _SubstanceReferenceInformationGeneElement.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceReferenceInformationGeneElement.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] Todo.
  CodeableConcept? get type;
  @override

  /// [element] Todo.
  Identifier? get element;
  @override

  /// [source] Todo.
  List<Reference>? get source;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceReferenceInformationGeneElementCopyWith<
          _$_SubstanceReferenceInformationGeneElement>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceReferenceInformationTarget
    _$SubstanceReferenceInformationTargetFromJson(Map<String, dynamic> json) {
  return _SubstanceReferenceInformationTarget.fromJson(json);
}

/// @nodoc
mixin _$SubstanceReferenceInformationTarget {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [target] Todo.
  Identifier? get target => throw _privateConstructorUsedError;

  /// [type] Todo.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [interaction] Todo.
  CodeableConcept? get interaction => throw _privateConstructorUsedError;

  /// [organism] Todo.
  CodeableConcept? get organism => throw _privateConstructorUsedError;

  /// [organismType] Todo.
  CodeableConcept? get organismType => throw _privateConstructorUsedError;

  /// [amountQuantity] Todo.
  Quantity? get amountQuantity => throw _privateConstructorUsedError;

  /// [amountRange] Todo.
  Range? get amountRange => throw _privateConstructorUsedError;

  /// [amountString] Todo.
  String? get amountString => throw _privateConstructorUsedError;

  /// [amountStringElement] ("_amountString") Extensions for amountString
  @JsonKey(name: '_amountString')
  Element? get amountStringElement => throw _privateConstructorUsedError;

  /// [amountType] Todo.
  CodeableConcept? get amountType => throw _privateConstructorUsedError;

  /// [source] Todo.
  List<Reference>? get source => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceReferenceInformationTargetCopyWith<
          SubstanceReferenceInformationTarget>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceReferenceInformationTargetCopyWith<$Res> {
  factory $SubstanceReferenceInformationTargetCopyWith(
          SubstanceReferenceInformationTarget value,
          $Res Function(SubstanceReferenceInformationTarget) then) =
      _$SubstanceReferenceInformationTargetCopyWithImpl<$Res,
          SubstanceReferenceInformationTarget>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Identifier? target,
      CodeableConcept? type,
      CodeableConcept? interaction,
      CodeableConcept? organism,
      CodeableConcept? organismType,
      Quantity? amountQuantity,
      Range? amountRange,
      String? amountString,
      @JsonKey(name: '_amountString') Element? amountStringElement,
      CodeableConcept? amountType,
      List<Reference>? source});

  $IdentifierCopyWith<$Res>? get target;
  $CodeableConceptCopyWith<$Res>? get type;
  $CodeableConceptCopyWith<$Res>? get interaction;
  $CodeableConceptCopyWith<$Res>? get organism;
  $CodeableConceptCopyWith<$Res>? get organismType;
  $QuantityCopyWith<$Res>? get amountQuantity;
  $RangeCopyWith<$Res>? get amountRange;
  $ElementCopyWith<$Res>? get amountStringElement;
  $CodeableConceptCopyWith<$Res>? get amountType;
}

/// @nodoc
class _$SubstanceReferenceInformationTargetCopyWithImpl<$Res,
        $Val extends SubstanceReferenceInformationTarget>
    implements $SubstanceReferenceInformationTargetCopyWith<$Res> {
  _$SubstanceReferenceInformationTargetCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? target = freezed,
    Object? type = freezed,
    Object? interaction = freezed,
    Object? organism = freezed,
    Object? organismType = freezed,
    Object? amountQuantity = freezed,
    Object? amountRange = freezed,
    Object? amountString = freezed,
    Object? amountStringElement = freezed,
    Object? amountType = freezed,
    Object? source = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      target: freezed == target
          ? _value.target
          : target // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      interaction: freezed == interaction
          ? _value.interaction
          : interaction // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      organism: freezed == organism
          ? _value.organism
          : organism // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      organismType: freezed == organismType
          ? _value.organismType
          : organismType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      amountQuantity: freezed == amountQuantity
          ? _value.amountQuantity
          : amountQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      amountRange: freezed == amountRange
          ? _value.amountRange
          : amountRange // ignore: cast_nullable_to_non_nullable
              as Range?,
      amountString: freezed == amountString
          ? _value.amountString
          : amountString // ignore: cast_nullable_to_non_nullable
              as String?,
      amountStringElement: freezed == amountStringElement
          ? _value.amountStringElement
          : amountStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      amountType: freezed == amountType
          ? _value.amountType
          : amountType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get target {
    if (_value.target == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.target!, (value) {
      return _then(_value.copyWith(target: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get interaction {
    if (_value.interaction == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.interaction!, (value) {
      return _then(_value.copyWith(interaction: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get organism {
    if (_value.organism == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.organism!, (value) {
      return _then(_value.copyWith(organism: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get organismType {
    if (_value.organismType == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.organismType!, (value) {
      return _then(_value.copyWith(organismType: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get amountQuantity {
    if (_value.amountQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.amountQuantity!, (value) {
      return _then(_value.copyWith(amountQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RangeCopyWith<$Res>? get amountRange {
    if (_value.amountRange == null) {
      return null;
    }

    return $RangeCopyWith<$Res>(_value.amountRange!, (value) {
      return _then(_value.copyWith(amountRange: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get amountStringElement {
    if (_value.amountStringElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.amountStringElement!, (value) {
      return _then(_value.copyWith(amountStringElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get amountType {
    if (_value.amountType == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.amountType!, (value) {
      return _then(_value.copyWith(amountType: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceReferenceInformationTargetCopyWith<$Res>
    implements $SubstanceReferenceInformationTargetCopyWith<$Res> {
  factory _$$_SubstanceReferenceInformationTargetCopyWith(
          _$_SubstanceReferenceInformationTarget value,
          $Res Function(_$_SubstanceReferenceInformationTarget) then) =
      __$$_SubstanceReferenceInformationTargetCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Identifier? target,
      CodeableConcept? type,
      CodeableConcept? interaction,
      CodeableConcept? organism,
      CodeableConcept? organismType,
      Quantity? amountQuantity,
      Range? amountRange,
      String? amountString,
      @JsonKey(name: '_amountString') Element? amountStringElement,
      CodeableConcept? amountType,
      List<Reference>? source});

  @override
  $IdentifierCopyWith<$Res>? get target;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $CodeableConceptCopyWith<$Res>? get interaction;
  @override
  $CodeableConceptCopyWith<$Res>? get organism;
  @override
  $CodeableConceptCopyWith<$Res>? get organismType;
  @override
  $QuantityCopyWith<$Res>? get amountQuantity;
  @override
  $RangeCopyWith<$Res>? get amountRange;
  @override
  $ElementCopyWith<$Res>? get amountStringElement;
  @override
  $CodeableConceptCopyWith<$Res>? get amountType;
}

/// @nodoc
class __$$_SubstanceReferenceInformationTargetCopyWithImpl<$Res>
    extends _$SubstanceReferenceInformationTargetCopyWithImpl<$Res,
        _$_SubstanceReferenceInformationTarget>
    implements _$$_SubstanceReferenceInformationTargetCopyWith<$Res> {
  __$$_SubstanceReferenceInformationTargetCopyWithImpl(
      _$_SubstanceReferenceInformationTarget _value,
      $Res Function(_$_SubstanceReferenceInformationTarget) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? target = freezed,
    Object? type = freezed,
    Object? interaction = freezed,
    Object? organism = freezed,
    Object? organismType = freezed,
    Object? amountQuantity = freezed,
    Object? amountRange = freezed,
    Object? amountString = freezed,
    Object? amountStringElement = freezed,
    Object? amountType = freezed,
    Object? source = freezed,
  }) {
    return _then(_$_SubstanceReferenceInformationTarget(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      target: freezed == target
          ? _value.target
          : target // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      interaction: freezed == interaction
          ? _value.interaction
          : interaction // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      organism: freezed == organism
          ? _value.organism
          : organism // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      organismType: freezed == organismType
          ? _value.organismType
          : organismType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      amountQuantity: freezed == amountQuantity
          ? _value.amountQuantity
          : amountQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      amountRange: freezed == amountRange
          ? _value.amountRange
          : amountRange // ignore: cast_nullable_to_non_nullable
              as Range?,
      amountString: freezed == amountString
          ? _value.amountString
          : amountString // ignore: cast_nullable_to_non_nullable
              as String?,
      amountStringElement: freezed == amountStringElement
          ? _value.amountStringElement
          : amountStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      amountType: freezed == amountType
          ? _value.amountType
          : amountType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      source: freezed == source
          ? _value._source
          : source // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceReferenceInformationTarget
    extends _SubstanceReferenceInformationTarget {
  _$_SubstanceReferenceInformationTarget(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.target,
      this.type,
      this.interaction,
      this.organism,
      this.organismType,
      this.amountQuantity,
      this.amountRange,
      this.amountString,
      @JsonKey(name: '_amountString') this.amountStringElement,
      this.amountType,
      final List<Reference>? source})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _source = source,
        super._();

  factory _$_SubstanceReferenceInformationTarget.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstanceReferenceInformationTargetFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [target] Todo.
  @override
  final Identifier? target;

  /// [type] Todo.
  @override
  final CodeableConcept? type;

  /// [interaction] Todo.
  @override
  final CodeableConcept? interaction;

  /// [organism] Todo.
  @override
  final CodeableConcept? organism;

  /// [organismType] Todo.
  @override
  final CodeableConcept? organismType;

  /// [amountQuantity] Todo.
  @override
  final Quantity? amountQuantity;

  /// [amountRange] Todo.
  @override
  final Range? amountRange;

  /// [amountString] Todo.
  @override
  final String? amountString;

  /// [amountStringElement] ("_amountString") Extensions for amountString
  @override
  @JsonKey(name: '_amountString')
  final Element? amountStringElement;

  /// [amountType] Todo.
  @override
  final CodeableConcept? amountType;

  /// [source] Todo.
  final List<Reference>? _source;

  /// [source] Todo.
  @override
  List<Reference>? get source {
    final value = _source;
    if (value == null) return null;
    if (_source is EqualUnmodifiableListView) return _source;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstanceReferenceInformationTarget(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, target: $target, type: $type, interaction: $interaction, organism: $organism, organismType: $organismType, amountQuantity: $amountQuantity, amountRange: $amountRange, amountString: $amountString, amountStringElement: $amountStringElement, amountType: $amountType, source: $source)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceReferenceInformationTarget &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.target, target) || other.target == target) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.interaction, interaction) ||
                other.interaction == interaction) &&
            (identical(other.organism, organism) ||
                other.organism == organism) &&
            (identical(other.organismType, organismType) ||
                other.organismType == organismType) &&
            (identical(other.amountQuantity, amountQuantity) ||
                other.amountQuantity == amountQuantity) &&
            (identical(other.amountRange, amountRange) ||
                other.amountRange == amountRange) &&
            (identical(other.amountString, amountString) ||
                other.amountString == amountString) &&
            (identical(other.amountStringElement, amountStringElement) ||
                other.amountStringElement == amountStringElement) &&
            (identical(other.amountType, amountType) ||
                other.amountType == amountType) &&
            const DeepCollectionEquality().equals(other._source, _source));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      target,
      type,
      interaction,
      organism,
      organismType,
      amountQuantity,
      amountRange,
      amountString,
      amountStringElement,
      amountType,
      const DeepCollectionEquality().hash(_source));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceReferenceInformationTargetCopyWith<
          _$_SubstanceReferenceInformationTarget>
      get copyWith => __$$_SubstanceReferenceInformationTargetCopyWithImpl<
          _$_SubstanceReferenceInformationTarget>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceReferenceInformationTargetToJson(
      this,
    );
  }
}

abstract class _SubstanceReferenceInformationTarget
    extends SubstanceReferenceInformationTarget {
  factory _SubstanceReferenceInformationTarget(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final Identifier? target,
      final CodeableConcept? type,
      final CodeableConcept? interaction,
      final CodeableConcept? organism,
      final CodeableConcept? organismType,
      final Quantity? amountQuantity,
      final Range? amountRange,
      final String? amountString,
      @JsonKey(name: '_amountString') final Element? amountStringElement,
      final CodeableConcept? amountType,
      final List<Reference>? source}) = _$_SubstanceReferenceInformationTarget;
  _SubstanceReferenceInformationTarget._() : super._();

  factory _SubstanceReferenceInformationTarget.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceReferenceInformationTarget.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [target] Todo.
  Identifier? get target;
  @override

  /// [type] Todo.
  CodeableConcept? get type;
  @override

  /// [interaction] Todo.
  CodeableConcept? get interaction;
  @override

  /// [organism] Todo.
  CodeableConcept? get organism;
  @override

  /// [organismType] Todo.
  CodeableConcept? get organismType;
  @override

  /// [amountQuantity] Todo.
  Quantity? get amountQuantity;
  @override

  /// [amountRange] Todo.
  Range? get amountRange;
  @override

  /// [amountString] Todo.
  String? get amountString;
  @override

  /// [amountStringElement] ("_amountString") Extensions for amountString
  @JsonKey(name: '_amountString')
  Element? get amountStringElement;
  @override

  /// [amountType] Todo.
  CodeableConcept? get amountType;
  @override

  /// [source] Todo.
  List<Reference>? get source;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceReferenceInformationTargetCopyWith<
          _$_SubstanceReferenceInformationTarget>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceSourceMaterial _$SubstanceSourceMaterialFromJson(
    Map<String, dynamic> json) {
  return _SubstanceSourceMaterial.fromJson(json);
}

/// @nodoc
mixin _$SubstanceSourceMaterial {
  /// [resourceType] This is a SubstanceSourceMaterial resource
  @JsonKey(unknownEnumValue: R5ResourceType.SubstanceSourceMaterial)
  R5ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [sourceMaterialClass] General high level classification of the source material specific to the origin of the material.
  CodeableConcept? get sourceMaterialClass =>
      throw _privateConstructorUsedError;

  /// [sourceMaterialType] The type of the source material shall be specified based on a controlled vocabulary. For vaccines, this subclause refers to the class of infectious agent.
  CodeableConcept? get sourceMaterialType => throw _privateConstructorUsedError;

  /// [sourceMaterialState] The state of the source material when extracted.
  CodeableConcept? get sourceMaterialState =>
      throw _privateConstructorUsedError;

  /// [organismId] The unique identifier associated with the source material parent organism shall be specified.
  Identifier? get organismId => throw _privateConstructorUsedError;

  /// [organismName] The organism accepted Scientific name shall be provided based on the organism taxonomy.
  String? get organismName => throw _privateConstructorUsedError;

  /// [organismNameElement] ("_organismName") Extensions for organismName
  @JsonKey(name: '_organismName')
  Element? get organismNameElement => throw _privateConstructorUsedError;

  /// [parentSubstanceId] The parent of the herbal drug Ginkgo biloba, Leaf is the substance ID of the substance (fresh) of Ginkgo biloba L. or Ginkgo biloba L. (Whole plant).
  List<Identifier>? get parentSubstanceId => throw _privateConstructorUsedError;

  /// [parentSubstanceName] The parent substance of the Herbal Drug, or Herbal preparation.
  List<String>? get parentSubstanceName => throw _privateConstructorUsedError;

  /// [parentSubstanceNameElement] ("_parentSubstanceName") Extensions for parentSubstanceName
  @JsonKey(name: '_parentSubstanceName')
  List<Element>? get parentSubstanceNameElement =>
      throw _privateConstructorUsedError;

  /// [countryOfOrigin] The country where the plant material is harvested or the countries where the plasma is sourced from as laid down in accordance with the Plasma Master File. For Plasma-derived substances the attribute country of origin provides information about the countries used for the manufacturing of the Cryopoor plama or Crioprecipitate.
  List<CodeableConcept>? get countryOfOrigin =>
      throw _privateConstructorUsedError;

  /// [geographicalLocation] The place/region where the plant is harvested or the places/regions where the animal source material has its habitat.
  List<String>? get geographicalLocation => throw _privateConstructorUsedError;

  /// [geographicalLocationElement] ("_geographicalLocation") Extensions for geographicalLocation
  @JsonKey(name: '_geographicalLocation')
  List<Element>? get geographicalLocationElement =>
      throw _privateConstructorUsedError;

  /// [developmentStage] Stage of life for animals, plants, insects and microorganisms. This information shall be provided only when the substance is significantly different in these stages (e.g. foetal bovine serum).
  CodeableConcept? get developmentStage => throw _privateConstructorUsedError;

  /// [fractionDescription] Many complex materials are fractions of parts of plants, animals, or minerals. Fraction elements are often necessary to define both Substances and Specified Group 1 Substances. For substances derived from Plants, fraction information will be captured at the Substance information level ( . Oils, Juices and Exudates). Additional information for Extracts, such as extraction solvent composition, will be captured at the Specified Substance Group 1 information level. For plasma-derived products fraction information will be captured at the Substance and the Specified Substance Group 1 levels.
  List<SubstanceSourceMaterialFractionDescription>? get fractionDescription =>
      throw _privateConstructorUsedError;

  /// [organism] This subclause describes the organism which the substance is derived from. For vaccines, the parent organism shall be specified based on these subclause elements. As an example, full taxonomy will be described for the Substance Name: ., Leaf.
  SubstanceSourceMaterialOrganism? get organism =>
      throw _privateConstructorUsedError;

  /// [partDescription] To do.
  List<SubstanceSourceMaterialPartDescription>? get partDescription =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceSourceMaterialCopyWith<SubstanceSourceMaterial> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceSourceMaterialCopyWith<$Res> {
  factory $SubstanceSourceMaterialCopyWith(SubstanceSourceMaterial value,
          $Res Function(SubstanceSourceMaterial) then) =
      _$SubstanceSourceMaterialCopyWithImpl<$Res, SubstanceSourceMaterial>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceSourceMaterial)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? sourceMaterialClass,
      CodeableConcept? sourceMaterialType,
      CodeableConcept? sourceMaterialState,
      Identifier? organismId,
      String? organismName,
      @JsonKey(name: '_organismName')
          Element? organismNameElement,
      List<Identifier>? parentSubstanceId,
      List<String>? parentSubstanceName,
      @JsonKey(name: '_parentSubstanceName')
          List<Element>? parentSubstanceNameElement,
      List<CodeableConcept>? countryOfOrigin,
      List<String>? geographicalLocation,
      @JsonKey(name: '_geographicalLocation')
          List<Element>? geographicalLocationElement,
      CodeableConcept? developmentStage,
      List<SubstanceSourceMaterialFractionDescription>? fractionDescription,
      SubstanceSourceMaterialOrganism? organism,
      List<SubstanceSourceMaterialPartDescription>? partDescription});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $CodeableConceptCopyWith<$Res>? get sourceMaterialClass;
  $CodeableConceptCopyWith<$Res>? get sourceMaterialType;
  $CodeableConceptCopyWith<$Res>? get sourceMaterialState;
  $IdentifierCopyWith<$Res>? get organismId;
  $ElementCopyWith<$Res>? get organismNameElement;
  $CodeableConceptCopyWith<$Res>? get developmentStage;
  $SubstanceSourceMaterialOrganismCopyWith<$Res>? get organism;
}

/// @nodoc
class _$SubstanceSourceMaterialCopyWithImpl<$Res,
        $Val extends SubstanceSourceMaterial>
    implements $SubstanceSourceMaterialCopyWith<$Res> {
  _$SubstanceSourceMaterialCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sourceMaterialClass = freezed,
    Object? sourceMaterialType = freezed,
    Object? sourceMaterialState = freezed,
    Object? organismId = freezed,
    Object? organismName = freezed,
    Object? organismNameElement = freezed,
    Object? parentSubstanceId = freezed,
    Object? parentSubstanceName = freezed,
    Object? parentSubstanceNameElement = freezed,
    Object? countryOfOrigin = freezed,
    Object? geographicalLocation = freezed,
    Object? geographicalLocationElement = freezed,
    Object? developmentStage = freezed,
    Object? fractionDescription = freezed,
    Object? organism = freezed,
    Object? partDescription = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sourceMaterialClass: freezed == sourceMaterialClass
          ? _value.sourceMaterialClass
          : sourceMaterialClass // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      sourceMaterialType: freezed == sourceMaterialType
          ? _value.sourceMaterialType
          : sourceMaterialType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      sourceMaterialState: freezed == sourceMaterialState
          ? _value.sourceMaterialState
          : sourceMaterialState // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      organismId: freezed == organismId
          ? _value.organismId
          : organismId // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      organismName: freezed == organismName
          ? _value.organismName
          : organismName // ignore: cast_nullable_to_non_nullable
              as String?,
      organismNameElement: freezed == organismNameElement
          ? _value.organismNameElement
          : organismNameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      parentSubstanceId: freezed == parentSubstanceId
          ? _value.parentSubstanceId
          : parentSubstanceId // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      parentSubstanceName: freezed == parentSubstanceName
          ? _value.parentSubstanceName
          : parentSubstanceName // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      parentSubstanceNameElement: freezed == parentSubstanceNameElement
          ? _value.parentSubstanceNameElement
          : parentSubstanceNameElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      countryOfOrigin: freezed == countryOfOrigin
          ? _value.countryOfOrigin
          : countryOfOrigin // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      geographicalLocation: freezed == geographicalLocation
          ? _value.geographicalLocation
          : geographicalLocation // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      geographicalLocationElement: freezed == geographicalLocationElement
          ? _value.geographicalLocationElement
          : geographicalLocationElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      developmentStage: freezed == developmentStage
          ? _value.developmentStage
          : developmentStage // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      fractionDescription: freezed == fractionDescription
          ? _value.fractionDescription
          : fractionDescription // ignore: cast_nullable_to_non_nullable
              as List<SubstanceSourceMaterialFractionDescription>?,
      organism: freezed == organism
          ? _value.organism
          : organism // ignore: cast_nullable_to_non_nullable
              as SubstanceSourceMaterialOrganism?,
      partDescription: freezed == partDescription
          ? _value.partDescription
          : partDescription // ignore: cast_nullable_to_non_nullable
              as List<SubstanceSourceMaterialPartDescription>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get sourceMaterialClass {
    if (_value.sourceMaterialClass == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.sourceMaterialClass!, (value) {
      return _then(_value.copyWith(sourceMaterialClass: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get sourceMaterialType {
    if (_value.sourceMaterialType == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.sourceMaterialType!, (value) {
      return _then(_value.copyWith(sourceMaterialType: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get sourceMaterialState {
    if (_value.sourceMaterialState == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.sourceMaterialState!, (value) {
      return _then(_value.copyWith(sourceMaterialState: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get organismId {
    if (_value.organismId == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.organismId!, (value) {
      return _then(_value.copyWith(organismId: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get organismNameElement {
    if (_value.organismNameElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.organismNameElement!, (value) {
      return _then(_value.copyWith(organismNameElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get developmentStage {
    if (_value.developmentStage == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.developmentStage!, (value) {
      return _then(_value.copyWith(developmentStage: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SubstanceSourceMaterialOrganismCopyWith<$Res>? get organism {
    if (_value.organism == null) {
      return null;
    }

    return $SubstanceSourceMaterialOrganismCopyWith<$Res>(_value.organism!,
        (value) {
      return _then(_value.copyWith(organism: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceSourceMaterialCopyWith<$Res>
    implements $SubstanceSourceMaterialCopyWith<$Res> {
  factory _$$_SubstanceSourceMaterialCopyWith(_$_SubstanceSourceMaterial value,
          $Res Function(_$_SubstanceSourceMaterial) then) =
      __$$_SubstanceSourceMaterialCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceSourceMaterial)
          R5ResourceType resourceType,
      FhirId? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? sourceMaterialClass,
      CodeableConcept? sourceMaterialType,
      CodeableConcept? sourceMaterialState,
      Identifier? organismId,
      String? organismName,
      @JsonKey(name: '_organismName')
          Element? organismNameElement,
      List<Identifier>? parentSubstanceId,
      List<String>? parentSubstanceName,
      @JsonKey(name: '_parentSubstanceName')
          List<Element>? parentSubstanceNameElement,
      List<CodeableConcept>? countryOfOrigin,
      List<String>? geographicalLocation,
      @JsonKey(name: '_geographicalLocation')
          List<Element>? geographicalLocationElement,
      CodeableConcept? developmentStage,
      List<SubstanceSourceMaterialFractionDescription>? fractionDescription,
      SubstanceSourceMaterialOrganism? organism,
      List<SubstanceSourceMaterialPartDescription>? partDescription});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $CodeableConceptCopyWith<$Res>? get sourceMaterialClass;
  @override
  $CodeableConceptCopyWith<$Res>? get sourceMaterialType;
  @override
  $CodeableConceptCopyWith<$Res>? get sourceMaterialState;
  @override
  $IdentifierCopyWith<$Res>? get organismId;
  @override
  $ElementCopyWith<$Res>? get organismNameElement;
  @override
  $CodeableConceptCopyWith<$Res>? get developmentStage;
  @override
  $SubstanceSourceMaterialOrganismCopyWith<$Res>? get organism;
}

/// @nodoc
class __$$_SubstanceSourceMaterialCopyWithImpl<$Res>
    extends _$SubstanceSourceMaterialCopyWithImpl<$Res,
        _$_SubstanceSourceMaterial>
    implements _$$_SubstanceSourceMaterialCopyWith<$Res> {
  __$$_SubstanceSourceMaterialCopyWithImpl(_$_SubstanceSourceMaterial _value,
      $Res Function(_$_SubstanceSourceMaterial) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sourceMaterialClass = freezed,
    Object? sourceMaterialType = freezed,
    Object? sourceMaterialState = freezed,
    Object? organismId = freezed,
    Object? organismName = freezed,
    Object? organismNameElement = freezed,
    Object? parentSubstanceId = freezed,
    Object? parentSubstanceName = freezed,
    Object? parentSubstanceNameElement = freezed,
    Object? countryOfOrigin = freezed,
    Object? geographicalLocation = freezed,
    Object? geographicalLocationElement = freezed,
    Object? developmentStage = freezed,
    Object? fractionDescription = freezed,
    Object? organism = freezed,
    Object? partDescription = freezed,
  }) {
    return _then(_$_SubstanceSourceMaterial(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R5ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sourceMaterialClass: freezed == sourceMaterialClass
          ? _value.sourceMaterialClass
          : sourceMaterialClass // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      sourceMaterialType: freezed == sourceMaterialType
          ? _value.sourceMaterialType
          : sourceMaterialType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      sourceMaterialState: freezed == sourceMaterialState
          ? _value.sourceMaterialState
          : sourceMaterialState // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      organismId: freezed == organismId
          ? _value.organismId
          : organismId // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      organismName: freezed == organismName
          ? _value.organismName
          : organismName // ignore: cast_nullable_to_non_nullable
              as String?,
      organismNameElement: freezed == organismNameElement
          ? _value.organismNameElement
          : organismNameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      parentSubstanceId: freezed == parentSubstanceId
          ? _value._parentSubstanceId
          : parentSubstanceId // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      parentSubstanceName: freezed == parentSubstanceName
          ? _value._parentSubstanceName
          : parentSubstanceName // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      parentSubstanceNameElement: freezed == parentSubstanceNameElement
          ? _value._parentSubstanceNameElement
          : parentSubstanceNameElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      countryOfOrigin: freezed == countryOfOrigin
          ? _value._countryOfOrigin
          : countryOfOrigin // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      geographicalLocation: freezed == geographicalLocation
          ? _value._geographicalLocation
          : geographicalLocation // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      geographicalLocationElement: freezed == geographicalLocationElement
          ? _value._geographicalLocationElement
          : geographicalLocationElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      developmentStage: freezed == developmentStage
          ? _value.developmentStage
          : developmentStage // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      fractionDescription: freezed == fractionDescription
          ? _value._fractionDescription
          : fractionDescription // ignore: cast_nullable_to_non_nullable
              as List<SubstanceSourceMaterialFractionDescription>?,
      organism: freezed == organism
          ? _value.organism
          : organism // ignore: cast_nullable_to_non_nullable
              as SubstanceSourceMaterialOrganism?,
      partDescription: freezed == partDescription
          ? _value._partDescription
          : partDescription // ignore: cast_nullable_to_non_nullable
              as List<SubstanceSourceMaterialPartDescription>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceSourceMaterial extends _SubstanceSourceMaterial {
  _$_SubstanceSourceMaterial(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceSourceMaterial)
          this.resourceType = R5ResourceType.SubstanceSourceMaterial,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules')
          this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language')
          this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.sourceMaterialClass,
      this.sourceMaterialType,
      this.sourceMaterialState,
      this.organismId,
      this.organismName,
      @JsonKey(name: '_organismName')
          this.organismNameElement,
      final List<Identifier>? parentSubstanceId,
      final List<String>? parentSubstanceName,
      @JsonKey(name: '_parentSubstanceName')
          final List<Element>? parentSubstanceNameElement,
      final List<CodeableConcept>? countryOfOrigin,
      final List<String>? geographicalLocation,
      @JsonKey(name: '_geographicalLocation')
          final List<Element>? geographicalLocationElement,
      this.developmentStage,
      final List<SubstanceSourceMaterialFractionDescription>?
          fractionDescription,
      this.organism,
      final List<SubstanceSourceMaterialPartDescription>? partDescription})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _parentSubstanceId = parentSubstanceId,
        _parentSubstanceName = parentSubstanceName,
        _parentSubstanceNameElement = parentSubstanceNameElement,
        _countryOfOrigin = countryOfOrigin,
        _geographicalLocation = geographicalLocation,
        _geographicalLocationElement = geographicalLocationElement,
        _fractionDescription = fractionDescription,
        _partDescription = partDescription,
        super._();

  factory _$_SubstanceSourceMaterial.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceSourceMaterialFromJson(json);

  /// [resourceType] This is a SubstanceSourceMaterial resource
  @override
  @JsonKey(unknownEnumValue: R5ResourceType.SubstanceSourceMaterial)
  final R5ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.
  @override
  final Code? language;

  /// [languageElement] ("_language") Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [sourceMaterialClass] General high level classification of the source material specific to the origin of the material.
  @override
  final CodeableConcept? sourceMaterialClass;

  /// [sourceMaterialType] The type of the source material shall be specified based on a controlled vocabulary. For vaccines, this subclause refers to the class of infectious agent.
  @override
  final CodeableConcept? sourceMaterialType;

  /// [sourceMaterialState] The state of the source material when extracted.
  @override
  final CodeableConcept? sourceMaterialState;

  /// [organismId] The unique identifier associated with the source material parent organism shall be specified.
  @override
  final Identifier? organismId;

  /// [organismName] The organism accepted Scientific name shall be provided based on the organism taxonomy.
  @override
  final String? organismName;

  /// [organismNameElement] ("_organismName") Extensions for organismName
  @override
  @JsonKey(name: '_organismName')
  final Element? organismNameElement;

  /// [parentSubstanceId] The parent of the herbal drug Ginkgo biloba, Leaf is the substance ID of the substance (fresh) of Ginkgo biloba L. or Ginkgo biloba L. (Whole plant).
  final List<Identifier>? _parentSubstanceId;

  /// [parentSubstanceId] The parent of the herbal drug Ginkgo biloba, Leaf is the substance ID of the substance (fresh) of Ginkgo biloba L. or Ginkgo biloba L. (Whole plant).
  @override
  List<Identifier>? get parentSubstanceId {
    final value = _parentSubstanceId;
    if (value == null) return null;
    if (_parentSubstanceId is EqualUnmodifiableListView)
      return _parentSubstanceId;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [parentSubstanceName] The parent substance of the Herbal Drug, or Herbal preparation.
  final List<String>? _parentSubstanceName;

  /// [parentSubstanceName] The parent substance of the Herbal Drug, or Herbal preparation.
  @override
  List<String>? get parentSubstanceName {
    final value = _parentSubstanceName;
    if (value == null) return null;
    if (_parentSubstanceName is EqualUnmodifiableListView)
      return _parentSubstanceName;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [parentSubstanceNameElement] ("_parentSubstanceName") Extensions for parentSubstanceName
  final List<Element>? _parentSubstanceNameElement;

  /// [parentSubstanceNameElement] ("_parentSubstanceName") Extensions for parentSubstanceName
  @override
  @JsonKey(name: '_parentSubstanceName')
  List<Element>? get parentSubstanceNameElement {
    final value = _parentSubstanceNameElement;
    if (value == null) return null;
    if (_parentSubstanceNameElement is EqualUnmodifiableListView)
      return _parentSubstanceNameElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [countryOfOrigin] The country where the plant material is harvested or the countries where the plasma is sourced from as laid down in accordance with the Plasma Master File. For Plasma-derived substances the attribute country of origin provides information about the countries used for the manufacturing of the Cryopoor plama or Crioprecipitate.
  final List<CodeableConcept>? _countryOfOrigin;

  /// [countryOfOrigin] The country where the plant material is harvested or the countries where the plasma is sourced from as laid down in accordance with the Plasma Master File. For Plasma-derived substances the attribute country of origin provides information about the countries used for the manufacturing of the Cryopoor plama or Crioprecipitate.
  @override
  List<CodeableConcept>? get countryOfOrigin {
    final value = _countryOfOrigin;
    if (value == null) return null;
    if (_countryOfOrigin is EqualUnmodifiableListView) return _countryOfOrigin;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [geographicalLocation] The place/region where the plant is harvested or the places/regions where the animal source material has its habitat.
  final List<String>? _geographicalLocation;

  /// [geographicalLocation] The place/region where the plant is harvested or the places/regions where the animal source material has its habitat.
  @override
  List<String>? get geographicalLocation {
    final value = _geographicalLocation;
    if (value == null) return null;
    if (_geographicalLocation is EqualUnmodifiableListView)
      return _geographicalLocation;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [geographicalLocationElement] ("_geographicalLocation") Extensions for geographicalLocation
  final List<Element>? _geographicalLocationElement;

  /// [geographicalLocationElement] ("_geographicalLocation") Extensions for geographicalLocation
  @override
  @JsonKey(name: '_geographicalLocation')
  List<Element>? get geographicalLocationElement {
    final value = _geographicalLocationElement;
    if (value == null) return null;
    if (_geographicalLocationElement is EqualUnmodifiableListView)
      return _geographicalLocationElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [developmentStage] Stage of life for animals, plants, insects and microorganisms. This information shall be provided only when the substance is significantly different in these stages (e.g. foetal bovine serum).
  @override
  final CodeableConcept? developmentStage;

  /// [fractionDescription] Many complex materials are fractions of parts of plants, animals, or minerals. Fraction elements are often necessary to define both Substances and Specified Group 1 Substances. For substances derived from Plants, fraction information will be captured at the Substance information level ( . Oils, Juices and Exudates). Additional information for Extracts, such as extraction solvent composition, will be captured at the Specified Substance Group 1 information level. For plasma-derived products fraction information will be captured at the Substance and the Specified Substance Group 1 levels.
  final List<SubstanceSourceMaterialFractionDescription>? _fractionDescription;

  /// [fractionDescription] Many complex materials are fractions of parts of plants, animals, or minerals. Fraction elements are often necessary to define both Substances and Specified Group 1 Substances. For substances derived from Plants, fraction information will be captured at the Substance information level ( . Oils, Juices and Exudates). Additional information for Extracts, such as extraction solvent composition, will be captured at the Specified Substance Group 1 information level. For plasma-derived products fraction information will be captured at the Substance and the Specified Substance Group 1 levels.
  @override
  List<SubstanceSourceMaterialFractionDescription>? get fractionDescription {
    final value = _fractionDescription;
    if (value == null) return null;
    if (_fractionDescription is EqualUnmodifiableListView)
      return _fractionDescription;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [organism] This subclause describes the organism which the substance is derived from. For vaccines, the parent organism shall be specified based on these subclause elements. As an example, full taxonomy will be described for the Substance Name: ., Leaf.
  @override
  final SubstanceSourceMaterialOrganism? organism;

  /// [partDescription] To do.
  final List<SubstanceSourceMaterialPartDescription>? _partDescription;

  /// [partDescription] To do.
  @override
  List<SubstanceSourceMaterialPartDescription>? get partDescription {
    final value = _partDescription;
    if (value == null) return null;
    if (_partDescription is EqualUnmodifiableListView) return _partDescription;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstanceSourceMaterial(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, sourceMaterialClass: $sourceMaterialClass, sourceMaterialType: $sourceMaterialType, sourceMaterialState: $sourceMaterialState, organismId: $organismId, organismName: $organismName, organismNameElement: $organismNameElement, parentSubstanceId: $parentSubstanceId, parentSubstanceName: $parentSubstanceName, parentSubstanceNameElement: $parentSubstanceNameElement, countryOfOrigin: $countryOfOrigin, geographicalLocation: $geographicalLocation, geographicalLocationElement: $geographicalLocationElement, developmentStage: $developmentStage, fractionDescription: $fractionDescription, organism: $organism, partDescription: $partDescription)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceSourceMaterial &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.sourceMaterialClass, sourceMaterialClass) ||
                other.sourceMaterialClass == sourceMaterialClass) &&
            (identical(other.sourceMaterialType, sourceMaterialType) ||
                other.sourceMaterialType == sourceMaterialType) &&
            (identical(other.sourceMaterialState, sourceMaterialState) ||
                other.sourceMaterialState == sourceMaterialState) &&
            (identical(other.organismId, organismId) ||
                other.organismId == organismId) &&
            (identical(other.organismName, organismName) ||
                other.organismName == organismName) &&
            (identical(other.organismNameElement, organismNameElement) ||
                other.organismNameElement == organismNameElement) &&
            const DeepCollectionEquality()
                .equals(other._parentSubstanceId, _parentSubstanceId) &&
            const DeepCollectionEquality()
                .equals(other._parentSubstanceName, _parentSubstanceName) &&
            const DeepCollectionEquality().equals(
                other._parentSubstanceNameElement,
                _parentSubstanceNameElement) &&
            const DeepCollectionEquality()
                .equals(other._countryOfOrigin, _countryOfOrigin) &&
            const DeepCollectionEquality()
                .equals(other._geographicalLocation, _geographicalLocation) &&
            const DeepCollectionEquality().equals(
                other._geographicalLocationElement,
                _geographicalLocationElement) &&
            (identical(other.developmentStage, developmentStage) ||
                other.developmentStage == developmentStage) &&
            const DeepCollectionEquality()
                .equals(other._fractionDescription, _fractionDescription) &&
            (identical(other.organism, organism) ||
                other.organism == organism) &&
            const DeepCollectionEquality()
                .equals(other._partDescription, _partDescription));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        sourceMaterialClass,
        sourceMaterialType,
        sourceMaterialState,
        organismId,
        organismName,
        organismNameElement,
        const DeepCollectionEquality().hash(_parentSubstanceId),
        const DeepCollectionEquality().hash(_parentSubstanceName),
        const DeepCollectionEquality().hash(_parentSubstanceNameElement),
        const DeepCollectionEquality().hash(_countryOfOrigin),
        const DeepCollectionEquality().hash(_geographicalLocation),
        const DeepCollectionEquality().hash(_geographicalLocationElement),
        developmentStage,
        const DeepCollectionEquality().hash(_fractionDescription),
        organism,
        const DeepCollectionEquality().hash(_partDescription)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceSourceMaterialCopyWith<_$_SubstanceSourceMaterial>
      get copyWith =>
          __$$_SubstanceSourceMaterialCopyWithImpl<_$_SubstanceSourceMaterial>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceSourceMaterialToJson(
      this,
    );
  }
}

abstract class _SubstanceSourceMaterial extends SubstanceSourceMaterial {
  factory _SubstanceSourceMaterial(
      {@JsonKey(unknownEnumValue: R5ResourceType.SubstanceSourceMaterial)
          final R5ResourceType resourceType,
      final FhirId? id,
      final Meta? meta,
      final FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          final Element? implicitRulesElement,
      final Code? language,
      @JsonKey(name: '_language')
          final Element? languageElement,
      final Narrative? text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? sourceMaterialClass,
      final CodeableConcept? sourceMaterialType,
      final CodeableConcept? sourceMaterialState,
      final Identifier? organismId,
      final String? organismName,
      @JsonKey(name: '_organismName')
          final Element? organismNameElement,
      final List<Identifier>? parentSubstanceId,
      final List<String>? parentSubstanceName,
      @JsonKey(name: '_parentSubstanceName')
          final List<Element>? parentSubstanceNameElement,
      final List<CodeableConcept>? countryOfOrigin,
      final List<String>? geographicalLocation,
      @JsonKey(name: '_geographicalLocation')
          final List<Element>? geographicalLocationElement,
      final CodeableConcept? developmentStage,
      final List<SubstanceSourceMaterialFractionDescription>?
          fractionDescription,
      final SubstanceSourceMaterialOrganism? organism,
      final List<SubstanceSourceMaterialPartDescription>?
          partDescription}) = _$_SubstanceSourceMaterial;
  _SubstanceSourceMaterial._() : super._();

  factory _SubstanceSourceMaterial.fromJson(Map<String, dynamic> json) =
      _$_SubstanceSourceMaterial.fromJson;

  @override

  /// [resourceType] This is a SubstanceSourceMaterial resource
  @JsonKey(unknownEnumValue: R5ResourceType.SubstanceSourceMaterial)
  R5ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when
  /// the resource was constructed, and which must be understood when
  /// processing the content. Often, this is a reference to an implementation
  /// guide that defines the special rules along with other profiles etc.
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.
  Code? get language;
  @override

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope. This is allowed to be a Parameters resource if and only if it is referenced by a resource that provides context/meaning.
  List<Resource>? get contained;
  @override

  /// [extension_] ("extension") May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [sourceMaterialClass] General high level classification of the source material specific to the origin of the material.
  CodeableConcept? get sourceMaterialClass;
  @override

  /// [sourceMaterialType] The type of the source material shall be specified based on a controlled vocabulary. For vaccines, this subclause refers to the class of infectious agent.
  CodeableConcept? get sourceMaterialType;
  @override

  /// [sourceMaterialState] The state of the source material when extracted.
  CodeableConcept? get sourceMaterialState;
  @override

  /// [organismId] The unique identifier associated with the source material parent organism shall be specified.
  Identifier? get organismId;
  @override

  /// [organismName] The organism accepted Scientific name shall be provided based on the organism taxonomy.
  String? get organismName;
  @override

  /// [organismNameElement] ("_organismName") Extensions for organismName
  @JsonKey(name: '_organismName')
  Element? get organismNameElement;
  @override

  /// [parentSubstanceId] The parent of the herbal drug Ginkgo biloba, Leaf is the substance ID of the substance (fresh) of Ginkgo biloba L. or Ginkgo biloba L. (Whole plant).
  List<Identifier>? get parentSubstanceId;
  @override

  /// [parentSubstanceName] The parent substance of the Herbal Drug, or Herbal preparation.
  List<String>? get parentSubstanceName;
  @override

  /// [parentSubstanceNameElement] ("_parentSubstanceName") Extensions for parentSubstanceName
  @JsonKey(name: '_parentSubstanceName')
  List<Element>? get parentSubstanceNameElement;
  @override

  /// [countryOfOrigin] The country where the plant material is harvested or the countries where the plasma is sourced from as laid down in accordance with the Plasma Master File. For Plasma-derived substances the attribute country of origin provides information about the countries used for the manufacturing of the Cryopoor plama or Crioprecipitate.
  List<CodeableConcept>? get countryOfOrigin;
  @override

  /// [geographicalLocation] The place/region where the plant is harvested or the places/regions where the animal source material has its habitat.
  List<String>? get geographicalLocation;
  @override

  /// [geographicalLocationElement] ("_geographicalLocation") Extensions for geographicalLocation
  @JsonKey(name: '_geographicalLocation')
  List<Element>? get geographicalLocationElement;
  @override

  /// [developmentStage] Stage of life for animals, plants, insects and microorganisms. This information shall be provided only when the substance is significantly different in these stages (e.g. foetal bovine serum).
  CodeableConcept? get developmentStage;
  @override

  /// [fractionDescription] Many complex materials are fractions of parts of plants, animals, or minerals. Fraction elements are often necessary to define both Substances and Specified Group 1 Substances. For substances derived from Plants, fraction information will be captured at the Substance information level ( . Oils, Juices and Exudates). Additional information for Extracts, such as extraction solvent composition, will be captured at the Specified Substance Group 1 information level. For plasma-derived products fraction information will be captured at the Substance and the Specified Substance Group 1 levels.
  List<SubstanceSourceMaterialFractionDescription>? get fractionDescription;
  @override

  /// [organism] This subclause describes the organism which the substance is derived from. For vaccines, the parent organism shall be specified based on these subclause elements. As an example, full taxonomy will be described for the Substance Name: ., Leaf.
  SubstanceSourceMaterialOrganism? get organism;
  @override

  /// [partDescription] To do.
  List<SubstanceSourceMaterialPartDescription>? get partDescription;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceSourceMaterialCopyWith<_$_SubstanceSourceMaterial>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceSourceMaterialFractionDescription
    _$SubstanceSourceMaterialFractionDescriptionFromJson(
        Map<String, dynamic> json) {
  return _SubstanceSourceMaterialFractionDescription.fromJson(json);
}

/// @nodoc
mixin _$SubstanceSourceMaterialFractionDescription {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [fraction] This element is capturing information about the fraction of a plant part, or human plasma for fractionation.
  String? get fraction => throw _privateConstructorUsedError;

  /// [fractionElement] ("_fraction") Extensions for fraction
  @JsonKey(name: '_fraction')
  Element? get fractionElement => throw _privateConstructorUsedError;

  /// [materialType] The specific type of the material constituting the component. For Herbal preparations the particulars of the extracts (liquid/dry) is described in Specified Substance Group 1.
  CodeableConcept? get materialType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceSourceMaterialFractionDescriptionCopyWith<
          SubstanceSourceMaterialFractionDescription>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceSourceMaterialFractionDescriptionCopyWith<$Res> {
  factory $SubstanceSourceMaterialFractionDescriptionCopyWith(
          SubstanceSourceMaterialFractionDescription value,
          $Res Function(SubstanceSourceMaterialFractionDescription) then) =
      _$SubstanceSourceMaterialFractionDescriptionCopyWithImpl<$Res,
          SubstanceSourceMaterialFractionDescription>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? fraction,
      @JsonKey(name: '_fraction') Element? fractionElement,
      CodeableConcept? materialType});

  $ElementCopyWith<$Res>? get fractionElement;
  $CodeableConceptCopyWith<$Res>? get materialType;
}

/// @nodoc
class _$SubstanceSourceMaterialFractionDescriptionCopyWithImpl<$Res,
        $Val extends SubstanceSourceMaterialFractionDescription>
    implements $SubstanceSourceMaterialFractionDescriptionCopyWith<$Res> {
  _$SubstanceSourceMaterialFractionDescriptionCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? fraction = freezed,
    Object? fractionElement = freezed,
    Object? materialType = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      fraction: freezed == fraction
          ? _value.fraction
          : fraction // ignore: cast_nullable_to_non_nullable
              as String?,
      fractionElement: freezed == fractionElement
          ? _value.fractionElement
          : fractionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      materialType: freezed == materialType
          ? _value.materialType
          : materialType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get fractionElement {
    if (_value.fractionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.fractionElement!, (value) {
      return _then(_value.copyWith(fractionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get materialType {
    if (_value.materialType == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.materialType!, (value) {
      return _then(_value.copyWith(materialType: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceSourceMaterialFractionDescriptionCopyWith<$Res>
    implements $SubstanceSourceMaterialFractionDescriptionCopyWith<$Res> {
  factory _$$_SubstanceSourceMaterialFractionDescriptionCopyWith(
          _$_SubstanceSourceMaterialFractionDescription value,
          $Res Function(_$_SubstanceSourceMaterialFractionDescription) then) =
      __$$_SubstanceSourceMaterialFractionDescriptionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? fraction,
      @JsonKey(name: '_fraction') Element? fractionElement,
      CodeableConcept? materialType});

  @override
  $ElementCopyWith<$Res>? get fractionElement;
  @override
  $CodeableConceptCopyWith<$Res>? get materialType;
}

/// @nodoc
class __$$_SubstanceSourceMaterialFractionDescriptionCopyWithImpl<$Res>
    extends _$SubstanceSourceMaterialFractionDescriptionCopyWithImpl<$Res,
        _$_SubstanceSourceMaterialFractionDescription>
    implements _$$_SubstanceSourceMaterialFractionDescriptionCopyWith<$Res> {
  __$$_SubstanceSourceMaterialFractionDescriptionCopyWithImpl(
      _$_SubstanceSourceMaterialFractionDescription _value,
      $Res Function(_$_SubstanceSourceMaterialFractionDescription) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? fraction = freezed,
    Object? fractionElement = freezed,
    Object? materialType = freezed,
  }) {
    return _then(_$_SubstanceSourceMaterialFractionDescription(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      fraction: freezed == fraction
          ? _value.fraction
          : fraction // ignore: cast_nullable_to_non_nullable
              as String?,
      fractionElement: freezed == fractionElement
          ? _value.fractionElement
          : fractionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      materialType: freezed == materialType
          ? _value.materialType
          : materialType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceSourceMaterialFractionDescription
    extends _SubstanceSourceMaterialFractionDescription {
  _$_SubstanceSourceMaterialFractionDescription(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.fraction,
      @JsonKey(name: '_fraction') this.fractionElement,
      this.materialType})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstanceSourceMaterialFractionDescription.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstanceSourceMaterialFractionDescriptionFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [fraction] This element is capturing information about the fraction of a plant part, or human plasma for fractionation.
  @override
  final String? fraction;

  /// [fractionElement] ("_fraction") Extensions for fraction
  @override
  @JsonKey(name: '_fraction')
  final Element? fractionElement;

  /// [materialType] The specific type of the material constituting the component. For Herbal preparations the particulars of the extracts (liquid/dry) is described in Specified Substance Group 1.
  @override
  final CodeableConcept? materialType;

  @override
  String toString() {
    return 'SubstanceSourceMaterialFractionDescription(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, fraction: $fraction, fractionElement: $fractionElement, materialType: $materialType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceSourceMaterialFractionDescription &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.fraction, fraction) ||
                other.fraction == fraction) &&
            (identical(other.fractionElement, fractionElement) ||
                other.fractionElement == fractionElement) &&
            (identical(other.materialType, materialType) ||
                other.materialType == materialType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      fraction,
      fractionElement,
      materialType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceSourceMaterialFractionDescriptionCopyWith<
          _$_SubstanceSourceMaterialFractionDescription>
      get copyWith =>
          __$$_SubstanceSourceMaterialFractionDescriptionCopyWithImpl<
              _$_SubstanceSourceMaterialFractionDescription>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceSourceMaterialFractionDescriptionToJson(
      this,
    );
  }
}

abstract class _SubstanceSourceMaterialFractionDescription
    extends SubstanceSourceMaterialFractionDescription {
  factory _SubstanceSourceMaterialFractionDescription(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final String? fraction,
          @JsonKey(name: '_fraction') final Element? fractionElement,
          final CodeableConcept? materialType}) =
      _$_SubstanceSourceMaterialFractionDescription;
  _SubstanceSourceMaterialFractionDescription._() : super._();

  factory _SubstanceSourceMaterialFractionDescription.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceSourceMaterialFractionDescription.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [fraction] This element is capturing information about the fraction of a plant part, or human plasma for fractionation.
  String? get fraction;
  @override

  /// [fractionElement] ("_fraction") Extensions for fraction
  @JsonKey(name: '_fraction')
  Element? get fractionElement;
  @override

  /// [materialType] The specific type of the material constituting the component. For Herbal preparations the particulars of the extracts (liquid/dry) is described in Specified Substance Group 1.
  CodeableConcept? get materialType;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceSourceMaterialFractionDescriptionCopyWith<
          _$_SubstanceSourceMaterialFractionDescription>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceSourceMaterialOrganism _$SubstanceSourceMaterialOrganismFromJson(
    Map<String, dynamic> json) {
  return _SubstanceSourceMaterialOrganism.fromJson(json);
}

/// @nodoc
mixin _$SubstanceSourceMaterialOrganism {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [family] The family of an organism shall be specified.
  CodeableConcept? get family => throw _privateConstructorUsedError;

  /// [genus] The genus of an organism shall be specified; refers to the Latin epithet of the genus element of the plant/animal scientific name; it is present in names for genera, species and infraspecies.
  CodeableConcept? get genus => throw _privateConstructorUsedError;

  /// [species] The species of an organism shall be specified; refers to the Latin epithet of the species of the plant/animal; it is present in names for species and infraspecies.
  CodeableConcept? get species => throw _privateConstructorUsedError;

  /// [intraspecificType] The Intraspecific type of an organism shall be specified.
  CodeableConcept? get intraspecificType => throw _privateConstructorUsedError;

  /// [intraspecificDescription] The intraspecific description of an organism shall be specified based on a controlled vocabulary. For Influenza Vaccine, the intraspecific description shall contain the syntax of the antigen in line with the WHO convention.
  String? get intraspecificDescription => throw _privateConstructorUsedError;

  /// [intraspecificDescriptionElement] ("_intraspecificDescription") Extensions for intraspecificDescription
  @JsonKey(name: '_intraspecificDescription')
  Element? get intraspecificDescriptionElement =>
      throw _privateConstructorUsedError;

  /// [author] 4.9.13.6.1 Author type (Conditional).
  List<SubstanceSourceMaterialAuthor>? get author =>
      throw _privateConstructorUsedError;

  /// [hybrid] 4.9.13.8.1 Hybrid species maternal organism ID (Optional).
  SubstanceSourceMaterialHybrid? get hybrid =>
      throw _privateConstructorUsedError;

  /// [organismGeneral] 4.9.13.7.1 Kingdom (Conditional).
  SubstanceSourceMaterialOrganismGeneral? get organismGeneral =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceSourceMaterialOrganismCopyWith<SubstanceSourceMaterialOrganism>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceSourceMaterialOrganismCopyWith<$Res> {
  factory $SubstanceSourceMaterialOrganismCopyWith(
          SubstanceSourceMaterialOrganism value,
          $Res Function(SubstanceSourceMaterialOrganism) then) =
      _$SubstanceSourceMaterialOrganismCopyWithImpl<$Res,
          SubstanceSourceMaterialOrganism>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? family,
      CodeableConcept? genus,
      CodeableConcept? species,
      CodeableConcept? intraspecificType,
      String? intraspecificDescription,
      @JsonKey(name: '_intraspecificDescription')
          Element? intraspecificDescriptionElement,
      List<SubstanceSourceMaterialAuthor>? author,
      SubstanceSourceMaterialHybrid? hybrid,
      SubstanceSourceMaterialOrganismGeneral? organismGeneral});

  $CodeableConceptCopyWith<$Res>? get family;
  $CodeableConceptCopyWith<$Res>? get genus;
  $CodeableConceptCopyWith<$Res>? get species;
  $CodeableConceptCopyWith<$Res>? get intraspecificType;
  $ElementCopyWith<$Res>? get intraspecificDescriptionElement;
  $SubstanceSourceMaterialHybridCopyWith<$Res>? get hybrid;
  $SubstanceSourceMaterialOrganismGeneralCopyWith<$Res>? get organismGeneral;
}

/// @nodoc
class _$SubstanceSourceMaterialOrganismCopyWithImpl<$Res,
        $Val extends SubstanceSourceMaterialOrganism>
    implements $SubstanceSourceMaterialOrganismCopyWith<$Res> {
  _$SubstanceSourceMaterialOrganismCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? family = freezed,
    Object? genus = freezed,
    Object? species = freezed,
    Object? intraspecificType = freezed,
    Object? intraspecificDescription = freezed,
    Object? intraspecificDescriptionElement = freezed,
    Object? author = freezed,
    Object? hybrid = freezed,
    Object? organismGeneral = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      family: freezed == family
          ? _value.family
          : family // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      genus: freezed == genus
          ? _value.genus
          : genus // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      species: freezed == species
          ? _value.species
          : species // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      intraspecificType: freezed == intraspecificType
          ? _value.intraspecificType
          : intraspecificType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      intraspecificDescription: freezed == intraspecificDescription
          ? _value.intraspecificDescription
          : intraspecificDescription // ignore: cast_nullable_to_non_nullable
              as String?,
      intraspecificDescriptionElement: freezed ==
              intraspecificDescriptionElement
          ? _value.intraspecificDescriptionElement
          : intraspecificDescriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      author: freezed == author
          ? _value.author
          : author // ignore: cast_nullable_to_non_nullable
              as List<SubstanceSourceMaterialAuthor>?,
      hybrid: freezed == hybrid
          ? _value.hybrid
          : hybrid // ignore: cast_nullable_to_non_nullable
              as SubstanceSourceMaterialHybrid?,
      organismGeneral: freezed == organismGeneral
          ? _value.organismGeneral
          : organismGeneral // ignore: cast_nullable_to_non_nullable
              as SubstanceSourceMaterialOrganismGeneral?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get family {
    if (_value.family == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.family!, (value) {
      return _then(_value.copyWith(family: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get genus {
    if (_value.genus == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.genus!, (value) {
      return _then(_value.copyWith(genus: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get species {
    if (_value.species == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.species!, (value) {
      return _then(_value.copyWith(species: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get intraspecificType {
    if (_value.intraspecificType == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.intraspecificType!, (value) {
      return _then(_value.copyWith(intraspecificType: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get intraspecificDescriptionElement {
    if (_value.intraspecificDescriptionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.intraspecificDescriptionElement!,
        (value) {
      return _then(
          _value.copyWith(intraspecificDescriptionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SubstanceSourceMaterialHybridCopyWith<$Res>? get hybrid {
    if (_value.hybrid == null) {
      return null;
    }

    return $SubstanceSourceMaterialHybridCopyWith<$Res>(_value.hybrid!,
        (value) {
      return _then(_value.copyWith(hybrid: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SubstanceSourceMaterialOrganismGeneralCopyWith<$Res>? get organismGeneral {
    if (_value.organismGeneral == null) {
      return null;
    }

    return $SubstanceSourceMaterialOrganismGeneralCopyWith<$Res>(
        _value.organismGeneral!, (value) {
      return _then(_value.copyWith(organismGeneral: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceSourceMaterialOrganismCopyWith<$Res>
    implements $SubstanceSourceMaterialOrganismCopyWith<$Res> {
  factory _$$_SubstanceSourceMaterialOrganismCopyWith(
          _$_SubstanceSourceMaterialOrganism value,
          $Res Function(_$_SubstanceSourceMaterialOrganism) then) =
      __$$_SubstanceSourceMaterialOrganismCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? family,
      CodeableConcept? genus,
      CodeableConcept? species,
      CodeableConcept? intraspecificType,
      String? intraspecificDescription,
      @JsonKey(name: '_intraspecificDescription')
          Element? intraspecificDescriptionElement,
      List<SubstanceSourceMaterialAuthor>? author,
      SubstanceSourceMaterialHybrid? hybrid,
      SubstanceSourceMaterialOrganismGeneral? organismGeneral});

  @override
  $CodeableConceptCopyWith<$Res>? get family;
  @override
  $CodeableConceptCopyWith<$Res>? get genus;
  @override
  $CodeableConceptCopyWith<$Res>? get species;
  @override
  $CodeableConceptCopyWith<$Res>? get intraspecificType;
  @override
  $ElementCopyWith<$Res>? get intraspecificDescriptionElement;
  @override
  $SubstanceSourceMaterialHybridCopyWith<$Res>? get hybrid;
  @override
  $SubstanceSourceMaterialOrganismGeneralCopyWith<$Res>? get organismGeneral;
}

/// @nodoc
class __$$_SubstanceSourceMaterialOrganismCopyWithImpl<$Res>
    extends _$SubstanceSourceMaterialOrganismCopyWithImpl<$Res,
        _$_SubstanceSourceMaterialOrganism>
    implements _$$_SubstanceSourceMaterialOrganismCopyWith<$Res> {
  __$$_SubstanceSourceMaterialOrganismCopyWithImpl(
      _$_SubstanceSourceMaterialOrganism _value,
      $Res Function(_$_SubstanceSourceMaterialOrganism) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? family = freezed,
    Object? genus = freezed,
    Object? species = freezed,
    Object? intraspecificType = freezed,
    Object? intraspecificDescription = freezed,
    Object? intraspecificDescriptionElement = freezed,
    Object? author = freezed,
    Object? hybrid = freezed,
    Object? organismGeneral = freezed,
  }) {
    return _then(_$_SubstanceSourceMaterialOrganism(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      family: freezed == family
          ? _value.family
          : family // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      genus: freezed == genus
          ? _value.genus
          : genus // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      species: freezed == species
          ? _value.species
          : species // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      intraspecificType: freezed == intraspecificType
          ? _value.intraspecificType
          : intraspecificType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      intraspecificDescription: freezed == intraspecificDescription
          ? _value.intraspecificDescription
          : intraspecificDescription // ignore: cast_nullable_to_non_nullable
              as String?,
      intraspecificDescriptionElement: freezed ==
              intraspecificDescriptionElement
          ? _value.intraspecificDescriptionElement
          : intraspecificDescriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      author: freezed == author
          ? _value._author
          : author // ignore: cast_nullable_to_non_nullable
              as List<SubstanceSourceMaterialAuthor>?,
      hybrid: freezed == hybrid
          ? _value.hybrid
          : hybrid // ignore: cast_nullable_to_non_nullable
              as SubstanceSourceMaterialHybrid?,
      organismGeneral: freezed == organismGeneral
          ? _value.organismGeneral
          : organismGeneral // ignore: cast_nullable_to_non_nullable
              as SubstanceSourceMaterialOrganismGeneral?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceSourceMaterialOrganism
    extends _SubstanceSourceMaterialOrganism {
  _$_SubstanceSourceMaterialOrganism(
      {this.id,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.family,
      this.genus,
      this.species,
      this.intraspecificType,
      this.intraspecificDescription,
      @JsonKey(name: '_intraspecificDescription')
          this.intraspecificDescriptionElement,
      final List<SubstanceSourceMaterialAuthor>? author,
      this.hybrid,
      this.organismGeneral})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _author = author,
        super._();

  factory _$_SubstanceSourceMaterialOrganism.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstanceSourceMaterialOrganismFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [family] The family of an organism shall be specified.
  @override
  final CodeableConcept? family;

  /// [genus] The genus of an organism shall be specified; refers to the Latin epithet of the genus element of the plant/animal scientific name; it is present in names for genera, species and infraspecies.
  @override
  final CodeableConcept? genus;

  /// [species] The species of an organism shall be specified; refers to the Latin epithet of the species of the plant/animal; it is present in names for species and infraspecies.
  @override
  final CodeableConcept? species;

  /// [intraspecificType] The Intraspecific type of an organism shall be specified.
  @override
  final CodeableConcept? intraspecificType;

  /// [intraspecificDescription] The intraspecific description of an organism shall be specified based on a controlled vocabulary. For Influenza Vaccine, the intraspecific description shall contain the syntax of the antigen in line with the WHO convention.
  @override
  final String? intraspecificDescription;

  /// [intraspecificDescriptionElement] ("_intraspecificDescription") Extensions for intraspecificDescription
  @override
  @JsonKey(name: '_intraspecificDescription')
  final Element? intraspecificDescriptionElement;

  /// [author] 4.9.13.6.1 Author type (Conditional).
  final List<SubstanceSourceMaterialAuthor>? _author;

  /// [author] 4.9.13.6.1 Author type (Conditional).
  @override
  List<SubstanceSourceMaterialAuthor>? get author {
    final value = _author;
    if (value == null) return null;
    if (_author is EqualUnmodifiableListView) return _author;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [hybrid] 4.9.13.8.1 Hybrid species maternal organism ID (Optional).
  @override
  final SubstanceSourceMaterialHybrid? hybrid;

  /// [organismGeneral] 4.9.13.7.1 Kingdom (Conditional).
  @override
  final SubstanceSourceMaterialOrganismGeneral? organismGeneral;

  @override
  String toString() {
    return 'SubstanceSourceMaterialOrganism(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, family: $family, genus: $genus, species: $species, intraspecificType: $intraspecificType, intraspecificDescription: $intraspecificDescription, intraspecificDescriptionElement: $intraspecificDescriptionElement, author: $author, hybrid: $hybrid, organismGeneral: $organismGeneral)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceSourceMaterialOrganism &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.family, family) || other.family == family) &&
            (identical(other.genus, genus) || other.genus == genus) &&
            (identical(other.species, species) || other.species == species) &&
            (identical(other.intraspecificType, intraspecificType) ||
                other.intraspecificType == intraspecificType) &&
            (identical(
                    other.intraspecificDescription, intraspecificDescription) ||
                other.intraspecificDescription == intraspecificDescription) &&
            (identical(other.intraspecificDescriptionElement,
                    intraspecificDescriptionElement) ||
                other.intraspecificDescriptionElement ==
                    intraspecificDescriptionElement) &&
            const DeepCollectionEquality().equals(other._author, _author) &&
            (identical(other.hybrid, hybrid) || other.hybrid == hybrid) &&
            (identical(other.organismGeneral, organismGeneral) ||
                other.organismGeneral == organismGeneral));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      family,
      genus,
      species,
      intraspecificType,
      intraspecificDescription,
      intraspecificDescriptionElement,
      const DeepCollectionEquality().hash(_author),
      hybrid,
      organismGeneral);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceSourceMaterialOrganismCopyWith<
          _$_SubstanceSourceMaterialOrganism>
      get copyWith => __$$_SubstanceSourceMaterialOrganismCopyWithImpl<
          _$_SubstanceSourceMaterialOrganism>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceSourceMaterialOrganismToJson(
      this,
    );
  }
}

abstract class _SubstanceSourceMaterialOrganism
    extends SubstanceSourceMaterialOrganism {
  factory _SubstanceSourceMaterialOrganism(
          {final String? id,
          @JsonKey(name: 'extension')
              final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableConcept? family,
          final CodeableConcept? genus,
          final CodeableConcept? species,
          final CodeableConcept? intraspecificType,
          final String? intraspecificDescription,
          @JsonKey(name: '_intraspecificDescription')
              final Element? intraspecificDescriptionElement,
          final List<SubstanceSourceMaterialAuthor>? author,
          final SubstanceSourceMaterialHybrid? hybrid,
          final SubstanceSourceMaterialOrganismGeneral? organismGeneral}) =
      _$_SubstanceSourceMaterialOrganism;
  _SubstanceSourceMaterialOrganism._() : super._();

  factory _SubstanceSourceMaterialOrganism.fromJson(Map<String, dynamic> json) =
      _$_SubstanceSourceMaterialOrganism.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [family] The family of an organism shall be specified.
  CodeableConcept? get family;
  @override

  /// [genus] The genus of an organism shall be specified; refers to the Latin epithet of the genus element of the plant/animal scientific name; it is present in names for genera, species and infraspecies.
  CodeableConcept? get genus;
  @override

  /// [species] The species of an organism shall be specified; refers to the Latin epithet of the species of the plant/animal; it is present in names for species and infraspecies.
  CodeableConcept? get species;
  @override

  /// [intraspecificType] The Intraspecific type of an organism shall be specified.
  CodeableConcept? get intraspecificType;
  @override

  /// [intraspecificDescription] The intraspecific description of an organism shall be specified based on a controlled vocabulary. For Influenza Vaccine, the intraspecific description shall contain the syntax of the antigen in line with the WHO convention.
  String? get intraspecificDescription;
  @override

  /// [intraspecificDescriptionElement] ("_intraspecificDescription") Extensions for intraspecificDescription
  @JsonKey(name: '_intraspecificDescription')
  Element? get intraspecificDescriptionElement;
  @override

  /// [author] 4.9.13.6.1 Author type (Conditional).
  List<SubstanceSourceMaterialAuthor>? get author;
  @override

  /// [hybrid] 4.9.13.8.1 Hybrid species maternal organism ID (Optional).
  SubstanceSourceMaterialHybrid? get hybrid;
  @override

  /// [organismGeneral] 4.9.13.7.1 Kingdom (Conditional).
  SubstanceSourceMaterialOrganismGeneral? get organismGeneral;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceSourceMaterialOrganismCopyWith<
          _$_SubstanceSourceMaterialOrganism>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceSourceMaterialAuthor _$SubstanceSourceMaterialAuthorFromJson(
    Map<String, dynamic> json) {
  return _SubstanceSourceMaterialAuthor.fromJson(json);
}

/// @nodoc
mixin _$SubstanceSourceMaterialAuthor {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [authorType] The type of author of an organism species shall be specified. The parenthetical author of an organism species refers to the first author who published the plant/animal name (of any rank). The primary author of an organism species refers to the first author(s), who validly published the plant/animal name.
  CodeableConcept? get authorType => throw _privateConstructorUsedError;

  /// [authorDescription] The author of an organism species shall be specified. The author year of an organism shall also be specified when applicable; refers to the year in which the first author(s) published the infraspecific plant/animal name (of any rank).
  String? get authorDescription => throw _privateConstructorUsedError;

  /// [authorDescriptionElement] ("_authorDescription") Extensions for authorDescription
  @JsonKey(name: '_authorDescription')
  Element? get authorDescriptionElement => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceSourceMaterialAuthorCopyWith<SubstanceSourceMaterialAuthor>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceSourceMaterialAuthorCopyWith<$Res> {
  factory $SubstanceSourceMaterialAuthorCopyWith(
          SubstanceSourceMaterialAuthor value,
          $Res Function(SubstanceSourceMaterialAuthor) then) =
      _$SubstanceSourceMaterialAuthorCopyWithImpl<$Res,
          SubstanceSourceMaterialAuthor>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? authorType,
      String? authorDescription,
      @JsonKey(name: '_authorDescription') Element? authorDescriptionElement});

  $CodeableConceptCopyWith<$Res>? get authorType;
  $ElementCopyWith<$Res>? get authorDescriptionElement;
}

/// @nodoc
class _$SubstanceSourceMaterialAuthorCopyWithImpl<$Res,
        $Val extends SubstanceSourceMaterialAuthor>
    implements $SubstanceSourceMaterialAuthorCopyWith<$Res> {
  _$SubstanceSourceMaterialAuthorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? authorType = freezed,
    Object? authorDescription = freezed,
    Object? authorDescriptionElement = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      authorType: freezed == authorType
          ? _value.authorType
          : authorType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      authorDescription: freezed == authorDescription
          ? _value.authorDescription
          : authorDescription // ignore: cast_nullable_to_non_nullable
              as String?,
      authorDescriptionElement: freezed == authorDescriptionElement
          ? _value.authorDescriptionElement
          : authorDescriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get authorType {
    if (_value.authorType == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.authorType!, (value) {
      return _then(_value.copyWith(authorType: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get authorDescriptionElement {
    if (_value.authorDescriptionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.authorDescriptionElement!, (value) {
      return _then(_value.copyWith(authorDescriptionElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceSourceMaterialAuthorCopyWith<$Res>
    implements $SubstanceSourceMaterialAuthorCopyWith<$Res> {
  factory _$$_SubstanceSourceMaterialAuthorCopyWith(
          _$_SubstanceSourceMaterialAuthor value,
          $Res Function(_$_SubstanceSourceMaterialAuthor) then) =
      __$$_SubstanceSourceMaterialAuthorCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? authorType,
      String? authorDescription,
      @JsonKey(name: '_authorDescription') Element? authorDescriptionElement});

  @override
  $CodeableConceptCopyWith<$Res>? get authorType;
  @override
  $ElementCopyWith<$Res>? get authorDescriptionElement;
}

/// @nodoc
class __$$_SubstanceSourceMaterialAuthorCopyWithImpl<$Res>
    extends _$SubstanceSourceMaterialAuthorCopyWithImpl<$Res,
        _$_SubstanceSourceMaterialAuthor>
    implements _$$_SubstanceSourceMaterialAuthorCopyWith<$Res> {
  __$$_SubstanceSourceMaterialAuthorCopyWithImpl(
      _$_SubstanceSourceMaterialAuthor _value,
      $Res Function(_$_SubstanceSourceMaterialAuthor) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? authorType = freezed,
    Object? authorDescription = freezed,
    Object? authorDescriptionElement = freezed,
  }) {
    return _then(_$_SubstanceSourceMaterialAuthor(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      authorType: freezed == authorType
          ? _value.authorType
          : authorType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      authorDescription: freezed == authorDescription
          ? _value.authorDescription
          : authorDescription // ignore: cast_nullable_to_non_nullable
              as String?,
      authorDescriptionElement: freezed == authorDescriptionElement
          ? _value.authorDescriptionElement
          : authorDescriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceSourceMaterialAuthor extends _SubstanceSourceMaterialAuthor {
  _$_SubstanceSourceMaterialAuthor(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.authorType,
      this.authorDescription,
      @JsonKey(name: '_authorDescription') this.authorDescriptionElement})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstanceSourceMaterialAuthor.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstanceSourceMaterialAuthorFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [authorType] The type of author of an organism species shall be specified. The parenthetical author of an organism species refers to the first author who published the plant/animal name (of any rank). The primary author of an organism species refers to the first author(s), who validly published the plant/animal name.
  @override
  final CodeableConcept? authorType;

  /// [authorDescription] The author of an organism species shall be specified. The author year of an organism shall also be specified when applicable; refers to the year in which the first author(s) published the infraspecific plant/animal name (of any rank).
  @override
  final String? authorDescription;

  /// [authorDescriptionElement] ("_authorDescription") Extensions for authorDescription
  @override
  @JsonKey(name: '_authorDescription')
  final Element? authorDescriptionElement;

  @override
  String toString() {
    return 'SubstanceSourceMaterialAuthor(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, authorType: $authorType, authorDescription: $authorDescription, authorDescriptionElement: $authorDescriptionElement)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceSourceMaterialAuthor &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.authorType, authorType) ||
                other.authorType == authorType) &&
            (identical(other.authorDescription, authorDescription) ||
                other.authorDescription == authorDescription) &&
            (identical(
                    other.authorDescriptionElement, authorDescriptionElement) ||
                other.authorDescriptionElement == authorDescriptionElement));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      authorType,
      authorDescription,
      authorDescriptionElement);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceSourceMaterialAuthorCopyWith<_$_SubstanceSourceMaterialAuthor>
      get copyWith => __$$_SubstanceSourceMaterialAuthorCopyWithImpl<
          _$_SubstanceSourceMaterialAuthor>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceSourceMaterialAuthorToJson(
      this,
    );
  }
}

abstract class _SubstanceSourceMaterialAuthor
    extends SubstanceSourceMaterialAuthor {
  factory _SubstanceSourceMaterialAuthor(
          {final String? id,
          @JsonKey(name: 'extension')
              final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableConcept? authorType,
          final String? authorDescription,
          @JsonKey(name: '_authorDescription')
              final Element? authorDescriptionElement}) =
      _$_SubstanceSourceMaterialAuthor;
  _SubstanceSourceMaterialAuthor._() : super._();

  factory _SubstanceSourceMaterialAuthor.fromJson(Map<String, dynamic> json) =
      _$_SubstanceSourceMaterialAuthor.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [authorType] The type of author of an organism species shall be specified. The parenthetical author of an organism species refers to the first author who published the plant/animal name (of any rank). The primary author of an organism species refers to the first author(s), who validly published the plant/animal name.
  CodeableConcept? get authorType;
  @override

  /// [authorDescription] The author of an organism species shall be specified. The author year of an organism shall also be specified when applicable; refers to the year in which the first author(s) published the infraspecific plant/animal name (of any rank).
  String? get authorDescription;
  @override

  /// [authorDescriptionElement] ("_authorDescription") Extensions for authorDescription
  @JsonKey(name: '_authorDescription')
  Element? get authorDescriptionElement;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceSourceMaterialAuthorCopyWith<_$_SubstanceSourceMaterialAuthor>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceSourceMaterialHybrid _$SubstanceSourceMaterialHybridFromJson(
    Map<String, dynamic> json) {
  return _SubstanceSourceMaterialHybrid.fromJson(json);
}

/// @nodoc
mixin _$SubstanceSourceMaterialHybrid {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [maternalOrganismId] The identifier of the maternal species constituting the hybrid organism shall be specified based on a controlled vocabulary. For plants, the parents arent always known, and it is unlikely that it will be known which is maternal and which is paternal.
  String? get maternalOrganismId => throw _privateConstructorUsedError;

  /// [maternalOrganismIdElement] ("_maternalOrganismId") Extensions for maternalOrganismId
  @JsonKey(name: '_maternalOrganismId')
  Element? get maternalOrganismIdElement => throw _privateConstructorUsedError;

  /// [maternalOrganismName] The name of the maternal species constituting the hybrid organism shall be specified. For plants, the parents arent always known, and it is unlikely that it will be known which is maternal and which is paternal.
  String? get maternalOrganismName => throw _privateConstructorUsedError;

  /// [maternalOrganismNameElement] ("_maternalOrganismName") Extensions for maternalOrganismName
  @JsonKey(name: '_maternalOrganismName')
  Element? get maternalOrganismNameElement =>
      throw _privateConstructorUsedError;

  /// [paternalOrganismId] The identifier of the paternal species constituting the hybrid organism shall be specified based on a controlled vocabulary.
  String? get paternalOrganismId => throw _privateConstructorUsedError;

  /// [paternalOrganismIdElement] ("_paternalOrganismId") Extensions for paternalOrganismId
  @JsonKey(name: '_paternalOrganismId')
  Element? get paternalOrganismIdElement => throw _privateConstructorUsedError;

  /// [paternalOrganismName] The name of the paternal species constituting the hybrid organism shall be specified.
  String? get paternalOrganismName => throw _privateConstructorUsedError;

  /// [paternalOrganismNameElement] ("_paternalOrganismName") Extensions for paternalOrganismName
  @JsonKey(name: '_paternalOrganismName')
  Element? get paternalOrganismNameElement =>
      throw _privateConstructorUsedError;

  /// [hybridType] The hybrid type of an organism shall be specified.
  CodeableConcept? get hybridType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceSourceMaterialHybridCopyWith<SubstanceSourceMaterialHybrid>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceSourceMaterialHybridCopyWith<$Res> {
  factory $SubstanceSourceMaterialHybridCopyWith(
          SubstanceSourceMaterialHybrid value,
          $Res Function(SubstanceSourceMaterialHybrid) then) =
      _$SubstanceSourceMaterialHybridCopyWithImpl<$Res,
          SubstanceSourceMaterialHybrid>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? maternalOrganismId,
      @JsonKey(name: '_maternalOrganismId')
          Element? maternalOrganismIdElement,
      String? maternalOrganismName,
      @JsonKey(name: '_maternalOrganismName')
          Element? maternalOrganismNameElement,
      String? paternalOrganismId,
      @JsonKey(name: '_paternalOrganismId')
          Element? paternalOrganismIdElement,
      String? paternalOrganismName,
      @JsonKey(name: '_paternalOrganismName')
          Element? paternalOrganismNameElement,
      CodeableConcept? hybridType});

  $ElementCopyWith<$Res>? get maternalOrganismIdElement;
  $ElementCopyWith<$Res>? get maternalOrganismNameElement;
  $ElementCopyWith<$Res>? get paternalOrganismIdElement;
  $ElementCopyWith<$Res>? get paternalOrganismNameElement;
  $CodeableConceptCopyWith<$Res>? get hybridType;
}

/// @nodoc
class _$SubstanceSourceMaterialHybridCopyWithImpl<$Res,
        $Val extends SubstanceSourceMaterialHybrid>
    implements $SubstanceSourceMaterialHybridCopyWith<$Res> {
  _$SubstanceSourceMaterialHybridCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? maternalOrganismId = freezed,
    Object? maternalOrganismIdElement = freezed,
    Object? maternalOrganismName = freezed,
    Object? maternalOrganismNameElement = freezed,
    Object? paternalOrganismId = freezed,
    Object? paternalOrganismIdElement = freezed,
    Object? paternalOrganismName = freezed,
    Object? paternalOrganismNameElement = freezed,
    Object? hybridType = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      maternalOrganismId: freezed == maternalOrganismId
          ? _value.maternalOrganismId
          : maternalOrganismId // ignore: cast_nullable_to_non_nullable
              as String?,
      maternalOrganismIdElement: freezed == maternalOrganismIdElement
          ? _value.maternalOrganismIdElement
          : maternalOrganismIdElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      maternalOrganismName: freezed == maternalOrganismName
          ? _value.maternalOrganismName
          : maternalOrganismName // ignore: cast_nullable_to_non_nullable
              as String?,
      maternalOrganismNameElement: freezed == maternalOrganismNameElement
          ? _value.maternalOrganismNameElement
          : maternalOrganismNameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      paternalOrganismId: freezed == paternalOrganismId
          ? _value.paternalOrganismId
          : paternalOrganismId // ignore: cast_nullable_to_non_nullable
              as String?,
      paternalOrganismIdElement: freezed == paternalOrganismIdElement
          ? _value.paternalOrganismIdElement
          : paternalOrganismIdElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      paternalOrganismName: freezed == paternalOrganismName
          ? _value.paternalOrganismName
          : paternalOrganismName // ignore: cast_nullable_to_non_nullable
              as String?,
      paternalOrganismNameElement: freezed == paternalOrganismNameElement
          ? _value.paternalOrganismNameElement
          : paternalOrganismNameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      hybridType: freezed == hybridType
          ? _value.hybridType
          : hybridType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get maternalOrganismIdElement {
    if (_value.maternalOrganismIdElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.maternalOrganismIdElement!, (value) {
      return _then(_value.copyWith(maternalOrganismIdElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get maternalOrganismNameElement {
    if (_value.maternalOrganismNameElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.maternalOrganismNameElement!, (value) {
      return _then(_value.copyWith(maternalOrganismNameElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get paternalOrganismIdElement {
    if (_value.paternalOrganismIdElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.paternalOrganismIdElement!, (value) {
      return _then(_value.copyWith(paternalOrganismIdElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get paternalOrganismNameElement {
    if (_value.paternalOrganismNameElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.paternalOrganismNameElement!, (value) {
      return _then(_value.copyWith(paternalOrganismNameElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get hybridType {
    if (_value.hybridType == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.hybridType!, (value) {
      return _then(_value.copyWith(hybridType: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceSourceMaterialHybridCopyWith<$Res>
    implements $SubstanceSourceMaterialHybridCopyWith<$Res> {
  factory _$$_SubstanceSourceMaterialHybridCopyWith(
          _$_SubstanceSourceMaterialHybrid value,
          $Res Function(_$_SubstanceSourceMaterialHybrid) then) =
      __$$_SubstanceSourceMaterialHybridCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? maternalOrganismId,
      @JsonKey(name: '_maternalOrganismId')
          Element? maternalOrganismIdElement,
      String? maternalOrganismName,
      @JsonKey(name: '_maternalOrganismName')
          Element? maternalOrganismNameElement,
      String? paternalOrganismId,
      @JsonKey(name: '_paternalOrganismId')
          Element? paternalOrganismIdElement,
      String? paternalOrganismName,
      @JsonKey(name: '_paternalOrganismName')
          Element? paternalOrganismNameElement,
      CodeableConcept? hybridType});

  @override
  $ElementCopyWith<$Res>? get maternalOrganismIdElement;
  @override
  $ElementCopyWith<$Res>? get maternalOrganismNameElement;
  @override
  $ElementCopyWith<$Res>? get paternalOrganismIdElement;
  @override
  $ElementCopyWith<$Res>? get paternalOrganismNameElement;
  @override
  $CodeableConceptCopyWith<$Res>? get hybridType;
}

/// @nodoc
class __$$_SubstanceSourceMaterialHybridCopyWithImpl<$Res>
    extends _$SubstanceSourceMaterialHybridCopyWithImpl<$Res,
        _$_SubstanceSourceMaterialHybrid>
    implements _$$_SubstanceSourceMaterialHybridCopyWith<$Res> {
  __$$_SubstanceSourceMaterialHybridCopyWithImpl(
      _$_SubstanceSourceMaterialHybrid _value,
      $Res Function(_$_SubstanceSourceMaterialHybrid) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? maternalOrganismId = freezed,
    Object? maternalOrganismIdElement = freezed,
    Object? maternalOrganismName = freezed,
    Object? maternalOrganismNameElement = freezed,
    Object? paternalOrganismId = freezed,
    Object? paternalOrganismIdElement = freezed,
    Object? paternalOrganismName = freezed,
    Object? paternalOrganismNameElement = freezed,
    Object? hybridType = freezed,
  }) {
    return _then(_$_SubstanceSourceMaterialHybrid(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      maternalOrganismId: freezed == maternalOrganismId
          ? _value.maternalOrganismId
          : maternalOrganismId // ignore: cast_nullable_to_non_nullable
              as String?,
      maternalOrganismIdElement: freezed == maternalOrganismIdElement
          ? _value.maternalOrganismIdElement
          : maternalOrganismIdElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      maternalOrganismName: freezed == maternalOrganismName
          ? _value.maternalOrganismName
          : maternalOrganismName // ignore: cast_nullable_to_non_nullable
              as String?,
      maternalOrganismNameElement: freezed == maternalOrganismNameElement
          ? _value.maternalOrganismNameElement
          : maternalOrganismNameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      paternalOrganismId: freezed == paternalOrganismId
          ? _value.paternalOrganismId
          : paternalOrganismId // ignore: cast_nullable_to_non_nullable
              as String?,
      paternalOrganismIdElement: freezed == paternalOrganismIdElement
          ? _value.paternalOrganismIdElement
          : paternalOrganismIdElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      paternalOrganismName: freezed == paternalOrganismName
          ? _value.paternalOrganismName
          : paternalOrganismName // ignore: cast_nullable_to_non_nullable
              as String?,
      paternalOrganismNameElement: freezed == paternalOrganismNameElement
          ? _value.paternalOrganismNameElement
          : paternalOrganismNameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      hybridType: freezed == hybridType
          ? _value.hybridType
          : hybridType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceSourceMaterialHybrid extends _SubstanceSourceMaterialHybrid {
  _$_SubstanceSourceMaterialHybrid(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.maternalOrganismId,
      @JsonKey(name: '_maternalOrganismId') this.maternalOrganismIdElement,
      this.maternalOrganismName,
      @JsonKey(name: '_maternalOrganismName') this.maternalOrganismNameElement,
      this.paternalOrganismId,
      @JsonKey(name: '_paternalOrganismId') this.paternalOrganismIdElement,
      this.paternalOrganismName,
      @JsonKey(name: '_paternalOrganismName') this.paternalOrganismNameElement,
      this.hybridType})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstanceSourceMaterialHybrid.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstanceSourceMaterialHybridFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [maternalOrganismId] The identifier of the maternal species constituting the hybrid organism shall be specified based on a controlled vocabulary. For plants, the parents arent always known, and it is unlikely that it will be known which is maternal and which is paternal.
  @override
  final String? maternalOrganismId;

  /// [maternalOrganismIdElement] ("_maternalOrganismId") Extensions for maternalOrganismId
  @override
  @JsonKey(name: '_maternalOrganismId')
  final Element? maternalOrganismIdElement;

  /// [maternalOrganismName] The name of the maternal species constituting the hybrid organism shall be specified. For plants, the parents arent always known, and it is unlikely that it will be known which is maternal and which is paternal.
  @override
  final String? maternalOrganismName;

  /// [maternalOrganismNameElement] ("_maternalOrganismName") Extensions for maternalOrganismName
  @override
  @JsonKey(name: '_maternalOrganismName')
  final Element? maternalOrganismNameElement;

  /// [paternalOrganismId] The identifier of the paternal species constituting the hybrid organism shall be specified based on a controlled vocabulary.
  @override
  final String? paternalOrganismId;

  /// [paternalOrganismIdElement] ("_paternalOrganismId") Extensions for paternalOrganismId
  @override
  @JsonKey(name: '_paternalOrganismId')
  final Element? paternalOrganismIdElement;

  /// [paternalOrganismName] The name of the paternal species constituting the hybrid organism shall be specified.
  @override
  final String? paternalOrganismName;

  /// [paternalOrganismNameElement] ("_paternalOrganismName") Extensions for paternalOrganismName
  @override
  @JsonKey(name: '_paternalOrganismName')
  final Element? paternalOrganismNameElement;

  /// [hybridType] The hybrid type of an organism shall be specified.
  @override
  final CodeableConcept? hybridType;

  @override
  String toString() {
    return 'SubstanceSourceMaterialHybrid(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, maternalOrganismId: $maternalOrganismId, maternalOrganismIdElement: $maternalOrganismIdElement, maternalOrganismName: $maternalOrganismName, maternalOrganismNameElement: $maternalOrganismNameElement, paternalOrganismId: $paternalOrganismId, paternalOrganismIdElement: $paternalOrganismIdElement, paternalOrganismName: $paternalOrganismName, paternalOrganismNameElement: $paternalOrganismNameElement, hybridType: $hybridType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceSourceMaterialHybrid &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.maternalOrganismId, maternalOrganismId) ||
                other.maternalOrganismId == maternalOrganismId) &&
            (identical(other.maternalOrganismIdElement,
                    maternalOrganismIdElement) ||
                other.maternalOrganismIdElement == maternalOrganismIdElement) &&
            (identical(other.maternalOrganismName, maternalOrganismName) ||
                other.maternalOrganismName == maternalOrganismName) &&
            (identical(other.maternalOrganismNameElement,
                    maternalOrganismNameElement) ||
                other.maternalOrganismNameElement ==
                    maternalOrganismNameElement) &&
            (identical(other.paternalOrganismId, paternalOrganismId) ||
                other.paternalOrganismId == paternalOrganismId) &&
            (identical(other.paternalOrganismIdElement,
                    paternalOrganismIdElement) ||
                other.paternalOrganismIdElement == paternalOrganismIdElement) &&
            (identical(other.paternalOrganismName, paternalOrganismName) ||
                other.paternalOrganismName == paternalOrganismName) &&
            (identical(other.paternalOrganismNameElement,
                    paternalOrganismNameElement) ||
                other.paternalOrganismNameElement ==
                    paternalOrganismNameElement) &&
            (identical(other.hybridType, hybridType) ||
                other.hybridType == hybridType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      maternalOrganismId,
      maternalOrganismIdElement,
      maternalOrganismName,
      maternalOrganismNameElement,
      paternalOrganismId,
      paternalOrganismIdElement,
      paternalOrganismName,
      paternalOrganismNameElement,
      hybridType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceSourceMaterialHybridCopyWith<_$_SubstanceSourceMaterialHybrid>
      get copyWith => __$$_SubstanceSourceMaterialHybridCopyWithImpl<
          _$_SubstanceSourceMaterialHybrid>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceSourceMaterialHybridToJson(
      this,
    );
  }
}

abstract class _SubstanceSourceMaterialHybrid
    extends SubstanceSourceMaterialHybrid {
  factory _SubstanceSourceMaterialHybrid(
      {final String? id,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final String? maternalOrganismId,
      @JsonKey(name: '_maternalOrganismId')
          final Element? maternalOrganismIdElement,
      final String? maternalOrganismName,
      @JsonKey(name: '_maternalOrganismName')
          final Element? maternalOrganismNameElement,
      final String? paternalOrganismId,
      @JsonKey(name: '_paternalOrganismId')
          final Element? paternalOrganismIdElement,
      final String? paternalOrganismName,
      @JsonKey(name: '_paternalOrganismName')
          final Element? paternalOrganismNameElement,
      final CodeableConcept? hybridType}) = _$_SubstanceSourceMaterialHybrid;
  _SubstanceSourceMaterialHybrid._() : super._();

  factory _SubstanceSourceMaterialHybrid.fromJson(Map<String, dynamic> json) =
      _$_SubstanceSourceMaterialHybrid.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [maternalOrganismId] The identifier of the maternal species constituting the hybrid organism shall be specified based on a controlled vocabulary. For plants, the parents arent always known, and it is unlikely that it will be known which is maternal and which is paternal.
  String? get maternalOrganismId;
  @override

  /// [maternalOrganismIdElement] ("_maternalOrganismId") Extensions for maternalOrganismId
  @JsonKey(name: '_maternalOrganismId')
  Element? get maternalOrganismIdElement;
  @override

  /// [maternalOrganismName] The name of the maternal species constituting the hybrid organism shall be specified. For plants, the parents arent always known, and it is unlikely that it will be known which is maternal and which is paternal.
  String? get maternalOrganismName;
  @override

  /// [maternalOrganismNameElement] ("_maternalOrganismName") Extensions for maternalOrganismName
  @JsonKey(name: '_maternalOrganismName')
  Element? get maternalOrganismNameElement;
  @override

  /// [paternalOrganismId] The identifier of the paternal species constituting the hybrid organism shall be specified based on a controlled vocabulary.
  String? get paternalOrganismId;
  @override

  /// [paternalOrganismIdElement] ("_paternalOrganismId") Extensions for paternalOrganismId
  @JsonKey(name: '_paternalOrganismId')
  Element? get paternalOrganismIdElement;
  @override

  /// [paternalOrganismName] The name of the paternal species constituting the hybrid organism shall be specified.
  String? get paternalOrganismName;
  @override

  /// [paternalOrganismNameElement] ("_paternalOrganismName") Extensions for paternalOrganismName
  @JsonKey(name: '_paternalOrganismName')
  Element? get paternalOrganismNameElement;
  @override

  /// [hybridType] The hybrid type of an organism shall be specified.
  CodeableConcept? get hybridType;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceSourceMaterialHybridCopyWith<_$_SubstanceSourceMaterialHybrid>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceSourceMaterialOrganismGeneral
    _$SubstanceSourceMaterialOrganismGeneralFromJson(
        Map<String, dynamic> json) {
  return _SubstanceSourceMaterialOrganismGeneral.fromJson(json);
}

/// @nodoc
mixin _$SubstanceSourceMaterialOrganismGeneral {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [kingdom] The kingdom of an organism shall be specified.
  CodeableConcept? get kingdom => throw _privateConstructorUsedError;

  /// [phylum] The phylum of an organism shall be specified.
  CodeableConcept? get phylum => throw _privateConstructorUsedError;

  /// [class_] ("class") The class of an organism shall be specified.
  @JsonKey(name: 'class')
  CodeableConcept? get class_ => throw _privateConstructorUsedError;

  /// [order] The order of an organism shall be specified,.
  CodeableConcept? get order => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceSourceMaterialOrganismGeneralCopyWith<
          SubstanceSourceMaterialOrganismGeneral>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceSourceMaterialOrganismGeneralCopyWith<$Res> {
  factory $SubstanceSourceMaterialOrganismGeneralCopyWith(
          SubstanceSourceMaterialOrganismGeneral value,
          $Res Function(SubstanceSourceMaterialOrganismGeneral) then) =
      _$SubstanceSourceMaterialOrganismGeneralCopyWithImpl<$Res,
          SubstanceSourceMaterialOrganismGeneral>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? kingdom,
      CodeableConcept? phylum,
      @JsonKey(name: 'class') CodeableConcept? class_,
      CodeableConcept? order});

  $CodeableConceptCopyWith<$Res>? get kingdom;
  $CodeableConceptCopyWith<$Res>? get phylum;
  $CodeableConceptCopyWith<$Res>? get class_;
  $CodeableConceptCopyWith<$Res>? get order;
}

/// @nodoc
class _$SubstanceSourceMaterialOrganismGeneralCopyWithImpl<$Res,
        $Val extends SubstanceSourceMaterialOrganismGeneral>
    implements $SubstanceSourceMaterialOrganismGeneralCopyWith<$Res> {
  _$SubstanceSourceMaterialOrganismGeneralCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? kingdom = freezed,
    Object? phylum = freezed,
    Object? class_ = freezed,
    Object? order = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      kingdom: freezed == kingdom
          ? _value.kingdom
          : kingdom // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      phylum: freezed == phylum
          ? _value.phylum
          : phylum // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      class_: freezed == class_
          ? _value.class_
          : class_ // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      order: freezed == order
          ? _value.order
          : order // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get kingdom {
    if (_value.kingdom == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.kingdom!, (value) {
      return _then(_value.copyWith(kingdom: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get phylum {
    if (_value.phylum == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.phylum!, (value) {
      return _then(_value.copyWith(phylum: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get class_ {
    if (_value.class_ == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.class_!, (value) {
      return _then(_value.copyWith(class_: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get order {
    if (_value.order == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.order!, (value) {
      return _then(_value.copyWith(order: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceSourceMaterialOrganismGeneralCopyWith<$Res>
    implements $SubstanceSourceMaterialOrganismGeneralCopyWith<$Res> {
  factory _$$_SubstanceSourceMaterialOrganismGeneralCopyWith(
          _$_SubstanceSourceMaterialOrganismGeneral value,
          $Res Function(_$_SubstanceSourceMaterialOrganismGeneral) then) =
      __$$_SubstanceSourceMaterialOrganismGeneralCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? kingdom,
      CodeableConcept? phylum,
      @JsonKey(name: 'class') CodeableConcept? class_,
      CodeableConcept? order});

  @override
  $CodeableConceptCopyWith<$Res>? get kingdom;
  @override
  $CodeableConceptCopyWith<$Res>? get phylum;
  @override
  $CodeableConceptCopyWith<$Res>? get class_;
  @override
  $CodeableConceptCopyWith<$Res>? get order;
}

/// @nodoc
class __$$_SubstanceSourceMaterialOrganismGeneralCopyWithImpl<$Res>
    extends _$SubstanceSourceMaterialOrganismGeneralCopyWithImpl<$Res,
        _$_SubstanceSourceMaterialOrganismGeneral>
    implements _$$_SubstanceSourceMaterialOrganismGeneralCopyWith<$Res> {
  __$$_SubstanceSourceMaterialOrganismGeneralCopyWithImpl(
      _$_SubstanceSourceMaterialOrganismGeneral _value,
      $Res Function(_$_SubstanceSourceMaterialOrganismGeneral) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? kingdom = freezed,
    Object? phylum = freezed,
    Object? class_ = freezed,
    Object? order = freezed,
  }) {
    return _then(_$_SubstanceSourceMaterialOrganismGeneral(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      kingdom: freezed == kingdom
          ? _value.kingdom
          : kingdom // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      phylum: freezed == phylum
          ? _value.phylum
          : phylum // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      class_: freezed == class_
          ? _value.class_
          : class_ // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      order: freezed == order
          ? _value.order
          : order // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceSourceMaterialOrganismGeneral
    extends _SubstanceSourceMaterialOrganismGeneral {
  _$_SubstanceSourceMaterialOrganismGeneral(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.kingdom,
      this.phylum,
      @JsonKey(name: 'class') this.class_,
      this.order})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstanceSourceMaterialOrganismGeneral.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstanceSourceMaterialOrganismGeneralFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [kingdom] The kingdom of an organism shall be specified.
  @override
  final CodeableConcept? kingdom;

  /// [phylum] The phylum of an organism shall be specified.
  @override
  final CodeableConcept? phylum;

  /// [class_] ("class") The class of an organism shall be specified.
  @override
  @JsonKey(name: 'class')
  final CodeableConcept? class_;

  /// [order] The order of an organism shall be specified,.
  @override
  final CodeableConcept? order;

  @override
  String toString() {
    return 'SubstanceSourceMaterialOrganismGeneral(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, kingdom: $kingdom, phylum: $phylum, class_: $class_, order: $order)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceSourceMaterialOrganismGeneral &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.kingdom, kingdom) || other.kingdom == kingdom) &&
            (identical(other.phylum, phylum) || other.phylum == phylum) &&
            (identical(other.class_, class_) || other.class_ == class_) &&
            (identical(other.order, order) || other.order == order));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      kingdom,
      phylum,
      class_,
      order);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceSourceMaterialOrganismGeneralCopyWith<
          _$_SubstanceSourceMaterialOrganismGeneral>
      get copyWith => __$$_SubstanceSourceMaterialOrganismGeneralCopyWithImpl<
          _$_SubstanceSourceMaterialOrganismGeneral>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceSourceMaterialOrganismGeneralToJson(
      this,
    );
  }
}

abstract class _SubstanceSourceMaterialOrganismGeneral
    extends SubstanceSourceMaterialOrganismGeneral {
  factory _SubstanceSourceMaterialOrganismGeneral(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableConcept? kingdom,
          final CodeableConcept? phylum,
          @JsonKey(name: 'class') final CodeableConcept? class_,
          final CodeableConcept? order}) =
      _$_SubstanceSourceMaterialOrganismGeneral;
  _SubstanceSourceMaterialOrganismGeneral._() : super._();

  factory _SubstanceSourceMaterialOrganismGeneral.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceSourceMaterialOrganismGeneral.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [kingdom] The kingdom of an organism shall be specified.
  CodeableConcept? get kingdom;
  @override

  /// [phylum] The phylum of an organism shall be specified.
  CodeableConcept? get phylum;
  @override

  /// [class_] ("class") The class of an organism shall be specified.
  @JsonKey(name: 'class')
  CodeableConcept? get class_;
  @override

  /// [order] The order of an organism shall be specified,.
  CodeableConcept? get order;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceSourceMaterialOrganismGeneralCopyWith<
          _$_SubstanceSourceMaterialOrganismGeneral>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceSourceMaterialPartDescription
    _$SubstanceSourceMaterialPartDescriptionFromJson(
        Map<String, dynamic> json) {
  return _SubstanceSourceMaterialPartDescription.fromJson(json);
}

/// @nodoc
mixin _$SubstanceSourceMaterialPartDescription {
  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [part_] ("part") Entity of anatomical origin of source material within an organism.
  @JsonKey(name: 'part')
  CodeableConcept? get part_ => throw _privateConstructorUsedError;

  /// [partLocation] The detailed anatomic location when the part can be extracted from different anatomical locations of the organism. Multiple alternative locations may apply.
  CodeableConcept? get partLocation => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceSourceMaterialPartDescriptionCopyWith<
          SubstanceSourceMaterialPartDescription>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceSourceMaterialPartDescriptionCopyWith<$Res> {
  factory $SubstanceSourceMaterialPartDescriptionCopyWith(
          SubstanceSourceMaterialPartDescription value,
          $Res Function(SubstanceSourceMaterialPartDescription) then) =
      _$SubstanceSourceMaterialPartDescriptionCopyWithImpl<$Res,
          SubstanceSourceMaterialPartDescription>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      @JsonKey(name: 'part') CodeableConcept? part_,
      CodeableConcept? partLocation});

  $CodeableConceptCopyWith<$Res>? get part_;
  $CodeableConceptCopyWith<$Res>? get partLocation;
}

/// @nodoc
class _$SubstanceSourceMaterialPartDescriptionCopyWithImpl<$Res,
        $Val extends SubstanceSourceMaterialPartDescription>
    implements $SubstanceSourceMaterialPartDescriptionCopyWith<$Res> {
  _$SubstanceSourceMaterialPartDescriptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? part_ = freezed,
    Object? partLocation = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      part_: freezed == part_
          ? _value.part_
          : part_ // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      partLocation: freezed == partLocation
          ? _value.partLocation
          : partLocation // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get part_ {
    if (_value.part_ == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.part_!, (value) {
      return _then(_value.copyWith(part_: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get partLocation {
    if (_value.partLocation == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.partLocation!, (value) {
      return _then(_value.copyWith(partLocation: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceSourceMaterialPartDescriptionCopyWith<$Res>
    implements $SubstanceSourceMaterialPartDescriptionCopyWith<$Res> {
  factory _$$_SubstanceSourceMaterialPartDescriptionCopyWith(
          _$_SubstanceSourceMaterialPartDescription value,
          $Res Function(_$_SubstanceSourceMaterialPartDescription) then) =
      __$$_SubstanceSourceMaterialPartDescriptionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      @JsonKey(name: 'part') CodeableConcept? part_,
      CodeableConcept? partLocation});

  @override
  $CodeableConceptCopyWith<$Res>? get part_;
  @override
  $CodeableConceptCopyWith<$Res>? get partLocation;
}

/// @nodoc
class __$$_SubstanceSourceMaterialPartDescriptionCopyWithImpl<$Res>
    extends _$SubstanceSourceMaterialPartDescriptionCopyWithImpl<$Res,
        _$_SubstanceSourceMaterialPartDescription>
    implements _$$_SubstanceSourceMaterialPartDescriptionCopyWith<$Res> {
  __$$_SubstanceSourceMaterialPartDescriptionCopyWithImpl(
      _$_SubstanceSourceMaterialPartDescription _value,
      $Res Function(_$_SubstanceSourceMaterialPartDescription) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? part_ = freezed,
    Object? partLocation = freezed,
  }) {
    return _then(_$_SubstanceSourceMaterialPartDescription(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      part_: freezed == part_
          ? _value.part_
          : part_ // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      partLocation: freezed == partLocation
          ? _value.partLocation
          : partLocation // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceSourceMaterialPartDescription
    extends _SubstanceSourceMaterialPartDescription {
  _$_SubstanceSourceMaterialPartDescription(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      @JsonKey(name: 'part') this.part_,
      this.partLocation})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstanceSourceMaterialPartDescription.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstanceSourceMaterialPartDescriptionFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [part_] ("part") Entity of anatomical origin of source material within an organism.
  @override
  @JsonKey(name: 'part')
  final CodeableConcept? part_;

  /// [partLocation] The detailed anatomic location when the part can be extracted from different anatomical locations of the organism. Multiple alternative locations may apply.
  @override
  final CodeableConcept? partLocation;

  @override
  String toString() {
    return 'SubstanceSourceMaterialPartDescription(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, part_: $part_, partLocation: $partLocation)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceSourceMaterialPartDescription &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.part_, part_) || other.part_ == part_) &&
            (identical(other.partLocation, partLocation) ||
                other.partLocation == partLocation));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      part_,
      partLocation);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceSourceMaterialPartDescriptionCopyWith<
          _$_SubstanceSourceMaterialPartDescription>
      get copyWith => __$$_SubstanceSourceMaterialPartDescriptionCopyWithImpl<
          _$_SubstanceSourceMaterialPartDescription>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceSourceMaterialPartDescriptionToJson(
      this,
    );
  }
}

abstract class _SubstanceSourceMaterialPartDescription
    extends SubstanceSourceMaterialPartDescription {
  factory _SubstanceSourceMaterialPartDescription(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          @JsonKey(name: 'part') final CodeableConcept? part_,
          final CodeableConcept? partLocation}) =
      _$_SubstanceSourceMaterialPartDescription;
  _SubstanceSourceMaterialPartDescription._() : super._();

  factory _SubstanceSourceMaterialPartDescription.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceSourceMaterialPartDescription.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  /// references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  /// information that is not part of the basic definition of the element.
  /// To make the use of extensions safe and manageable, there is a strict set
  /// of governance  applied to the definition and use of extensions. Though
  /// any implementer can define an extension, there is a set of requirements
  /// that SHALL be met as part of the definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies
  /// the understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of
  /// the definition of the extension. Applications processing a resource are
  /// required to check for modifier extensions.Modifier extensions SHALL NOT
  /// change the meaning of any elements on Resource or DomainResource
  /// (including cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [part_] ("part") Entity of anatomical origin of source material within an organism.
  @JsonKey(name: 'part')
  CodeableConcept? get part_;
  @override

  /// [partLocation] The detailed anatomic location when the part can be extracted from different anatomical locations of the organism. Multiple alternative locations may apply.
  CodeableConcept? get partLocation;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceSourceMaterialPartDescriptionCopyWith<
          _$_SubstanceSourceMaterialPartDescription>
      get copyWith => throw _privateConstructorUsedError;
}
