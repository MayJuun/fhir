// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'medication_definition.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

AdministrableProductDefinition _$AdministrableProductDefinitionFromJson(
    Map<String, dynamic> json) {
  return _AdministrableProductDefinition.fromJson(json);
}

/// @nodoc
mixin _$AdministrableProductDefinition {
  R4ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.",
  String? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.;
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] (_language): Extensions for language;
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] The identifier(s) of this Ingredient that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate.;
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [status] The status of this ingredient. Enables tracking the life-cycle of the content.;
  Code? get status => throw _privateConstructorUsedError;

  /// [statusElement] (_status): Extensions for status;
  @JsonKey(name: '_status')
  Element? get statusElement => throw _privateConstructorUsedError;
  List<Reference>? get formOf => throw _privateConstructorUsedError;
  CodeableConcept? get administrableDoseForm =>
      throw _privateConstructorUsedError;
  CodeableConcept? get unitOfPresentation => throw _privateConstructorUsedError;
  List<Reference>? get producedFrom => throw _privateConstructorUsedError;
  List<CodeableConcept>? get ingredient => throw _privateConstructorUsedError;
  Reference? get device => throw _privateConstructorUsedError;
  List<AdministrableProductDefinitionProperty>? get property =>
      throw _privateConstructorUsedError;
  List<AdministrableProductDefinitionRouteOfAdministration>
      get routeOfAdministration => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AdministrableProductDefinitionCopyWith<AdministrableProductDefinition>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AdministrableProductDefinitionCopyWith<$Res> {
  factory $AdministrableProductDefinitionCopyWith(
          AdministrableProductDefinition value,
          $Res Function(AdministrableProductDefinition) then) =
      _$AdministrableProductDefinitionCopyWithImpl<$Res,
          AdministrableProductDefinition>;
  @useResult
  $Res call(
      {R4ResourceType resourceType,
      String? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      Code? status,
      @JsonKey(name: '_status') Element? statusElement,
      List<Reference>? formOf,
      CodeableConcept? administrableDoseForm,
      CodeableConcept? unitOfPresentation,
      List<Reference>? producedFrom,
      List<CodeableConcept>? ingredient,
      Reference? device,
      List<AdministrableProductDefinitionProperty>? property,
      List<AdministrableProductDefinitionRouteOfAdministration>
          routeOfAdministration});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $ElementCopyWith<$Res>? get statusElement;
  $CodeableConceptCopyWith<$Res>? get administrableDoseForm;
  $CodeableConceptCopyWith<$Res>? get unitOfPresentation;
  $ReferenceCopyWith<$Res>? get device;
}

/// @nodoc
class _$AdministrableProductDefinitionCopyWithImpl<$Res,
        $Val extends AdministrableProductDefinition>
    implements $AdministrableProductDefinitionCopyWith<$Res> {
  _$AdministrableProductDefinitionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? formOf = freezed,
    Object? administrableDoseForm = freezed,
    Object? unitOfPresentation = freezed,
    Object? producedFrom = freezed,
    Object? ingredient = freezed,
    Object? device = freezed,
    Object? property = freezed,
    Object? routeOfAdministration = null,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R4ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as Code?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      formOf: freezed == formOf
          ? _value.formOf
          : formOf // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      administrableDoseForm: freezed == administrableDoseForm
          ? _value.administrableDoseForm
          : administrableDoseForm // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      unitOfPresentation: freezed == unitOfPresentation
          ? _value.unitOfPresentation
          : unitOfPresentation // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      producedFrom: freezed == producedFrom
          ? _value.producedFrom
          : producedFrom // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      ingredient: freezed == ingredient
          ? _value.ingredient
          : ingredient // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      device: freezed == device
          ? _value.device
          : device // ignore: cast_nullable_to_non_nullable
              as Reference?,
      property: freezed == property
          ? _value.property
          : property // ignore: cast_nullable_to_non_nullable
              as List<AdministrableProductDefinitionProperty>?,
      routeOfAdministration: null == routeOfAdministration
          ? _value.routeOfAdministration
          : routeOfAdministration // ignore: cast_nullable_to_non_nullable
              as List<AdministrableProductDefinitionRouteOfAdministration>,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusElement {
    if (_value.statusElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusElement!, (value) {
      return _then(_value.copyWith(statusElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get administrableDoseForm {
    if (_value.administrableDoseForm == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.administrableDoseForm!,
        (value) {
      return _then(_value.copyWith(administrableDoseForm: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get unitOfPresentation {
    if (_value.unitOfPresentation == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.unitOfPresentation!, (value) {
      return _then(_value.copyWith(unitOfPresentation: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get device {
    if (_value.device == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.device!, (value) {
      return _then(_value.copyWith(device: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AdministrableProductDefinitionCopyWith<$Res>
    implements $AdministrableProductDefinitionCopyWith<$Res> {
  factory _$$_AdministrableProductDefinitionCopyWith(
          _$_AdministrableProductDefinition value,
          $Res Function(_$_AdministrableProductDefinition) then) =
      __$$_AdministrableProductDefinitionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {R4ResourceType resourceType,
      String? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      Code? status,
      @JsonKey(name: '_status') Element? statusElement,
      List<Reference>? formOf,
      CodeableConcept? administrableDoseForm,
      CodeableConcept? unitOfPresentation,
      List<Reference>? producedFrom,
      List<CodeableConcept>? ingredient,
      Reference? device,
      List<AdministrableProductDefinitionProperty>? property,
      List<AdministrableProductDefinitionRouteOfAdministration>
          routeOfAdministration});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $ElementCopyWith<$Res>? get statusElement;
  @override
  $CodeableConceptCopyWith<$Res>? get administrableDoseForm;
  @override
  $CodeableConceptCopyWith<$Res>? get unitOfPresentation;
  @override
  $ReferenceCopyWith<$Res>? get device;
}

/// @nodoc
class __$$_AdministrableProductDefinitionCopyWithImpl<$Res>
    extends _$AdministrableProductDefinitionCopyWithImpl<$Res,
        _$_AdministrableProductDefinition>
    implements _$$_AdministrableProductDefinitionCopyWith<$Res> {
  __$$_AdministrableProductDefinitionCopyWithImpl(
      _$_AdministrableProductDefinition _value,
      $Res Function(_$_AdministrableProductDefinition) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? formOf = freezed,
    Object? administrableDoseForm = freezed,
    Object? unitOfPresentation = freezed,
    Object? producedFrom = freezed,
    Object? ingredient = freezed,
    Object? device = freezed,
    Object? property = freezed,
    Object? routeOfAdministration = null,
  }) {
    return _then(_$_AdministrableProductDefinition(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R4ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as Code?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      formOf: freezed == formOf
          ? _value._formOf
          : formOf // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      administrableDoseForm: freezed == administrableDoseForm
          ? _value.administrableDoseForm
          : administrableDoseForm // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      unitOfPresentation: freezed == unitOfPresentation
          ? _value.unitOfPresentation
          : unitOfPresentation // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      producedFrom: freezed == producedFrom
          ? _value._producedFrom
          : producedFrom // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      ingredient: freezed == ingredient
          ? _value._ingredient
          : ingredient // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      device: freezed == device
          ? _value.device
          : device // ignore: cast_nullable_to_non_nullable
              as Reference?,
      property: freezed == property
          ? _value._property
          : property // ignore: cast_nullable_to_non_nullable
              as List<AdministrableProductDefinitionProperty>?,
      routeOfAdministration: null == routeOfAdministration
          ? _value._routeOfAdministration
          : routeOfAdministration // ignore: cast_nullable_to_non_nullable
              as List<AdministrableProductDefinitionRouteOfAdministration>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AdministrableProductDefinition
    extends _AdministrableProductDefinition {
  _$_AdministrableProductDefinition(
      {this.resourceType = R4ResourceType.AdministrableProductDefinition,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules') this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language') this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      this.status,
      @JsonKey(name: '_status') this.statusElement,
      final List<Reference>? formOf,
      this.administrableDoseForm,
      this.unitOfPresentation,
      final List<Reference>? producedFrom,
      final List<CodeableConcept>? ingredient,
      this.device,
      final List<AdministrableProductDefinitionProperty>? property,
      required final List<AdministrableProductDefinitionRouteOfAdministration>
          routeOfAdministration})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _formOf = formOf,
        _producedFrom = producedFrom,
        _ingredient = ingredient,
        _property = property,
        _routeOfAdministration = routeOfAdministration,
        super._();

  factory _$_AdministrableProductDefinition.fromJson(
          Map<String, dynamic> json) =>
      _$$_AdministrableProductDefinitionFromJson(json);

  @override
  @JsonKey()
  final R4ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.",
  @override
  final String? id;

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.;
  @override
  final Code? language;

  /// [languageElement] (_language): Extensions for language;
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] The identifier(s) of this Ingredient that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate.;
  final List<Identifier>? _identifier;

  /// [identifier] The identifier(s) of this Ingredient that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate.;
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [status] The status of this ingredient. Enables tracking the life-cycle of the content.;
  @override
  final Code? status;

  /// [statusElement] (_status): Extensions for status;
  @override
  @JsonKey(name: '_status')
  final Element? statusElement;
  final List<Reference>? _formOf;
  @override
  List<Reference>? get formOf {
    final value = _formOf;
    if (value == null) return null;
    if (_formOf is EqualUnmodifiableListView) return _formOf;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final CodeableConcept? administrableDoseForm;
  @override
  final CodeableConcept? unitOfPresentation;
  final List<Reference>? _producedFrom;
  @override
  List<Reference>? get producedFrom {
    final value = _producedFrom;
    if (value == null) return null;
    if (_producedFrom is EqualUnmodifiableListView) return _producedFrom;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<CodeableConcept>? _ingredient;
  @override
  List<CodeableConcept>? get ingredient {
    final value = _ingredient;
    if (value == null) return null;
    if (_ingredient is EqualUnmodifiableListView) return _ingredient;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final Reference? device;
  final List<AdministrableProductDefinitionProperty>? _property;
  @override
  List<AdministrableProductDefinitionProperty>? get property {
    final value = _property;
    if (value == null) return null;
    if (_property is EqualUnmodifiableListView) return _property;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<AdministrableProductDefinitionRouteOfAdministration>
      _routeOfAdministration;
  @override
  List<AdministrableProductDefinitionRouteOfAdministration>
      get routeOfAdministration {
    if (_routeOfAdministration is EqualUnmodifiableListView)
      return _routeOfAdministration;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_routeOfAdministration);
  }

  @override
  String toString() {
    return 'AdministrableProductDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, status: $status, statusElement: $statusElement, formOf: $formOf, administrableDoseForm: $administrableDoseForm, unitOfPresentation: $unitOfPresentation, producedFrom: $producedFrom, ingredient: $ingredient, device: $device, property: $property, routeOfAdministration: $routeOfAdministration)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AdministrableProductDefinition &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusElement, statusElement) ||
                other.statusElement == statusElement) &&
            const DeepCollectionEquality().equals(other._formOf, _formOf) &&
            (identical(other.administrableDoseForm, administrableDoseForm) ||
                other.administrableDoseForm == administrableDoseForm) &&
            (identical(other.unitOfPresentation, unitOfPresentation) ||
                other.unitOfPresentation == unitOfPresentation) &&
            const DeepCollectionEquality()
                .equals(other._producedFrom, _producedFrom) &&
            const DeepCollectionEquality()
                .equals(other._ingredient, _ingredient) &&
            (identical(other.device, device) || other.device == device) &&
            const DeepCollectionEquality().equals(other._property, _property) &&
            const DeepCollectionEquality()
                .equals(other._routeOfAdministration, _routeOfAdministration));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_identifier),
        status,
        statusElement,
        const DeepCollectionEquality().hash(_formOf),
        administrableDoseForm,
        unitOfPresentation,
        const DeepCollectionEquality().hash(_producedFrom),
        const DeepCollectionEquality().hash(_ingredient),
        device,
        const DeepCollectionEquality().hash(_property),
        const DeepCollectionEquality().hash(_routeOfAdministration)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AdministrableProductDefinitionCopyWith<_$_AdministrableProductDefinition>
      get copyWith => __$$_AdministrableProductDefinitionCopyWithImpl<
          _$_AdministrableProductDefinition>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AdministrableProductDefinitionToJson(
      this,
    );
  }
}

abstract class _AdministrableProductDefinition
    extends AdministrableProductDefinition {
  factory _AdministrableProductDefinition(
      {final R4ResourceType resourceType,
      final String? id,
      final Meta? meta,
      final FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') final Element? implicitRulesElement,
      final Code? language,
      @JsonKey(name: '_language') final Element? languageElement,
      final Narrative? text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      final Code? status,
      @JsonKey(name: '_status') final Element? statusElement,
      final List<Reference>? formOf,
      final CodeableConcept? administrableDoseForm,
      final CodeableConcept? unitOfPresentation,
      final List<Reference>? producedFrom,
      final List<CodeableConcept>? ingredient,
      final Reference? device,
      final List<AdministrableProductDefinitionProperty>? property,
      required final List<AdministrableProductDefinitionRouteOfAdministration>
          routeOfAdministration}) = _$_AdministrableProductDefinition;
  _AdministrableProductDefinition._() : super._();

  factory _AdministrableProductDefinition.fromJson(Map<String, dynamic> json) =
      _$_AdministrableProductDefinition.fromJson;

  @override
  R4ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.",
  String? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.;
  Code? get language;
  @override

  /// [languageElement] (_language): Extensions for language;
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  List<Resource>? get contained;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] The identifier(s) of this Ingredient that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate.;
  List<Identifier>? get identifier;
  @override

  /// [status] The status of this ingredient. Enables tracking the life-cycle of the content.;
  Code? get status;
  @override

  /// [statusElement] (_status): Extensions for status;
  @JsonKey(name: '_status')
  Element? get statusElement;
  @override
  List<Reference>? get formOf;
  @override
  CodeableConcept? get administrableDoseForm;
  @override
  CodeableConcept? get unitOfPresentation;
  @override
  List<Reference>? get producedFrom;
  @override
  List<CodeableConcept>? get ingredient;
  @override
  Reference? get device;
  @override
  List<AdministrableProductDefinitionProperty>? get property;
  @override
  List<AdministrableProductDefinitionRouteOfAdministration>
      get routeOfAdministration;
  @override
  @JsonKey(ignore: true)
  _$$_AdministrableProductDefinitionCopyWith<_$_AdministrableProductDefinition>
      get copyWith => throw _privateConstructorUsedError;
}

AdministrableProductDefinitionProperty
    _$AdministrableProductDefinitionPropertyFromJson(
        Map<String, dynamic> json) {
  return _AdministrableProductDefinitionProperty.fromJson(json);
}

/// @nodoc
mixin _$AdministrableProductDefinitionProperty {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] A code expressing the type of characteristic.;
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [valueCodeableConcept] A value for the characteristic.;
  CodeableConcept? get valueCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [valueQuantity] A value for the characteristic.;
  Quantity? get valueQuantity => throw _privateConstructorUsedError;

  /// [valueDate] A value for the characteristic.;
  Date? get valueDate => throw _privateConstructorUsedError;

  /// [valueDateElement] (_valueDate): Extensions for valueDate;
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement => throw _privateConstructorUsedError;

  /// [valueBoolean] A value for the characteristic.;
  Boolean? get valueBoolean => throw _privateConstructorUsedError;

  /// [valueBooleanElement] (_valueBoolean): Extensions for valueBoolean;
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement => throw _privateConstructorUsedError;

  /// [valueAttachment] A value for the characteristic.;
  Attachment? get valueAttachment => throw _privateConstructorUsedError;

  /// [status] The status of characteristic e.g. assigned or pending.;
  CodeableConcept? get status => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AdministrableProductDefinitionPropertyCopyWith<
          AdministrableProductDefinitionProperty>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AdministrableProductDefinitionPropertyCopyWith<$Res> {
  factory $AdministrableProductDefinitionPropertyCopyWith(
          AdministrableProductDefinitionProperty value,
          $Res Function(AdministrableProductDefinitionProperty) then) =
      _$AdministrableProductDefinitionPropertyCopyWithImpl<$Res,
          AdministrableProductDefinitionProperty>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      Quantity? valueQuantity,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment,
      CodeableConcept? status});

  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  $QuantityCopyWith<$Res>? get valueQuantity;
  $ElementCopyWith<$Res>? get valueDateElement;
  $ElementCopyWith<$Res>? get valueBooleanElement;
  $AttachmentCopyWith<$Res>? get valueAttachment;
  $CodeableConceptCopyWith<$Res>? get status;
}

/// @nodoc
class _$AdministrableProductDefinitionPropertyCopyWithImpl<$Res,
        $Val extends AdministrableProductDefinitionProperty>
    implements $AdministrableProductDefinitionPropertyCopyWith<$Res> {
  _$AdministrableProductDefinitionPropertyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueQuantity = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
    Object? status = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept {
    if (_value.valueCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.valueCodeableConcept!,
        (value) {
      return _then(_value.copyWith(valueCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get valueQuantity {
    if (_value.valueQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.valueQuantity!, (value) {
      return _then(_value.copyWith(valueQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueDateElement {
    if (_value.valueDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueDateElement!, (value) {
      return _then(_value.copyWith(valueDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueBooleanElement {
    if (_value.valueBooleanElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueBooleanElement!, (value) {
      return _then(_value.copyWith(valueBooleanElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get valueAttachment {
    if (_value.valueAttachment == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.valueAttachment!, (value) {
      return _then(_value.copyWith(valueAttachment: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AdministrableProductDefinitionPropertyCopyWith<$Res>
    implements $AdministrableProductDefinitionPropertyCopyWith<$Res> {
  factory _$$_AdministrableProductDefinitionPropertyCopyWith(
          _$_AdministrableProductDefinitionProperty value,
          $Res Function(_$_AdministrableProductDefinitionProperty) then) =
      __$$_AdministrableProductDefinitionPropertyCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      Quantity? valueQuantity,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment,
      CodeableConcept? status});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  @override
  $QuantityCopyWith<$Res>? get valueQuantity;
  @override
  $ElementCopyWith<$Res>? get valueDateElement;
  @override
  $ElementCopyWith<$Res>? get valueBooleanElement;
  @override
  $AttachmentCopyWith<$Res>? get valueAttachment;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
}

/// @nodoc
class __$$_AdministrableProductDefinitionPropertyCopyWithImpl<$Res>
    extends _$AdministrableProductDefinitionPropertyCopyWithImpl<$Res,
        _$_AdministrableProductDefinitionProperty>
    implements _$$_AdministrableProductDefinitionPropertyCopyWith<$Res> {
  __$$_AdministrableProductDefinitionPropertyCopyWithImpl(
      _$_AdministrableProductDefinitionProperty _value,
      $Res Function(_$_AdministrableProductDefinitionProperty) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueQuantity = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
    Object? status = freezed,
  }) {
    return _then(_$_AdministrableProductDefinitionProperty(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AdministrableProductDefinitionProperty
    extends _AdministrableProductDefinitionProperty {
  _$_AdministrableProductDefinitionProperty(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.type,
      this.valueCodeableConcept,
      this.valueQuantity,
      this.valueDate,
      @JsonKey(name: '_valueDate') this.valueDateElement,
      this.valueBoolean,
      @JsonKey(name: '_valueBoolean') this.valueBooleanElement,
      this.valueAttachment,
      this.status})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_AdministrableProductDefinitionProperty.fromJson(
          Map<String, dynamic> json) =>
      _$$_AdministrableProductDefinitionPropertyFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] A code expressing the type of characteristic.;
  @override
  final CodeableConcept type;

  /// [valueCodeableConcept] A value for the characteristic.;
  @override
  final CodeableConcept? valueCodeableConcept;

  /// [valueQuantity] A value for the characteristic.;
  @override
  final Quantity? valueQuantity;

  /// [valueDate] A value for the characteristic.;
  @override
  final Date? valueDate;

  /// [valueDateElement] (_valueDate): Extensions for valueDate;
  @override
  @JsonKey(name: '_valueDate')
  final Element? valueDateElement;

  /// [valueBoolean] A value for the characteristic.;
  @override
  final Boolean? valueBoolean;

  /// [valueBooleanElement] (_valueBoolean): Extensions for valueBoolean;
  @override
  @JsonKey(name: '_valueBoolean')
  final Element? valueBooleanElement;

  /// [valueAttachment] A value for the characteristic.;
  @override
  final Attachment? valueAttachment;

  /// [status] The status of characteristic e.g. assigned or pending.;
  @override
  final CodeableConcept? status;

  @override
  String toString() {
    return 'AdministrableProductDefinitionProperty(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, valueCodeableConcept: $valueCodeableConcept, valueQuantity: $valueQuantity, valueDate: $valueDate, valueDateElement: $valueDateElement, valueBoolean: $valueBoolean, valueBooleanElement: $valueBooleanElement, valueAttachment: $valueAttachment, status: $status)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AdministrableProductDefinitionProperty &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.valueCodeableConcept, valueCodeableConcept) ||
                other.valueCodeableConcept == valueCodeableConcept) &&
            (identical(other.valueQuantity, valueQuantity) ||
                other.valueQuantity == valueQuantity) &&
            (identical(other.valueDate, valueDate) ||
                other.valueDate == valueDate) &&
            (identical(other.valueDateElement, valueDateElement) ||
                other.valueDateElement == valueDateElement) &&
            (identical(other.valueBoolean, valueBoolean) ||
                other.valueBoolean == valueBoolean) &&
            (identical(other.valueBooleanElement, valueBooleanElement) ||
                other.valueBooleanElement == valueBooleanElement) &&
            (identical(other.valueAttachment, valueAttachment) ||
                other.valueAttachment == valueAttachment) &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      valueCodeableConcept,
      valueQuantity,
      valueDate,
      valueDateElement,
      valueBoolean,
      valueBooleanElement,
      valueAttachment,
      status);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AdministrableProductDefinitionPropertyCopyWith<
          _$_AdministrableProductDefinitionProperty>
      get copyWith => __$$_AdministrableProductDefinitionPropertyCopyWithImpl<
          _$_AdministrableProductDefinitionProperty>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AdministrableProductDefinitionPropertyToJson(
      this,
    );
  }
}

abstract class _AdministrableProductDefinitionProperty
    extends AdministrableProductDefinitionProperty {
  factory _AdministrableProductDefinitionProperty(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept type,
          final CodeableConcept? valueCodeableConcept,
          final Quantity? valueQuantity,
          final Date? valueDate,
          @JsonKey(name: '_valueDate') final Element? valueDateElement,
          final Boolean? valueBoolean,
          @JsonKey(name: '_valueBoolean') final Element? valueBooleanElement,
          final Attachment? valueAttachment,
          final CodeableConcept? status}) =
      _$_AdministrableProductDefinitionProperty;
  _AdministrableProductDefinitionProperty._() : super._();

  factory _AdministrableProductDefinitionProperty.fromJson(
          Map<String, dynamic> json) =
      _$_AdministrableProductDefinitionProperty.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] A code expressing the type of characteristic.;
  CodeableConcept get type;
  @override

  /// [valueCodeableConcept] A value for the characteristic.;
  CodeableConcept? get valueCodeableConcept;
  @override

  /// [valueQuantity] A value for the characteristic.;
  Quantity? get valueQuantity;
  @override

  /// [valueDate] A value for the characteristic.;
  Date? get valueDate;
  @override

  /// [valueDateElement] (_valueDate): Extensions for valueDate;
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement;
  @override

  /// [valueBoolean] A value for the characteristic.;
  Boolean? get valueBoolean;
  @override

  /// [valueBooleanElement] (_valueBoolean): Extensions for valueBoolean;
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement;
  @override

  /// [valueAttachment] A value for the characteristic.;
  Attachment? get valueAttachment;
  @override

  /// [status] The status of characteristic e.g. assigned or pending.;
  CodeableConcept? get status;
  @override
  @JsonKey(ignore: true)
  _$$_AdministrableProductDefinitionPropertyCopyWith<
          _$_AdministrableProductDefinitionProperty>
      get copyWith => throw _privateConstructorUsedError;
}

AdministrableProductDefinitionRouteOfAdministration
    _$AdministrableProductDefinitionRouteOfAdministrationFromJson(
        Map<String, dynamic> json) {
  return _AdministrableProductDefinitionRouteOfAdministration.fromJson(json);
}

/// @nodoc
mixin _$AdministrableProductDefinitionRouteOfAdministration {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [code] Coded expression for the route.;
  CodeableConcept get code => throw _privateConstructorUsedError;

  /// [firstDose] The first dose (dose quantity) administered can be specified for the product, using a numerical value and its unit of measurement.;
  Quantity? get firstDose => throw _privateConstructorUsedError;

  /// [maxSingleDose] The maximum single dose that can be administered, specified using a numerical value and its unit of measurement.;
  Quantity? get maxSingleDose => throw _privateConstructorUsedError;

  /// [maxDosePerDay] The maximum dose per day (maximum dose quantity to be administered in any one 24-h period) that can be administered.;
  Quantity? get maxDosePerDay => throw _privateConstructorUsedError;

  /// [maxDosePerTreatmentPeriod] The maximum dose per treatment period that can be administered.;
  Ratio? get maxDosePerTreatmentPeriod => throw _privateConstructorUsedError;

  /// [maxTreatmentPeriod] The maximum treatment period during which the product can be administered.;
  FhirDuration? get maxTreatmentPeriod => throw _privateConstructorUsedError;

  /// [targetSpecies] A species for which this route applies.;
  List<AdministrableProductDefinitionTargetSpecies>? get targetSpecies =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AdministrableProductDefinitionRouteOfAdministrationCopyWith<
          AdministrableProductDefinitionRouteOfAdministration>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AdministrableProductDefinitionRouteOfAdministrationCopyWith<
    $Res> {
  factory $AdministrableProductDefinitionRouteOfAdministrationCopyWith(
          AdministrableProductDefinitionRouteOfAdministration value,
          $Res Function(AdministrableProductDefinitionRouteOfAdministration)
              then) =
      _$AdministrableProductDefinitionRouteOfAdministrationCopyWithImpl<$Res,
          AdministrableProductDefinitionRouteOfAdministration>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept code,
      Quantity? firstDose,
      Quantity? maxSingleDose,
      Quantity? maxDosePerDay,
      Ratio? maxDosePerTreatmentPeriod,
      FhirDuration? maxTreatmentPeriod,
      List<AdministrableProductDefinitionTargetSpecies>? targetSpecies});

  $CodeableConceptCopyWith<$Res> get code;
  $QuantityCopyWith<$Res>? get firstDose;
  $QuantityCopyWith<$Res>? get maxSingleDose;
  $QuantityCopyWith<$Res>? get maxDosePerDay;
  $RatioCopyWith<$Res>? get maxDosePerTreatmentPeriod;
  $FhirDurationCopyWith<$Res>? get maxTreatmentPeriod;
}

/// @nodoc
class _$AdministrableProductDefinitionRouteOfAdministrationCopyWithImpl<$Res,
        $Val extends AdministrableProductDefinitionRouteOfAdministration>
    implements
        $AdministrableProductDefinitionRouteOfAdministrationCopyWith<$Res> {
  _$AdministrableProductDefinitionRouteOfAdministrationCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = null,
    Object? firstDose = freezed,
    Object? maxSingleDose = freezed,
    Object? maxDosePerDay = freezed,
    Object? maxDosePerTreatmentPeriod = freezed,
    Object? maxTreatmentPeriod = freezed,
    Object? targetSpecies = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      firstDose: freezed == firstDose
          ? _value.firstDose
          : firstDose // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      maxSingleDose: freezed == maxSingleDose
          ? _value.maxSingleDose
          : maxSingleDose // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      maxDosePerDay: freezed == maxDosePerDay
          ? _value.maxDosePerDay
          : maxDosePerDay // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      maxDosePerTreatmentPeriod: freezed == maxDosePerTreatmentPeriod
          ? _value.maxDosePerTreatmentPeriod
          : maxDosePerTreatmentPeriod // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      maxTreatmentPeriod: freezed == maxTreatmentPeriod
          ? _value.maxTreatmentPeriod
          : maxTreatmentPeriod // ignore: cast_nullable_to_non_nullable
              as FhirDuration?,
      targetSpecies: freezed == targetSpecies
          ? _value.targetSpecies
          : targetSpecies // ignore: cast_nullable_to_non_nullable
              as List<AdministrableProductDefinitionTargetSpecies>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get code {
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get firstDose {
    if (_value.firstDose == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.firstDose!, (value) {
      return _then(_value.copyWith(firstDose: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get maxSingleDose {
    if (_value.maxSingleDose == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.maxSingleDose!, (value) {
      return _then(_value.copyWith(maxSingleDose: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get maxDosePerDay {
    if (_value.maxDosePerDay == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.maxDosePerDay!, (value) {
      return _then(_value.copyWith(maxDosePerDay: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RatioCopyWith<$Res>? get maxDosePerTreatmentPeriod {
    if (_value.maxDosePerTreatmentPeriod == null) {
      return null;
    }

    return $RatioCopyWith<$Res>(_value.maxDosePerTreatmentPeriod!, (value) {
      return _then(_value.copyWith(maxDosePerTreatmentPeriod: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FhirDurationCopyWith<$Res>? get maxTreatmentPeriod {
    if (_value.maxTreatmentPeriod == null) {
      return null;
    }

    return $FhirDurationCopyWith<$Res>(_value.maxTreatmentPeriod!, (value) {
      return _then(_value.copyWith(maxTreatmentPeriod: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AdministrableProductDefinitionRouteOfAdministrationCopyWith<
        $Res>
    implements
        $AdministrableProductDefinitionRouteOfAdministrationCopyWith<$Res> {
  factory _$$_AdministrableProductDefinitionRouteOfAdministrationCopyWith(
          _$_AdministrableProductDefinitionRouteOfAdministration value,
          $Res Function(_$_AdministrableProductDefinitionRouteOfAdministration)
              then) =
      __$$_AdministrableProductDefinitionRouteOfAdministrationCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept code,
      Quantity? firstDose,
      Quantity? maxSingleDose,
      Quantity? maxDosePerDay,
      Ratio? maxDosePerTreatmentPeriod,
      FhirDuration? maxTreatmentPeriod,
      List<AdministrableProductDefinitionTargetSpecies>? targetSpecies});

  @override
  $CodeableConceptCopyWith<$Res> get code;
  @override
  $QuantityCopyWith<$Res>? get firstDose;
  @override
  $QuantityCopyWith<$Res>? get maxSingleDose;
  @override
  $QuantityCopyWith<$Res>? get maxDosePerDay;
  @override
  $RatioCopyWith<$Res>? get maxDosePerTreatmentPeriod;
  @override
  $FhirDurationCopyWith<$Res>? get maxTreatmentPeriod;
}

/// @nodoc
class __$$_AdministrableProductDefinitionRouteOfAdministrationCopyWithImpl<$Res>
    extends _$AdministrableProductDefinitionRouteOfAdministrationCopyWithImpl<
        $Res, _$_AdministrableProductDefinitionRouteOfAdministration>
    implements
        _$$_AdministrableProductDefinitionRouteOfAdministrationCopyWith<$Res> {
  __$$_AdministrableProductDefinitionRouteOfAdministrationCopyWithImpl(
      _$_AdministrableProductDefinitionRouteOfAdministration _value,
      $Res Function(_$_AdministrableProductDefinitionRouteOfAdministration)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = null,
    Object? firstDose = freezed,
    Object? maxSingleDose = freezed,
    Object? maxDosePerDay = freezed,
    Object? maxDosePerTreatmentPeriod = freezed,
    Object? maxTreatmentPeriod = freezed,
    Object? targetSpecies = freezed,
  }) {
    return _then(_$_AdministrableProductDefinitionRouteOfAdministration(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      firstDose: freezed == firstDose
          ? _value.firstDose
          : firstDose // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      maxSingleDose: freezed == maxSingleDose
          ? _value.maxSingleDose
          : maxSingleDose // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      maxDosePerDay: freezed == maxDosePerDay
          ? _value.maxDosePerDay
          : maxDosePerDay // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      maxDosePerTreatmentPeriod: freezed == maxDosePerTreatmentPeriod
          ? _value.maxDosePerTreatmentPeriod
          : maxDosePerTreatmentPeriod // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      maxTreatmentPeriod: freezed == maxTreatmentPeriod
          ? _value.maxTreatmentPeriod
          : maxTreatmentPeriod // ignore: cast_nullable_to_non_nullable
              as FhirDuration?,
      targetSpecies: freezed == targetSpecies
          ? _value._targetSpecies
          : targetSpecies // ignore: cast_nullable_to_non_nullable
              as List<AdministrableProductDefinitionTargetSpecies>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AdministrableProductDefinitionRouteOfAdministration
    extends _AdministrableProductDefinitionRouteOfAdministration {
  _$_AdministrableProductDefinitionRouteOfAdministration(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.code,
      this.firstDose,
      this.maxSingleDose,
      this.maxDosePerDay,
      this.maxDosePerTreatmentPeriod,
      this.maxTreatmentPeriod,
      final List<AdministrableProductDefinitionTargetSpecies>? targetSpecies})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _targetSpecies = targetSpecies,
        super._();

  factory _$_AdministrableProductDefinitionRouteOfAdministration.fromJson(
          Map<String, dynamic> json) =>
      _$$_AdministrableProductDefinitionRouteOfAdministrationFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [code] Coded expression for the route.;
  @override
  final CodeableConcept code;

  /// [firstDose] The first dose (dose quantity) administered can be specified for the product, using a numerical value and its unit of measurement.;
  @override
  final Quantity? firstDose;

  /// [maxSingleDose] The maximum single dose that can be administered, specified using a numerical value and its unit of measurement.;
  @override
  final Quantity? maxSingleDose;

  /// [maxDosePerDay] The maximum dose per day (maximum dose quantity to be administered in any one 24-h period) that can be administered.;
  @override
  final Quantity? maxDosePerDay;

  /// [maxDosePerTreatmentPeriod] The maximum dose per treatment period that can be administered.;
  @override
  final Ratio? maxDosePerTreatmentPeriod;

  /// [maxTreatmentPeriod] The maximum treatment period during which the product can be administered.;
  @override
  final FhirDuration? maxTreatmentPeriod;

  /// [targetSpecies] A species for which this route applies.;
  final List<AdministrableProductDefinitionTargetSpecies>? _targetSpecies;

  /// [targetSpecies] A species for which this route applies.;
  @override
  List<AdministrableProductDefinitionTargetSpecies>? get targetSpecies {
    final value = _targetSpecies;
    if (value == null) return null;
    if (_targetSpecies is EqualUnmodifiableListView) return _targetSpecies;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'AdministrableProductDefinitionRouteOfAdministration(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, firstDose: $firstDose, maxSingleDose: $maxSingleDose, maxDosePerDay: $maxDosePerDay, maxDosePerTreatmentPeriod: $maxDosePerTreatmentPeriod, maxTreatmentPeriod: $maxTreatmentPeriod, targetSpecies: $targetSpecies)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AdministrableProductDefinitionRouteOfAdministration &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.firstDose, firstDose) ||
                other.firstDose == firstDose) &&
            (identical(other.maxSingleDose, maxSingleDose) ||
                other.maxSingleDose == maxSingleDose) &&
            (identical(other.maxDosePerDay, maxDosePerDay) ||
                other.maxDosePerDay == maxDosePerDay) &&
            (identical(other.maxDosePerTreatmentPeriod,
                    maxDosePerTreatmentPeriod) ||
                other.maxDosePerTreatmentPeriod == maxDosePerTreatmentPeriod) &&
            (identical(other.maxTreatmentPeriod, maxTreatmentPeriod) ||
                other.maxTreatmentPeriod == maxTreatmentPeriod) &&
            const DeepCollectionEquality()
                .equals(other._targetSpecies, _targetSpecies));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      code,
      firstDose,
      maxSingleDose,
      maxDosePerDay,
      maxDosePerTreatmentPeriod,
      maxTreatmentPeriod,
      const DeepCollectionEquality().hash(_targetSpecies));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AdministrableProductDefinitionRouteOfAdministrationCopyWith<
          _$_AdministrableProductDefinitionRouteOfAdministration>
      get copyWith =>
          __$$_AdministrableProductDefinitionRouteOfAdministrationCopyWithImpl<
                  _$_AdministrableProductDefinitionRouteOfAdministration>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AdministrableProductDefinitionRouteOfAdministrationToJson(
      this,
    );
  }
}

abstract class _AdministrableProductDefinitionRouteOfAdministration
    extends AdministrableProductDefinitionRouteOfAdministration {
  factory _AdministrableProductDefinitionRouteOfAdministration(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept code,
          final Quantity? firstDose,
          final Quantity? maxSingleDose,
          final Quantity? maxDosePerDay,
          final Ratio? maxDosePerTreatmentPeriod,
          final FhirDuration? maxTreatmentPeriod,
          final List<AdministrableProductDefinitionTargetSpecies>?
              targetSpecies}) =
      _$_AdministrableProductDefinitionRouteOfAdministration;
  _AdministrableProductDefinitionRouteOfAdministration._() : super._();

  factory _AdministrableProductDefinitionRouteOfAdministration.fromJson(
          Map<String, dynamic> json) =
      _$_AdministrableProductDefinitionRouteOfAdministration.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [code] Coded expression for the route.;
  CodeableConcept get code;
  @override

  /// [firstDose] The first dose (dose quantity) administered can be specified for the product, using a numerical value and its unit of measurement.;
  Quantity? get firstDose;
  @override

  /// [maxSingleDose] The maximum single dose that can be administered, specified using a numerical value and its unit of measurement.;
  Quantity? get maxSingleDose;
  @override

  /// [maxDosePerDay] The maximum dose per day (maximum dose quantity to be administered in any one 24-h period) that can be administered.;
  Quantity? get maxDosePerDay;
  @override

  /// [maxDosePerTreatmentPeriod] The maximum dose per treatment period that can be administered.;
  Ratio? get maxDosePerTreatmentPeriod;
  @override

  /// [maxTreatmentPeriod] The maximum treatment period during which the product can be administered.;
  FhirDuration? get maxTreatmentPeriod;
  @override

  /// [targetSpecies] A species for which this route applies.;
  List<AdministrableProductDefinitionTargetSpecies>? get targetSpecies;
  @override
  @JsonKey(ignore: true)
  _$$_AdministrableProductDefinitionRouteOfAdministrationCopyWith<
          _$_AdministrableProductDefinitionRouteOfAdministration>
      get copyWith => throw _privateConstructorUsedError;
}

AdministrableProductDefinitionTargetSpecies
    _$AdministrableProductDefinitionTargetSpeciesFromJson(
        Map<String, dynamic> json) {
  return _AdministrableProductDefinitionTargetSpecies.fromJson(json);
}

/// @nodoc
mixin _$AdministrableProductDefinitionTargetSpecies {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [code] Coded expression for the species.;
  CodeableConcept get code => throw _privateConstructorUsedError;

  /// [withdrawalPeriod] A species specific time during which consumption of animal product is not appropriate.;
  List<AdministrableProductDefinitionWithdrawalPeriod>? get withdrawalPeriod =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AdministrableProductDefinitionTargetSpeciesCopyWith<
          AdministrableProductDefinitionTargetSpecies>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AdministrableProductDefinitionTargetSpeciesCopyWith<$Res> {
  factory $AdministrableProductDefinitionTargetSpeciesCopyWith(
          AdministrableProductDefinitionTargetSpecies value,
          $Res Function(AdministrableProductDefinitionTargetSpecies) then) =
      _$AdministrableProductDefinitionTargetSpeciesCopyWithImpl<$Res,
          AdministrableProductDefinitionTargetSpecies>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept code,
      List<AdministrableProductDefinitionWithdrawalPeriod>? withdrawalPeriod});

  $CodeableConceptCopyWith<$Res> get code;
}

/// @nodoc
class _$AdministrableProductDefinitionTargetSpeciesCopyWithImpl<$Res,
        $Val extends AdministrableProductDefinitionTargetSpecies>
    implements $AdministrableProductDefinitionTargetSpeciesCopyWith<$Res> {
  _$AdministrableProductDefinitionTargetSpeciesCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = null,
    Object? withdrawalPeriod = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      withdrawalPeriod: freezed == withdrawalPeriod
          ? _value.withdrawalPeriod
          : withdrawalPeriod // ignore: cast_nullable_to_non_nullable
              as List<AdministrableProductDefinitionWithdrawalPeriod>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get code {
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AdministrableProductDefinitionTargetSpeciesCopyWith<$Res>
    implements $AdministrableProductDefinitionTargetSpeciesCopyWith<$Res> {
  factory _$$_AdministrableProductDefinitionTargetSpeciesCopyWith(
          _$_AdministrableProductDefinitionTargetSpecies value,
          $Res Function(_$_AdministrableProductDefinitionTargetSpecies) then) =
      __$$_AdministrableProductDefinitionTargetSpeciesCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept code,
      List<AdministrableProductDefinitionWithdrawalPeriod>? withdrawalPeriod});

  @override
  $CodeableConceptCopyWith<$Res> get code;
}

/// @nodoc
class __$$_AdministrableProductDefinitionTargetSpeciesCopyWithImpl<$Res>
    extends _$AdministrableProductDefinitionTargetSpeciesCopyWithImpl<$Res,
        _$_AdministrableProductDefinitionTargetSpecies>
    implements _$$_AdministrableProductDefinitionTargetSpeciesCopyWith<$Res> {
  __$$_AdministrableProductDefinitionTargetSpeciesCopyWithImpl(
      _$_AdministrableProductDefinitionTargetSpecies _value,
      $Res Function(_$_AdministrableProductDefinitionTargetSpecies) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = null,
    Object? withdrawalPeriod = freezed,
  }) {
    return _then(_$_AdministrableProductDefinitionTargetSpecies(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      withdrawalPeriod: freezed == withdrawalPeriod
          ? _value._withdrawalPeriod
          : withdrawalPeriod // ignore: cast_nullable_to_non_nullable
              as List<AdministrableProductDefinitionWithdrawalPeriod>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AdministrableProductDefinitionTargetSpecies
    extends _AdministrableProductDefinitionTargetSpecies {
  _$_AdministrableProductDefinitionTargetSpecies(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.code,
      final List<AdministrableProductDefinitionWithdrawalPeriod>?
          withdrawalPeriod})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _withdrawalPeriod = withdrawalPeriod,
        super._();

  factory _$_AdministrableProductDefinitionTargetSpecies.fromJson(
          Map<String, dynamic> json) =>
      _$$_AdministrableProductDefinitionTargetSpeciesFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [code] Coded expression for the species.;
  @override
  final CodeableConcept code;

  /// [withdrawalPeriod] A species specific time during which consumption of animal product is not appropriate.;
  final List<AdministrableProductDefinitionWithdrawalPeriod>? _withdrawalPeriod;

  /// [withdrawalPeriod] A species specific time during which consumption of animal product is not appropriate.;
  @override
  List<AdministrableProductDefinitionWithdrawalPeriod>? get withdrawalPeriod {
    final value = _withdrawalPeriod;
    if (value == null) return null;
    if (_withdrawalPeriod is EqualUnmodifiableListView)
      return _withdrawalPeriod;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'AdministrableProductDefinitionTargetSpecies(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, withdrawalPeriod: $withdrawalPeriod)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AdministrableProductDefinitionTargetSpecies &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.code, code) || other.code == code) &&
            const DeepCollectionEquality()
                .equals(other._withdrawalPeriod, _withdrawalPeriod));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      code,
      const DeepCollectionEquality().hash(_withdrawalPeriod));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AdministrableProductDefinitionTargetSpeciesCopyWith<
          _$_AdministrableProductDefinitionTargetSpecies>
      get copyWith =>
          __$$_AdministrableProductDefinitionTargetSpeciesCopyWithImpl<
              _$_AdministrableProductDefinitionTargetSpecies>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AdministrableProductDefinitionTargetSpeciesToJson(
      this,
    );
  }
}

abstract class _AdministrableProductDefinitionTargetSpecies
    extends AdministrableProductDefinitionTargetSpecies {
  factory _AdministrableProductDefinitionTargetSpecies(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final CodeableConcept code,
      final List<AdministrableProductDefinitionWithdrawalPeriod>?
          withdrawalPeriod}) = _$_AdministrableProductDefinitionTargetSpecies;
  _AdministrableProductDefinitionTargetSpecies._() : super._();

  factory _AdministrableProductDefinitionTargetSpecies.fromJson(
          Map<String, dynamic> json) =
      _$_AdministrableProductDefinitionTargetSpecies.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [code] Coded expression for the species.;
  CodeableConcept get code;
  @override

  /// [withdrawalPeriod] A species specific time during which consumption of animal product is not appropriate.;
  List<AdministrableProductDefinitionWithdrawalPeriod>? get withdrawalPeriod;
  @override
  @JsonKey(ignore: true)
  _$$_AdministrableProductDefinitionTargetSpeciesCopyWith<
          _$_AdministrableProductDefinitionTargetSpecies>
      get copyWith => throw _privateConstructorUsedError;
}

AdministrableProductDefinitionWithdrawalPeriod
    _$AdministrableProductDefinitionWithdrawalPeriodFromJson(
        Map<String, dynamic> json) {
  return _AdministrableProductDefinitionWithdrawalPeriod.fromJson(json);
}

/// @nodoc
mixin _$AdministrableProductDefinitionWithdrawalPeriod {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [tissue] Coded expression for the type of tissue for which the withdrawal period applies, e.g. meat, milk.;
  CodeableConcept get tissue => throw _privateConstructorUsedError;

  /// [value] A value for the time.;
  Quantity get value => throw _privateConstructorUsedError;

  /// [supportingInformation] Extra information about the withdrawal period.;
  String? get supportingInformation => throw _privateConstructorUsedError;
  @JsonKey(name: '_supportingInformation')
  Element? get supportingInformationElement =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AdministrableProductDefinitionWithdrawalPeriodCopyWith<
          AdministrableProductDefinitionWithdrawalPeriod>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AdministrableProductDefinitionWithdrawalPeriodCopyWith<$Res> {
  factory $AdministrableProductDefinitionWithdrawalPeriodCopyWith(
          AdministrableProductDefinitionWithdrawalPeriod value,
          $Res Function(AdministrableProductDefinitionWithdrawalPeriod) then) =
      _$AdministrableProductDefinitionWithdrawalPeriodCopyWithImpl<$Res,
          AdministrableProductDefinitionWithdrawalPeriod>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept tissue,
      Quantity value,
      String? supportingInformation,
      @JsonKey(name: '_supportingInformation')
          Element? supportingInformationElement});

  $CodeableConceptCopyWith<$Res> get tissue;
  $QuantityCopyWith<$Res> get value;
  $ElementCopyWith<$Res>? get supportingInformationElement;
}

/// @nodoc
class _$AdministrableProductDefinitionWithdrawalPeriodCopyWithImpl<$Res,
        $Val extends AdministrableProductDefinitionWithdrawalPeriod>
    implements $AdministrableProductDefinitionWithdrawalPeriodCopyWith<$Res> {
  _$AdministrableProductDefinitionWithdrawalPeriodCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? tissue = null,
    Object? value = null,
    Object? supportingInformation = freezed,
    Object? supportingInformationElement = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      tissue: null == tissue
          ? _value.tissue
          : tissue // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Quantity,
      supportingInformation: freezed == supportingInformation
          ? _value.supportingInformation
          : supportingInformation // ignore: cast_nullable_to_non_nullable
              as String?,
      supportingInformationElement: freezed == supportingInformationElement
          ? _value.supportingInformationElement
          : supportingInformationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get tissue {
    return $CodeableConceptCopyWith<$Res>(_value.tissue, (value) {
      return _then(_value.copyWith(tissue: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res> get value {
    return $QuantityCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get supportingInformationElement {
    if (_value.supportingInformationElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.supportingInformationElement!,
        (value) {
      return _then(
          _value.copyWith(supportingInformationElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AdministrableProductDefinitionWithdrawalPeriodCopyWith<$Res>
    implements $AdministrableProductDefinitionWithdrawalPeriodCopyWith<$Res> {
  factory _$$_AdministrableProductDefinitionWithdrawalPeriodCopyWith(
          _$_AdministrableProductDefinitionWithdrawalPeriod value,
          $Res Function(_$_AdministrableProductDefinitionWithdrawalPeriod)
              then) =
      __$$_AdministrableProductDefinitionWithdrawalPeriodCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept tissue,
      Quantity value,
      String? supportingInformation,
      @JsonKey(name: '_supportingInformation')
          Element? supportingInformationElement});

  @override
  $CodeableConceptCopyWith<$Res> get tissue;
  @override
  $QuantityCopyWith<$Res> get value;
  @override
  $ElementCopyWith<$Res>? get supportingInformationElement;
}

/// @nodoc
class __$$_AdministrableProductDefinitionWithdrawalPeriodCopyWithImpl<$Res>
    extends _$AdministrableProductDefinitionWithdrawalPeriodCopyWithImpl<$Res,
        _$_AdministrableProductDefinitionWithdrawalPeriod>
    implements
        _$$_AdministrableProductDefinitionWithdrawalPeriodCopyWith<$Res> {
  __$$_AdministrableProductDefinitionWithdrawalPeriodCopyWithImpl(
      _$_AdministrableProductDefinitionWithdrawalPeriod _value,
      $Res Function(_$_AdministrableProductDefinitionWithdrawalPeriod) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? tissue = null,
    Object? value = null,
    Object? supportingInformation = freezed,
    Object? supportingInformationElement = freezed,
  }) {
    return _then(_$_AdministrableProductDefinitionWithdrawalPeriod(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      tissue: null == tissue
          ? _value.tissue
          : tissue // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Quantity,
      supportingInformation: freezed == supportingInformation
          ? _value.supportingInformation
          : supportingInformation // ignore: cast_nullable_to_non_nullable
              as String?,
      supportingInformationElement: freezed == supportingInformationElement
          ? _value.supportingInformationElement
          : supportingInformationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AdministrableProductDefinitionWithdrawalPeriod
    extends _AdministrableProductDefinitionWithdrawalPeriod {
  _$_AdministrableProductDefinitionWithdrawalPeriod(
      {this.id,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.tissue,
      required this.value,
      this.supportingInformation,
      @JsonKey(name: '_supportingInformation')
          this.supportingInformationElement})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_AdministrableProductDefinitionWithdrawalPeriod.fromJson(
          Map<String, dynamic> json) =>
      _$$_AdministrableProductDefinitionWithdrawalPeriodFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [tissue] Coded expression for the type of tissue for which the withdrawal period applies, e.g. meat, milk.;
  @override
  final CodeableConcept tissue;

  /// [value] A value for the time.;
  @override
  final Quantity value;

  /// [supportingInformation] Extra information about the withdrawal period.;
  @override
  final String? supportingInformation;
  @override
  @JsonKey(name: '_supportingInformation')
  final Element? supportingInformationElement;

  @override
  String toString() {
    return 'AdministrableProductDefinitionWithdrawalPeriod(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, tissue: $tissue, value: $value, supportingInformation: $supportingInformation, supportingInformationElement: $supportingInformationElement)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AdministrableProductDefinitionWithdrawalPeriod &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.tissue, tissue) || other.tissue == tissue) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.supportingInformation, supportingInformation) ||
                other.supportingInformation == supportingInformation) &&
            (identical(other.supportingInformationElement,
                    supportingInformationElement) ||
                other.supportingInformationElement ==
                    supportingInformationElement));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      tissue,
      value,
      supportingInformation,
      supportingInformationElement);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AdministrableProductDefinitionWithdrawalPeriodCopyWith<
          _$_AdministrableProductDefinitionWithdrawalPeriod>
      get copyWith =>
          __$$_AdministrableProductDefinitionWithdrawalPeriodCopyWithImpl<
                  _$_AdministrableProductDefinitionWithdrawalPeriod>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AdministrableProductDefinitionWithdrawalPeriodToJson(
      this,
    );
  }
}

abstract class _AdministrableProductDefinitionWithdrawalPeriod
    extends AdministrableProductDefinitionWithdrawalPeriod {
  factory _AdministrableProductDefinitionWithdrawalPeriod(
          {final String? id,
          @JsonKey(name: 'extension')
              final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept tissue,
          required final Quantity value,
          final String? supportingInformation,
          @JsonKey(name: '_supportingInformation')
              final Element? supportingInformationElement}) =
      _$_AdministrableProductDefinitionWithdrawalPeriod;
  _AdministrableProductDefinitionWithdrawalPeriod._() : super._();

  factory _AdministrableProductDefinitionWithdrawalPeriod.fromJson(
          Map<String, dynamic> json) =
      _$_AdministrableProductDefinitionWithdrawalPeriod.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [tissue] Coded expression for the type of tissue for which the withdrawal period applies, e.g. meat, milk.;
  CodeableConcept get tissue;
  @override

  /// [value] A value for the time.;
  Quantity get value;
  @override

  /// [supportingInformation] Extra information about the withdrawal period.;
  String? get supportingInformation;
  @override
  @JsonKey(name: '_supportingInformation')
  Element? get supportingInformationElement;
  @override
  @JsonKey(ignore: true)
  _$$_AdministrableProductDefinitionWithdrawalPeriodCopyWith<
          _$_AdministrableProductDefinitionWithdrawalPeriod>
      get copyWith => throw _privateConstructorUsedError;
}

Ingredient _$IngredientFromJson(Map<String, dynamic> json) {
  return _Ingredient.fromJson(json);
}

/// @nodoc
mixin _$Ingredient {
  /// [resourceType] This is a Ingredient resource;
  R4ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  String? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.;
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] (_language): Extensions for language;
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] The identifier(s) of this Ingredient that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate.;
  Identifier? get identifier => throw _privateConstructorUsedError;

  /// [status] The status of this ingredient. Enables tracking the life-cycle of the content.;
  Code? get status => throw _privateConstructorUsedError;

  /// [statusElement] (_status): Extensions for status;
  @JsonKey(name: '_status')
  Element? get statusElement => throw _privateConstructorUsedError;

  /// [for] The product which this ingredient is a constituent part of.;
  @JsonKey(name: 'for')
  List<Reference>? get for_ => throw _privateConstructorUsedError;

  /// [role] A classification of the ingredient identifying its purpose within the product, e.g. active, inactive.;
  CodeableConcept get role => throw _privateConstructorUsedError;

  /// [function] A classification of the ingredient identifying its precise purpose(s) in the drug product. This extends the Ingredient.role to add more detail. Example: antioxidant, alkalizing agent.;
  List<CodeableConcept>? get function => throw _privateConstructorUsedError;

  /// [group] A classification of the ingredient according to where in the physical item it tends to be used, such the outer shell of a tablet, inner body or ink.;
  CodeableConcept? get group => throw _privateConstructorUsedError;

  /// [allergenicIndicator] If the ingredient is a known or suspected allergen. Note that this is a property of the substance, so if a reference to a SubstanceDefinition is used to decribe that (rather than just a code), the allergen information should go there, not here.;
  Boolean? get allergenicIndicator => throw _privateConstructorUsedError;

  /// [allergenicIndicatorElement] (_allergenicIndicator): Extensions for allergenicIndicator;
  @JsonKey(name: '_allergenicIndicator')
  Element? get allergenicIndicatorElement => throw _privateConstructorUsedError;

  /// [manufacturer] The organization(s) that manufacture this ingredient. Can be used to indicate:         1) Organizations we are aware of that manufacture this ingredient         2) Specific Manufacturer(s) currently being used         3) Set of organisations allowed to manufacture this ingredient for this product         Users must be clear on the application of context relevant to their use case.;
  List<IngredientManufacturer>? get manufacturer =>
      throw _privateConstructorUsedError;

  /// [substance] The substance that comprises this ingredient.;
  IngredientSubstance get substance => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $IngredientCopyWith<Ingredient> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IngredientCopyWith<$Res> {
  factory $IngredientCopyWith(
          Ingredient value, $Res Function(Ingredient) then) =
      _$IngredientCopyWithImpl<$Res, Ingredient>;
  @useResult
  $Res call(
      {R4ResourceType resourceType,
      String? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Identifier? identifier,
      Code? status,
      @JsonKey(name: '_status')
          Element? statusElement,
      @JsonKey(name: 'for')
          List<Reference>? for_,
      CodeableConcept role,
      List<CodeableConcept>? function,
      CodeableConcept? group,
      Boolean? allergenicIndicator,
      @JsonKey(name: '_allergenicIndicator')
          Element? allergenicIndicatorElement,
      List<IngredientManufacturer>? manufacturer,
      IngredientSubstance substance});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $IdentifierCopyWith<$Res>? get identifier;
  $ElementCopyWith<$Res>? get statusElement;
  $CodeableConceptCopyWith<$Res> get role;
  $CodeableConceptCopyWith<$Res>? get group;
  $ElementCopyWith<$Res>? get allergenicIndicatorElement;
  $IngredientSubstanceCopyWith<$Res> get substance;
}

/// @nodoc
class _$IngredientCopyWithImpl<$Res, $Val extends Ingredient>
    implements $IngredientCopyWith<$Res> {
  _$IngredientCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? for_ = freezed,
    Object? role = null,
    Object? function = freezed,
    Object? group = freezed,
    Object? allergenicIndicator = freezed,
    Object? allergenicIndicatorElement = freezed,
    Object? manufacturer = freezed,
    Object? substance = null,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R4ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as Code?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      for_: freezed == for_
          ? _value.for_
          : for_ // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      group: freezed == group
          ? _value.group
          : group // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      allergenicIndicator: freezed == allergenicIndicator
          ? _value.allergenicIndicator
          : allergenicIndicator // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      allergenicIndicatorElement: freezed == allergenicIndicatorElement
          ? _value.allergenicIndicatorElement
          : allergenicIndicatorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      manufacturer: freezed == manufacturer
          ? _value.manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<IngredientManufacturer>?,
      substance: null == substance
          ? _value.substance
          : substance // ignore: cast_nullable_to_non_nullable
              as IngredientSubstance,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get identifier {
    if (_value.identifier == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.identifier!, (value) {
      return _then(_value.copyWith(identifier: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusElement {
    if (_value.statusElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusElement!, (value) {
      return _then(_value.copyWith(statusElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get role {
    return $CodeableConceptCopyWith<$Res>(_value.role, (value) {
      return _then(_value.copyWith(role: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get group {
    if (_value.group == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.group!, (value) {
      return _then(_value.copyWith(group: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get allergenicIndicatorElement {
    if (_value.allergenicIndicatorElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.allergenicIndicatorElement!, (value) {
      return _then(_value.copyWith(allergenicIndicatorElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $IngredientSubstanceCopyWith<$Res> get substance {
    return $IngredientSubstanceCopyWith<$Res>(_value.substance, (value) {
      return _then(_value.copyWith(substance: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_IngredientCopyWith<$Res>
    implements $IngredientCopyWith<$Res> {
  factory _$$_IngredientCopyWith(
          _$_Ingredient value, $Res Function(_$_Ingredient) then) =
      __$$_IngredientCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {R4ResourceType resourceType,
      String? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Identifier? identifier,
      Code? status,
      @JsonKey(name: '_status')
          Element? statusElement,
      @JsonKey(name: 'for')
          List<Reference>? for_,
      CodeableConcept role,
      List<CodeableConcept>? function,
      CodeableConcept? group,
      Boolean? allergenicIndicator,
      @JsonKey(name: '_allergenicIndicator')
          Element? allergenicIndicatorElement,
      List<IngredientManufacturer>? manufacturer,
      IngredientSubstance substance});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $IdentifierCopyWith<$Res>? get identifier;
  @override
  $ElementCopyWith<$Res>? get statusElement;
  @override
  $CodeableConceptCopyWith<$Res> get role;
  @override
  $CodeableConceptCopyWith<$Res>? get group;
  @override
  $ElementCopyWith<$Res>? get allergenicIndicatorElement;
  @override
  $IngredientSubstanceCopyWith<$Res> get substance;
}

/// @nodoc
class __$$_IngredientCopyWithImpl<$Res>
    extends _$IngredientCopyWithImpl<$Res, _$_Ingredient>
    implements _$$_IngredientCopyWith<$Res> {
  __$$_IngredientCopyWithImpl(
      _$_Ingredient _value, $Res Function(_$_Ingredient) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? for_ = freezed,
    Object? role = null,
    Object? function = freezed,
    Object? group = freezed,
    Object? allergenicIndicator = freezed,
    Object? allergenicIndicatorElement = freezed,
    Object? manufacturer = freezed,
    Object? substance = null,
  }) {
    return _then(_$_Ingredient(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R4ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as Code?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      for_: freezed == for_
          ? _value._for_
          : for_ // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      function: freezed == function
          ? _value._function
          : function // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      group: freezed == group
          ? _value.group
          : group // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      allergenicIndicator: freezed == allergenicIndicator
          ? _value.allergenicIndicator
          : allergenicIndicator // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      allergenicIndicatorElement: freezed == allergenicIndicatorElement
          ? _value.allergenicIndicatorElement
          : allergenicIndicatorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      manufacturer: freezed == manufacturer
          ? _value._manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<IngredientManufacturer>?,
      substance: null == substance
          ? _value.substance
          : substance // ignore: cast_nullable_to_non_nullable
              as IngredientSubstance,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Ingredient extends _Ingredient {
  _$_Ingredient(
      {this.resourceType = R4ResourceType.Ingredient,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules') this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language') this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.identifier,
      this.status,
      @JsonKey(name: '_status') this.statusElement,
      @JsonKey(name: 'for') final List<Reference>? for_,
      required this.role,
      final List<CodeableConcept>? function,
      this.group,
      this.allergenicIndicator,
      @JsonKey(name: '_allergenicIndicator') this.allergenicIndicatorElement,
      final List<IngredientManufacturer>? manufacturer,
      required this.substance})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _for_ = for_,
        _function = function,
        _manufacturer = manufacturer,
        super._();

  factory _$_Ingredient.fromJson(Map<String, dynamic> json) =>
      _$$_IngredientFromJson(json);

  /// [resourceType] This is a Ingredient resource;
  @override
  @JsonKey()
  final R4ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  @override
  final String? id;

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.;
  @override
  final Code? language;

  /// [languageElement] (_language): Extensions for language;
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] The identifier(s) of this Ingredient that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate.;
  @override
  final Identifier? identifier;

  /// [status] The status of this ingredient. Enables tracking the life-cycle of the content.;
  @override
  final Code? status;

  /// [statusElement] (_status): Extensions for status;
  @override
  @JsonKey(name: '_status')
  final Element? statusElement;

  /// [for] The product which this ingredient is a constituent part of.;
  final List<Reference>? _for_;

  /// [for] The product which this ingredient is a constituent part of.;
  @override
  @JsonKey(name: 'for')
  List<Reference>? get for_ {
    final value = _for_;
    if (value == null) return null;
    if (_for_ is EqualUnmodifiableListView) return _for_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [role] A classification of the ingredient identifying its purpose within the product, e.g. active, inactive.;
  @override
  final CodeableConcept role;

  /// [function] A classification of the ingredient identifying its precise purpose(s) in the drug product. This extends the Ingredient.role to add more detail. Example: antioxidant, alkalizing agent.;
  final List<CodeableConcept>? _function;

  /// [function] A classification of the ingredient identifying its precise purpose(s) in the drug product. This extends the Ingredient.role to add more detail. Example: antioxidant, alkalizing agent.;
  @override
  List<CodeableConcept>? get function {
    final value = _function;
    if (value == null) return null;
    if (_function is EqualUnmodifiableListView) return _function;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [group] A classification of the ingredient according to where in the physical item it tends to be used, such the outer shell of a tablet, inner body or ink.;
  @override
  final CodeableConcept? group;

  /// [allergenicIndicator] If the ingredient is a known or suspected allergen. Note that this is a property of the substance, so if a reference to a SubstanceDefinition is used to decribe that (rather than just a code), the allergen information should go there, not here.;
  @override
  final Boolean? allergenicIndicator;

  /// [allergenicIndicatorElement] (_allergenicIndicator): Extensions for allergenicIndicator;
  @override
  @JsonKey(name: '_allergenicIndicator')
  final Element? allergenicIndicatorElement;

  /// [manufacturer] The organization(s) that manufacture this ingredient. Can be used to indicate:         1) Organizations we are aware of that manufacture this ingredient         2) Specific Manufacturer(s) currently being used         3) Set of organisations allowed to manufacture this ingredient for this product         Users must be clear on the application of context relevant to their use case.;
  final List<IngredientManufacturer>? _manufacturer;

  /// [manufacturer] The organization(s) that manufacture this ingredient. Can be used to indicate:         1) Organizations we are aware of that manufacture this ingredient         2) Specific Manufacturer(s) currently being used         3) Set of organisations allowed to manufacture this ingredient for this product         Users must be clear on the application of context relevant to their use case.;
  @override
  List<IngredientManufacturer>? get manufacturer {
    final value = _manufacturer;
    if (value == null) return null;
    if (_manufacturer is EqualUnmodifiableListView) return _manufacturer;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [substance] The substance that comprises this ingredient.;
  @override
  final IngredientSubstance substance;

  @override
  String toString() {
    return 'Ingredient(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, status: $status, statusElement: $statusElement, for_: $for_, role: $role, function: $function, group: $group, allergenicIndicator: $allergenicIndicator, allergenicIndicatorElement: $allergenicIndicatorElement, manufacturer: $manufacturer, substance: $substance)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Ingredient &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusElement, statusElement) ||
                other.statusElement == statusElement) &&
            const DeepCollectionEquality().equals(other._for_, _for_) &&
            (identical(other.role, role) || other.role == role) &&
            const DeepCollectionEquality().equals(other._function, _function) &&
            (identical(other.group, group) || other.group == group) &&
            (identical(other.allergenicIndicator, allergenicIndicator) ||
                other.allergenicIndicator == allergenicIndicator) &&
            (identical(other.allergenicIndicatorElement,
                    allergenicIndicatorElement) ||
                other.allergenicIndicatorElement ==
                    allergenicIndicatorElement) &&
            const DeepCollectionEquality()
                .equals(other._manufacturer, _manufacturer) &&
            (identical(other.substance, substance) ||
                other.substance == substance));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        identifier,
        status,
        statusElement,
        const DeepCollectionEquality().hash(_for_),
        role,
        const DeepCollectionEquality().hash(_function),
        group,
        allergenicIndicator,
        allergenicIndicatorElement,
        const DeepCollectionEquality().hash(_manufacturer),
        substance
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_IngredientCopyWith<_$_Ingredient> get copyWith =>
      __$$_IngredientCopyWithImpl<_$_Ingredient>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_IngredientToJson(
      this,
    );
  }
}

abstract class _Ingredient extends Ingredient {
  factory _Ingredient(
      {final R4ResourceType resourceType,
      final String? id,
      final Meta? meta,
      final FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          final Element? implicitRulesElement,
      final Code? language,
      @JsonKey(name: '_language')
          final Element? languageElement,
      final Narrative? text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final Identifier? identifier,
      final Code? status,
      @JsonKey(name: '_status')
          final Element? statusElement,
      @JsonKey(name: 'for')
          final List<Reference>? for_,
      required final CodeableConcept role,
      final List<CodeableConcept>? function,
      final CodeableConcept? group,
      final Boolean? allergenicIndicator,
      @JsonKey(name: '_allergenicIndicator')
          final Element? allergenicIndicatorElement,
      final List<IngredientManufacturer>? manufacturer,
      required final IngredientSubstance substance}) = _$_Ingredient;
  _Ingredient._() : super._();

  factory _Ingredient.fromJson(Map<String, dynamic> json) =
      _$_Ingredient.fromJson;

  @override

  /// [resourceType] This is a Ingredient resource;
  R4ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  String? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.;
  Code? get language;
  @override

  /// [languageElement] (_language): Extensions for language;
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  List<Resource>? get contained;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] The identifier(s) of this Ingredient that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate.;
  Identifier? get identifier;
  @override

  /// [status] The status of this ingredient. Enables tracking the life-cycle of the content.;
  Code? get status;
  @override

  /// [statusElement] (_status): Extensions for status;
  @JsonKey(name: '_status')
  Element? get statusElement;
  @override

  /// [for] The product which this ingredient is a constituent part of.;
  @JsonKey(name: 'for')
  List<Reference>? get for_;
  @override

  /// [role] A classification of the ingredient identifying its purpose within the product, e.g. active, inactive.;
  CodeableConcept get role;
  @override

  /// [function] A classification of the ingredient identifying its precise purpose(s) in the drug product. This extends the Ingredient.role to add more detail. Example: antioxidant, alkalizing agent.;
  List<CodeableConcept>? get function;
  @override

  /// [group] A classification of the ingredient according to where in the physical item it tends to be used, such the outer shell of a tablet, inner body or ink.;
  CodeableConcept? get group;
  @override

  /// [allergenicIndicator] If the ingredient is a known or suspected allergen. Note that this is a property of the substance, so if a reference to a SubstanceDefinition is used to decribe that (rather than just a code), the allergen information should go there, not here.;
  Boolean? get allergenicIndicator;
  @override

  /// [allergenicIndicatorElement] (_allergenicIndicator): Extensions for allergenicIndicator;
  @JsonKey(name: '_allergenicIndicator')
  Element? get allergenicIndicatorElement;
  @override

  /// [manufacturer] The organization(s) that manufacture this ingredient. Can be used to indicate:         1) Organizations we are aware of that manufacture this ingredient         2) Specific Manufacturer(s) currently being used         3) Set of organisations allowed to manufacture this ingredient for this product         Users must be clear on the application of context relevant to their use case.;
  List<IngredientManufacturer>? get manufacturer;
  @override

  /// [substance] The substance that comprises this ingredient.;
  IngredientSubstance get substance;
  @override
  @JsonKey(ignore: true)
  _$$_IngredientCopyWith<_$_Ingredient> get copyWith =>
      throw _privateConstructorUsedError;
}

IngredientManufacturer _$IngredientManufacturerFromJson(
    Map<String, dynamic> json) {
  return _IngredientManufacturer.fromJson(json);
}

/// @nodoc
mixin _$IngredientManufacturer {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [role] The way in which this manufacturer is associated with the ingredient. For example whether it is a possible one (others allowed), or an exclusive authorized one for this ingredient. Note that this is not the manufacturing process role.;
  Code? get role => throw _privateConstructorUsedError;

  /// [roleElement] (_role): Extensions for role;
  @JsonKey(name: '_role')
  Element? get roleElement => throw _privateConstructorUsedError;

  /// [manufacturer] An organization that manufactures this ingredient.;
  Reference get manufacturer => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $IngredientManufacturerCopyWith<IngredientManufacturer> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IngredientManufacturerCopyWith<$Res> {
  factory $IngredientManufacturerCopyWith(IngredientManufacturer value,
          $Res Function(IngredientManufacturer) then) =
      _$IngredientManufacturerCopyWithImpl<$Res, IngredientManufacturer>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Code? role,
      @JsonKey(name: '_role') Element? roleElement,
      Reference manufacturer});

  $ElementCopyWith<$Res>? get roleElement;
  $ReferenceCopyWith<$Res> get manufacturer;
}

/// @nodoc
class _$IngredientManufacturerCopyWithImpl<$Res,
        $Val extends IngredientManufacturer>
    implements $IngredientManufacturerCopyWith<$Res> {
  _$IngredientManufacturerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? role = freezed,
    Object? roleElement = freezed,
    Object? manufacturer = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as Code?,
      roleElement: freezed == roleElement
          ? _value.roleElement
          : roleElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      manufacturer: null == manufacturer
          ? _value.manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as Reference,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get roleElement {
    if (_value.roleElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.roleElement!, (value) {
      return _then(_value.copyWith(roleElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res> get manufacturer {
    return $ReferenceCopyWith<$Res>(_value.manufacturer, (value) {
      return _then(_value.copyWith(manufacturer: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_IngredientManufacturerCopyWith<$Res>
    implements $IngredientManufacturerCopyWith<$Res> {
  factory _$$_IngredientManufacturerCopyWith(_$_IngredientManufacturer value,
          $Res Function(_$_IngredientManufacturer) then) =
      __$$_IngredientManufacturerCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Code? role,
      @JsonKey(name: '_role') Element? roleElement,
      Reference manufacturer});

  @override
  $ElementCopyWith<$Res>? get roleElement;
  @override
  $ReferenceCopyWith<$Res> get manufacturer;
}

/// @nodoc
class __$$_IngredientManufacturerCopyWithImpl<$Res>
    extends _$IngredientManufacturerCopyWithImpl<$Res,
        _$_IngredientManufacturer>
    implements _$$_IngredientManufacturerCopyWith<$Res> {
  __$$_IngredientManufacturerCopyWithImpl(_$_IngredientManufacturer _value,
      $Res Function(_$_IngredientManufacturer) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? role = freezed,
    Object? roleElement = freezed,
    Object? manufacturer = null,
  }) {
    return _then(_$_IngredientManufacturer(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as Code?,
      roleElement: freezed == roleElement
          ? _value.roleElement
          : roleElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      manufacturer: null == manufacturer
          ? _value.manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as Reference,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_IngredientManufacturer extends _IngredientManufacturer {
  _$_IngredientManufacturer(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.role,
      @JsonKey(name: '_role') this.roleElement,
      required this.manufacturer})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_IngredientManufacturer.fromJson(Map<String, dynamic> json) =>
      _$$_IngredientManufacturerFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [role] The way in which this manufacturer is associated with the ingredient. For example whether it is a possible one (others allowed), or an exclusive authorized one for this ingredient. Note that this is not the manufacturing process role.;
  @override
  final Code? role;

  /// [roleElement] (_role): Extensions for role;
  @override
  @JsonKey(name: '_role')
  final Element? roleElement;

  /// [manufacturer] An organization that manufactures this ingredient.;
  @override
  final Reference manufacturer;

  @override
  String toString() {
    return 'IngredientManufacturer(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, role: $role, roleElement: $roleElement, manufacturer: $manufacturer)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_IngredientManufacturer &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.roleElement, roleElement) ||
                other.roleElement == roleElement) &&
            (identical(other.manufacturer, manufacturer) ||
                other.manufacturer == manufacturer));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      role,
      roleElement,
      manufacturer);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_IngredientManufacturerCopyWith<_$_IngredientManufacturer> get copyWith =>
      __$$_IngredientManufacturerCopyWithImpl<_$_IngredientManufacturer>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_IngredientManufacturerToJson(
      this,
    );
  }
}

abstract class _IngredientManufacturer extends IngredientManufacturer {
  factory _IngredientManufacturer(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final Code? role,
      @JsonKey(name: '_role') final Element? roleElement,
      required final Reference manufacturer}) = _$_IngredientManufacturer;
  _IngredientManufacturer._() : super._();

  factory _IngredientManufacturer.fromJson(Map<String, dynamic> json) =
      _$_IngredientManufacturer.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [role] The way in which this manufacturer is associated with the ingredient. For example whether it is a possible one (others allowed), or an exclusive authorized one for this ingredient. Note that this is not the manufacturing process role.;
  Code? get role;
  @override

  /// [roleElement] (_role): Extensions for role;
  @JsonKey(name: '_role')
  Element? get roleElement;
  @override

  /// [manufacturer] An organization that manufactures this ingredient.;
  Reference get manufacturer;
  @override
  @JsonKey(ignore: true)
  _$$_IngredientManufacturerCopyWith<_$_IngredientManufacturer> get copyWith =>
      throw _privateConstructorUsedError;
}

IngredientSubstance _$IngredientSubstanceFromJson(Map<String, dynamic> json) {
  return _IngredientSubstance.fromJson(json);
}

/// @nodoc
mixin _$IngredientSubstance {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [code] A code or full resource that represents the ingredient's substance.;
  CodeableReference get code => throw _privateConstructorUsedError;

  /// [strength] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. The allowed repetitions do not represent different strengths, but are different representations - mathematically equivalent - of a single strength.;
  List<IngredientStrength>? get strength => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $IngredientSubstanceCopyWith<IngredientSubstance> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IngredientSubstanceCopyWith<$Res> {
  factory $IngredientSubstanceCopyWith(
          IngredientSubstance value, $Res Function(IngredientSubstance) then) =
      _$IngredientSubstanceCopyWithImpl<$Res, IngredientSubstance>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference code,
      List<IngredientStrength>? strength});

  $CodeableReferenceCopyWith<$Res> get code;
}

/// @nodoc
class _$IngredientSubstanceCopyWithImpl<$Res, $Val extends IngredientSubstance>
    implements $IngredientSubstanceCopyWith<$Res> {
  _$IngredientSubstanceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = null,
    Object? strength = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
      strength: freezed == strength
          ? _value.strength
          : strength // ignore: cast_nullable_to_non_nullable
              as List<IngredientStrength>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res> get code {
    return $CodeableReferenceCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_IngredientSubstanceCopyWith<$Res>
    implements $IngredientSubstanceCopyWith<$Res> {
  factory _$$_IngredientSubstanceCopyWith(_$_IngredientSubstance value,
          $Res Function(_$_IngredientSubstance) then) =
      __$$_IngredientSubstanceCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference code,
      List<IngredientStrength>? strength});

  @override
  $CodeableReferenceCopyWith<$Res> get code;
}

/// @nodoc
class __$$_IngredientSubstanceCopyWithImpl<$Res>
    extends _$IngredientSubstanceCopyWithImpl<$Res, _$_IngredientSubstance>
    implements _$$_IngredientSubstanceCopyWith<$Res> {
  __$$_IngredientSubstanceCopyWithImpl(_$_IngredientSubstance _value,
      $Res Function(_$_IngredientSubstance) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = null,
    Object? strength = freezed,
  }) {
    return _then(_$_IngredientSubstance(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
      strength: freezed == strength
          ? _value._strength
          : strength // ignore: cast_nullable_to_non_nullable
              as List<IngredientStrength>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_IngredientSubstance extends _IngredientSubstance {
  _$_IngredientSubstance(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.code,
      final List<IngredientStrength>? strength})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _strength = strength,
        super._();

  factory _$_IngredientSubstance.fromJson(Map<String, dynamic> json) =>
      _$$_IngredientSubstanceFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [code] A code or full resource that represents the ingredient's substance.;
  @override
  final CodeableReference code;

  /// [strength] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. The allowed repetitions do not represent different strengths, but are different representations - mathematically equivalent - of a single strength.;
  final List<IngredientStrength>? _strength;

  /// [strength] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. The allowed repetitions do not represent different strengths, but are different representations - mathematically equivalent - of a single strength.;
  @override
  List<IngredientStrength>? get strength {
    final value = _strength;
    if (value == null) return null;
    if (_strength is EqualUnmodifiableListView) return _strength;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'IngredientSubstance(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, strength: $strength)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_IngredientSubstance &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.code, code) || other.code == code) &&
            const DeepCollectionEquality().equals(other._strength, _strength));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      code,
      const DeepCollectionEquality().hash(_strength));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_IngredientSubstanceCopyWith<_$_IngredientSubstance> get copyWith =>
      __$$_IngredientSubstanceCopyWithImpl<_$_IngredientSubstance>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_IngredientSubstanceToJson(
      this,
    );
  }
}

abstract class _IngredientSubstance extends IngredientSubstance {
  factory _IngredientSubstance(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final CodeableReference code,
      final List<IngredientStrength>? strength}) = _$_IngredientSubstance;
  _IngredientSubstance._() : super._();

  factory _IngredientSubstance.fromJson(Map<String, dynamic> json) =
      _$_IngredientSubstance.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [code] A code or full resource that represents the ingredient's substance.;
  CodeableReference get code;
  @override

  /// [strength] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. The allowed repetitions do not represent different strengths, but are different representations - mathematically equivalent - of a single strength.;
  List<IngredientStrength>? get strength;
  @override
  @JsonKey(ignore: true)
  _$$_IngredientSubstanceCopyWith<_$_IngredientSubstance> get copyWith =>
      throw _privateConstructorUsedError;
}

IngredientStrength _$IngredientStrengthFromJson(Map<String, dynamic> json) {
  return _IngredientStrength.fromJson(json);
}

/// @nodoc
mixin _$IngredientStrength {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [presentationRatio] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg').;
  Ratio? get presentationRatio => throw _privateConstructorUsedError;

  /// [presentationRatioRange] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg').;
  RatioRange? get presentationRatioRange => throw _privateConstructorUsedError;

  /// [textPresentation] A textual represention of either the whole of the presentation strength or a part of it - with the rest being in Strength.presentation as a ratio.;
  String? get textPresentation => throw _privateConstructorUsedError;

  /// [textPresentationElement] (_textPresentation): Extensions for textPresentation;
  @JsonKey(name: '_textPresentation')
  Element? get textPresentationElement => throw _privateConstructorUsedError;

  /// [concentrationRatio] The strength per unitary volume (or mass).;
  Ratio? get concentrationRatio => throw _privateConstructorUsedError;

  /// [concentrationRatioRange] The strength per unitary volume (or mass).;
  RatioRange? get concentrationRatioRange => throw _privateConstructorUsedError;

  /// [textConcentration] A textual represention of either the whole of the concentration strength or a part of it - with the rest being in Strength.concentration as a ratio.;
  String? get textConcentration => throw _privateConstructorUsedError;

  /// [textConcentrationElement] (_textConcentration): Extensions for textConcentration;
  @JsonKey(name: '_textConcentration')
  Element? get textConcentrationElement => throw _privateConstructorUsedError;

  /// [measurementPoint] For when strength is measured at a particular point or distance. There are products where strength is measured at a particular point. For example, the strength of the ingredient in some inhalers is measured at a particular position relative to the point of aerosolization.;
  String? get measurementPoint => throw _privateConstructorUsedError;

  /// [measurementPointElement] (_measurementPoint): Extensions for measurementPoint;
  @JsonKey(name: '_measurementPoint')
  Element? get measurementPointElement => throw _privateConstructorUsedError;

  /// [country] The country or countries for which the strength range applies.;
  List<CodeableConcept>? get country => throw _privateConstructorUsedError;

  /// [referenceStrength] Strength expressed in terms of a reference substance. For when the ingredient strength is additionally expressed as equivalent to the strength of some other closely related substance (e.g. salt vs. base). Reference strength represents the strength (quantitative composition) of the active moiety of the active substance. There are situations when the active substance and active moiety are different, therefore both a strength and a reference strength are needed.;
  List<IngredientReferenceStrength>? get referenceStrength =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $IngredientStrengthCopyWith<IngredientStrength> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IngredientStrengthCopyWith<$Res> {
  factory $IngredientStrengthCopyWith(
          IngredientStrength value, $Res Function(IngredientStrength) then) =
      _$IngredientStrengthCopyWithImpl<$Res, IngredientStrength>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Ratio? presentationRatio,
      RatioRange? presentationRatioRange,
      String? textPresentation,
      @JsonKey(name: '_textPresentation') Element? textPresentationElement,
      Ratio? concentrationRatio,
      RatioRange? concentrationRatioRange,
      String? textConcentration,
      @JsonKey(name: '_textConcentration') Element? textConcentrationElement,
      String? measurementPoint,
      @JsonKey(name: '_measurementPoint') Element? measurementPointElement,
      List<CodeableConcept>? country,
      List<IngredientReferenceStrength>? referenceStrength});

  $RatioCopyWith<$Res>? get presentationRatio;
  $RatioRangeCopyWith<$Res>? get presentationRatioRange;
  $ElementCopyWith<$Res>? get textPresentationElement;
  $RatioCopyWith<$Res>? get concentrationRatio;
  $RatioRangeCopyWith<$Res>? get concentrationRatioRange;
  $ElementCopyWith<$Res>? get textConcentrationElement;
  $ElementCopyWith<$Res>? get measurementPointElement;
}

/// @nodoc
class _$IngredientStrengthCopyWithImpl<$Res, $Val extends IngredientStrength>
    implements $IngredientStrengthCopyWith<$Res> {
  _$IngredientStrengthCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? presentationRatio = freezed,
    Object? presentationRatioRange = freezed,
    Object? textPresentation = freezed,
    Object? textPresentationElement = freezed,
    Object? concentrationRatio = freezed,
    Object? concentrationRatioRange = freezed,
    Object? textConcentration = freezed,
    Object? textConcentrationElement = freezed,
    Object? measurementPoint = freezed,
    Object? measurementPointElement = freezed,
    Object? country = freezed,
    Object? referenceStrength = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      presentationRatio: freezed == presentationRatio
          ? _value.presentationRatio
          : presentationRatio // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      presentationRatioRange: freezed == presentationRatioRange
          ? _value.presentationRatioRange
          : presentationRatioRange // ignore: cast_nullable_to_non_nullable
              as RatioRange?,
      textPresentation: freezed == textPresentation
          ? _value.textPresentation
          : textPresentation // ignore: cast_nullable_to_non_nullable
              as String?,
      textPresentationElement: freezed == textPresentationElement
          ? _value.textPresentationElement
          : textPresentationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      concentrationRatio: freezed == concentrationRatio
          ? _value.concentrationRatio
          : concentrationRatio // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      concentrationRatioRange: freezed == concentrationRatioRange
          ? _value.concentrationRatioRange
          : concentrationRatioRange // ignore: cast_nullable_to_non_nullable
              as RatioRange?,
      textConcentration: freezed == textConcentration
          ? _value.textConcentration
          : textConcentration // ignore: cast_nullable_to_non_nullable
              as String?,
      textConcentrationElement: freezed == textConcentrationElement
          ? _value.textConcentrationElement
          : textConcentrationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      measurementPoint: freezed == measurementPoint
          ? _value.measurementPoint
          : measurementPoint // ignore: cast_nullable_to_non_nullable
              as String?,
      measurementPointElement: freezed == measurementPointElement
          ? _value.measurementPointElement
          : measurementPointElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      country: freezed == country
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      referenceStrength: freezed == referenceStrength
          ? _value.referenceStrength
          : referenceStrength // ignore: cast_nullable_to_non_nullable
              as List<IngredientReferenceStrength>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RatioCopyWith<$Res>? get presentationRatio {
    if (_value.presentationRatio == null) {
      return null;
    }

    return $RatioCopyWith<$Res>(_value.presentationRatio!, (value) {
      return _then(_value.copyWith(presentationRatio: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RatioRangeCopyWith<$Res>? get presentationRatioRange {
    if (_value.presentationRatioRange == null) {
      return null;
    }

    return $RatioRangeCopyWith<$Res>(_value.presentationRatioRange!, (value) {
      return _then(_value.copyWith(presentationRatioRange: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get textPresentationElement {
    if (_value.textPresentationElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.textPresentationElement!, (value) {
      return _then(_value.copyWith(textPresentationElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RatioCopyWith<$Res>? get concentrationRatio {
    if (_value.concentrationRatio == null) {
      return null;
    }

    return $RatioCopyWith<$Res>(_value.concentrationRatio!, (value) {
      return _then(_value.copyWith(concentrationRatio: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RatioRangeCopyWith<$Res>? get concentrationRatioRange {
    if (_value.concentrationRatioRange == null) {
      return null;
    }

    return $RatioRangeCopyWith<$Res>(_value.concentrationRatioRange!, (value) {
      return _then(_value.copyWith(concentrationRatioRange: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get textConcentrationElement {
    if (_value.textConcentrationElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.textConcentrationElement!, (value) {
      return _then(_value.copyWith(textConcentrationElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get measurementPointElement {
    if (_value.measurementPointElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.measurementPointElement!, (value) {
      return _then(_value.copyWith(measurementPointElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_IngredientStrengthCopyWith<$Res>
    implements $IngredientStrengthCopyWith<$Res> {
  factory _$$_IngredientStrengthCopyWith(_$_IngredientStrength value,
          $Res Function(_$_IngredientStrength) then) =
      __$$_IngredientStrengthCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Ratio? presentationRatio,
      RatioRange? presentationRatioRange,
      String? textPresentation,
      @JsonKey(name: '_textPresentation') Element? textPresentationElement,
      Ratio? concentrationRatio,
      RatioRange? concentrationRatioRange,
      String? textConcentration,
      @JsonKey(name: '_textConcentration') Element? textConcentrationElement,
      String? measurementPoint,
      @JsonKey(name: '_measurementPoint') Element? measurementPointElement,
      List<CodeableConcept>? country,
      List<IngredientReferenceStrength>? referenceStrength});

  @override
  $RatioCopyWith<$Res>? get presentationRatio;
  @override
  $RatioRangeCopyWith<$Res>? get presentationRatioRange;
  @override
  $ElementCopyWith<$Res>? get textPresentationElement;
  @override
  $RatioCopyWith<$Res>? get concentrationRatio;
  @override
  $RatioRangeCopyWith<$Res>? get concentrationRatioRange;
  @override
  $ElementCopyWith<$Res>? get textConcentrationElement;
  @override
  $ElementCopyWith<$Res>? get measurementPointElement;
}

/// @nodoc
class __$$_IngredientStrengthCopyWithImpl<$Res>
    extends _$IngredientStrengthCopyWithImpl<$Res, _$_IngredientStrength>
    implements _$$_IngredientStrengthCopyWith<$Res> {
  __$$_IngredientStrengthCopyWithImpl(
      _$_IngredientStrength _value, $Res Function(_$_IngredientStrength) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? presentationRatio = freezed,
    Object? presentationRatioRange = freezed,
    Object? textPresentation = freezed,
    Object? textPresentationElement = freezed,
    Object? concentrationRatio = freezed,
    Object? concentrationRatioRange = freezed,
    Object? textConcentration = freezed,
    Object? textConcentrationElement = freezed,
    Object? measurementPoint = freezed,
    Object? measurementPointElement = freezed,
    Object? country = freezed,
    Object? referenceStrength = freezed,
  }) {
    return _then(_$_IngredientStrength(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      presentationRatio: freezed == presentationRatio
          ? _value.presentationRatio
          : presentationRatio // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      presentationRatioRange: freezed == presentationRatioRange
          ? _value.presentationRatioRange
          : presentationRatioRange // ignore: cast_nullable_to_non_nullable
              as RatioRange?,
      textPresentation: freezed == textPresentation
          ? _value.textPresentation
          : textPresentation // ignore: cast_nullable_to_non_nullable
              as String?,
      textPresentationElement: freezed == textPresentationElement
          ? _value.textPresentationElement
          : textPresentationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      concentrationRatio: freezed == concentrationRatio
          ? _value.concentrationRatio
          : concentrationRatio // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      concentrationRatioRange: freezed == concentrationRatioRange
          ? _value.concentrationRatioRange
          : concentrationRatioRange // ignore: cast_nullable_to_non_nullable
              as RatioRange?,
      textConcentration: freezed == textConcentration
          ? _value.textConcentration
          : textConcentration // ignore: cast_nullable_to_non_nullable
              as String?,
      textConcentrationElement: freezed == textConcentrationElement
          ? _value.textConcentrationElement
          : textConcentrationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      measurementPoint: freezed == measurementPoint
          ? _value.measurementPoint
          : measurementPoint // ignore: cast_nullable_to_non_nullable
              as String?,
      measurementPointElement: freezed == measurementPointElement
          ? _value.measurementPointElement
          : measurementPointElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      country: freezed == country
          ? _value._country
          : country // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      referenceStrength: freezed == referenceStrength
          ? _value._referenceStrength
          : referenceStrength // ignore: cast_nullable_to_non_nullable
              as List<IngredientReferenceStrength>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_IngredientStrength extends _IngredientStrength {
  _$_IngredientStrength(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.presentationRatio,
      this.presentationRatioRange,
      this.textPresentation,
      @JsonKey(name: '_textPresentation') this.textPresentationElement,
      this.concentrationRatio,
      this.concentrationRatioRange,
      this.textConcentration,
      @JsonKey(name: '_textConcentration') this.textConcentrationElement,
      this.measurementPoint,
      @JsonKey(name: '_measurementPoint') this.measurementPointElement,
      final List<CodeableConcept>? country,
      final List<IngredientReferenceStrength>? referenceStrength})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _country = country,
        _referenceStrength = referenceStrength,
        super._();

  factory _$_IngredientStrength.fromJson(Map<String, dynamic> json) =>
      _$$_IngredientStrengthFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [presentationRatio] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg').;
  @override
  final Ratio? presentationRatio;

  /// [presentationRatioRange] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg').;
  @override
  final RatioRange? presentationRatioRange;

  /// [textPresentation] A textual represention of either the whole of the presentation strength or a part of it - with the rest being in Strength.presentation as a ratio.;
  @override
  final String? textPresentation;

  /// [textPresentationElement] (_textPresentation): Extensions for textPresentation;
  @override
  @JsonKey(name: '_textPresentation')
  final Element? textPresentationElement;

  /// [concentrationRatio] The strength per unitary volume (or mass).;
  @override
  final Ratio? concentrationRatio;

  /// [concentrationRatioRange] The strength per unitary volume (or mass).;
  @override
  final RatioRange? concentrationRatioRange;

  /// [textConcentration] A textual represention of either the whole of the concentration strength or a part of it - with the rest being in Strength.concentration as a ratio.;
  @override
  final String? textConcentration;

  /// [textConcentrationElement] (_textConcentration): Extensions for textConcentration;
  @override
  @JsonKey(name: '_textConcentration')
  final Element? textConcentrationElement;

  /// [measurementPoint] For when strength is measured at a particular point or distance. There are products where strength is measured at a particular point. For example, the strength of the ingredient in some inhalers is measured at a particular position relative to the point of aerosolization.;
  @override
  final String? measurementPoint;

  /// [measurementPointElement] (_measurementPoint): Extensions for measurementPoint;
  @override
  @JsonKey(name: '_measurementPoint')
  final Element? measurementPointElement;

  /// [country] The country or countries for which the strength range applies.;
  final List<CodeableConcept>? _country;

  /// [country] The country or countries for which the strength range applies.;
  @override
  List<CodeableConcept>? get country {
    final value = _country;
    if (value == null) return null;
    if (_country is EqualUnmodifiableListView) return _country;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [referenceStrength] Strength expressed in terms of a reference substance. For when the ingredient strength is additionally expressed as equivalent to the strength of some other closely related substance (e.g. salt vs. base). Reference strength represents the strength (quantitative composition) of the active moiety of the active substance. There are situations when the active substance and active moiety are different, therefore both a strength and a reference strength are needed.;
  final List<IngredientReferenceStrength>? _referenceStrength;

  /// [referenceStrength] Strength expressed in terms of a reference substance. For when the ingredient strength is additionally expressed as equivalent to the strength of some other closely related substance (e.g. salt vs. base). Reference strength represents the strength (quantitative composition) of the active moiety of the active substance. There are situations when the active substance and active moiety are different, therefore both a strength and a reference strength are needed.;
  @override
  List<IngredientReferenceStrength>? get referenceStrength {
    final value = _referenceStrength;
    if (value == null) return null;
    if (_referenceStrength is EqualUnmodifiableListView)
      return _referenceStrength;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'IngredientStrength(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, presentationRatio: $presentationRatio, presentationRatioRange: $presentationRatioRange, textPresentation: $textPresentation, textPresentationElement: $textPresentationElement, concentrationRatio: $concentrationRatio, concentrationRatioRange: $concentrationRatioRange, textConcentration: $textConcentration, textConcentrationElement: $textConcentrationElement, measurementPoint: $measurementPoint, measurementPointElement: $measurementPointElement, country: $country, referenceStrength: $referenceStrength)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_IngredientStrength &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.presentationRatio, presentationRatio) ||
                other.presentationRatio == presentationRatio) &&
            (identical(other.presentationRatioRange, presentationRatioRange) ||
                other.presentationRatioRange == presentationRatioRange) &&
            (identical(other.textPresentation, textPresentation) ||
                other.textPresentation == textPresentation) &&
            (identical(
                    other.textPresentationElement, textPresentationElement) ||
                other.textPresentationElement == textPresentationElement) &&
            (identical(other.concentrationRatio, concentrationRatio) ||
                other.concentrationRatio == concentrationRatio) &&
            (identical(
                    other.concentrationRatioRange, concentrationRatioRange) ||
                other.concentrationRatioRange == concentrationRatioRange) &&
            (identical(other.textConcentration, textConcentration) ||
                other.textConcentration == textConcentration) &&
            (identical(
                    other.textConcentrationElement, textConcentrationElement) ||
                other.textConcentrationElement == textConcentrationElement) &&
            (identical(other.measurementPoint, measurementPoint) ||
                other.measurementPoint == measurementPoint) &&
            (identical(
                    other.measurementPointElement, measurementPointElement) ||
                other.measurementPointElement == measurementPointElement) &&
            const DeepCollectionEquality().equals(other._country, _country) &&
            const DeepCollectionEquality()
                .equals(other._referenceStrength, _referenceStrength));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      presentationRatio,
      presentationRatioRange,
      textPresentation,
      textPresentationElement,
      concentrationRatio,
      concentrationRatioRange,
      textConcentration,
      textConcentrationElement,
      measurementPoint,
      measurementPointElement,
      const DeepCollectionEquality().hash(_country),
      const DeepCollectionEquality().hash(_referenceStrength));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_IngredientStrengthCopyWith<_$_IngredientStrength> get copyWith =>
      __$$_IngredientStrengthCopyWithImpl<_$_IngredientStrength>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_IngredientStrengthToJson(
      this,
    );
  }
}

abstract class _IngredientStrength extends IngredientStrength {
  factory _IngredientStrength(
          {final String? id,
          @JsonKey(name: 'extension')
              final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final Ratio? presentationRatio,
          final RatioRange? presentationRatioRange,
          final String? textPresentation,
          @JsonKey(name: '_textPresentation')
              final Element? textPresentationElement,
          final Ratio? concentrationRatio,
          final RatioRange? concentrationRatioRange,
          final String? textConcentration,
          @JsonKey(name: '_textConcentration')
              final Element? textConcentrationElement,
          final String? measurementPoint,
          @JsonKey(name: '_measurementPoint')
              final Element? measurementPointElement,
          final List<CodeableConcept>? country,
          final List<IngredientReferenceStrength>? referenceStrength}) =
      _$_IngredientStrength;
  _IngredientStrength._() : super._();

  factory _IngredientStrength.fromJson(Map<String, dynamic> json) =
      _$_IngredientStrength.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [presentationRatio] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg').;
  Ratio? get presentationRatio;
  @override

  /// [presentationRatioRange] The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. Unit of presentation refers to the quantity that the item occurs in e.g. a strength per tablet size, perhaps 'per 20mg' (the size of the tablet). It is not generally normalized as a unitary unit, which would be 'per mg').;
  RatioRange? get presentationRatioRange;
  @override

  /// [textPresentation] A textual represention of either the whole of the presentation strength or a part of it - with the rest being in Strength.presentation as a ratio.;
  String? get textPresentation;
  @override

  /// [textPresentationElement] (_textPresentation): Extensions for textPresentation;
  @JsonKey(name: '_textPresentation')
  Element? get textPresentationElement;
  @override

  /// [concentrationRatio] The strength per unitary volume (or mass).;
  Ratio? get concentrationRatio;
  @override

  /// [concentrationRatioRange] The strength per unitary volume (or mass).;
  RatioRange? get concentrationRatioRange;
  @override

  /// [textConcentration] A textual represention of either the whole of the concentration strength or a part of it - with the rest being in Strength.concentration as a ratio.;
  String? get textConcentration;
  @override

  /// [textConcentrationElement] (_textConcentration): Extensions for textConcentration;
  @JsonKey(name: '_textConcentration')
  Element? get textConcentrationElement;
  @override

  /// [measurementPoint] For when strength is measured at a particular point or distance. There are products where strength is measured at a particular point. For example, the strength of the ingredient in some inhalers is measured at a particular position relative to the point of aerosolization.;
  String? get measurementPoint;
  @override

  /// [measurementPointElement] (_measurementPoint): Extensions for measurementPoint;
  @JsonKey(name: '_measurementPoint')
  Element? get measurementPointElement;
  @override

  /// [country] The country or countries for which the strength range applies.;
  List<CodeableConcept>? get country;
  @override

  /// [referenceStrength] Strength expressed in terms of a reference substance. For when the ingredient strength is additionally expressed as equivalent to the strength of some other closely related substance (e.g. salt vs. base). Reference strength represents the strength (quantitative composition) of the active moiety of the active substance. There are situations when the active substance and active moiety are different, therefore both a strength and a reference strength are needed.;
  List<IngredientReferenceStrength>? get referenceStrength;
  @override
  @JsonKey(ignore: true)
  _$$_IngredientStrengthCopyWith<_$_IngredientStrength> get copyWith =>
      throw _privateConstructorUsedError;
}

IngredientReferenceStrength _$IngredientReferenceStrengthFromJson(
    Map<String, dynamic> json) {
  return _IngredientReferenceStrength.fromJson(json);
}

/// @nodoc
mixin _$IngredientReferenceStrength {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [substance] Relevant reference substance.;
  CodeableReference? get substance => throw _privateConstructorUsedError;

  /// [strengthRatio] Strength expressed in terms of a reference substance.;
  Ratio? get strengthRatio => throw _privateConstructorUsedError;

  /// [strengthRatioRange] Strength expressed in terms of a reference substance.;
  RatioRange? get strengthRatioRange => throw _privateConstructorUsedError;

  /// [strengthQuantity] Strength expressed in terms of a reference substance.;
  Quantity? get strengthQuantity => throw _privateConstructorUsedError;

  /// [measurementPoint] For when strength is measured at a particular point or distance.;
  String? get measurementPoint => throw _privateConstructorUsedError;

  /// [measurementPointElement] (_measurementPoint): Extensions for measurementPoint;
  @JsonKey(name: '_measurementPoint')
  Element? get measurementPointElement => throw _privateConstructorUsedError;

  /// [country] The country or countries for which the strength range applies.;
  List<CodeableConcept>? get country => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $IngredientReferenceStrengthCopyWith<IngredientReferenceStrength>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IngredientReferenceStrengthCopyWith<$Res> {
  factory $IngredientReferenceStrengthCopyWith(
          IngredientReferenceStrength value,
          $Res Function(IngredientReferenceStrength) then) =
      _$IngredientReferenceStrengthCopyWithImpl<$Res,
          IngredientReferenceStrength>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? substance,
      Ratio? strengthRatio,
      RatioRange? strengthRatioRange,
      Quantity? strengthQuantity,
      String? measurementPoint,
      @JsonKey(name: '_measurementPoint') Element? measurementPointElement,
      List<CodeableConcept>? country});

  $CodeableReferenceCopyWith<$Res>? get substance;
  $RatioCopyWith<$Res>? get strengthRatio;
  $RatioRangeCopyWith<$Res>? get strengthRatioRange;
  $QuantityCopyWith<$Res>? get strengthQuantity;
  $ElementCopyWith<$Res>? get measurementPointElement;
}

/// @nodoc
class _$IngredientReferenceStrengthCopyWithImpl<$Res,
        $Val extends IngredientReferenceStrength>
    implements $IngredientReferenceStrengthCopyWith<$Res> {
  _$IngredientReferenceStrengthCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? substance = freezed,
    Object? strengthRatio = freezed,
    Object? strengthRatioRange = freezed,
    Object? strengthQuantity = freezed,
    Object? measurementPoint = freezed,
    Object? measurementPointElement = freezed,
    Object? country = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      substance: freezed == substance
          ? _value.substance
          : substance // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      strengthRatio: freezed == strengthRatio
          ? _value.strengthRatio
          : strengthRatio // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      strengthRatioRange: freezed == strengthRatioRange
          ? _value.strengthRatioRange
          : strengthRatioRange // ignore: cast_nullable_to_non_nullable
              as RatioRange?,
      strengthQuantity: freezed == strengthQuantity
          ? _value.strengthQuantity
          : strengthQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      measurementPoint: freezed == measurementPoint
          ? _value.measurementPoint
          : measurementPoint // ignore: cast_nullable_to_non_nullable
              as String?,
      measurementPointElement: freezed == measurementPointElement
          ? _value.measurementPointElement
          : measurementPointElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      country: freezed == country
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res>? get substance {
    if (_value.substance == null) {
      return null;
    }

    return $CodeableReferenceCopyWith<$Res>(_value.substance!, (value) {
      return _then(_value.copyWith(substance: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RatioCopyWith<$Res>? get strengthRatio {
    if (_value.strengthRatio == null) {
      return null;
    }

    return $RatioCopyWith<$Res>(_value.strengthRatio!, (value) {
      return _then(_value.copyWith(strengthRatio: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RatioRangeCopyWith<$Res>? get strengthRatioRange {
    if (_value.strengthRatioRange == null) {
      return null;
    }

    return $RatioRangeCopyWith<$Res>(_value.strengthRatioRange!, (value) {
      return _then(_value.copyWith(strengthRatioRange: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get strengthQuantity {
    if (_value.strengthQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.strengthQuantity!, (value) {
      return _then(_value.copyWith(strengthQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get measurementPointElement {
    if (_value.measurementPointElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.measurementPointElement!, (value) {
      return _then(_value.copyWith(measurementPointElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_IngredientReferenceStrengthCopyWith<$Res>
    implements $IngredientReferenceStrengthCopyWith<$Res> {
  factory _$$_IngredientReferenceStrengthCopyWith(
          _$_IngredientReferenceStrength value,
          $Res Function(_$_IngredientReferenceStrength) then) =
      __$$_IngredientReferenceStrengthCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? substance,
      Ratio? strengthRatio,
      RatioRange? strengthRatioRange,
      Quantity? strengthQuantity,
      String? measurementPoint,
      @JsonKey(name: '_measurementPoint') Element? measurementPointElement,
      List<CodeableConcept>? country});

  @override
  $CodeableReferenceCopyWith<$Res>? get substance;
  @override
  $RatioCopyWith<$Res>? get strengthRatio;
  @override
  $RatioRangeCopyWith<$Res>? get strengthRatioRange;
  @override
  $QuantityCopyWith<$Res>? get strengthQuantity;
  @override
  $ElementCopyWith<$Res>? get measurementPointElement;
}

/// @nodoc
class __$$_IngredientReferenceStrengthCopyWithImpl<$Res>
    extends _$IngredientReferenceStrengthCopyWithImpl<$Res,
        _$_IngredientReferenceStrength>
    implements _$$_IngredientReferenceStrengthCopyWith<$Res> {
  __$$_IngredientReferenceStrengthCopyWithImpl(
      _$_IngredientReferenceStrength _value,
      $Res Function(_$_IngredientReferenceStrength) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? substance = freezed,
    Object? strengthRatio = freezed,
    Object? strengthRatioRange = freezed,
    Object? strengthQuantity = freezed,
    Object? measurementPoint = freezed,
    Object? measurementPointElement = freezed,
    Object? country = freezed,
  }) {
    return _then(_$_IngredientReferenceStrength(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      substance: freezed == substance
          ? _value.substance
          : substance // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      strengthRatio: freezed == strengthRatio
          ? _value.strengthRatio
          : strengthRatio // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      strengthRatioRange: freezed == strengthRatioRange
          ? _value.strengthRatioRange
          : strengthRatioRange // ignore: cast_nullable_to_non_nullable
              as RatioRange?,
      strengthQuantity: freezed == strengthQuantity
          ? _value.strengthQuantity
          : strengthQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      measurementPoint: freezed == measurementPoint
          ? _value.measurementPoint
          : measurementPoint // ignore: cast_nullable_to_non_nullable
              as String?,
      measurementPointElement: freezed == measurementPointElement
          ? _value.measurementPointElement
          : measurementPointElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      country: freezed == country
          ? _value._country
          : country // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_IngredientReferenceStrength extends _IngredientReferenceStrength {
  _$_IngredientReferenceStrength(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.substance,
      this.strengthRatio,
      this.strengthRatioRange,
      this.strengthQuantity,
      this.measurementPoint,
      @JsonKey(name: '_measurementPoint') this.measurementPointElement,
      final List<CodeableConcept>? country})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _country = country,
        super._();

  factory _$_IngredientReferenceStrength.fromJson(Map<String, dynamic> json) =>
      _$$_IngredientReferenceStrengthFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [substance] Relevant reference substance.;
  @override
  final CodeableReference? substance;

  /// [strengthRatio] Strength expressed in terms of a reference substance.;
  @override
  final Ratio? strengthRatio;

  /// [strengthRatioRange] Strength expressed in terms of a reference substance.;
  @override
  final RatioRange? strengthRatioRange;

  /// [strengthQuantity] Strength expressed in terms of a reference substance.;
  @override
  final Quantity? strengthQuantity;

  /// [measurementPoint] For when strength is measured at a particular point or distance.;
  @override
  final String? measurementPoint;

  /// [measurementPointElement] (_measurementPoint): Extensions for measurementPoint;
  @override
  @JsonKey(name: '_measurementPoint')
  final Element? measurementPointElement;

  /// [country] The country or countries for which the strength range applies.;
  final List<CodeableConcept>? _country;

  /// [country] The country or countries for which the strength range applies.;
  @override
  List<CodeableConcept>? get country {
    final value = _country;
    if (value == null) return null;
    if (_country is EqualUnmodifiableListView) return _country;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'IngredientReferenceStrength(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, substance: $substance, strengthRatio: $strengthRatio, strengthRatioRange: $strengthRatioRange, strengthQuantity: $strengthQuantity, measurementPoint: $measurementPoint, measurementPointElement: $measurementPointElement, country: $country)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_IngredientReferenceStrength &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.substance, substance) ||
                other.substance == substance) &&
            (identical(other.strengthRatio, strengthRatio) ||
                other.strengthRatio == strengthRatio) &&
            (identical(other.strengthRatioRange, strengthRatioRange) ||
                other.strengthRatioRange == strengthRatioRange) &&
            (identical(other.strengthQuantity, strengthQuantity) ||
                other.strengthQuantity == strengthQuantity) &&
            (identical(other.measurementPoint, measurementPoint) ||
                other.measurementPoint == measurementPoint) &&
            (identical(
                    other.measurementPointElement, measurementPointElement) ||
                other.measurementPointElement == measurementPointElement) &&
            const DeepCollectionEquality().equals(other._country, _country));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      substance,
      strengthRatio,
      strengthRatioRange,
      strengthQuantity,
      measurementPoint,
      measurementPointElement,
      const DeepCollectionEquality().hash(_country));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_IngredientReferenceStrengthCopyWith<_$_IngredientReferenceStrength>
      get copyWith => __$$_IngredientReferenceStrengthCopyWithImpl<
          _$_IngredientReferenceStrength>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_IngredientReferenceStrengthToJson(
      this,
    );
  }
}

abstract class _IngredientReferenceStrength
    extends IngredientReferenceStrength {
  factory _IngredientReferenceStrength(
      {final String? id,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableReference? substance,
      final Ratio? strengthRatio,
      final RatioRange? strengthRatioRange,
      final Quantity? strengthQuantity,
      final String? measurementPoint,
      @JsonKey(name: '_measurementPoint')
          final Element? measurementPointElement,
      final List<CodeableConcept>? country}) = _$_IngredientReferenceStrength;
  _IngredientReferenceStrength._() : super._();

  factory _IngredientReferenceStrength.fromJson(Map<String, dynamic> json) =
      _$_IngredientReferenceStrength.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [substance] Relevant reference substance.;
  CodeableReference? get substance;
  @override

  /// [strengthRatio] Strength expressed in terms of a reference substance.;
  Ratio? get strengthRatio;
  @override

  /// [strengthRatioRange] Strength expressed in terms of a reference substance.;
  RatioRange? get strengthRatioRange;
  @override

  /// [strengthQuantity] Strength expressed in terms of a reference substance.;
  Quantity? get strengthQuantity;
  @override

  /// [measurementPoint] For when strength is measured at a particular point or distance.;
  String? get measurementPoint;
  @override

  /// [measurementPointElement] (_measurementPoint): Extensions for measurementPoint;
  @JsonKey(name: '_measurementPoint')
  Element? get measurementPointElement;
  @override

  /// [country] The country or countries for which the strength range applies.;
  List<CodeableConcept>? get country;
  @override
  @JsonKey(ignore: true)
  _$$_IngredientReferenceStrengthCopyWith<_$_IngredientReferenceStrength>
      get copyWith => throw _privateConstructorUsedError;
}

ClinicalUseDefinition _$ClinicalUseDefinitionFromJson(
    Map<String, dynamic> json) {
  return _ClinicalUseDefinition.fromJson(json);
}

/// @nodoc
mixin _$ClinicalUseDefinition {
  /// [resourceType] This is a ClinicalUseDefinition resource;
  R4ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  String? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.;
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] (_language): Extensions for language;
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] Business identifier for this issue.;
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [type] indication | contraindication | interaction | undesirable-effect | warning.;
  Code? get type => throw _privateConstructorUsedError;

  /// [typeElement] (_type): Extensions for type;
  @JsonKey(name: '_type')
  Element? get typeElement => throw _privateConstructorUsedError;

  /// [category] A categorisation of the issue, primarily for dividing warnings into subject heading areas such as "Pregnancy and Lactation", "Overdose", "Effects on Ability to Drive and Use Machines".;
  List<CodeableConcept>? get category => throw _privateConstructorUsedError;

  /// [subject] The medication or procedure for which this is an indication.;
  List<Reference>? get subject => throw _privateConstructorUsedError;

  /// [status] Whether this is a current issue or one that has been retired etc.;
  CodeableConcept? get status => throw _privateConstructorUsedError;

  /// [contraindication] Specifics for when this is a contraindication.;
  ClinicalUseDefinitionContraindication? get contraindication =>
      throw _privateConstructorUsedError;

  /// [indication] Specifics for when this is an indication.;
  ClinicalUseDefinitionIndication? get indication =>
      throw _privateConstructorUsedError;

  /// [interaction] Specifics for when this is an interaction.;
  ClinicalUseDefinitionInteraction? get interaction =>
      throw _privateConstructorUsedError;

  /// [population] The population group to which this applies.;
  List<Reference>? get population => throw _privateConstructorUsedError;

  /// [undesirableEffect] Describe the possible undesirable effects (negative outcomes) from the use of the medicinal product as treatment.;
  ClinicalUseDefinitionUndesirableEffect? get undesirableEffect =>
      throw _privateConstructorUsedError;

  /// [warning] A critical piece of information about environmental, health or physical risks or hazards that serve as caution to the user. For example 'Do not operate heavy machinery', 'May cause drowsiness', or 'Get medical advice/attention if you feel unwell'.;
  ClinicalUseDefinitionWarning? get warning =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ClinicalUseDefinitionCopyWith<ClinicalUseDefinition> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClinicalUseDefinitionCopyWith<$Res> {
  factory $ClinicalUseDefinitionCopyWith(ClinicalUseDefinition value,
          $Res Function(ClinicalUseDefinition) then) =
      _$ClinicalUseDefinitionCopyWithImpl<$Res, ClinicalUseDefinition>;
  @useResult
  $Res call(
      {R4ResourceType resourceType,
      String? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      Code? type,
      @JsonKey(name: '_type') Element? typeElement,
      List<CodeableConcept>? category,
      List<Reference>? subject,
      CodeableConcept? status,
      ClinicalUseDefinitionContraindication? contraindication,
      ClinicalUseDefinitionIndication? indication,
      ClinicalUseDefinitionInteraction? interaction,
      List<Reference>? population,
      ClinicalUseDefinitionUndesirableEffect? undesirableEffect,
      ClinicalUseDefinitionWarning? warning});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $ElementCopyWith<$Res>? get typeElement;
  $CodeableConceptCopyWith<$Res>? get status;
  $ClinicalUseDefinitionContraindicationCopyWith<$Res>? get contraindication;
  $ClinicalUseDefinitionIndicationCopyWith<$Res>? get indication;
  $ClinicalUseDefinitionInteractionCopyWith<$Res>? get interaction;
  $ClinicalUseDefinitionUndesirableEffectCopyWith<$Res>? get undesirableEffect;
  $ClinicalUseDefinitionWarningCopyWith<$Res>? get warning;
}

/// @nodoc
class _$ClinicalUseDefinitionCopyWithImpl<$Res,
        $Val extends ClinicalUseDefinition>
    implements $ClinicalUseDefinitionCopyWith<$Res> {
  _$ClinicalUseDefinitionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = freezed,
    Object? typeElement = freezed,
    Object? category = freezed,
    Object? subject = freezed,
    Object? status = freezed,
    Object? contraindication = freezed,
    Object? indication = freezed,
    Object? interaction = freezed,
    Object? population = freezed,
    Object? undesirableEffect = freezed,
    Object? warning = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R4ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as Code?,
      typeElement: freezed == typeElement
          ? _value.typeElement
          : typeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      subject: freezed == subject
          ? _value.subject
          : subject // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      contraindication: freezed == contraindication
          ? _value.contraindication
          : contraindication // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionContraindication?,
      indication: freezed == indication
          ? _value.indication
          : indication // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionIndication?,
      interaction: freezed == interaction
          ? _value.interaction
          : interaction // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionInteraction?,
      population: freezed == population
          ? _value.population
          : population // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      undesirableEffect: freezed == undesirableEffect
          ? _value.undesirableEffect
          : undesirableEffect // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionUndesirableEffect?,
      warning: freezed == warning
          ? _value.warning
          : warning // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionWarning?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get typeElement {
    if (_value.typeElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.typeElement!, (value) {
      return _then(_value.copyWith(typeElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ClinicalUseDefinitionContraindicationCopyWith<$Res>? get contraindication {
    if (_value.contraindication == null) {
      return null;
    }

    return $ClinicalUseDefinitionContraindicationCopyWith<$Res>(
        _value.contraindication!, (value) {
      return _then(_value.copyWith(contraindication: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ClinicalUseDefinitionIndicationCopyWith<$Res>? get indication {
    if (_value.indication == null) {
      return null;
    }

    return $ClinicalUseDefinitionIndicationCopyWith<$Res>(_value.indication!,
        (value) {
      return _then(_value.copyWith(indication: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ClinicalUseDefinitionInteractionCopyWith<$Res>? get interaction {
    if (_value.interaction == null) {
      return null;
    }

    return $ClinicalUseDefinitionInteractionCopyWith<$Res>(_value.interaction!,
        (value) {
      return _then(_value.copyWith(interaction: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ClinicalUseDefinitionUndesirableEffectCopyWith<$Res>? get undesirableEffect {
    if (_value.undesirableEffect == null) {
      return null;
    }

    return $ClinicalUseDefinitionUndesirableEffectCopyWith<$Res>(
        _value.undesirableEffect!, (value) {
      return _then(_value.copyWith(undesirableEffect: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ClinicalUseDefinitionWarningCopyWith<$Res>? get warning {
    if (_value.warning == null) {
      return null;
    }

    return $ClinicalUseDefinitionWarningCopyWith<$Res>(_value.warning!,
        (value) {
      return _then(_value.copyWith(warning: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ClinicalUseDefinitionCopyWith<$Res>
    implements $ClinicalUseDefinitionCopyWith<$Res> {
  factory _$$_ClinicalUseDefinitionCopyWith(_$_ClinicalUseDefinition value,
          $Res Function(_$_ClinicalUseDefinition) then) =
      __$$_ClinicalUseDefinitionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {R4ResourceType resourceType,
      String? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      Code? type,
      @JsonKey(name: '_type') Element? typeElement,
      List<CodeableConcept>? category,
      List<Reference>? subject,
      CodeableConcept? status,
      ClinicalUseDefinitionContraindication? contraindication,
      ClinicalUseDefinitionIndication? indication,
      ClinicalUseDefinitionInteraction? interaction,
      List<Reference>? population,
      ClinicalUseDefinitionUndesirableEffect? undesirableEffect,
      ClinicalUseDefinitionWarning? warning});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $ElementCopyWith<$Res>? get typeElement;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
  @override
  $ClinicalUseDefinitionContraindicationCopyWith<$Res>? get contraindication;
  @override
  $ClinicalUseDefinitionIndicationCopyWith<$Res>? get indication;
  @override
  $ClinicalUseDefinitionInteractionCopyWith<$Res>? get interaction;
  @override
  $ClinicalUseDefinitionUndesirableEffectCopyWith<$Res>? get undesirableEffect;
  @override
  $ClinicalUseDefinitionWarningCopyWith<$Res>? get warning;
}

/// @nodoc
class __$$_ClinicalUseDefinitionCopyWithImpl<$Res>
    extends _$ClinicalUseDefinitionCopyWithImpl<$Res, _$_ClinicalUseDefinition>
    implements _$$_ClinicalUseDefinitionCopyWith<$Res> {
  __$$_ClinicalUseDefinitionCopyWithImpl(_$_ClinicalUseDefinition _value,
      $Res Function(_$_ClinicalUseDefinition) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = freezed,
    Object? typeElement = freezed,
    Object? category = freezed,
    Object? subject = freezed,
    Object? status = freezed,
    Object? contraindication = freezed,
    Object? indication = freezed,
    Object? interaction = freezed,
    Object? population = freezed,
    Object? undesirableEffect = freezed,
    Object? warning = freezed,
  }) {
    return _then(_$_ClinicalUseDefinition(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R4ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as Code?,
      typeElement: freezed == typeElement
          ? _value.typeElement
          : typeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      category: freezed == category
          ? _value._category
          : category // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      subject: freezed == subject
          ? _value._subject
          : subject // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      contraindication: freezed == contraindication
          ? _value.contraindication
          : contraindication // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionContraindication?,
      indication: freezed == indication
          ? _value.indication
          : indication // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionIndication?,
      interaction: freezed == interaction
          ? _value.interaction
          : interaction // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionInteraction?,
      population: freezed == population
          ? _value._population
          : population // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      undesirableEffect: freezed == undesirableEffect
          ? _value.undesirableEffect
          : undesirableEffect // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionUndesirableEffect?,
      warning: freezed == warning
          ? _value.warning
          : warning // ignore: cast_nullable_to_non_nullable
              as ClinicalUseDefinitionWarning?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ClinicalUseDefinition extends _ClinicalUseDefinition {
  _$_ClinicalUseDefinition(
      {this.resourceType = R4ResourceType.ClinicalUseDefinition,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules') this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language') this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      this.type,
      @JsonKey(name: '_type') this.typeElement,
      final List<CodeableConcept>? category,
      final List<Reference>? subject,
      this.status,
      this.contraindication,
      this.indication,
      this.interaction,
      final List<Reference>? population,
      this.undesirableEffect,
      this.warning})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _category = category,
        _subject = subject,
        _population = population,
        super._();

  factory _$_ClinicalUseDefinition.fromJson(Map<String, dynamic> json) =>
      _$$_ClinicalUseDefinitionFromJson(json);

  /// [resourceType] This is a ClinicalUseDefinition resource;
  @override
  @JsonKey()
  final R4ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  @override
  final String? id;

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.;
  @override
  final Code? language;

  /// [languageElement] (_language): Extensions for language;
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] Business identifier for this issue.;
  final List<Identifier>? _identifier;

  /// [identifier] Business identifier for this issue.;
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] indication | contraindication | interaction | undesirable-effect | warning.;
  @override
  final Code? type;

  /// [typeElement] (_type): Extensions for type;
  @override
  @JsonKey(name: '_type')
  final Element? typeElement;

  /// [category] A categorisation of the issue, primarily for dividing warnings into subject heading areas such as "Pregnancy and Lactation", "Overdose", "Effects on Ability to Drive and Use Machines".;
  final List<CodeableConcept>? _category;

  /// [category] A categorisation of the issue, primarily for dividing warnings into subject heading areas such as "Pregnancy and Lactation", "Overdose", "Effects on Ability to Drive and Use Machines".;
  @override
  List<CodeableConcept>? get category {
    final value = _category;
    if (value == null) return null;
    if (_category is EqualUnmodifiableListView) return _category;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [subject] The medication or procedure for which this is an indication.;
  final List<Reference>? _subject;

  /// [subject] The medication or procedure for which this is an indication.;
  @override
  List<Reference>? get subject {
    final value = _subject;
    if (value == null) return null;
    if (_subject is EqualUnmodifiableListView) return _subject;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [status] Whether this is a current issue or one that has been retired etc.;
  @override
  final CodeableConcept? status;

  /// [contraindication] Specifics for when this is a contraindication.;
  @override
  final ClinicalUseDefinitionContraindication? contraindication;

  /// [indication] Specifics for when this is an indication.;
  @override
  final ClinicalUseDefinitionIndication? indication;

  /// [interaction] Specifics for when this is an interaction.;
  @override
  final ClinicalUseDefinitionInteraction? interaction;

  /// [population] The population group to which this applies.;
  final List<Reference>? _population;

  /// [population] The population group to which this applies.;
  @override
  List<Reference>? get population {
    final value = _population;
    if (value == null) return null;
    if (_population is EqualUnmodifiableListView) return _population;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [undesirableEffect] Describe the possible undesirable effects (negative outcomes) from the use of the medicinal product as treatment.;
  @override
  final ClinicalUseDefinitionUndesirableEffect? undesirableEffect;

  /// [warning] A critical piece of information about environmental, health or physical risks or hazards that serve as caution to the user. For example 'Do not operate heavy machinery', 'May cause drowsiness', or 'Get medical advice/attention if you feel unwell'.;
  @override
  final ClinicalUseDefinitionWarning? warning;

  @override
  String toString() {
    return 'ClinicalUseDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, type: $type, typeElement: $typeElement, category: $category, subject: $subject, status: $status, contraindication: $contraindication, indication: $indication, interaction: $interaction, population: $population, undesirableEffect: $undesirableEffect, warning: $warning)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ClinicalUseDefinition &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.typeElement, typeElement) ||
                other.typeElement == typeElement) &&
            const DeepCollectionEquality().equals(other._category, _category) &&
            const DeepCollectionEquality().equals(other._subject, _subject) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.contraindication, contraindication) ||
                other.contraindication == contraindication) &&
            (identical(other.indication, indication) ||
                other.indication == indication) &&
            (identical(other.interaction, interaction) ||
                other.interaction == interaction) &&
            const DeepCollectionEquality()
                .equals(other._population, _population) &&
            (identical(other.undesirableEffect, undesirableEffect) ||
                other.undesirableEffect == undesirableEffect) &&
            (identical(other.warning, warning) || other.warning == warning));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_identifier),
        type,
        typeElement,
        const DeepCollectionEquality().hash(_category),
        const DeepCollectionEquality().hash(_subject),
        status,
        contraindication,
        indication,
        interaction,
        const DeepCollectionEquality().hash(_population),
        undesirableEffect,
        warning
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ClinicalUseDefinitionCopyWith<_$_ClinicalUseDefinition> get copyWith =>
      __$$_ClinicalUseDefinitionCopyWithImpl<_$_ClinicalUseDefinition>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ClinicalUseDefinitionToJson(
      this,
    );
  }
}

abstract class _ClinicalUseDefinition extends ClinicalUseDefinition {
  factory _ClinicalUseDefinition(
      {final R4ResourceType resourceType,
      final String? id,
      final Meta? meta,
      final FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') final Element? implicitRulesElement,
      final Code? language,
      @JsonKey(name: '_language') final Element? languageElement,
      final Narrative? text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      final Code? type,
      @JsonKey(name: '_type') final Element? typeElement,
      final List<CodeableConcept>? category,
      final List<Reference>? subject,
      final CodeableConcept? status,
      final ClinicalUseDefinitionContraindication? contraindication,
      final ClinicalUseDefinitionIndication? indication,
      final ClinicalUseDefinitionInteraction? interaction,
      final List<Reference>? population,
      final ClinicalUseDefinitionUndesirableEffect? undesirableEffect,
      final ClinicalUseDefinitionWarning? warning}) = _$_ClinicalUseDefinition;
  _ClinicalUseDefinition._() : super._();

  factory _ClinicalUseDefinition.fromJson(Map<String, dynamic> json) =
      _$_ClinicalUseDefinition.fromJson;

  @override

  /// [resourceType] This is a ClinicalUseDefinition resource;
  R4ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  String? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.;
  Code? get language;
  @override

  /// [languageElement] (_language): Extensions for language;
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  List<Resource>? get contained;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] Business identifier for this issue.;
  List<Identifier>? get identifier;
  @override

  /// [type] indication | contraindication | interaction | undesirable-effect | warning.;
  Code? get type;
  @override

  /// [typeElement] (_type): Extensions for type;
  @JsonKey(name: '_type')
  Element? get typeElement;
  @override

  /// [category] A categorisation of the issue, primarily for dividing warnings into subject heading areas such as "Pregnancy and Lactation", "Overdose", "Effects on Ability to Drive and Use Machines".;
  List<CodeableConcept>? get category;
  @override

  /// [subject] The medication or procedure for which this is an indication.;
  List<Reference>? get subject;
  @override

  /// [status] Whether this is a current issue or one that has been retired etc.;
  CodeableConcept? get status;
  @override

  /// [contraindication] Specifics for when this is a contraindication.;
  ClinicalUseDefinitionContraindication? get contraindication;
  @override

  /// [indication] Specifics for when this is an indication.;
  ClinicalUseDefinitionIndication? get indication;
  @override

  /// [interaction] Specifics for when this is an interaction.;
  ClinicalUseDefinitionInteraction? get interaction;
  @override

  /// [population] The population group to which this applies.;
  List<Reference>? get population;
  @override

  /// [undesirableEffect] Describe the possible undesirable effects (negative outcomes) from the use of the medicinal product as treatment.;
  ClinicalUseDefinitionUndesirableEffect? get undesirableEffect;
  @override

  /// [warning] A critical piece of information about environmental, health or physical risks or hazards that serve as caution to the user. For example 'Do not operate heavy machinery', 'May cause drowsiness', or 'Get medical advice/attention if you feel unwell'.;
  ClinicalUseDefinitionWarning? get warning;
  @override
  @JsonKey(ignore: true)
  _$$_ClinicalUseDefinitionCopyWith<_$_ClinicalUseDefinition> get copyWith =>
      throw _privateConstructorUsedError;
}

ClinicalUseDefinitionContraindication
    _$ClinicalUseDefinitionContraindicationFromJson(Map<String, dynamic> json) {
  return _ClinicalUseDefinitionContraindication.fromJson(json);
}

/// @nodoc
mixin _$ClinicalUseDefinitionContraindication {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [diseaseSymptomProcedure] The situation that is being documented as contraindicating against this item.;
  CodeableReference? get diseaseSymptomProcedure =>
      throw _privateConstructorUsedError;

  /// [diseaseStatus] The status of the disease or symptom for the contraindication, for example "chronic" or "metastatic".;
  CodeableReference? get diseaseStatus => throw _privateConstructorUsedError;

  /// [comorbidity] A comorbidity (concurrent condition) or coinfection.;
  List<CodeableReference>? get comorbidity =>
      throw _privateConstructorUsedError;

  /// [indication] The indication which this is a contraidication for.;
  List<Reference>? get indication => throw _privateConstructorUsedError;

  /// [otherTherapy] Information about the use of the medicinal product in relation to other therapies described as part of the contraindication.;
  List<ClinicalUseDefinitionOtherTherapy>? get otherTherapy =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ClinicalUseDefinitionContraindicationCopyWith<
          ClinicalUseDefinitionContraindication>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClinicalUseDefinitionContraindicationCopyWith<$Res> {
  factory $ClinicalUseDefinitionContraindicationCopyWith(
          ClinicalUseDefinitionContraindication value,
          $Res Function(ClinicalUseDefinitionContraindication) then) =
      _$ClinicalUseDefinitionContraindicationCopyWithImpl<$Res,
          ClinicalUseDefinitionContraindication>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? diseaseSymptomProcedure,
      CodeableReference? diseaseStatus,
      List<CodeableReference>? comorbidity,
      List<Reference>? indication,
      List<ClinicalUseDefinitionOtherTherapy>? otherTherapy});

  $CodeableReferenceCopyWith<$Res>? get diseaseSymptomProcedure;
  $CodeableReferenceCopyWith<$Res>? get diseaseStatus;
}

/// @nodoc
class _$ClinicalUseDefinitionContraindicationCopyWithImpl<$Res,
        $Val extends ClinicalUseDefinitionContraindication>
    implements $ClinicalUseDefinitionContraindicationCopyWith<$Res> {
  _$ClinicalUseDefinitionContraindicationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? diseaseSymptomProcedure = freezed,
    Object? diseaseStatus = freezed,
    Object? comorbidity = freezed,
    Object? indication = freezed,
    Object? otherTherapy = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      diseaseSymptomProcedure: freezed == diseaseSymptomProcedure
          ? _value.diseaseSymptomProcedure
          : diseaseSymptomProcedure // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      diseaseStatus: freezed == diseaseStatus
          ? _value.diseaseStatus
          : diseaseStatus // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      comorbidity: freezed == comorbidity
          ? _value.comorbidity
          : comorbidity // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      indication: freezed == indication
          ? _value.indication
          : indication // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      otherTherapy: freezed == otherTherapy
          ? _value.otherTherapy
          : otherTherapy // ignore: cast_nullable_to_non_nullable
              as List<ClinicalUseDefinitionOtherTherapy>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res>? get diseaseSymptomProcedure {
    if (_value.diseaseSymptomProcedure == null) {
      return null;
    }

    return $CodeableReferenceCopyWith<$Res>(_value.diseaseSymptomProcedure!,
        (value) {
      return _then(_value.copyWith(diseaseSymptomProcedure: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res>? get diseaseStatus {
    if (_value.diseaseStatus == null) {
      return null;
    }

    return $CodeableReferenceCopyWith<$Res>(_value.diseaseStatus!, (value) {
      return _then(_value.copyWith(diseaseStatus: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ClinicalUseDefinitionContraindicationCopyWith<$Res>
    implements $ClinicalUseDefinitionContraindicationCopyWith<$Res> {
  factory _$$_ClinicalUseDefinitionContraindicationCopyWith(
          _$_ClinicalUseDefinitionContraindication value,
          $Res Function(_$_ClinicalUseDefinitionContraindication) then) =
      __$$_ClinicalUseDefinitionContraindicationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? diseaseSymptomProcedure,
      CodeableReference? diseaseStatus,
      List<CodeableReference>? comorbidity,
      List<Reference>? indication,
      List<ClinicalUseDefinitionOtherTherapy>? otherTherapy});

  @override
  $CodeableReferenceCopyWith<$Res>? get diseaseSymptomProcedure;
  @override
  $CodeableReferenceCopyWith<$Res>? get diseaseStatus;
}

/// @nodoc
class __$$_ClinicalUseDefinitionContraindicationCopyWithImpl<$Res>
    extends _$ClinicalUseDefinitionContraindicationCopyWithImpl<$Res,
        _$_ClinicalUseDefinitionContraindication>
    implements _$$_ClinicalUseDefinitionContraindicationCopyWith<$Res> {
  __$$_ClinicalUseDefinitionContraindicationCopyWithImpl(
      _$_ClinicalUseDefinitionContraindication _value,
      $Res Function(_$_ClinicalUseDefinitionContraindication) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? diseaseSymptomProcedure = freezed,
    Object? diseaseStatus = freezed,
    Object? comorbidity = freezed,
    Object? indication = freezed,
    Object? otherTherapy = freezed,
  }) {
    return _then(_$_ClinicalUseDefinitionContraindication(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      diseaseSymptomProcedure: freezed == diseaseSymptomProcedure
          ? _value.diseaseSymptomProcedure
          : diseaseSymptomProcedure // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      diseaseStatus: freezed == diseaseStatus
          ? _value.diseaseStatus
          : diseaseStatus // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      comorbidity: freezed == comorbidity
          ? _value._comorbidity
          : comorbidity // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      indication: freezed == indication
          ? _value._indication
          : indication // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      otherTherapy: freezed == otherTherapy
          ? _value._otherTherapy
          : otherTherapy // ignore: cast_nullable_to_non_nullable
              as List<ClinicalUseDefinitionOtherTherapy>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ClinicalUseDefinitionContraindication
    extends _ClinicalUseDefinitionContraindication {
  _$_ClinicalUseDefinitionContraindication(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.diseaseSymptomProcedure,
      this.diseaseStatus,
      final List<CodeableReference>? comorbidity,
      final List<Reference>? indication,
      final List<ClinicalUseDefinitionOtherTherapy>? otherTherapy})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _comorbidity = comorbidity,
        _indication = indication,
        _otherTherapy = otherTherapy,
        super._();

  factory _$_ClinicalUseDefinitionContraindication.fromJson(
          Map<String, dynamic> json) =>
      _$$_ClinicalUseDefinitionContraindicationFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [diseaseSymptomProcedure] The situation that is being documented as contraindicating against this item.;
  @override
  final CodeableReference? diseaseSymptomProcedure;

  /// [diseaseStatus] The status of the disease or symptom for the contraindication, for example "chronic" or "metastatic".;
  @override
  final CodeableReference? diseaseStatus;

  /// [comorbidity] A comorbidity (concurrent condition) or coinfection.;
  final List<CodeableReference>? _comorbidity;

  /// [comorbidity] A comorbidity (concurrent condition) or coinfection.;
  @override
  List<CodeableReference>? get comorbidity {
    final value = _comorbidity;
    if (value == null) return null;
    if (_comorbidity is EqualUnmodifiableListView) return _comorbidity;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [indication] The indication which this is a contraidication for.;
  final List<Reference>? _indication;

  /// [indication] The indication which this is a contraidication for.;
  @override
  List<Reference>? get indication {
    final value = _indication;
    if (value == null) return null;
    if (_indication is EqualUnmodifiableListView) return _indication;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [otherTherapy] Information about the use of the medicinal product in relation to other therapies described as part of the contraindication.;
  final List<ClinicalUseDefinitionOtherTherapy>? _otherTherapy;

  /// [otherTherapy] Information about the use of the medicinal product in relation to other therapies described as part of the contraindication.;
  @override
  List<ClinicalUseDefinitionOtherTherapy>? get otherTherapy {
    final value = _otherTherapy;
    if (value == null) return null;
    if (_otherTherapy is EqualUnmodifiableListView) return _otherTherapy;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ClinicalUseDefinitionContraindication(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, diseaseSymptomProcedure: $diseaseSymptomProcedure, diseaseStatus: $diseaseStatus, comorbidity: $comorbidity, indication: $indication, otherTherapy: $otherTherapy)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ClinicalUseDefinitionContraindication &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(
                    other.diseaseSymptomProcedure, diseaseSymptomProcedure) ||
                other.diseaseSymptomProcedure == diseaseSymptomProcedure) &&
            (identical(other.diseaseStatus, diseaseStatus) ||
                other.diseaseStatus == diseaseStatus) &&
            const DeepCollectionEquality()
                .equals(other._comorbidity, _comorbidity) &&
            const DeepCollectionEquality()
                .equals(other._indication, _indication) &&
            const DeepCollectionEquality()
                .equals(other._otherTherapy, _otherTherapy));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      diseaseSymptomProcedure,
      diseaseStatus,
      const DeepCollectionEquality().hash(_comorbidity),
      const DeepCollectionEquality().hash(_indication),
      const DeepCollectionEquality().hash(_otherTherapy));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ClinicalUseDefinitionContraindicationCopyWith<
          _$_ClinicalUseDefinitionContraindication>
      get copyWith => __$$_ClinicalUseDefinitionContraindicationCopyWithImpl<
          _$_ClinicalUseDefinitionContraindication>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ClinicalUseDefinitionContraindicationToJson(
      this,
    );
  }
}

abstract class _ClinicalUseDefinitionContraindication
    extends ClinicalUseDefinitionContraindication {
  factory _ClinicalUseDefinitionContraindication(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableReference? diseaseSymptomProcedure,
          final CodeableReference? diseaseStatus,
          final List<CodeableReference>? comorbidity,
          final List<Reference>? indication,
          final List<ClinicalUseDefinitionOtherTherapy>? otherTherapy}) =
      _$_ClinicalUseDefinitionContraindication;
  _ClinicalUseDefinitionContraindication._() : super._();

  factory _ClinicalUseDefinitionContraindication.fromJson(
          Map<String, dynamic> json) =
      _$_ClinicalUseDefinitionContraindication.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [diseaseSymptomProcedure] The situation that is being documented as contraindicating against this item.;
  CodeableReference? get diseaseSymptomProcedure;
  @override

  /// [diseaseStatus] The status of the disease or symptom for the contraindication, for example "chronic" or "metastatic".;
  CodeableReference? get diseaseStatus;
  @override

  /// [comorbidity] A comorbidity (concurrent condition) or coinfection.;
  List<CodeableReference>? get comorbidity;
  @override

  /// [indication] The indication which this is a contraidication for.;
  List<Reference>? get indication;
  @override

  /// [otherTherapy] Information about the use of the medicinal product in relation to other therapies described as part of the contraindication.;
  List<ClinicalUseDefinitionOtherTherapy>? get otherTherapy;
  @override
  @JsonKey(ignore: true)
  _$$_ClinicalUseDefinitionContraindicationCopyWith<
          _$_ClinicalUseDefinitionContraindication>
      get copyWith => throw _privateConstructorUsedError;
}

ClinicalUseDefinitionOtherTherapy _$ClinicalUseDefinitionOtherTherapyFromJson(
    Map<String, dynamic> json) {
  return _ClinicalUseDefinitionOtherTherapy.fromJson(json);
}

/// @nodoc
mixin _$ClinicalUseDefinitionOtherTherapy {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [relationshipType] The type of relationship between the medicinal product indication or contraindication and another therapy.;
  CodeableConcept get relationshipType => throw _privateConstructorUsedError;

  /// [therapy] Reference to a specific medication (active substance, medicinal product or class of products) as part of an indication or contraindication.;
  CodeableReference get therapy => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ClinicalUseDefinitionOtherTherapyCopyWith<ClinicalUseDefinitionOtherTherapy>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClinicalUseDefinitionOtherTherapyCopyWith<$Res> {
  factory $ClinicalUseDefinitionOtherTherapyCopyWith(
          ClinicalUseDefinitionOtherTherapy value,
          $Res Function(ClinicalUseDefinitionOtherTherapy) then) =
      _$ClinicalUseDefinitionOtherTherapyCopyWithImpl<$Res,
          ClinicalUseDefinitionOtherTherapy>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept relationshipType,
      CodeableReference therapy});

  $CodeableConceptCopyWith<$Res> get relationshipType;
  $CodeableReferenceCopyWith<$Res> get therapy;
}

/// @nodoc
class _$ClinicalUseDefinitionOtherTherapyCopyWithImpl<$Res,
        $Val extends ClinicalUseDefinitionOtherTherapy>
    implements $ClinicalUseDefinitionOtherTherapyCopyWith<$Res> {
  _$ClinicalUseDefinitionOtherTherapyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? relationshipType = null,
    Object? therapy = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      relationshipType: null == relationshipType
          ? _value.relationshipType
          : relationshipType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      therapy: null == therapy
          ? _value.therapy
          : therapy // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get relationshipType {
    return $CodeableConceptCopyWith<$Res>(_value.relationshipType, (value) {
      return _then(_value.copyWith(relationshipType: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res> get therapy {
    return $CodeableReferenceCopyWith<$Res>(_value.therapy, (value) {
      return _then(_value.copyWith(therapy: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ClinicalUseDefinitionOtherTherapyCopyWith<$Res>
    implements $ClinicalUseDefinitionOtherTherapyCopyWith<$Res> {
  factory _$$_ClinicalUseDefinitionOtherTherapyCopyWith(
          _$_ClinicalUseDefinitionOtherTherapy value,
          $Res Function(_$_ClinicalUseDefinitionOtherTherapy) then) =
      __$$_ClinicalUseDefinitionOtherTherapyCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept relationshipType,
      CodeableReference therapy});

  @override
  $CodeableConceptCopyWith<$Res> get relationshipType;
  @override
  $CodeableReferenceCopyWith<$Res> get therapy;
}

/// @nodoc
class __$$_ClinicalUseDefinitionOtherTherapyCopyWithImpl<$Res>
    extends _$ClinicalUseDefinitionOtherTherapyCopyWithImpl<$Res,
        _$_ClinicalUseDefinitionOtherTherapy>
    implements _$$_ClinicalUseDefinitionOtherTherapyCopyWith<$Res> {
  __$$_ClinicalUseDefinitionOtherTherapyCopyWithImpl(
      _$_ClinicalUseDefinitionOtherTherapy _value,
      $Res Function(_$_ClinicalUseDefinitionOtherTherapy) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? relationshipType = null,
    Object? therapy = null,
  }) {
    return _then(_$_ClinicalUseDefinitionOtherTherapy(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      relationshipType: null == relationshipType
          ? _value.relationshipType
          : relationshipType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      therapy: null == therapy
          ? _value.therapy
          : therapy // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ClinicalUseDefinitionOtherTherapy
    extends _ClinicalUseDefinitionOtherTherapy {
  _$_ClinicalUseDefinitionOtherTherapy(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.relationshipType,
      required this.therapy})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_ClinicalUseDefinitionOtherTherapy.fromJson(
          Map<String, dynamic> json) =>
      _$$_ClinicalUseDefinitionOtherTherapyFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [relationshipType] The type of relationship between the medicinal product indication or contraindication and another therapy.;
  @override
  final CodeableConcept relationshipType;

  /// [therapy] Reference to a specific medication (active substance, medicinal product or class of products) as part of an indication or contraindication.;
  @override
  final CodeableReference therapy;

  @override
  String toString() {
    return 'ClinicalUseDefinitionOtherTherapy(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, relationshipType: $relationshipType, therapy: $therapy)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ClinicalUseDefinitionOtherTherapy &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.relationshipType, relationshipType) ||
                other.relationshipType == relationshipType) &&
            (identical(other.therapy, therapy) || other.therapy == therapy));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      relationshipType,
      therapy);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ClinicalUseDefinitionOtherTherapyCopyWith<
          _$_ClinicalUseDefinitionOtherTherapy>
      get copyWith => __$$_ClinicalUseDefinitionOtherTherapyCopyWithImpl<
          _$_ClinicalUseDefinitionOtherTherapy>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ClinicalUseDefinitionOtherTherapyToJson(
      this,
    );
  }
}

abstract class _ClinicalUseDefinitionOtherTherapy
    extends ClinicalUseDefinitionOtherTherapy {
  factory _ClinicalUseDefinitionOtherTherapy(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept relationshipType,
          required final CodeableReference therapy}) =
      _$_ClinicalUseDefinitionOtherTherapy;
  _ClinicalUseDefinitionOtherTherapy._() : super._();

  factory _ClinicalUseDefinitionOtherTherapy.fromJson(
          Map<String, dynamic> json) =
      _$_ClinicalUseDefinitionOtherTherapy.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [relationshipType] The type of relationship between the medicinal product indication or contraindication and another therapy.;
  CodeableConcept get relationshipType;
  @override

  /// [therapy] Reference to a specific medication (active substance, medicinal product or class of products) as part of an indication or contraindication.;
  CodeableReference get therapy;
  @override
  @JsonKey(ignore: true)
  _$$_ClinicalUseDefinitionOtherTherapyCopyWith<
          _$_ClinicalUseDefinitionOtherTherapy>
      get copyWith => throw _privateConstructorUsedError;
}

ClinicalUseDefinitionIndication _$ClinicalUseDefinitionIndicationFromJson(
    Map<String, dynamic> json) {
  return _ClinicalUseDefinitionIndication.fromJson(json);
}

/// @nodoc
mixin _$ClinicalUseDefinitionIndication {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [diseaseSymptomProcedure] The situation that is being documented as an indicaton for this item.;
  CodeableReference? get diseaseSymptomProcedure =>
      throw _privateConstructorUsedError;

  /// [diseaseStatus] The status of the disease or symptom for the indication, for example "chronic" or "metastatic".;
  CodeableReference? get diseaseStatus => throw _privateConstructorUsedError;

  /// [comorbidity] A comorbidity (concurrent condition) or coinfection as part of the indication.;
  List<CodeableReference>? get comorbidity =>
      throw _privateConstructorUsedError;

  /// [intendedEffect] The intended effect, aim or strategy to be achieved.;
  CodeableReference? get intendedEffect => throw _privateConstructorUsedError;

  /// [durationRange] Timing or duration information, that may be associated with use with the indicated condition e.g. Adult patients suffering from myocardial infarction (from a few days until less than 35 days), ischaemic stroke (from 7 days until less than 6 months).;
  Range? get durationRange => throw _privateConstructorUsedError;

  /// [durationString] Timing or duration information, that may be associated with use with the indicated condition e.g. Adult patients suffering from myocardial infarction (from a few days until less than 35 days), ischaemic stroke (from 7 days until less than 6 months).;
  Markdown? get durationString => throw _privateConstructorUsedError;

  /// [durationStringElement] (_durationString): Extensions for durationString;
  @JsonKey(name: '_durationString')
  Element? get durationStringElement => throw _privateConstructorUsedError;

  /// [undesirableEffect] An unwanted side effect or negative outcome that may happen if you use the drug (or other subject of this resource) for this indication.;
  List<Reference>? get undesirableEffect => throw _privateConstructorUsedError;

  /// [otherTherapy] Information about the use of the medicinal product in relation to other therapies described as part of the indication.;
  List<ClinicalUseDefinitionOtherTherapy>? get otherTherapy =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ClinicalUseDefinitionIndicationCopyWith<ClinicalUseDefinitionIndication>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClinicalUseDefinitionIndicationCopyWith<$Res> {
  factory $ClinicalUseDefinitionIndicationCopyWith(
          ClinicalUseDefinitionIndication value,
          $Res Function(ClinicalUseDefinitionIndication) then) =
      _$ClinicalUseDefinitionIndicationCopyWithImpl<$Res,
          ClinicalUseDefinitionIndication>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? diseaseSymptomProcedure,
      CodeableReference? diseaseStatus,
      List<CodeableReference>? comorbidity,
      CodeableReference? intendedEffect,
      Range? durationRange,
      Markdown? durationString,
      @JsonKey(name: '_durationString') Element? durationStringElement,
      List<Reference>? undesirableEffect,
      List<ClinicalUseDefinitionOtherTherapy>? otherTherapy});

  $CodeableReferenceCopyWith<$Res>? get diseaseSymptomProcedure;
  $CodeableReferenceCopyWith<$Res>? get diseaseStatus;
  $CodeableReferenceCopyWith<$Res>? get intendedEffect;
  $RangeCopyWith<$Res>? get durationRange;
  $ElementCopyWith<$Res>? get durationStringElement;
}

/// @nodoc
class _$ClinicalUseDefinitionIndicationCopyWithImpl<$Res,
        $Val extends ClinicalUseDefinitionIndication>
    implements $ClinicalUseDefinitionIndicationCopyWith<$Res> {
  _$ClinicalUseDefinitionIndicationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? diseaseSymptomProcedure = freezed,
    Object? diseaseStatus = freezed,
    Object? comorbidity = freezed,
    Object? intendedEffect = freezed,
    Object? durationRange = freezed,
    Object? durationString = freezed,
    Object? durationStringElement = freezed,
    Object? undesirableEffect = freezed,
    Object? otherTherapy = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      diseaseSymptomProcedure: freezed == diseaseSymptomProcedure
          ? _value.diseaseSymptomProcedure
          : diseaseSymptomProcedure // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      diseaseStatus: freezed == diseaseStatus
          ? _value.diseaseStatus
          : diseaseStatus // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      comorbidity: freezed == comorbidity
          ? _value.comorbidity
          : comorbidity // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      intendedEffect: freezed == intendedEffect
          ? _value.intendedEffect
          : intendedEffect // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      durationRange: freezed == durationRange
          ? _value.durationRange
          : durationRange // ignore: cast_nullable_to_non_nullable
              as Range?,
      durationString: freezed == durationString
          ? _value.durationString
          : durationString // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      durationStringElement: freezed == durationStringElement
          ? _value.durationStringElement
          : durationStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      undesirableEffect: freezed == undesirableEffect
          ? _value.undesirableEffect
          : undesirableEffect // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      otherTherapy: freezed == otherTherapy
          ? _value.otherTherapy
          : otherTherapy // ignore: cast_nullable_to_non_nullable
              as List<ClinicalUseDefinitionOtherTherapy>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res>? get diseaseSymptomProcedure {
    if (_value.diseaseSymptomProcedure == null) {
      return null;
    }

    return $CodeableReferenceCopyWith<$Res>(_value.diseaseSymptomProcedure!,
        (value) {
      return _then(_value.copyWith(diseaseSymptomProcedure: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res>? get diseaseStatus {
    if (_value.diseaseStatus == null) {
      return null;
    }

    return $CodeableReferenceCopyWith<$Res>(_value.diseaseStatus!, (value) {
      return _then(_value.copyWith(diseaseStatus: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res>? get intendedEffect {
    if (_value.intendedEffect == null) {
      return null;
    }

    return $CodeableReferenceCopyWith<$Res>(_value.intendedEffect!, (value) {
      return _then(_value.copyWith(intendedEffect: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RangeCopyWith<$Res>? get durationRange {
    if (_value.durationRange == null) {
      return null;
    }

    return $RangeCopyWith<$Res>(_value.durationRange!, (value) {
      return _then(_value.copyWith(durationRange: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get durationStringElement {
    if (_value.durationStringElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.durationStringElement!, (value) {
      return _then(_value.copyWith(durationStringElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ClinicalUseDefinitionIndicationCopyWith<$Res>
    implements $ClinicalUseDefinitionIndicationCopyWith<$Res> {
  factory _$$_ClinicalUseDefinitionIndicationCopyWith(
          _$_ClinicalUseDefinitionIndication value,
          $Res Function(_$_ClinicalUseDefinitionIndication) then) =
      __$$_ClinicalUseDefinitionIndicationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? diseaseSymptomProcedure,
      CodeableReference? diseaseStatus,
      List<CodeableReference>? comorbidity,
      CodeableReference? intendedEffect,
      Range? durationRange,
      Markdown? durationString,
      @JsonKey(name: '_durationString') Element? durationStringElement,
      List<Reference>? undesirableEffect,
      List<ClinicalUseDefinitionOtherTherapy>? otherTherapy});

  @override
  $CodeableReferenceCopyWith<$Res>? get diseaseSymptomProcedure;
  @override
  $CodeableReferenceCopyWith<$Res>? get diseaseStatus;
  @override
  $CodeableReferenceCopyWith<$Res>? get intendedEffect;
  @override
  $RangeCopyWith<$Res>? get durationRange;
  @override
  $ElementCopyWith<$Res>? get durationStringElement;
}

/// @nodoc
class __$$_ClinicalUseDefinitionIndicationCopyWithImpl<$Res>
    extends _$ClinicalUseDefinitionIndicationCopyWithImpl<$Res,
        _$_ClinicalUseDefinitionIndication>
    implements _$$_ClinicalUseDefinitionIndicationCopyWith<$Res> {
  __$$_ClinicalUseDefinitionIndicationCopyWithImpl(
      _$_ClinicalUseDefinitionIndication _value,
      $Res Function(_$_ClinicalUseDefinitionIndication) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? diseaseSymptomProcedure = freezed,
    Object? diseaseStatus = freezed,
    Object? comorbidity = freezed,
    Object? intendedEffect = freezed,
    Object? durationRange = freezed,
    Object? durationString = freezed,
    Object? durationStringElement = freezed,
    Object? undesirableEffect = freezed,
    Object? otherTherapy = freezed,
  }) {
    return _then(_$_ClinicalUseDefinitionIndication(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      diseaseSymptomProcedure: freezed == diseaseSymptomProcedure
          ? _value.diseaseSymptomProcedure
          : diseaseSymptomProcedure // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      diseaseStatus: freezed == diseaseStatus
          ? _value.diseaseStatus
          : diseaseStatus // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      comorbidity: freezed == comorbidity
          ? _value._comorbidity
          : comorbidity // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      intendedEffect: freezed == intendedEffect
          ? _value.intendedEffect
          : intendedEffect // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      durationRange: freezed == durationRange
          ? _value.durationRange
          : durationRange // ignore: cast_nullable_to_non_nullable
              as Range?,
      durationString: freezed == durationString
          ? _value.durationString
          : durationString // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      durationStringElement: freezed == durationStringElement
          ? _value.durationStringElement
          : durationStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      undesirableEffect: freezed == undesirableEffect
          ? _value._undesirableEffect
          : undesirableEffect // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      otherTherapy: freezed == otherTherapy
          ? _value._otherTherapy
          : otherTherapy // ignore: cast_nullable_to_non_nullable
              as List<ClinicalUseDefinitionOtherTherapy>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ClinicalUseDefinitionIndication
    extends _ClinicalUseDefinitionIndication {
  _$_ClinicalUseDefinitionIndication(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.diseaseSymptomProcedure,
      this.diseaseStatus,
      final List<CodeableReference>? comorbidity,
      this.intendedEffect,
      this.durationRange,
      this.durationString,
      @JsonKey(name: '_durationString') this.durationStringElement,
      final List<Reference>? undesirableEffect,
      final List<ClinicalUseDefinitionOtherTherapy>? otherTherapy})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _comorbidity = comorbidity,
        _undesirableEffect = undesirableEffect,
        _otherTherapy = otherTherapy,
        super._();

  factory _$_ClinicalUseDefinitionIndication.fromJson(
          Map<String, dynamic> json) =>
      _$$_ClinicalUseDefinitionIndicationFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [diseaseSymptomProcedure] The situation that is being documented as an indicaton for this item.;
  @override
  final CodeableReference? diseaseSymptomProcedure;

  /// [diseaseStatus] The status of the disease or symptom for the indication, for example "chronic" or "metastatic".;
  @override
  final CodeableReference? diseaseStatus;

  /// [comorbidity] A comorbidity (concurrent condition) or coinfection as part of the indication.;
  final List<CodeableReference>? _comorbidity;

  /// [comorbidity] A comorbidity (concurrent condition) or coinfection as part of the indication.;
  @override
  List<CodeableReference>? get comorbidity {
    final value = _comorbidity;
    if (value == null) return null;
    if (_comorbidity is EqualUnmodifiableListView) return _comorbidity;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [intendedEffect] The intended effect, aim or strategy to be achieved.;
  @override
  final CodeableReference? intendedEffect;

  /// [durationRange] Timing or duration information, that may be associated with use with the indicated condition e.g. Adult patients suffering from myocardial infarction (from a few days until less than 35 days), ischaemic stroke (from 7 days until less than 6 months).;
  @override
  final Range? durationRange;

  /// [durationString] Timing or duration information, that may be associated with use with the indicated condition e.g. Adult patients suffering from myocardial infarction (from a few days until less than 35 days), ischaemic stroke (from 7 days until less than 6 months).;
  @override
  final Markdown? durationString;

  /// [durationStringElement] (_durationString): Extensions for durationString;
  @override
  @JsonKey(name: '_durationString')
  final Element? durationStringElement;

  /// [undesirableEffect] An unwanted side effect or negative outcome that may happen if you use the drug (or other subject of this resource) for this indication.;
  final List<Reference>? _undesirableEffect;

  /// [undesirableEffect] An unwanted side effect or negative outcome that may happen if you use the drug (or other subject of this resource) for this indication.;
  @override
  List<Reference>? get undesirableEffect {
    final value = _undesirableEffect;
    if (value == null) return null;
    if (_undesirableEffect is EqualUnmodifiableListView)
      return _undesirableEffect;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [otherTherapy] Information about the use of the medicinal product in relation to other therapies described as part of the indication.;
  final List<ClinicalUseDefinitionOtherTherapy>? _otherTherapy;

  /// [otherTherapy] Information about the use of the medicinal product in relation to other therapies described as part of the indication.;
  @override
  List<ClinicalUseDefinitionOtherTherapy>? get otherTherapy {
    final value = _otherTherapy;
    if (value == null) return null;
    if (_otherTherapy is EqualUnmodifiableListView) return _otherTherapy;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ClinicalUseDefinitionIndication(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, diseaseSymptomProcedure: $diseaseSymptomProcedure, diseaseStatus: $diseaseStatus, comorbidity: $comorbidity, intendedEffect: $intendedEffect, durationRange: $durationRange, durationString: $durationString, durationStringElement: $durationStringElement, undesirableEffect: $undesirableEffect, otherTherapy: $otherTherapy)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ClinicalUseDefinitionIndication &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(
                    other.diseaseSymptomProcedure, diseaseSymptomProcedure) ||
                other.diseaseSymptomProcedure == diseaseSymptomProcedure) &&
            (identical(other.diseaseStatus, diseaseStatus) ||
                other.diseaseStatus == diseaseStatus) &&
            const DeepCollectionEquality()
                .equals(other._comorbidity, _comorbidity) &&
            (identical(other.intendedEffect, intendedEffect) ||
                other.intendedEffect == intendedEffect) &&
            (identical(other.durationRange, durationRange) ||
                other.durationRange == durationRange) &&
            (identical(other.durationString, durationString) ||
                other.durationString == durationString) &&
            (identical(other.durationStringElement, durationStringElement) ||
                other.durationStringElement == durationStringElement) &&
            const DeepCollectionEquality()
                .equals(other._undesirableEffect, _undesirableEffect) &&
            const DeepCollectionEquality()
                .equals(other._otherTherapy, _otherTherapy));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      diseaseSymptomProcedure,
      diseaseStatus,
      const DeepCollectionEquality().hash(_comorbidity),
      intendedEffect,
      durationRange,
      durationString,
      durationStringElement,
      const DeepCollectionEquality().hash(_undesirableEffect),
      const DeepCollectionEquality().hash(_otherTherapy));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ClinicalUseDefinitionIndicationCopyWith<
          _$_ClinicalUseDefinitionIndication>
      get copyWith => __$$_ClinicalUseDefinitionIndicationCopyWithImpl<
          _$_ClinicalUseDefinitionIndication>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ClinicalUseDefinitionIndicationToJson(
      this,
    );
  }
}

abstract class _ClinicalUseDefinitionIndication
    extends ClinicalUseDefinitionIndication {
  factory _ClinicalUseDefinitionIndication(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableReference? diseaseSymptomProcedure,
      final CodeableReference? diseaseStatus,
      final List<CodeableReference>? comorbidity,
      final CodeableReference? intendedEffect,
      final Range? durationRange,
      final Markdown? durationString,
      @JsonKey(name: '_durationString') final Element? durationStringElement,
      final List<Reference>? undesirableEffect,
      final List<ClinicalUseDefinitionOtherTherapy>?
          otherTherapy}) = _$_ClinicalUseDefinitionIndication;
  _ClinicalUseDefinitionIndication._() : super._();

  factory _ClinicalUseDefinitionIndication.fromJson(Map<String, dynamic> json) =
      _$_ClinicalUseDefinitionIndication.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [diseaseSymptomProcedure] The situation that is being documented as an indicaton for this item.;
  CodeableReference? get diseaseSymptomProcedure;
  @override

  /// [diseaseStatus] The status of the disease or symptom for the indication, for example "chronic" or "metastatic".;
  CodeableReference? get diseaseStatus;
  @override

  /// [comorbidity] A comorbidity (concurrent condition) or coinfection as part of the indication.;
  List<CodeableReference>? get comorbidity;
  @override

  /// [intendedEffect] The intended effect, aim or strategy to be achieved.;
  CodeableReference? get intendedEffect;
  @override

  /// [durationRange] Timing or duration information, that may be associated with use with the indicated condition e.g. Adult patients suffering from myocardial infarction (from a few days until less than 35 days), ischaemic stroke (from 7 days until less than 6 months).;
  Range? get durationRange;
  @override

  /// [durationString] Timing or duration information, that may be associated with use with the indicated condition e.g. Adult patients suffering from myocardial infarction (from a few days until less than 35 days), ischaemic stroke (from 7 days until less than 6 months).;
  Markdown? get durationString;
  @override

  /// [durationStringElement] (_durationString): Extensions for durationString;
  @JsonKey(name: '_durationString')
  Element? get durationStringElement;
  @override

  /// [undesirableEffect] An unwanted side effect or negative outcome that may happen if you use the drug (or other subject of this resource) for this indication.;
  List<Reference>? get undesirableEffect;
  @override

  /// [otherTherapy] Information about the use of the medicinal product in relation to other therapies described as part of the indication.;
  List<ClinicalUseDefinitionOtherTherapy>? get otherTherapy;
  @override
  @JsonKey(ignore: true)
  _$$_ClinicalUseDefinitionIndicationCopyWith<
          _$_ClinicalUseDefinitionIndication>
      get copyWith => throw _privateConstructorUsedError;
}

ClinicalUseDefinitionInteraction _$ClinicalUseDefinitionInteractionFromJson(
    Map<String, dynamic> json) {
  return _ClinicalUseDefinitionInteraction.fromJson(json);
}

/// @nodoc
mixin _$ClinicalUseDefinitionInteraction {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [interactant] The specific medication, food, substance or laboratory test that interacts.;
  List<ClinicalUseDefinitionInteractant>? get interactant =>
      throw _privateConstructorUsedError;

  /// [type] The type of the interaction e.g. drug-drug interaction, drug-food interaction, drug-lab test interaction.;
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [effect] The effect of the interaction, for example "reduced gastric absorption of primary medication".;
  CodeableReference? get effect => throw _privateConstructorUsedError;

  /// [incidence] The incidence of the interaction, e.g. theoretical, observed.;
  CodeableConcept? get incidence => throw _privateConstructorUsedError;

  /// [management] Actions for managing the interaction.;
  List<CodeableConcept>? get management => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ClinicalUseDefinitionInteractionCopyWith<ClinicalUseDefinitionInteraction>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClinicalUseDefinitionInteractionCopyWith<$Res> {
  factory $ClinicalUseDefinitionInteractionCopyWith(
          ClinicalUseDefinitionInteraction value,
          $Res Function(ClinicalUseDefinitionInteraction) then) =
      _$ClinicalUseDefinitionInteractionCopyWithImpl<$Res,
          ClinicalUseDefinitionInteraction>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<ClinicalUseDefinitionInteractant>? interactant,
      CodeableConcept? type,
      CodeableReference? effect,
      CodeableConcept? incidence,
      List<CodeableConcept>? management});

  $CodeableConceptCopyWith<$Res>? get type;
  $CodeableReferenceCopyWith<$Res>? get effect;
  $CodeableConceptCopyWith<$Res>? get incidence;
}

/// @nodoc
class _$ClinicalUseDefinitionInteractionCopyWithImpl<$Res,
        $Val extends ClinicalUseDefinitionInteraction>
    implements $ClinicalUseDefinitionInteractionCopyWith<$Res> {
  _$ClinicalUseDefinitionInteractionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? interactant = freezed,
    Object? type = freezed,
    Object? effect = freezed,
    Object? incidence = freezed,
    Object? management = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      interactant: freezed == interactant
          ? _value.interactant
          : interactant // ignore: cast_nullable_to_non_nullable
              as List<ClinicalUseDefinitionInteractant>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      effect: freezed == effect
          ? _value.effect
          : effect // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      incidence: freezed == incidence
          ? _value.incidence
          : incidence // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      management: freezed == management
          ? _value.management
          : management // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res>? get effect {
    if (_value.effect == null) {
      return null;
    }

    return $CodeableReferenceCopyWith<$Res>(_value.effect!, (value) {
      return _then(_value.copyWith(effect: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get incidence {
    if (_value.incidence == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.incidence!, (value) {
      return _then(_value.copyWith(incidence: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ClinicalUseDefinitionInteractionCopyWith<$Res>
    implements $ClinicalUseDefinitionInteractionCopyWith<$Res> {
  factory _$$_ClinicalUseDefinitionInteractionCopyWith(
          _$_ClinicalUseDefinitionInteraction value,
          $Res Function(_$_ClinicalUseDefinitionInteraction) then) =
      __$$_ClinicalUseDefinitionInteractionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<ClinicalUseDefinitionInteractant>? interactant,
      CodeableConcept? type,
      CodeableReference? effect,
      CodeableConcept? incidence,
      List<CodeableConcept>? management});

  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $CodeableReferenceCopyWith<$Res>? get effect;
  @override
  $CodeableConceptCopyWith<$Res>? get incidence;
}

/// @nodoc
class __$$_ClinicalUseDefinitionInteractionCopyWithImpl<$Res>
    extends _$ClinicalUseDefinitionInteractionCopyWithImpl<$Res,
        _$_ClinicalUseDefinitionInteraction>
    implements _$$_ClinicalUseDefinitionInteractionCopyWith<$Res> {
  __$$_ClinicalUseDefinitionInteractionCopyWithImpl(
      _$_ClinicalUseDefinitionInteraction _value,
      $Res Function(_$_ClinicalUseDefinitionInteraction) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? interactant = freezed,
    Object? type = freezed,
    Object? effect = freezed,
    Object? incidence = freezed,
    Object? management = freezed,
  }) {
    return _then(_$_ClinicalUseDefinitionInteraction(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      interactant: freezed == interactant
          ? _value._interactant
          : interactant // ignore: cast_nullable_to_non_nullable
              as List<ClinicalUseDefinitionInteractant>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      effect: freezed == effect
          ? _value.effect
          : effect // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      incidence: freezed == incidence
          ? _value.incidence
          : incidence // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      management: freezed == management
          ? _value._management
          : management // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ClinicalUseDefinitionInteraction
    extends _ClinicalUseDefinitionInteraction {
  _$_ClinicalUseDefinitionInteraction(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<ClinicalUseDefinitionInteractant>? interactant,
      this.type,
      this.effect,
      this.incidence,
      final List<CodeableConcept>? management})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _interactant = interactant,
        _management = management,
        super._();

  factory _$_ClinicalUseDefinitionInteraction.fromJson(
          Map<String, dynamic> json) =>
      _$$_ClinicalUseDefinitionInteractionFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [interactant] The specific medication, food, substance or laboratory test that interacts.;
  final List<ClinicalUseDefinitionInteractant>? _interactant;

  /// [interactant] The specific medication, food, substance or laboratory test that interacts.;
  @override
  List<ClinicalUseDefinitionInteractant>? get interactant {
    final value = _interactant;
    if (value == null) return null;
    if (_interactant is EqualUnmodifiableListView) return _interactant;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] The type of the interaction e.g. drug-drug interaction, drug-food interaction, drug-lab test interaction.;
  @override
  final CodeableConcept? type;

  /// [effect] The effect of the interaction, for example "reduced gastric absorption of primary medication".;
  @override
  final CodeableReference? effect;

  /// [incidence] The incidence of the interaction, e.g. theoretical, observed.;
  @override
  final CodeableConcept? incidence;

  /// [management] Actions for managing the interaction.;
  final List<CodeableConcept>? _management;

  /// [management] Actions for managing the interaction.;
  @override
  List<CodeableConcept>? get management {
    final value = _management;
    if (value == null) return null;
    if (_management is EqualUnmodifiableListView) return _management;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ClinicalUseDefinitionInteraction(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, interactant: $interactant, type: $type, effect: $effect, incidence: $incidence, management: $management)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ClinicalUseDefinitionInteraction &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._interactant, _interactant) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.effect, effect) || other.effect == effect) &&
            (identical(other.incidence, incidence) ||
                other.incidence == incidence) &&
            const DeepCollectionEquality()
                .equals(other._management, _management));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      const DeepCollectionEquality().hash(_interactant),
      type,
      effect,
      incidence,
      const DeepCollectionEquality().hash(_management));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ClinicalUseDefinitionInteractionCopyWith<
          _$_ClinicalUseDefinitionInteraction>
      get copyWith => __$$_ClinicalUseDefinitionInteractionCopyWithImpl<
          _$_ClinicalUseDefinitionInteraction>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ClinicalUseDefinitionInteractionToJson(
      this,
    );
  }
}

abstract class _ClinicalUseDefinitionInteraction
    extends ClinicalUseDefinitionInteraction {
  factory _ClinicalUseDefinitionInteraction(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final List<ClinicalUseDefinitionInteractant>? interactant,
          final CodeableConcept? type,
          final CodeableReference? effect,
          final CodeableConcept? incidence,
          final List<CodeableConcept>? management}) =
      _$_ClinicalUseDefinitionInteraction;
  _ClinicalUseDefinitionInteraction._() : super._();

  factory _ClinicalUseDefinitionInteraction.fromJson(
      Map<String, dynamic> json) = _$_ClinicalUseDefinitionInteraction.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [interactant] The specific medication, food, substance or laboratory test that interacts.;
  List<ClinicalUseDefinitionInteractant>? get interactant;
  @override

  /// [type] The type of the interaction e.g. drug-drug interaction, drug-food interaction, drug-lab test interaction.;
  CodeableConcept? get type;
  @override

  /// [effect] The effect of the interaction, for example "reduced gastric absorption of primary medication".;
  CodeableReference? get effect;
  @override

  /// [incidence] The incidence of the interaction, e.g. theoretical, observed.;
  CodeableConcept? get incidence;
  @override

  /// [management] Actions for managing the interaction.;
  List<CodeableConcept>? get management;
  @override
  @JsonKey(ignore: true)
  _$$_ClinicalUseDefinitionInteractionCopyWith<
          _$_ClinicalUseDefinitionInteraction>
      get copyWith => throw _privateConstructorUsedError;
}

ClinicalUseDefinitionInteractant _$ClinicalUseDefinitionInteractantFromJson(
    Map<String, dynamic> json) {
  return _ClinicalUseDefinitionInteractant.fromJson(json);
}

/// @nodoc
mixin _$ClinicalUseDefinitionInteractant {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [itemReference] The specific medication, food or laboratory test that interacts.;
  Reference? get itemReference => throw _privateConstructorUsedError;

  /// [itemCodeableConcept] The specific medication, food or laboratory test that interacts.;
  CodeableConcept? get itemCodeableConcept =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ClinicalUseDefinitionInteractantCopyWith<ClinicalUseDefinitionInteractant>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClinicalUseDefinitionInteractantCopyWith<$Res> {
  factory $ClinicalUseDefinitionInteractantCopyWith(
          ClinicalUseDefinitionInteractant value,
          $Res Function(ClinicalUseDefinitionInteractant) then) =
      _$ClinicalUseDefinitionInteractantCopyWithImpl<$Res,
          ClinicalUseDefinitionInteractant>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Reference? itemReference,
      CodeableConcept? itemCodeableConcept});

  $ReferenceCopyWith<$Res>? get itemReference;
  $CodeableConceptCopyWith<$Res>? get itemCodeableConcept;
}

/// @nodoc
class _$ClinicalUseDefinitionInteractantCopyWithImpl<$Res,
        $Val extends ClinicalUseDefinitionInteractant>
    implements $ClinicalUseDefinitionInteractantCopyWith<$Res> {
  _$ClinicalUseDefinitionInteractantCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? itemReference = freezed,
    Object? itemCodeableConcept = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      itemReference: freezed == itemReference
          ? _value.itemReference
          : itemReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      itemCodeableConcept: freezed == itemCodeableConcept
          ? _value.itemCodeableConcept
          : itemCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get itemReference {
    if (_value.itemReference == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.itemReference!, (value) {
      return _then(_value.copyWith(itemReference: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get itemCodeableConcept {
    if (_value.itemCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.itemCodeableConcept!, (value) {
      return _then(_value.copyWith(itemCodeableConcept: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ClinicalUseDefinitionInteractantCopyWith<$Res>
    implements $ClinicalUseDefinitionInteractantCopyWith<$Res> {
  factory _$$_ClinicalUseDefinitionInteractantCopyWith(
          _$_ClinicalUseDefinitionInteractant value,
          $Res Function(_$_ClinicalUseDefinitionInteractant) then) =
      __$$_ClinicalUseDefinitionInteractantCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Reference? itemReference,
      CodeableConcept? itemCodeableConcept});

  @override
  $ReferenceCopyWith<$Res>? get itemReference;
  @override
  $CodeableConceptCopyWith<$Res>? get itemCodeableConcept;
}

/// @nodoc
class __$$_ClinicalUseDefinitionInteractantCopyWithImpl<$Res>
    extends _$ClinicalUseDefinitionInteractantCopyWithImpl<$Res,
        _$_ClinicalUseDefinitionInteractant>
    implements _$$_ClinicalUseDefinitionInteractantCopyWith<$Res> {
  __$$_ClinicalUseDefinitionInteractantCopyWithImpl(
      _$_ClinicalUseDefinitionInteractant _value,
      $Res Function(_$_ClinicalUseDefinitionInteractant) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? itemReference = freezed,
    Object? itemCodeableConcept = freezed,
  }) {
    return _then(_$_ClinicalUseDefinitionInteractant(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      itemReference: freezed == itemReference
          ? _value.itemReference
          : itemReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      itemCodeableConcept: freezed == itemCodeableConcept
          ? _value.itemCodeableConcept
          : itemCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ClinicalUseDefinitionInteractant
    extends _ClinicalUseDefinitionInteractant {
  _$_ClinicalUseDefinitionInteractant(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.itemReference,
      this.itemCodeableConcept})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_ClinicalUseDefinitionInteractant.fromJson(
          Map<String, dynamic> json) =>
      _$$_ClinicalUseDefinitionInteractantFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [itemReference] The specific medication, food or laboratory test that interacts.;
  @override
  final Reference? itemReference;

  /// [itemCodeableConcept] The specific medication, food or laboratory test that interacts.;
  @override
  final CodeableConcept? itemCodeableConcept;

  @override
  String toString() {
    return 'ClinicalUseDefinitionInteractant(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, itemReference: $itemReference, itemCodeableConcept: $itemCodeableConcept)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ClinicalUseDefinitionInteractant &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.itemReference, itemReference) ||
                other.itemReference == itemReference) &&
            (identical(other.itemCodeableConcept, itemCodeableConcept) ||
                other.itemCodeableConcept == itemCodeableConcept));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      itemReference,
      itemCodeableConcept);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ClinicalUseDefinitionInteractantCopyWith<
          _$_ClinicalUseDefinitionInteractant>
      get copyWith => __$$_ClinicalUseDefinitionInteractantCopyWithImpl<
          _$_ClinicalUseDefinitionInteractant>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ClinicalUseDefinitionInteractantToJson(
      this,
    );
  }
}

abstract class _ClinicalUseDefinitionInteractant
    extends ClinicalUseDefinitionInteractant {
  factory _ClinicalUseDefinitionInteractant(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final Reference? itemReference,
          final CodeableConcept? itemCodeableConcept}) =
      _$_ClinicalUseDefinitionInteractant;
  _ClinicalUseDefinitionInteractant._() : super._();

  factory _ClinicalUseDefinitionInteractant.fromJson(
      Map<String, dynamic> json) = _$_ClinicalUseDefinitionInteractant.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [itemReference] The specific medication, food or laboratory test that interacts.;
  Reference? get itemReference;
  @override

  /// [itemCodeableConcept] The specific medication, food or laboratory test that interacts.;
  CodeableConcept? get itemCodeableConcept;
  @override
  @JsonKey(ignore: true)
  _$$_ClinicalUseDefinitionInteractantCopyWith<
          _$_ClinicalUseDefinitionInteractant>
      get copyWith => throw _privateConstructorUsedError;
}

ClinicalUseDefinitionUndesirableEffect
    _$ClinicalUseDefinitionUndesirableEffectFromJson(
        Map<String, dynamic> json) {
  return _ClinicalUseDefinitionUndesirableEffect.fromJson(json);
}

/// @nodoc
mixin _$ClinicalUseDefinitionUndesirableEffect {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [symptomConditionEffect] The situation in which the undesirable effect may manifest.;
  CodeableReference? get symptomConditionEffect =>
      throw _privateConstructorUsedError;

  /// [classification] High level classification of the effect.;
  CodeableConcept? get classification => throw _privateConstructorUsedError;

  /// [frequencyOfOccurrence] How often the effect is seen.;
  CodeableConcept? get frequencyOfOccurrence =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ClinicalUseDefinitionUndesirableEffectCopyWith<
          ClinicalUseDefinitionUndesirableEffect>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClinicalUseDefinitionUndesirableEffectCopyWith<$Res> {
  factory $ClinicalUseDefinitionUndesirableEffectCopyWith(
          ClinicalUseDefinitionUndesirableEffect value,
          $Res Function(ClinicalUseDefinitionUndesirableEffect) then) =
      _$ClinicalUseDefinitionUndesirableEffectCopyWithImpl<$Res,
          ClinicalUseDefinitionUndesirableEffect>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? symptomConditionEffect,
      CodeableConcept? classification,
      CodeableConcept? frequencyOfOccurrence});

  $CodeableReferenceCopyWith<$Res>? get symptomConditionEffect;
  $CodeableConceptCopyWith<$Res>? get classification;
  $CodeableConceptCopyWith<$Res>? get frequencyOfOccurrence;
}

/// @nodoc
class _$ClinicalUseDefinitionUndesirableEffectCopyWithImpl<$Res,
        $Val extends ClinicalUseDefinitionUndesirableEffect>
    implements $ClinicalUseDefinitionUndesirableEffectCopyWith<$Res> {
  _$ClinicalUseDefinitionUndesirableEffectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? symptomConditionEffect = freezed,
    Object? classification = freezed,
    Object? frequencyOfOccurrence = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      symptomConditionEffect: freezed == symptomConditionEffect
          ? _value.symptomConditionEffect
          : symptomConditionEffect // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      classification: freezed == classification
          ? _value.classification
          : classification // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      frequencyOfOccurrence: freezed == frequencyOfOccurrence
          ? _value.frequencyOfOccurrence
          : frequencyOfOccurrence // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res>? get symptomConditionEffect {
    if (_value.symptomConditionEffect == null) {
      return null;
    }

    return $CodeableReferenceCopyWith<$Res>(_value.symptomConditionEffect!,
        (value) {
      return _then(_value.copyWith(symptomConditionEffect: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get classification {
    if (_value.classification == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.classification!, (value) {
      return _then(_value.copyWith(classification: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get frequencyOfOccurrence {
    if (_value.frequencyOfOccurrence == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.frequencyOfOccurrence!,
        (value) {
      return _then(_value.copyWith(frequencyOfOccurrence: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ClinicalUseDefinitionUndesirableEffectCopyWith<$Res>
    implements $ClinicalUseDefinitionUndesirableEffectCopyWith<$Res> {
  factory _$$_ClinicalUseDefinitionUndesirableEffectCopyWith(
          _$_ClinicalUseDefinitionUndesirableEffect value,
          $Res Function(_$_ClinicalUseDefinitionUndesirableEffect) then) =
      __$$_ClinicalUseDefinitionUndesirableEffectCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? symptomConditionEffect,
      CodeableConcept? classification,
      CodeableConcept? frequencyOfOccurrence});

  @override
  $CodeableReferenceCopyWith<$Res>? get symptomConditionEffect;
  @override
  $CodeableConceptCopyWith<$Res>? get classification;
  @override
  $CodeableConceptCopyWith<$Res>? get frequencyOfOccurrence;
}

/// @nodoc
class __$$_ClinicalUseDefinitionUndesirableEffectCopyWithImpl<$Res>
    extends _$ClinicalUseDefinitionUndesirableEffectCopyWithImpl<$Res,
        _$_ClinicalUseDefinitionUndesirableEffect>
    implements _$$_ClinicalUseDefinitionUndesirableEffectCopyWith<$Res> {
  __$$_ClinicalUseDefinitionUndesirableEffectCopyWithImpl(
      _$_ClinicalUseDefinitionUndesirableEffect _value,
      $Res Function(_$_ClinicalUseDefinitionUndesirableEffect) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? symptomConditionEffect = freezed,
    Object? classification = freezed,
    Object? frequencyOfOccurrence = freezed,
  }) {
    return _then(_$_ClinicalUseDefinitionUndesirableEffect(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      symptomConditionEffect: freezed == symptomConditionEffect
          ? _value.symptomConditionEffect
          : symptomConditionEffect // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      classification: freezed == classification
          ? _value.classification
          : classification // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      frequencyOfOccurrence: freezed == frequencyOfOccurrence
          ? _value.frequencyOfOccurrence
          : frequencyOfOccurrence // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ClinicalUseDefinitionUndesirableEffect
    extends _ClinicalUseDefinitionUndesirableEffect {
  _$_ClinicalUseDefinitionUndesirableEffect(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.symptomConditionEffect,
      this.classification,
      this.frequencyOfOccurrence})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_ClinicalUseDefinitionUndesirableEffect.fromJson(
          Map<String, dynamic> json) =>
      _$$_ClinicalUseDefinitionUndesirableEffectFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [symptomConditionEffect] The situation in which the undesirable effect may manifest.;
  @override
  final CodeableReference? symptomConditionEffect;

  /// [classification] High level classification of the effect.;
  @override
  final CodeableConcept? classification;

  /// [frequencyOfOccurrence] How often the effect is seen.;
  @override
  final CodeableConcept? frequencyOfOccurrence;

  @override
  String toString() {
    return 'ClinicalUseDefinitionUndesirableEffect(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, symptomConditionEffect: $symptomConditionEffect, classification: $classification, frequencyOfOccurrence: $frequencyOfOccurrence)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ClinicalUseDefinitionUndesirableEffect &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.symptomConditionEffect, symptomConditionEffect) ||
                other.symptomConditionEffect == symptomConditionEffect) &&
            (identical(other.classification, classification) ||
                other.classification == classification) &&
            (identical(other.frequencyOfOccurrence, frequencyOfOccurrence) ||
                other.frequencyOfOccurrence == frequencyOfOccurrence));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      symptomConditionEffect,
      classification,
      frequencyOfOccurrence);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ClinicalUseDefinitionUndesirableEffectCopyWith<
          _$_ClinicalUseDefinitionUndesirableEffect>
      get copyWith => __$$_ClinicalUseDefinitionUndesirableEffectCopyWithImpl<
          _$_ClinicalUseDefinitionUndesirableEffect>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ClinicalUseDefinitionUndesirableEffectToJson(
      this,
    );
  }
}

abstract class _ClinicalUseDefinitionUndesirableEffect
    extends ClinicalUseDefinitionUndesirableEffect {
  factory _ClinicalUseDefinitionUndesirableEffect(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableReference? symptomConditionEffect,
          final CodeableConcept? classification,
          final CodeableConcept? frequencyOfOccurrence}) =
      _$_ClinicalUseDefinitionUndesirableEffect;
  _ClinicalUseDefinitionUndesirableEffect._() : super._();

  factory _ClinicalUseDefinitionUndesirableEffect.fromJson(
          Map<String, dynamic> json) =
      _$_ClinicalUseDefinitionUndesirableEffect.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [symptomConditionEffect] The situation in which the undesirable effect may manifest.;
  CodeableReference? get symptomConditionEffect;
  @override

  /// [classification] High level classification of the effect.;
  CodeableConcept? get classification;
  @override

  /// [frequencyOfOccurrence] How often the effect is seen.;
  CodeableConcept? get frequencyOfOccurrence;
  @override
  @JsonKey(ignore: true)
  _$$_ClinicalUseDefinitionUndesirableEffectCopyWith<
          _$_ClinicalUseDefinitionUndesirableEffect>
      get copyWith => throw _privateConstructorUsedError;
}

ClinicalUseDefinitionWarning _$ClinicalUseDefinitionWarningFromJson(
    Map<String, dynamic> json) {
  return _ClinicalUseDefinitionWarning.fromJson(json);
}

/// @nodoc
mixin _$ClinicalUseDefinitionWarning {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [description] A textual definition of this warning, with formatting.;
  Markdown? get description => throw _privateConstructorUsedError;

  /// [descriptionElement] (_description): Extensions for description;
  @JsonKey(name: '_description')
  Element? get descriptionElement => throw _privateConstructorUsedError;

  /// [code] A coded or unformatted textual definition of this warning.;
  CodeableConcept? get code => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ClinicalUseDefinitionWarningCopyWith<ClinicalUseDefinitionWarning>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ClinicalUseDefinitionWarningCopyWith<$Res> {
  factory $ClinicalUseDefinitionWarningCopyWith(
          ClinicalUseDefinitionWarning value,
          $Res Function(ClinicalUseDefinitionWarning) then) =
      _$ClinicalUseDefinitionWarningCopyWithImpl<$Res,
          ClinicalUseDefinitionWarning>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Markdown? description,
      @JsonKey(name: '_description') Element? descriptionElement,
      CodeableConcept? code});

  $ElementCopyWith<$Res>? get descriptionElement;
  $CodeableConceptCopyWith<$Res>? get code;
}

/// @nodoc
class _$ClinicalUseDefinitionWarningCopyWithImpl<$Res,
        $Val extends ClinicalUseDefinitionWarning>
    implements $ClinicalUseDefinitionWarningCopyWith<$Res> {
  _$ClinicalUseDefinitionWarningCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? code = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get descriptionElement {
    if (_value.descriptionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.descriptionElement!, (value) {
      return _then(_value.copyWith(descriptionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get code {
    if (_value.code == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.code!, (value) {
      return _then(_value.copyWith(code: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ClinicalUseDefinitionWarningCopyWith<$Res>
    implements $ClinicalUseDefinitionWarningCopyWith<$Res> {
  factory _$$_ClinicalUseDefinitionWarningCopyWith(
          _$_ClinicalUseDefinitionWarning value,
          $Res Function(_$_ClinicalUseDefinitionWarning) then) =
      __$$_ClinicalUseDefinitionWarningCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Markdown? description,
      @JsonKey(name: '_description') Element? descriptionElement,
      CodeableConcept? code});

  @override
  $ElementCopyWith<$Res>? get descriptionElement;
  @override
  $CodeableConceptCopyWith<$Res>? get code;
}

/// @nodoc
class __$$_ClinicalUseDefinitionWarningCopyWithImpl<$Res>
    extends _$ClinicalUseDefinitionWarningCopyWithImpl<$Res,
        _$_ClinicalUseDefinitionWarning>
    implements _$$_ClinicalUseDefinitionWarningCopyWith<$Res> {
  __$$_ClinicalUseDefinitionWarningCopyWithImpl(
      _$_ClinicalUseDefinitionWarning _value,
      $Res Function(_$_ClinicalUseDefinitionWarning) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? code = freezed,
  }) {
    return _then(_$_ClinicalUseDefinitionWarning(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ClinicalUseDefinitionWarning extends _ClinicalUseDefinitionWarning {
  _$_ClinicalUseDefinitionWarning(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.description,
      @JsonKey(name: '_description') this.descriptionElement,
      this.code})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_ClinicalUseDefinitionWarning.fromJson(Map<String, dynamic> json) =>
      _$$_ClinicalUseDefinitionWarningFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [description] A textual definition of this warning, with formatting.;
  @override
  final Markdown? description;

  /// [descriptionElement] (_description): Extensions for description;
  @override
  @JsonKey(name: '_description')
  final Element? descriptionElement;

  /// [code] A coded or unformatted textual definition of this warning.;
  @override
  final CodeableConcept? code;

  @override
  String toString() {
    return 'ClinicalUseDefinitionWarning(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, description: $description, descriptionElement: $descriptionElement, code: $code)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ClinicalUseDefinitionWarning &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.descriptionElement, descriptionElement) ||
                other.descriptionElement == descriptionElement) &&
            (identical(other.code, code) || other.code == code));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      description,
      descriptionElement,
      code);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ClinicalUseDefinitionWarningCopyWith<_$_ClinicalUseDefinitionWarning>
      get copyWith => __$$_ClinicalUseDefinitionWarningCopyWithImpl<
          _$_ClinicalUseDefinitionWarning>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ClinicalUseDefinitionWarningToJson(
      this,
    );
  }
}

abstract class _ClinicalUseDefinitionWarning
    extends ClinicalUseDefinitionWarning {
  factory _ClinicalUseDefinitionWarning(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final Markdown? description,
      @JsonKey(name: '_description') final Element? descriptionElement,
      final CodeableConcept? code}) = _$_ClinicalUseDefinitionWarning;
  _ClinicalUseDefinitionWarning._() : super._();

  factory _ClinicalUseDefinitionWarning.fromJson(Map<String, dynamic> json) =
      _$_ClinicalUseDefinitionWarning.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions. Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [description] A textual definition of this warning, with formatting.;
  Markdown? get description;
  @override

  /// [descriptionElement] (_description): Extensions for description;
  @JsonKey(name: '_description')
  Element? get descriptionElement;
  @override

  /// [code] A coded or unformatted textual definition of this warning.;
  CodeableConcept? get code;
  @override
  @JsonKey(ignore: true)
  _$$_ClinicalUseDefinitionWarningCopyWith<_$_ClinicalUseDefinitionWarning>
      get copyWith => throw _privateConstructorUsedError;
}

ManufacturedItemDefinition _$ManufacturedItemDefinitionFromJson(
    Map<String, dynamic> json) {
  return _ManufacturedItemDefinition.fromJson(json);
}

/// @nodoc
mixin _$ManufacturedItemDefinition {
  R4ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  String? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.;
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] (_language): Extensions for language;
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] Unique identifier.;
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [status] The status of this item. Enables tracking the life-cycle of the content.;
  Code? get status => throw _privateConstructorUsedError;

  /// [statusElement] (_status): Extensions for status;
  @JsonKey(name: '_status')
  Element? get statusElement => throw _privateConstructorUsedError;

  /// [manufacturedDoseForm] Dose form as manufactured and before any transformation into the pharmaceutical product.;
  CodeableConcept get manufacturedDoseForm =>
      throw _privateConstructorUsedError;

  /// [unitOfPresentation] The “real world” units in which the quantity of the manufactured item is described.;
  CodeableConcept? get unitOfPresentation => throw _privateConstructorUsedError;

  /// [manufacturer] Manufacturer of the item (Note that this should be named "manufacturer" but it currently causes technical issues).;
  List<Reference>? get manufacturer => throw _privateConstructorUsedError;

  /// [ingredient] The ingredients of this manufactured item. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource.;
  List<CodeableConcept>? get ingredient => throw _privateConstructorUsedError;

  /// [property] General characteristics of this item.;
  List<ManufacturedItemDefinitionProperty>? get property =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ManufacturedItemDefinitionCopyWith<ManufacturedItemDefinition>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ManufacturedItemDefinitionCopyWith<$Res> {
  factory $ManufacturedItemDefinitionCopyWith(ManufacturedItemDefinition value,
          $Res Function(ManufacturedItemDefinition) then) =
      _$ManufacturedItemDefinitionCopyWithImpl<$Res,
          ManufacturedItemDefinition>;
  @useResult
  $Res call(
      {R4ResourceType resourceType,
      String? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      Code? status,
      @JsonKey(name: '_status') Element? statusElement,
      CodeableConcept manufacturedDoseForm,
      CodeableConcept? unitOfPresentation,
      List<Reference>? manufacturer,
      List<CodeableConcept>? ingredient,
      List<ManufacturedItemDefinitionProperty>? property});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $ElementCopyWith<$Res>? get statusElement;
  $CodeableConceptCopyWith<$Res> get manufacturedDoseForm;
  $CodeableConceptCopyWith<$Res>? get unitOfPresentation;
}

/// @nodoc
class _$ManufacturedItemDefinitionCopyWithImpl<$Res,
        $Val extends ManufacturedItemDefinition>
    implements $ManufacturedItemDefinitionCopyWith<$Res> {
  _$ManufacturedItemDefinitionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? manufacturedDoseForm = null,
    Object? unitOfPresentation = freezed,
    Object? manufacturer = freezed,
    Object? ingredient = freezed,
    Object? property = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R4ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as Code?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      manufacturedDoseForm: null == manufacturedDoseForm
          ? _value.manufacturedDoseForm
          : manufacturedDoseForm // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      unitOfPresentation: freezed == unitOfPresentation
          ? _value.unitOfPresentation
          : unitOfPresentation // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      manufacturer: freezed == manufacturer
          ? _value.manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      ingredient: freezed == ingredient
          ? _value.ingredient
          : ingredient // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      property: freezed == property
          ? _value.property
          : property // ignore: cast_nullable_to_non_nullable
              as List<ManufacturedItemDefinitionProperty>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusElement {
    if (_value.statusElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusElement!, (value) {
      return _then(_value.copyWith(statusElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get manufacturedDoseForm {
    return $CodeableConceptCopyWith<$Res>(_value.manufacturedDoseForm, (value) {
      return _then(_value.copyWith(manufacturedDoseForm: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get unitOfPresentation {
    if (_value.unitOfPresentation == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.unitOfPresentation!, (value) {
      return _then(_value.copyWith(unitOfPresentation: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ManufacturedItemDefinitionCopyWith<$Res>
    implements $ManufacturedItemDefinitionCopyWith<$Res> {
  factory _$$_ManufacturedItemDefinitionCopyWith(
          _$_ManufacturedItemDefinition value,
          $Res Function(_$_ManufacturedItemDefinition) then) =
      __$$_ManufacturedItemDefinitionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {R4ResourceType resourceType,
      String? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      Code? status,
      @JsonKey(name: '_status') Element? statusElement,
      CodeableConcept manufacturedDoseForm,
      CodeableConcept? unitOfPresentation,
      List<Reference>? manufacturer,
      List<CodeableConcept>? ingredient,
      List<ManufacturedItemDefinitionProperty>? property});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $ElementCopyWith<$Res>? get statusElement;
  @override
  $CodeableConceptCopyWith<$Res> get manufacturedDoseForm;
  @override
  $CodeableConceptCopyWith<$Res>? get unitOfPresentation;
}

/// @nodoc
class __$$_ManufacturedItemDefinitionCopyWithImpl<$Res>
    extends _$ManufacturedItemDefinitionCopyWithImpl<$Res,
        _$_ManufacturedItemDefinition>
    implements _$$_ManufacturedItemDefinitionCopyWith<$Res> {
  __$$_ManufacturedItemDefinitionCopyWithImpl(
      _$_ManufacturedItemDefinition _value,
      $Res Function(_$_ManufacturedItemDefinition) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? manufacturedDoseForm = null,
    Object? unitOfPresentation = freezed,
    Object? manufacturer = freezed,
    Object? ingredient = freezed,
    Object? property = freezed,
  }) {
    return _then(_$_ManufacturedItemDefinition(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R4ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as Code?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      manufacturedDoseForm: null == manufacturedDoseForm
          ? _value.manufacturedDoseForm
          : manufacturedDoseForm // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      unitOfPresentation: freezed == unitOfPresentation
          ? _value.unitOfPresentation
          : unitOfPresentation // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      manufacturer: freezed == manufacturer
          ? _value._manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      ingredient: freezed == ingredient
          ? _value._ingredient
          : ingredient // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      property: freezed == property
          ? _value._property
          : property // ignore: cast_nullable_to_non_nullable
              as List<ManufacturedItemDefinitionProperty>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ManufacturedItemDefinition extends _ManufacturedItemDefinition {
  _$_ManufacturedItemDefinition(
      {this.resourceType = R4ResourceType.ManufacturedItemDefinition,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules') this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language') this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      this.status,
      @JsonKey(name: '_status') this.statusElement,
      required this.manufacturedDoseForm,
      this.unitOfPresentation,
      final List<Reference>? manufacturer,
      final List<CodeableConcept>? ingredient,
      final List<ManufacturedItemDefinitionProperty>? property})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _manufacturer = manufacturer,
        _ingredient = ingredient,
        _property = property,
        super._();

  factory _$_ManufacturedItemDefinition.fromJson(Map<String, dynamic> json) =>
      _$$_ManufacturedItemDefinitionFromJson(json);

  @override
  @JsonKey()
  final R4ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  @override
  final String? id;

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.;
  @override
  final Code? language;

  /// [languageElement] (_language): Extensions for language;
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] Unique identifier.;
  final List<Identifier>? _identifier;

  /// [identifier] Unique identifier.;
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [status] The status of this item. Enables tracking the life-cycle of the content.;
  @override
  final Code? status;

  /// [statusElement] (_status): Extensions for status;
  @override
  @JsonKey(name: '_status')
  final Element? statusElement;

  /// [manufacturedDoseForm] Dose form as manufactured and before any transformation into the pharmaceutical product.;
  @override
  final CodeableConcept manufacturedDoseForm;

  /// [unitOfPresentation] The “real world” units in which the quantity of the manufactured item is described.;
  @override
  final CodeableConcept? unitOfPresentation;

  /// [manufacturer] Manufacturer of the item (Note that this should be named "manufacturer" but it currently causes technical issues).;
  final List<Reference>? _manufacturer;

  /// [manufacturer] Manufacturer of the item (Note that this should be named "manufacturer" but it currently causes technical issues).;
  @override
  List<Reference>? get manufacturer {
    final value = _manufacturer;
    if (value == null) return null;
    if (_manufacturer is EqualUnmodifiableListView) return _manufacturer;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [ingredient] The ingredients of this manufactured item. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource.;
  final List<CodeableConcept>? _ingredient;

  /// [ingredient] The ingredients of this manufactured item. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource.;
  @override
  List<CodeableConcept>? get ingredient {
    final value = _ingredient;
    if (value == null) return null;
    if (_ingredient is EqualUnmodifiableListView) return _ingredient;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [property] General characteristics of this item.;
  final List<ManufacturedItemDefinitionProperty>? _property;

  /// [property] General characteristics of this item.;
  @override
  List<ManufacturedItemDefinitionProperty>? get property {
    final value = _property;
    if (value == null) return null;
    if (_property is EqualUnmodifiableListView) return _property;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ManufacturedItemDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, status: $status, statusElement: $statusElement, manufacturedDoseForm: $manufacturedDoseForm, unitOfPresentation: $unitOfPresentation, manufacturer: $manufacturer, ingredient: $ingredient, property: $property)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ManufacturedItemDefinition &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusElement, statusElement) ||
                other.statusElement == statusElement) &&
            (identical(other.manufacturedDoseForm, manufacturedDoseForm) ||
                other.manufacturedDoseForm == manufacturedDoseForm) &&
            (identical(other.unitOfPresentation, unitOfPresentation) ||
                other.unitOfPresentation == unitOfPresentation) &&
            const DeepCollectionEquality()
                .equals(other._manufacturer, _manufacturer) &&
            const DeepCollectionEquality()
                .equals(other._ingredient, _ingredient) &&
            const DeepCollectionEquality().equals(other._property, _property));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_identifier),
        status,
        statusElement,
        manufacturedDoseForm,
        unitOfPresentation,
        const DeepCollectionEquality().hash(_manufacturer),
        const DeepCollectionEquality().hash(_ingredient),
        const DeepCollectionEquality().hash(_property)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ManufacturedItemDefinitionCopyWith<_$_ManufacturedItemDefinition>
      get copyWith => __$$_ManufacturedItemDefinitionCopyWithImpl<
          _$_ManufacturedItemDefinition>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ManufacturedItemDefinitionToJson(
      this,
    );
  }
}

abstract class _ManufacturedItemDefinition extends ManufacturedItemDefinition {
  factory _ManufacturedItemDefinition(
          {final R4ResourceType resourceType,
          final String? id,
          final Meta? meta,
          final FhirUri? implicitRules,
          @JsonKey(name: '_implicitRules') final Element? implicitRulesElement,
          final Code? language,
          @JsonKey(name: '_language') final Element? languageElement,
          final Narrative? text,
          final List<Resource>? contained,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final List<Identifier>? identifier,
          final Code? status,
          @JsonKey(name: '_status') final Element? statusElement,
          required final CodeableConcept manufacturedDoseForm,
          final CodeableConcept? unitOfPresentation,
          final List<Reference>? manufacturer,
          final List<CodeableConcept>? ingredient,
          final List<ManufacturedItemDefinitionProperty>? property}) =
      _$_ManufacturedItemDefinition;
  _ManufacturedItemDefinition._() : super._();

  factory _ManufacturedItemDefinition.fromJson(Map<String, dynamic> json) =
      _$_ManufacturedItemDefinition.fromJson;

  @override
  R4ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  String? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.;
  Code? get language;
  @override

  /// [languageElement] (_language): Extensions for language;
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  List<Resource>? get contained;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] Unique identifier.;
  List<Identifier>? get identifier;
  @override

  /// [status] The status of this item. Enables tracking the life-cycle of the content.;
  Code? get status;
  @override

  /// [statusElement] (_status): Extensions for status;
  @JsonKey(name: '_status')
  Element? get statusElement;
  @override

  /// [manufacturedDoseForm] Dose form as manufactured and before any transformation into the pharmaceutical product.;
  CodeableConcept get manufacturedDoseForm;
  @override

  /// [unitOfPresentation] The “real world” units in which the quantity of the manufactured item is described.;
  CodeableConcept? get unitOfPresentation;
  @override

  /// [manufacturer] Manufacturer of the item (Note that this should be named "manufacturer" but it currently causes technical issues).;
  List<Reference>? get manufacturer;
  @override

  /// [ingredient] The ingredients of this manufactured item. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource.;
  List<CodeableConcept>? get ingredient;
  @override

  /// [property] General characteristics of this item.;
  List<ManufacturedItemDefinitionProperty>? get property;
  @override
  @JsonKey(ignore: true)
  _$$_ManufacturedItemDefinitionCopyWith<_$_ManufacturedItemDefinition>
      get copyWith => throw _privateConstructorUsedError;
}

ManufacturedItemDefinitionProperty _$ManufacturedItemDefinitionPropertyFromJson(
    Map<String, dynamic> json) {
  return _ManufacturedItemDefinitionProperty.fromJson(json);
}

/// @nodoc
mixin _$ManufacturedItemDefinitionProperty {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] A code expressing the type of characteristic.;
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [valueCodeableConcept] A value for the characteristic.;
  CodeableConcept? get valueCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [valueQuantity] A value for the characteristic.;
  Quantity? get valueQuantity => throw _privateConstructorUsedError;

  /// [valueDate] A value for the characteristic.;
  Date? get valueDate => throw _privateConstructorUsedError;

  /// [valueDateElement] (_valueDate): Extensions for valueDate;
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement => throw _privateConstructorUsedError;

  /// [valueBoolean] A value for the characteristic.;
  Boolean? get valueBoolean => throw _privateConstructorUsedError;

  /// [valueBooleanElement] (_valueBoolean): Extensions for valueBoolean;
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement => throw _privateConstructorUsedError;

  /// [valueAttachment] A value for the characteristic.;
  Attachment? get valueAttachment => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ManufacturedItemDefinitionPropertyCopyWith<
          ManufacturedItemDefinitionProperty>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ManufacturedItemDefinitionPropertyCopyWith<$Res> {
  factory $ManufacturedItemDefinitionPropertyCopyWith(
          ManufacturedItemDefinitionProperty value,
          $Res Function(ManufacturedItemDefinitionProperty) then) =
      _$ManufacturedItemDefinitionPropertyCopyWithImpl<$Res,
          ManufacturedItemDefinitionProperty>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      Quantity? valueQuantity,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment});

  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  $QuantityCopyWith<$Res>? get valueQuantity;
  $ElementCopyWith<$Res>? get valueDateElement;
  $ElementCopyWith<$Res>? get valueBooleanElement;
  $AttachmentCopyWith<$Res>? get valueAttachment;
}

/// @nodoc
class _$ManufacturedItemDefinitionPropertyCopyWithImpl<$Res,
        $Val extends ManufacturedItemDefinitionProperty>
    implements $ManufacturedItemDefinitionPropertyCopyWith<$Res> {
  _$ManufacturedItemDefinitionPropertyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueQuantity = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept {
    if (_value.valueCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.valueCodeableConcept!,
        (value) {
      return _then(_value.copyWith(valueCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get valueQuantity {
    if (_value.valueQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.valueQuantity!, (value) {
      return _then(_value.copyWith(valueQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueDateElement {
    if (_value.valueDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueDateElement!, (value) {
      return _then(_value.copyWith(valueDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueBooleanElement {
    if (_value.valueBooleanElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueBooleanElement!, (value) {
      return _then(_value.copyWith(valueBooleanElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get valueAttachment {
    if (_value.valueAttachment == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.valueAttachment!, (value) {
      return _then(_value.copyWith(valueAttachment: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ManufacturedItemDefinitionPropertyCopyWith<$Res>
    implements $ManufacturedItemDefinitionPropertyCopyWith<$Res> {
  factory _$$_ManufacturedItemDefinitionPropertyCopyWith(
          _$_ManufacturedItemDefinitionProperty value,
          $Res Function(_$_ManufacturedItemDefinitionProperty) then) =
      __$$_ManufacturedItemDefinitionPropertyCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      Quantity? valueQuantity,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  @override
  $QuantityCopyWith<$Res>? get valueQuantity;
  @override
  $ElementCopyWith<$Res>? get valueDateElement;
  @override
  $ElementCopyWith<$Res>? get valueBooleanElement;
  @override
  $AttachmentCopyWith<$Res>? get valueAttachment;
}

/// @nodoc
class __$$_ManufacturedItemDefinitionPropertyCopyWithImpl<$Res>
    extends _$ManufacturedItemDefinitionPropertyCopyWithImpl<$Res,
        _$_ManufacturedItemDefinitionProperty>
    implements _$$_ManufacturedItemDefinitionPropertyCopyWith<$Res> {
  __$$_ManufacturedItemDefinitionPropertyCopyWithImpl(
      _$_ManufacturedItemDefinitionProperty _value,
      $Res Function(_$_ManufacturedItemDefinitionProperty) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueQuantity = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
  }) {
    return _then(_$_ManufacturedItemDefinitionProperty(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ManufacturedItemDefinitionProperty
    extends _ManufacturedItemDefinitionProperty {
  _$_ManufacturedItemDefinitionProperty(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.type,
      this.valueCodeableConcept,
      this.valueQuantity,
      this.valueDate,
      @JsonKey(name: '_valueDate') this.valueDateElement,
      this.valueBoolean,
      @JsonKey(name: '_valueBoolean') this.valueBooleanElement,
      this.valueAttachment})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_ManufacturedItemDefinitionProperty.fromJson(
          Map<String, dynamic> json) =>
      _$$_ManufacturedItemDefinitionPropertyFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] A code expressing the type of characteristic.;
  @override
  final CodeableConcept type;

  /// [valueCodeableConcept] A value for the characteristic.;
  @override
  final CodeableConcept? valueCodeableConcept;

  /// [valueQuantity] A value for the characteristic.;
  @override
  final Quantity? valueQuantity;

  /// [valueDate] A value for the characteristic.;
  @override
  final Date? valueDate;

  /// [valueDateElement] (_valueDate): Extensions for valueDate;
  @override
  @JsonKey(name: '_valueDate')
  final Element? valueDateElement;

  /// [valueBoolean] A value for the characteristic.;
  @override
  final Boolean? valueBoolean;

  /// [valueBooleanElement] (_valueBoolean): Extensions for valueBoolean;
  @override
  @JsonKey(name: '_valueBoolean')
  final Element? valueBooleanElement;

  /// [valueAttachment] A value for the characteristic.;
  @override
  final Attachment? valueAttachment;

  @override
  String toString() {
    return 'ManufacturedItemDefinitionProperty(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, valueCodeableConcept: $valueCodeableConcept, valueQuantity: $valueQuantity, valueDate: $valueDate, valueDateElement: $valueDateElement, valueBoolean: $valueBoolean, valueBooleanElement: $valueBooleanElement, valueAttachment: $valueAttachment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ManufacturedItemDefinitionProperty &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.valueCodeableConcept, valueCodeableConcept) ||
                other.valueCodeableConcept == valueCodeableConcept) &&
            (identical(other.valueQuantity, valueQuantity) ||
                other.valueQuantity == valueQuantity) &&
            (identical(other.valueDate, valueDate) ||
                other.valueDate == valueDate) &&
            (identical(other.valueDateElement, valueDateElement) ||
                other.valueDateElement == valueDateElement) &&
            (identical(other.valueBoolean, valueBoolean) ||
                other.valueBoolean == valueBoolean) &&
            (identical(other.valueBooleanElement, valueBooleanElement) ||
                other.valueBooleanElement == valueBooleanElement) &&
            (identical(other.valueAttachment, valueAttachment) ||
                other.valueAttachment == valueAttachment));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      valueCodeableConcept,
      valueQuantity,
      valueDate,
      valueDateElement,
      valueBoolean,
      valueBooleanElement,
      valueAttachment);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ManufacturedItemDefinitionPropertyCopyWith<
          _$_ManufacturedItemDefinitionProperty>
      get copyWith => __$$_ManufacturedItemDefinitionPropertyCopyWithImpl<
          _$_ManufacturedItemDefinitionProperty>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ManufacturedItemDefinitionPropertyToJson(
      this,
    );
  }
}

abstract class _ManufacturedItemDefinitionProperty
    extends ManufacturedItemDefinitionProperty {
  factory _ManufacturedItemDefinitionProperty(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept type,
          final CodeableConcept? valueCodeableConcept,
          final Quantity? valueQuantity,
          final Date? valueDate,
          @JsonKey(name: '_valueDate') final Element? valueDateElement,
          final Boolean? valueBoolean,
          @JsonKey(name: '_valueBoolean') final Element? valueBooleanElement,
          final Attachment? valueAttachment}) =
      _$_ManufacturedItemDefinitionProperty;
  _ManufacturedItemDefinitionProperty._() : super._();

  factory _ManufacturedItemDefinitionProperty.fromJson(
          Map<String, dynamic> json) =
      _$_ManufacturedItemDefinitionProperty.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] A code expressing the type of characteristic.;
  CodeableConcept get type;
  @override

  /// [valueCodeableConcept] A value for the characteristic.;
  CodeableConcept? get valueCodeableConcept;
  @override

  /// [valueQuantity] A value for the characteristic.;
  Quantity? get valueQuantity;
  @override

  /// [valueDate] A value for the characteristic.;
  Date? get valueDate;
  @override

  /// [valueDateElement] (_valueDate): Extensions for valueDate;
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement;
  @override

  /// [valueBoolean] A value for the characteristic.;
  Boolean? get valueBoolean;
  @override

  /// [valueBooleanElement] (_valueBoolean): Extensions for valueBoolean;
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement;
  @override

  /// [valueAttachment] A value for the characteristic.;
  Attachment? get valueAttachment;
  @override
  @JsonKey(ignore: true)
  _$$_ManufacturedItemDefinitionPropertyCopyWith<
          _$_ManufacturedItemDefinitionProperty>
      get copyWith => throw _privateConstructorUsedError;
}

MedicinalProductDefinition _$MedicinalProductDefinitionFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductDefinition.fromJson(json);
}

/// @nodoc
mixin _$MedicinalProductDefinition {
  R4ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  String? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.;
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] (_language): Extensions for language;
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] Business identifier for this product. Could be an MPID. When in development or being regulated, products are typically referenced by official identifiers, assigned by a manufacturer or regulator, and unique to a product (which, when compared to a product instance being prescribed, is actually a product type). See also MedicinalProductDefinition.code.;
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [type] Regulatory type, e.g. Investigational or Authorized.;
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [domain] If this medicine applies to human or veterinary uses.;
  CodeableConcept? get domain => throw _privateConstructorUsedError;

  /// [version] A business identifier relating to a specific version of the product, this is commonly used to support revisions to an existing product.;
  String? get version => throw _privateConstructorUsedError;

  /// [versionElement] (_version): Extensions for version;
  @JsonKey(name: '_version')
  Element? get versionElement => throw _privateConstructorUsedError;

  /// [status] The status within the lifecycle of this product record. A high-level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization status.;
  CodeableConcept? get status => throw _privateConstructorUsedError;

  /// [statusDate] The date at which the given status became applicable.;
  FhirDateTime? get statusDate => throw _privateConstructorUsedError;

  /// [statusDateElement] (_statusDate): Extensions for statusDate;
  @JsonKey(name: '_statusDate')
  Element? get statusDateElement => throw _privateConstructorUsedError;

  /// [description] General description of this product.;
  Markdown? get description => throw _privateConstructorUsedError;

  /// [descriptionElement] (_description): Extensions for description;
  @JsonKey(name: '_description')
  Element? get descriptionElement => throw _privateConstructorUsedError;

  /// [combinedPharmaceuticalDoseForm] The dose form for a single part product, or combined form of a multiple part product. This is one concept that describes all the components. It does not represent the form with components physically mixed, if that might be necessary, for which see (AdministrableProductDefinition.administrableDoseForm).;
  CodeableConcept? get combinedPharmaceuticalDoseForm =>
      throw _privateConstructorUsedError;

  /// [route] The path by which the product is taken into or makes contact with the body. In some regions this is referred to as the licenced or approved route. See also AdministrableProductDefinition resource. MedicinalProductDefinition.route is the same concept as AdministrableProductDefinition.routeOfAdministration.code, and they cannot be used together.;
  List<CodeableConcept>? get route => throw _privateConstructorUsedError;

  /// [indication] Description of indication(s) for this product, used when structured indications are not required. In cases where structured indications are required, they are captured using the ClinicalUseDefinition resource. An indication is a medical situation for which using the product is appropriate.;
  Markdown? get indication => throw _privateConstructorUsedError;

  /// [indicationElement] (_indication): Extensions for indication;
  @JsonKey(name: '_indication')
  Element? get indicationElement => throw _privateConstructorUsedError;

  /// [legalStatusOfSupply] The legal status of supply of the medicinal product as classified by the regulator.;
  CodeableConcept? get legalStatusOfSupply =>
      throw _privateConstructorUsedError;

  /// [additionalMonitoringIndicator] Whether the Medicinal Product is subject to additional monitoring for regulatory reasons, such as heightened reporting requirements.;
  CodeableConcept? get additionalMonitoringIndicator =>
      throw _privateConstructorUsedError;

  /// [specialMeasures] Whether the Medicinal Product is subject to special measures for regulatory reasons, such as a requirement to conduct post-authorisation studies.;
  List<CodeableConcept>? get specialMeasures =>
      throw _privateConstructorUsedError;

  /// [pediatricUseIndicator] If authorised for use in children, or infants, neonates etc.;
  CodeableConcept? get pediatricUseIndicator =>
      throw _privateConstructorUsedError;

  /// [classification] Allows the product to be classified by various systems, commonly WHO ATC.;
  List<CodeableConcept>? get classification =>
      throw _privateConstructorUsedError;

  /// [marketingStatus] Marketing status of the medicinal product, in contrast to marketing authorization. This refers to the product being actually 'on the market' as opposed to being allowed to be on the market (which is an authorization).;
  List<MarketingStatus>? get marketingStatus =>
      throw _privateConstructorUsedError;

  /// [packagedMedicinalProduct] Package type for the product. See also the PackagedProductDefinition resource.;
  List<CodeableConcept>? get packagedMedicinalProduct =>
      throw _privateConstructorUsedError;

  /// [ingredient] The ingredients of this medicinal product - when not detailed in other resources. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource, or indirectly via incoming AdministrableProductDefinition, PackagedProductDefinition or ManufacturedItemDefinition references. In cases where those levels of detail are not used, the ingredients may be specified directly here as codes.;
  List<CodeableConcept>? get ingredient => throw _privateConstructorUsedError;

  /// [impurity] Any component of the drug product which is not the chemical entity defined as the drug substance, or an excipient in the drug product. This includes process-related impurities and contaminants, product-related impurities including degradation products.;
  List<CodeableReference>? get impurity => throw _privateConstructorUsedError;

  /// [attachedDocument] Additional information or supporting documentation about the medicinal product.;
  List<Reference>? get attachedDocument => throw _privateConstructorUsedError;

  /// [masterFile] A master file for the medicinal product (e.g. Pharmacovigilance System Master File). Drug master files (DMFs) are documents submitted to regulatory agencies to provide confidential detailed information about facilities, processes or articles used in the manufacturing, processing, packaging and storing of drug products.;
  List<Reference>? get masterFile => throw _privateConstructorUsedError;

  /// [contact] A product specific contact, person (in a role), or an organization.;
  List<MedicinalProductDefinitionContact>? get contact =>
      throw _privateConstructorUsedError;

  /// [clinicalTrial] Clinical trials or studies that this product is involved in.;
  List<Reference>? get clinicalTrial => throw _privateConstructorUsedError;

  /// [code] A code that this product is known by, usually within some formal terminology, perhaps assigned by a third party (i.e. not the manufacturer or regulator). Products (types of medications) tend to be known by identifiers during development and within regulatory process. However when they are prescribed they tend to be identified by codes. The same product may be have multiple codes, applied to it by multiple organizations.;
  List<Coding>? get code => throw _privateConstructorUsedError;

  /// [name] The product's name, including full name and possibly coded parts.;
  List<MedicinalProductDefinitionName> get name =>
      throw _privateConstructorUsedError;

  /// [crossReference] Reference to another product, e.g. for linking authorised to investigational product, or a virtual product.;
  List<MedicinalProductDefinitionCrossReference>? get crossReference =>
      throw _privateConstructorUsedError;

  /// [operation] A manufacturing or administrative process or step associated with (or performed on) the medicinal product.;
  List<MedicinalProductDefinitionOperation>? get operation =>
      throw _privateConstructorUsedError;

  /// [characteristic] Allows the key product features to be recorded, such as "sugar free", "modified release", "parallel import".;
  List<MedicinalProductDefinitionCharacteristic>? get characteristic =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MedicinalProductDefinitionCopyWith<MedicinalProductDefinition>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MedicinalProductDefinitionCopyWith<$Res> {
  factory $MedicinalProductDefinitionCopyWith(MedicinalProductDefinition value,
          $Res Function(MedicinalProductDefinition) then) =
      _$MedicinalProductDefinitionCopyWithImpl<$Res,
          MedicinalProductDefinition>;
  @useResult
  $Res call(
      {R4ResourceType resourceType,
      String? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      CodeableConcept? type,
      CodeableConcept? domain,
      String? version,
      @JsonKey(name: '_version') Element? versionElement,
      CodeableConcept? status,
      FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate') Element? statusDateElement,
      Markdown? description,
      @JsonKey(name: '_description') Element? descriptionElement,
      CodeableConcept? combinedPharmaceuticalDoseForm,
      List<CodeableConcept>? route,
      Markdown? indication,
      @JsonKey(name: '_indication') Element? indicationElement,
      CodeableConcept? legalStatusOfSupply,
      CodeableConcept? additionalMonitoringIndicator,
      List<CodeableConcept>? specialMeasures,
      CodeableConcept? pediatricUseIndicator,
      List<CodeableConcept>? classification,
      List<MarketingStatus>? marketingStatus,
      List<CodeableConcept>? packagedMedicinalProduct,
      List<CodeableConcept>? ingredient,
      List<CodeableReference>? impurity,
      List<Reference>? attachedDocument,
      List<Reference>? masterFile,
      List<MedicinalProductDefinitionContact>? contact,
      List<Reference>? clinicalTrial,
      List<Coding>? code,
      List<MedicinalProductDefinitionName> name,
      List<MedicinalProductDefinitionCrossReference>? crossReference,
      List<MedicinalProductDefinitionOperation>? operation,
      List<MedicinalProductDefinitionCharacteristic>? characteristic});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $CodeableConceptCopyWith<$Res>? get type;
  $CodeableConceptCopyWith<$Res>? get domain;
  $ElementCopyWith<$Res>? get versionElement;
  $CodeableConceptCopyWith<$Res>? get status;
  $ElementCopyWith<$Res>? get statusDateElement;
  $ElementCopyWith<$Res>? get descriptionElement;
  $CodeableConceptCopyWith<$Res>? get combinedPharmaceuticalDoseForm;
  $ElementCopyWith<$Res>? get indicationElement;
  $CodeableConceptCopyWith<$Res>? get legalStatusOfSupply;
  $CodeableConceptCopyWith<$Res>? get additionalMonitoringIndicator;
  $CodeableConceptCopyWith<$Res>? get pediatricUseIndicator;
}

/// @nodoc
class _$MedicinalProductDefinitionCopyWithImpl<$Res,
        $Val extends MedicinalProductDefinition>
    implements $MedicinalProductDefinitionCopyWith<$Res> {
  _$MedicinalProductDefinitionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = freezed,
    Object? domain = freezed,
    Object? version = freezed,
    Object? versionElement = freezed,
    Object? status = freezed,
    Object? statusDate = freezed,
    Object? statusDateElement = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? combinedPharmaceuticalDoseForm = freezed,
    Object? route = freezed,
    Object? indication = freezed,
    Object? indicationElement = freezed,
    Object? legalStatusOfSupply = freezed,
    Object? additionalMonitoringIndicator = freezed,
    Object? specialMeasures = freezed,
    Object? pediatricUseIndicator = freezed,
    Object? classification = freezed,
    Object? marketingStatus = freezed,
    Object? packagedMedicinalProduct = freezed,
    Object? ingredient = freezed,
    Object? impurity = freezed,
    Object? attachedDocument = freezed,
    Object? masterFile = freezed,
    Object? contact = freezed,
    Object? clinicalTrial = freezed,
    Object? code = freezed,
    Object? name = null,
    Object? crossReference = freezed,
    Object? operation = freezed,
    Object? characteristic = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R4ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      domain: freezed == domain
          ? _value.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      version: freezed == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String?,
      versionElement: freezed == versionElement
          ? _value.versionElement
          : versionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      statusDate: freezed == statusDate
          ? _value.statusDate
          : statusDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      statusDateElement: freezed == statusDateElement
          ? _value.statusDateElement
          : statusDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      combinedPharmaceuticalDoseForm: freezed == combinedPharmaceuticalDoseForm
          ? _value.combinedPharmaceuticalDoseForm
          : combinedPharmaceuticalDoseForm // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      route: freezed == route
          ? _value.route
          : route // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      indication: freezed == indication
          ? _value.indication
          : indication // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      indicationElement: freezed == indicationElement
          ? _value.indicationElement
          : indicationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      legalStatusOfSupply: freezed == legalStatusOfSupply
          ? _value.legalStatusOfSupply
          : legalStatusOfSupply // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      additionalMonitoringIndicator: freezed == additionalMonitoringIndicator
          ? _value.additionalMonitoringIndicator
          : additionalMonitoringIndicator // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      specialMeasures: freezed == specialMeasures
          ? _value.specialMeasures
          : specialMeasures // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      pediatricUseIndicator: freezed == pediatricUseIndicator
          ? _value.pediatricUseIndicator
          : pediatricUseIndicator // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      classification: freezed == classification
          ? _value.classification
          : classification // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      marketingStatus: freezed == marketingStatus
          ? _value.marketingStatus
          : marketingStatus // ignore: cast_nullable_to_non_nullable
              as List<MarketingStatus>?,
      packagedMedicinalProduct: freezed == packagedMedicinalProduct
          ? _value.packagedMedicinalProduct
          : packagedMedicinalProduct // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      ingredient: freezed == ingredient
          ? _value.ingredient
          : ingredient // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      impurity: freezed == impurity
          ? _value.impurity
          : impurity // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      attachedDocument: freezed == attachedDocument
          ? _value.attachedDocument
          : attachedDocument // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      masterFile: freezed == masterFile
          ? _value.masterFile
          : masterFile // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      contact: freezed == contact
          ? _value.contact
          : contact // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionContact>?,
      clinicalTrial: freezed == clinicalTrial
          ? _value.clinicalTrial
          : clinicalTrial // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as List<Coding>?,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionName>,
      crossReference: freezed == crossReference
          ? _value.crossReference
          : crossReference // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionCrossReference>?,
      operation: freezed == operation
          ? _value.operation
          : operation // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionOperation>?,
      characteristic: freezed == characteristic
          ? _value.characteristic
          : characteristic // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionCharacteristic>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get domain {
    if (_value.domain == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.domain!, (value) {
      return _then(_value.copyWith(domain: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get versionElement {
    if (_value.versionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.versionElement!, (value) {
      return _then(_value.copyWith(versionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusDateElement {
    if (_value.statusDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusDateElement!, (value) {
      return _then(_value.copyWith(statusDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get descriptionElement {
    if (_value.descriptionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.descriptionElement!, (value) {
      return _then(_value.copyWith(descriptionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get combinedPharmaceuticalDoseForm {
    if (_value.combinedPharmaceuticalDoseForm == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(
        _value.combinedPharmaceuticalDoseForm!, (value) {
      return _then(
          _value.copyWith(combinedPharmaceuticalDoseForm: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get indicationElement {
    if (_value.indicationElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.indicationElement!, (value) {
      return _then(_value.copyWith(indicationElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get legalStatusOfSupply {
    if (_value.legalStatusOfSupply == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.legalStatusOfSupply!, (value) {
      return _then(_value.copyWith(legalStatusOfSupply: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get additionalMonitoringIndicator {
    if (_value.additionalMonitoringIndicator == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.additionalMonitoringIndicator!,
        (value) {
      return _then(
          _value.copyWith(additionalMonitoringIndicator: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get pediatricUseIndicator {
    if (_value.pediatricUseIndicator == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.pediatricUseIndicator!,
        (value) {
      return _then(_value.copyWith(pediatricUseIndicator: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MedicinalProductDefinitionCopyWith<$Res>
    implements $MedicinalProductDefinitionCopyWith<$Res> {
  factory _$$_MedicinalProductDefinitionCopyWith(
          _$_MedicinalProductDefinition value,
          $Res Function(_$_MedicinalProductDefinition) then) =
      __$$_MedicinalProductDefinitionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {R4ResourceType resourceType,
      String? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      CodeableConcept? type,
      CodeableConcept? domain,
      String? version,
      @JsonKey(name: '_version') Element? versionElement,
      CodeableConcept? status,
      FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate') Element? statusDateElement,
      Markdown? description,
      @JsonKey(name: '_description') Element? descriptionElement,
      CodeableConcept? combinedPharmaceuticalDoseForm,
      List<CodeableConcept>? route,
      Markdown? indication,
      @JsonKey(name: '_indication') Element? indicationElement,
      CodeableConcept? legalStatusOfSupply,
      CodeableConcept? additionalMonitoringIndicator,
      List<CodeableConcept>? specialMeasures,
      CodeableConcept? pediatricUseIndicator,
      List<CodeableConcept>? classification,
      List<MarketingStatus>? marketingStatus,
      List<CodeableConcept>? packagedMedicinalProduct,
      List<CodeableConcept>? ingredient,
      List<CodeableReference>? impurity,
      List<Reference>? attachedDocument,
      List<Reference>? masterFile,
      List<MedicinalProductDefinitionContact>? contact,
      List<Reference>? clinicalTrial,
      List<Coding>? code,
      List<MedicinalProductDefinitionName> name,
      List<MedicinalProductDefinitionCrossReference>? crossReference,
      List<MedicinalProductDefinitionOperation>? operation,
      List<MedicinalProductDefinitionCharacteristic>? characteristic});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $CodeableConceptCopyWith<$Res>? get domain;
  @override
  $ElementCopyWith<$Res>? get versionElement;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
  @override
  $ElementCopyWith<$Res>? get statusDateElement;
  @override
  $ElementCopyWith<$Res>? get descriptionElement;
  @override
  $CodeableConceptCopyWith<$Res>? get combinedPharmaceuticalDoseForm;
  @override
  $ElementCopyWith<$Res>? get indicationElement;
  @override
  $CodeableConceptCopyWith<$Res>? get legalStatusOfSupply;
  @override
  $CodeableConceptCopyWith<$Res>? get additionalMonitoringIndicator;
  @override
  $CodeableConceptCopyWith<$Res>? get pediatricUseIndicator;
}

/// @nodoc
class __$$_MedicinalProductDefinitionCopyWithImpl<$Res>
    extends _$MedicinalProductDefinitionCopyWithImpl<$Res,
        _$_MedicinalProductDefinition>
    implements _$$_MedicinalProductDefinitionCopyWith<$Res> {
  __$$_MedicinalProductDefinitionCopyWithImpl(
      _$_MedicinalProductDefinition _value,
      $Res Function(_$_MedicinalProductDefinition) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = freezed,
    Object? domain = freezed,
    Object? version = freezed,
    Object? versionElement = freezed,
    Object? status = freezed,
    Object? statusDate = freezed,
    Object? statusDateElement = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? combinedPharmaceuticalDoseForm = freezed,
    Object? route = freezed,
    Object? indication = freezed,
    Object? indicationElement = freezed,
    Object? legalStatusOfSupply = freezed,
    Object? additionalMonitoringIndicator = freezed,
    Object? specialMeasures = freezed,
    Object? pediatricUseIndicator = freezed,
    Object? classification = freezed,
    Object? marketingStatus = freezed,
    Object? packagedMedicinalProduct = freezed,
    Object? ingredient = freezed,
    Object? impurity = freezed,
    Object? attachedDocument = freezed,
    Object? masterFile = freezed,
    Object? contact = freezed,
    Object? clinicalTrial = freezed,
    Object? code = freezed,
    Object? name = null,
    Object? crossReference = freezed,
    Object? operation = freezed,
    Object? characteristic = freezed,
  }) {
    return _then(_$_MedicinalProductDefinition(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R4ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      domain: freezed == domain
          ? _value.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      version: freezed == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String?,
      versionElement: freezed == versionElement
          ? _value.versionElement
          : versionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      statusDate: freezed == statusDate
          ? _value.statusDate
          : statusDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      statusDateElement: freezed == statusDateElement
          ? _value.statusDateElement
          : statusDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      combinedPharmaceuticalDoseForm: freezed == combinedPharmaceuticalDoseForm
          ? _value.combinedPharmaceuticalDoseForm
          : combinedPharmaceuticalDoseForm // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      route: freezed == route
          ? _value._route
          : route // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      indication: freezed == indication
          ? _value.indication
          : indication // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      indicationElement: freezed == indicationElement
          ? _value.indicationElement
          : indicationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      legalStatusOfSupply: freezed == legalStatusOfSupply
          ? _value.legalStatusOfSupply
          : legalStatusOfSupply // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      additionalMonitoringIndicator: freezed == additionalMonitoringIndicator
          ? _value.additionalMonitoringIndicator
          : additionalMonitoringIndicator // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      specialMeasures: freezed == specialMeasures
          ? _value._specialMeasures
          : specialMeasures // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      pediatricUseIndicator: freezed == pediatricUseIndicator
          ? _value.pediatricUseIndicator
          : pediatricUseIndicator // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      classification: freezed == classification
          ? _value._classification
          : classification // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      marketingStatus: freezed == marketingStatus
          ? _value._marketingStatus
          : marketingStatus // ignore: cast_nullable_to_non_nullable
              as List<MarketingStatus>?,
      packagedMedicinalProduct: freezed == packagedMedicinalProduct
          ? _value._packagedMedicinalProduct
          : packagedMedicinalProduct // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      ingredient: freezed == ingredient
          ? _value._ingredient
          : ingredient // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      impurity: freezed == impurity
          ? _value._impurity
          : impurity // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      attachedDocument: freezed == attachedDocument
          ? _value._attachedDocument
          : attachedDocument // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      masterFile: freezed == masterFile
          ? _value._masterFile
          : masterFile // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      contact: freezed == contact
          ? _value._contact
          : contact // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionContact>?,
      clinicalTrial: freezed == clinicalTrial
          ? _value._clinicalTrial
          : clinicalTrial // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      code: freezed == code
          ? _value._code
          : code // ignore: cast_nullable_to_non_nullable
              as List<Coding>?,
      name: null == name
          ? _value._name
          : name // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionName>,
      crossReference: freezed == crossReference
          ? _value._crossReference
          : crossReference // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionCrossReference>?,
      operation: freezed == operation
          ? _value._operation
          : operation // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionOperation>?,
      characteristic: freezed == characteristic
          ? _value._characteristic
          : characteristic // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionCharacteristic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MedicinalProductDefinition extends _MedicinalProductDefinition {
  _$_MedicinalProductDefinition(
      {this.resourceType = R4ResourceType.MedicinalProductDefinition,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules') this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language') this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      this.type,
      this.domain,
      this.version,
      @JsonKey(name: '_version') this.versionElement,
      this.status,
      this.statusDate,
      @JsonKey(name: '_statusDate') this.statusDateElement,
      this.description,
      @JsonKey(name: '_description') this.descriptionElement,
      this.combinedPharmaceuticalDoseForm,
      final List<CodeableConcept>? route,
      this.indication,
      @JsonKey(name: '_indication') this.indicationElement,
      this.legalStatusOfSupply,
      this.additionalMonitoringIndicator,
      final List<CodeableConcept>? specialMeasures,
      this.pediatricUseIndicator,
      final List<CodeableConcept>? classification,
      final List<MarketingStatus>? marketingStatus,
      final List<CodeableConcept>? packagedMedicinalProduct,
      final List<CodeableConcept>? ingredient,
      final List<CodeableReference>? impurity,
      final List<Reference>? attachedDocument,
      final List<Reference>? masterFile,
      final List<MedicinalProductDefinitionContact>? contact,
      final List<Reference>? clinicalTrial,
      final List<Coding>? code,
      required final List<MedicinalProductDefinitionName> name,
      final List<MedicinalProductDefinitionCrossReference>? crossReference,
      final List<MedicinalProductDefinitionOperation>? operation,
      final List<MedicinalProductDefinitionCharacteristic>? characteristic})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _route = route,
        _specialMeasures = specialMeasures,
        _classification = classification,
        _marketingStatus = marketingStatus,
        _packagedMedicinalProduct = packagedMedicinalProduct,
        _ingredient = ingredient,
        _impurity = impurity,
        _attachedDocument = attachedDocument,
        _masterFile = masterFile,
        _contact = contact,
        _clinicalTrial = clinicalTrial,
        _code = code,
        _name = name,
        _crossReference = crossReference,
        _operation = operation,
        _characteristic = characteristic,
        super._();

  factory _$_MedicinalProductDefinition.fromJson(Map<String, dynamic> json) =>
      _$$_MedicinalProductDefinitionFromJson(json);

  @override
  @JsonKey()
  final R4ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  @override
  final String? id;

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.;
  @override
  final Code? language;

  /// [languageElement] (_language): Extensions for language;
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] Business identifier for this product. Could be an MPID. When in development or being regulated, products are typically referenced by official identifiers, assigned by a manufacturer or regulator, and unique to a product (which, when compared to a product instance being prescribed, is actually a product type). See also MedicinalProductDefinition.code.;
  final List<Identifier>? _identifier;

  /// [identifier] Business identifier for this product. Could be an MPID. When in development or being regulated, products are typically referenced by official identifiers, assigned by a manufacturer or regulator, and unique to a product (which, when compared to a product instance being prescribed, is actually a product type). See also MedicinalProductDefinition.code.;
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] Regulatory type, e.g. Investigational or Authorized.;
  @override
  final CodeableConcept? type;

  /// [domain] If this medicine applies to human or veterinary uses.;
  @override
  final CodeableConcept? domain;

  /// [version] A business identifier relating to a specific version of the product, this is commonly used to support revisions to an existing product.;
  @override
  final String? version;

  /// [versionElement] (_version): Extensions for version;
  @override
  @JsonKey(name: '_version')
  final Element? versionElement;

  /// [status] The status within the lifecycle of this product record. A high-level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization status.;
  @override
  final CodeableConcept? status;

  /// [statusDate] The date at which the given status became applicable.;
  @override
  final FhirDateTime? statusDate;

  /// [statusDateElement] (_statusDate): Extensions for statusDate;
  @override
  @JsonKey(name: '_statusDate')
  final Element? statusDateElement;

  /// [description] General description of this product.;
  @override
  final Markdown? description;

  /// [descriptionElement] (_description): Extensions for description;
  @override
  @JsonKey(name: '_description')
  final Element? descriptionElement;

  /// [combinedPharmaceuticalDoseForm] The dose form for a single part product, or combined form of a multiple part product. This is one concept that describes all the components. It does not represent the form with components physically mixed, if that might be necessary, for which see (AdministrableProductDefinition.administrableDoseForm).;
  @override
  final CodeableConcept? combinedPharmaceuticalDoseForm;

  /// [route] The path by which the product is taken into or makes contact with the body. In some regions this is referred to as the licenced or approved route. See also AdministrableProductDefinition resource. MedicinalProductDefinition.route is the same concept as AdministrableProductDefinition.routeOfAdministration.code, and they cannot be used together.;
  final List<CodeableConcept>? _route;

  /// [route] The path by which the product is taken into or makes contact with the body. In some regions this is referred to as the licenced or approved route. See also AdministrableProductDefinition resource. MedicinalProductDefinition.route is the same concept as AdministrableProductDefinition.routeOfAdministration.code, and they cannot be used together.;
  @override
  List<CodeableConcept>? get route {
    final value = _route;
    if (value == null) return null;
    if (_route is EqualUnmodifiableListView) return _route;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [indication] Description of indication(s) for this product, used when structured indications are not required. In cases where structured indications are required, they are captured using the ClinicalUseDefinition resource. An indication is a medical situation for which using the product is appropriate.;
  @override
  final Markdown? indication;

  /// [indicationElement] (_indication): Extensions for indication;
  @override
  @JsonKey(name: '_indication')
  final Element? indicationElement;

  /// [legalStatusOfSupply] The legal status of supply of the medicinal product as classified by the regulator.;
  @override
  final CodeableConcept? legalStatusOfSupply;

  /// [additionalMonitoringIndicator] Whether the Medicinal Product is subject to additional monitoring for regulatory reasons, such as heightened reporting requirements.;
  @override
  final CodeableConcept? additionalMonitoringIndicator;

  /// [specialMeasures] Whether the Medicinal Product is subject to special measures for regulatory reasons, such as a requirement to conduct post-authorisation studies.;
  final List<CodeableConcept>? _specialMeasures;

  /// [specialMeasures] Whether the Medicinal Product is subject to special measures for regulatory reasons, such as a requirement to conduct post-authorisation studies.;
  @override
  List<CodeableConcept>? get specialMeasures {
    final value = _specialMeasures;
    if (value == null) return null;
    if (_specialMeasures is EqualUnmodifiableListView) return _specialMeasures;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [pediatricUseIndicator] If authorised for use in children, or infants, neonates etc.;
  @override
  final CodeableConcept? pediatricUseIndicator;

  /// [classification] Allows the product to be classified by various systems, commonly WHO ATC.;
  final List<CodeableConcept>? _classification;

  /// [classification] Allows the product to be classified by various systems, commonly WHO ATC.;
  @override
  List<CodeableConcept>? get classification {
    final value = _classification;
    if (value == null) return null;
    if (_classification is EqualUnmodifiableListView) return _classification;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [marketingStatus] Marketing status of the medicinal product, in contrast to marketing authorization. This refers to the product being actually 'on the market' as opposed to being allowed to be on the market (which is an authorization).;
  final List<MarketingStatus>? _marketingStatus;

  /// [marketingStatus] Marketing status of the medicinal product, in contrast to marketing authorization. This refers to the product being actually 'on the market' as opposed to being allowed to be on the market (which is an authorization).;
  @override
  List<MarketingStatus>? get marketingStatus {
    final value = _marketingStatus;
    if (value == null) return null;
    if (_marketingStatus is EqualUnmodifiableListView) return _marketingStatus;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [packagedMedicinalProduct] Package type for the product. See also the PackagedProductDefinition resource.;
  final List<CodeableConcept>? _packagedMedicinalProduct;

  /// [packagedMedicinalProduct] Package type for the product. See also the PackagedProductDefinition resource.;
  @override
  List<CodeableConcept>? get packagedMedicinalProduct {
    final value = _packagedMedicinalProduct;
    if (value == null) return null;
    if (_packagedMedicinalProduct is EqualUnmodifiableListView)
      return _packagedMedicinalProduct;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [ingredient] The ingredients of this medicinal product - when not detailed in other resources. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource, or indirectly via incoming AdministrableProductDefinition, PackagedProductDefinition or ManufacturedItemDefinition references. In cases where those levels of detail are not used, the ingredients may be specified directly here as codes.;
  final List<CodeableConcept>? _ingredient;

  /// [ingredient] The ingredients of this medicinal product - when not detailed in other resources. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource, or indirectly via incoming AdministrableProductDefinition, PackagedProductDefinition or ManufacturedItemDefinition references. In cases where those levels of detail are not used, the ingredients may be specified directly here as codes.;
  @override
  List<CodeableConcept>? get ingredient {
    final value = _ingredient;
    if (value == null) return null;
    if (_ingredient is EqualUnmodifiableListView) return _ingredient;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [impurity] Any component of the drug product which is not the chemical entity defined as the drug substance, or an excipient in the drug product. This includes process-related impurities and contaminants, product-related impurities including degradation products.;
  final List<CodeableReference>? _impurity;

  /// [impurity] Any component of the drug product which is not the chemical entity defined as the drug substance, or an excipient in the drug product. This includes process-related impurities and contaminants, product-related impurities including degradation products.;
  @override
  List<CodeableReference>? get impurity {
    final value = _impurity;
    if (value == null) return null;
    if (_impurity is EqualUnmodifiableListView) return _impurity;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [attachedDocument] Additional information or supporting documentation about the medicinal product.;
  final List<Reference>? _attachedDocument;

  /// [attachedDocument] Additional information or supporting documentation about the medicinal product.;
  @override
  List<Reference>? get attachedDocument {
    final value = _attachedDocument;
    if (value == null) return null;
    if (_attachedDocument is EqualUnmodifiableListView)
      return _attachedDocument;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [masterFile] A master file for the medicinal product (e.g. Pharmacovigilance System Master File). Drug master files (DMFs) are documents submitted to regulatory agencies to provide confidential detailed information about facilities, processes or articles used in the manufacturing, processing, packaging and storing of drug products.;
  final List<Reference>? _masterFile;

  /// [masterFile] A master file for the medicinal product (e.g. Pharmacovigilance System Master File). Drug master files (DMFs) are documents submitted to regulatory agencies to provide confidential detailed information about facilities, processes or articles used in the manufacturing, processing, packaging and storing of drug products.;
  @override
  List<Reference>? get masterFile {
    final value = _masterFile;
    if (value == null) return null;
    if (_masterFile is EqualUnmodifiableListView) return _masterFile;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [contact] A product specific contact, person (in a role), or an organization.;
  final List<MedicinalProductDefinitionContact>? _contact;

  /// [contact] A product specific contact, person (in a role), or an organization.;
  @override
  List<MedicinalProductDefinitionContact>? get contact {
    final value = _contact;
    if (value == null) return null;
    if (_contact is EqualUnmodifiableListView) return _contact;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [clinicalTrial] Clinical trials or studies that this product is involved in.;
  final List<Reference>? _clinicalTrial;

  /// [clinicalTrial] Clinical trials or studies that this product is involved in.;
  @override
  List<Reference>? get clinicalTrial {
    final value = _clinicalTrial;
    if (value == null) return null;
    if (_clinicalTrial is EqualUnmodifiableListView) return _clinicalTrial;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [code] A code that this product is known by, usually within some formal terminology, perhaps assigned by a third party (i.e. not the manufacturer or regulator). Products (types of medications) tend to be known by identifiers during development and within regulatory process. However when they are prescribed they tend to be identified by codes. The same product may be have multiple codes, applied to it by multiple organizations.;
  final List<Coding>? _code;

  /// [code] A code that this product is known by, usually within some formal terminology, perhaps assigned by a third party (i.e. not the manufacturer or regulator). Products (types of medications) tend to be known by identifiers during development and within regulatory process. However when they are prescribed they tend to be identified by codes. The same product may be have multiple codes, applied to it by multiple organizations.;
  @override
  List<Coding>? get code {
    final value = _code;
    if (value == null) return null;
    if (_code is EqualUnmodifiableListView) return _code;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [name] The product's name, including full name and possibly coded parts.;
  final List<MedicinalProductDefinitionName> _name;

  /// [name] The product's name, including full name and possibly coded parts.;
  @override
  List<MedicinalProductDefinitionName> get name {
    if (_name is EqualUnmodifiableListView) return _name;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_name);
  }

  /// [crossReference] Reference to another product, e.g. for linking authorised to investigational product, or a virtual product.;
  final List<MedicinalProductDefinitionCrossReference>? _crossReference;

  /// [crossReference] Reference to another product, e.g. for linking authorised to investigational product, or a virtual product.;
  @override
  List<MedicinalProductDefinitionCrossReference>? get crossReference {
    final value = _crossReference;
    if (value == null) return null;
    if (_crossReference is EqualUnmodifiableListView) return _crossReference;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [operation] A manufacturing or administrative process or step associated with (or performed on) the medicinal product.;
  final List<MedicinalProductDefinitionOperation>? _operation;

  /// [operation] A manufacturing or administrative process or step associated with (or performed on) the medicinal product.;
  @override
  List<MedicinalProductDefinitionOperation>? get operation {
    final value = _operation;
    if (value == null) return null;
    if (_operation is EqualUnmodifiableListView) return _operation;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [characteristic] Allows the key product features to be recorded, such as "sugar free", "modified release", "parallel import".;
  final List<MedicinalProductDefinitionCharacteristic>? _characteristic;

  /// [characteristic] Allows the key product features to be recorded, such as "sugar free", "modified release", "parallel import".;
  @override
  List<MedicinalProductDefinitionCharacteristic>? get characteristic {
    final value = _characteristic;
    if (value == null) return null;
    if (_characteristic is EqualUnmodifiableListView) return _characteristic;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'MedicinalProductDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, type: $type, domain: $domain, version: $version, versionElement: $versionElement, status: $status, statusDate: $statusDate, statusDateElement: $statusDateElement, description: $description, descriptionElement: $descriptionElement, combinedPharmaceuticalDoseForm: $combinedPharmaceuticalDoseForm, route: $route, indication: $indication, indicationElement: $indicationElement, legalStatusOfSupply: $legalStatusOfSupply, additionalMonitoringIndicator: $additionalMonitoringIndicator, specialMeasures: $specialMeasures, pediatricUseIndicator: $pediatricUseIndicator, classification: $classification, marketingStatus: $marketingStatus, packagedMedicinalProduct: $packagedMedicinalProduct, ingredient: $ingredient, impurity: $impurity, attachedDocument: $attachedDocument, masterFile: $masterFile, contact: $contact, clinicalTrial: $clinicalTrial, code: $code, name: $name, crossReference: $crossReference, operation: $operation, characteristic: $characteristic)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MedicinalProductDefinition &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.domain, domain) || other.domain == domain) &&
            (identical(other.version, version) || other.version == version) &&
            (identical(other.versionElement, versionElement) ||
                other.versionElement == versionElement) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusDate, statusDate) ||
                other.statusDate == statusDate) &&
            (identical(other.statusDateElement, statusDateElement) ||
                other.statusDateElement == statusDateElement) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.descriptionElement, descriptionElement) ||
                other.descriptionElement == descriptionElement) &&
            (identical(other.combinedPharmaceuticalDoseForm,
                    combinedPharmaceuticalDoseForm) ||
                other.combinedPharmaceuticalDoseForm ==
                    combinedPharmaceuticalDoseForm) &&
            const DeepCollectionEquality().equals(other._route, _route) &&
            (identical(other.indication, indication) ||
                other.indication == indication) &&
            (identical(other.indicationElement, indicationElement) ||
                other.indicationElement == indicationElement) &&
            (identical(other.legalStatusOfSupply, legalStatusOfSupply) ||
                other.legalStatusOfSupply == legalStatusOfSupply) &&
            (identical(other.additionalMonitoringIndicator, additionalMonitoringIndicator) ||
                other.additionalMonitoringIndicator ==
                    additionalMonitoringIndicator) &&
            const DeepCollectionEquality()
                .equals(other._specialMeasures, _specialMeasures) &&
            (identical(other.pediatricUseIndicator, pediatricUseIndicator) ||
                other.pediatricUseIndicator == pediatricUseIndicator) &&
            const DeepCollectionEquality()
                .equals(other._classification, _classification) &&
            const DeepCollectionEquality()
                .equals(other._marketingStatus, _marketingStatus) &&
            const DeepCollectionEquality().equals(
                other._packagedMedicinalProduct, _packagedMedicinalProduct) &&
            const DeepCollectionEquality()
                .equals(other._ingredient, _ingredient) &&
            const DeepCollectionEquality().equals(other._impurity, _impurity) &&
            const DeepCollectionEquality()
                .equals(other._attachedDocument, _attachedDocument) &&
            const DeepCollectionEquality()
                .equals(other._masterFile, _masterFile) &&
            const DeepCollectionEquality().equals(other._contact, _contact) &&
            const DeepCollectionEquality()
                .equals(other._clinicalTrial, _clinicalTrial) &&
            const DeepCollectionEquality().equals(other._code, _code) &&
            const DeepCollectionEquality().equals(other._name, _name) &&
            const DeepCollectionEquality()
                .equals(other._crossReference, _crossReference) &&
            const DeepCollectionEquality()
                .equals(other._operation, _operation) &&
            const DeepCollectionEquality().equals(other._characteristic, _characteristic));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_identifier),
        type,
        domain,
        version,
        versionElement,
        status,
        statusDate,
        statusDateElement,
        description,
        descriptionElement,
        combinedPharmaceuticalDoseForm,
        const DeepCollectionEquality().hash(_route),
        indication,
        indicationElement,
        legalStatusOfSupply,
        additionalMonitoringIndicator,
        const DeepCollectionEquality().hash(_specialMeasures),
        pediatricUseIndicator,
        const DeepCollectionEquality().hash(_classification),
        const DeepCollectionEquality().hash(_marketingStatus),
        const DeepCollectionEquality().hash(_packagedMedicinalProduct),
        const DeepCollectionEquality().hash(_ingredient),
        const DeepCollectionEquality().hash(_impurity),
        const DeepCollectionEquality().hash(_attachedDocument),
        const DeepCollectionEquality().hash(_masterFile),
        const DeepCollectionEquality().hash(_contact),
        const DeepCollectionEquality().hash(_clinicalTrial),
        const DeepCollectionEquality().hash(_code),
        const DeepCollectionEquality().hash(_name),
        const DeepCollectionEquality().hash(_crossReference),
        const DeepCollectionEquality().hash(_operation),
        const DeepCollectionEquality().hash(_characteristic)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MedicinalProductDefinitionCopyWith<_$_MedicinalProductDefinition>
      get copyWith => __$$_MedicinalProductDefinitionCopyWithImpl<
          _$_MedicinalProductDefinition>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MedicinalProductDefinitionToJson(
      this,
    );
  }
}

abstract class _MedicinalProductDefinition extends MedicinalProductDefinition {
  factory _MedicinalProductDefinition(
      {final R4ResourceType resourceType,
      final String? id,
      final Meta? meta,
      final FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') final Element? implicitRulesElement,
      final Code? language,
      @JsonKey(name: '_language') final Element? languageElement,
      final Narrative? text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      final CodeableConcept? type,
      final CodeableConcept? domain,
      final String? version,
      @JsonKey(name: '_version') final Element? versionElement,
      final CodeableConcept? status,
      final FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate') final Element? statusDateElement,
      final Markdown? description,
      @JsonKey(name: '_description') final Element? descriptionElement,
      final CodeableConcept? combinedPharmaceuticalDoseForm,
      final List<CodeableConcept>? route,
      final Markdown? indication,
      @JsonKey(name: '_indication') final Element? indicationElement,
      final CodeableConcept? legalStatusOfSupply,
      final CodeableConcept? additionalMonitoringIndicator,
      final List<CodeableConcept>? specialMeasures,
      final CodeableConcept? pediatricUseIndicator,
      final List<CodeableConcept>? classification,
      final List<MarketingStatus>? marketingStatus,
      final List<CodeableConcept>? packagedMedicinalProduct,
      final List<CodeableConcept>? ingredient,
      final List<CodeableReference>? impurity,
      final List<Reference>? attachedDocument,
      final List<Reference>? masterFile,
      final List<MedicinalProductDefinitionContact>? contact,
      final List<Reference>? clinicalTrial,
      final List<Coding>? code,
      required final List<MedicinalProductDefinitionName> name,
      final List<MedicinalProductDefinitionCrossReference>? crossReference,
      final List<MedicinalProductDefinitionOperation>? operation,
      final List<MedicinalProductDefinitionCharacteristic>?
          characteristic}) = _$_MedicinalProductDefinition;
  _MedicinalProductDefinition._() : super._();

  factory _MedicinalProductDefinition.fromJson(Map<String, dynamic> json) =
      _$_MedicinalProductDefinition.fromJson;

  @override
  R4ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  String? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.;
  Code? get language;
  @override

  /// [languageElement] (_language): Extensions for language;
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  List<Resource>? get contained;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] Business identifier for this product. Could be an MPID. When in development or being regulated, products are typically referenced by official identifiers, assigned by a manufacturer or regulator, and unique to a product (which, when compared to a product instance being prescribed, is actually a product type). See also MedicinalProductDefinition.code.;
  List<Identifier>? get identifier;
  @override

  /// [type] Regulatory type, e.g. Investigational or Authorized.;
  CodeableConcept? get type;
  @override

  /// [domain] If this medicine applies to human or veterinary uses.;
  CodeableConcept? get domain;
  @override

  /// [version] A business identifier relating to a specific version of the product, this is commonly used to support revisions to an existing product.;
  String? get version;
  @override

  /// [versionElement] (_version): Extensions for version;
  @JsonKey(name: '_version')
  Element? get versionElement;
  @override

  /// [status] The status within the lifecycle of this product record. A high-level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization status.;
  CodeableConcept? get status;
  @override

  /// [statusDate] The date at which the given status became applicable.;
  FhirDateTime? get statusDate;
  @override

  /// [statusDateElement] (_statusDate): Extensions for statusDate;
  @JsonKey(name: '_statusDate')
  Element? get statusDateElement;
  @override

  /// [description] General description of this product.;
  Markdown? get description;
  @override

  /// [descriptionElement] (_description): Extensions for description;
  @JsonKey(name: '_description')
  Element? get descriptionElement;
  @override

  /// [combinedPharmaceuticalDoseForm] The dose form for a single part product, or combined form of a multiple part product. This is one concept that describes all the components. It does not represent the form with components physically mixed, if that might be necessary, for which see (AdministrableProductDefinition.administrableDoseForm).;
  CodeableConcept? get combinedPharmaceuticalDoseForm;
  @override

  /// [route] The path by which the product is taken into or makes contact with the body. In some regions this is referred to as the licenced or approved route. See also AdministrableProductDefinition resource. MedicinalProductDefinition.route is the same concept as AdministrableProductDefinition.routeOfAdministration.code, and they cannot be used together.;
  List<CodeableConcept>? get route;
  @override

  /// [indication] Description of indication(s) for this product, used when structured indications are not required. In cases where structured indications are required, they are captured using the ClinicalUseDefinition resource. An indication is a medical situation for which using the product is appropriate.;
  Markdown? get indication;
  @override

  /// [indicationElement] (_indication): Extensions for indication;
  @JsonKey(name: '_indication')
  Element? get indicationElement;
  @override

  /// [legalStatusOfSupply] The legal status of supply of the medicinal product as classified by the regulator.;
  CodeableConcept? get legalStatusOfSupply;
  @override

  /// [additionalMonitoringIndicator] Whether the Medicinal Product is subject to additional monitoring for regulatory reasons, such as heightened reporting requirements.;
  CodeableConcept? get additionalMonitoringIndicator;
  @override

  /// [specialMeasures] Whether the Medicinal Product is subject to special measures for regulatory reasons, such as a requirement to conduct post-authorisation studies.;
  List<CodeableConcept>? get specialMeasures;
  @override

  /// [pediatricUseIndicator] If authorised for use in children, or infants, neonates etc.;
  CodeableConcept? get pediatricUseIndicator;
  @override

  /// [classification] Allows the product to be classified by various systems, commonly WHO ATC.;
  List<CodeableConcept>? get classification;
  @override

  /// [marketingStatus] Marketing status of the medicinal product, in contrast to marketing authorization. This refers to the product being actually 'on the market' as opposed to being allowed to be on the market (which is an authorization).;
  List<MarketingStatus>? get marketingStatus;
  @override

  /// [packagedMedicinalProduct] Package type for the product. See also the PackagedProductDefinition resource.;
  List<CodeableConcept>? get packagedMedicinalProduct;
  @override

  /// [ingredient] The ingredients of this medicinal product - when not detailed in other resources. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource, or indirectly via incoming AdministrableProductDefinition, PackagedProductDefinition or ManufacturedItemDefinition references. In cases where those levels of detail are not used, the ingredients may be specified directly here as codes.;
  List<CodeableConcept>? get ingredient;
  @override

  /// [impurity] Any component of the drug product which is not the chemical entity defined as the drug substance, or an excipient in the drug product. This includes process-related impurities and contaminants, product-related impurities including degradation products.;
  List<CodeableReference>? get impurity;
  @override

  /// [attachedDocument] Additional information or supporting documentation about the medicinal product.;
  List<Reference>? get attachedDocument;
  @override

  /// [masterFile] A master file for the medicinal product (e.g. Pharmacovigilance System Master File). Drug master files (DMFs) are documents submitted to regulatory agencies to provide confidential detailed information about facilities, processes or articles used in the manufacturing, processing, packaging and storing of drug products.;
  List<Reference>? get masterFile;
  @override

  /// [contact] A product specific contact, person (in a role), or an organization.;
  List<MedicinalProductDefinitionContact>? get contact;
  @override

  /// [clinicalTrial] Clinical trials or studies that this product is involved in.;
  List<Reference>? get clinicalTrial;
  @override

  /// [code] A code that this product is known by, usually within some formal terminology, perhaps assigned by a third party (i.e. not the manufacturer or regulator). Products (types of medications) tend to be known by identifiers during development and within regulatory process. However when they are prescribed they tend to be identified by codes. The same product may be have multiple codes, applied to it by multiple organizations.;
  List<Coding>? get code;
  @override

  /// [name] The product's name, including full name and possibly coded parts.;
  List<MedicinalProductDefinitionName> get name;
  @override

  /// [crossReference] Reference to another product, e.g. for linking authorised to investigational product, or a virtual product.;
  List<MedicinalProductDefinitionCrossReference>? get crossReference;
  @override

  /// [operation] A manufacturing or administrative process or step associated with (or performed on) the medicinal product.;
  List<MedicinalProductDefinitionOperation>? get operation;
  @override

  /// [characteristic] Allows the key product features to be recorded, such as "sugar free", "modified release", "parallel import".;
  List<MedicinalProductDefinitionCharacteristic>? get characteristic;
  @override
  @JsonKey(ignore: true)
  _$$_MedicinalProductDefinitionCopyWith<_$_MedicinalProductDefinition>
      get copyWith => throw _privateConstructorUsedError;
}

MedicinalProductDefinitionContact _$MedicinalProductDefinitionContactFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductDefinitionContact.fromJson(json);
}

/// @nodoc
mixin _$MedicinalProductDefinitionContact {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] Allows the contact to be classified, for example QPPV, Pharmacovigilance Enquiry Information.;
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [contact] A product specific contact, person (in a role), or an organization.;
  Reference get contact => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MedicinalProductDefinitionContactCopyWith<MedicinalProductDefinitionContact>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MedicinalProductDefinitionContactCopyWith<$Res> {
  factory $MedicinalProductDefinitionContactCopyWith(
          MedicinalProductDefinitionContact value,
          $Res Function(MedicinalProductDefinitionContact) then) =
      _$MedicinalProductDefinitionContactCopyWithImpl<$Res,
          MedicinalProductDefinitionContact>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      Reference contact});

  $CodeableConceptCopyWith<$Res>? get type;
  $ReferenceCopyWith<$Res> get contact;
}

/// @nodoc
class _$MedicinalProductDefinitionContactCopyWithImpl<$Res,
        $Val extends MedicinalProductDefinitionContact>
    implements $MedicinalProductDefinitionContactCopyWith<$Res> {
  _$MedicinalProductDefinitionContactCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? contact = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      contact: null == contact
          ? _value.contact
          : contact // ignore: cast_nullable_to_non_nullable
              as Reference,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res> get contact {
    return $ReferenceCopyWith<$Res>(_value.contact, (value) {
      return _then(_value.copyWith(contact: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MedicinalProductDefinitionContactCopyWith<$Res>
    implements $MedicinalProductDefinitionContactCopyWith<$Res> {
  factory _$$_MedicinalProductDefinitionContactCopyWith(
          _$_MedicinalProductDefinitionContact value,
          $Res Function(_$_MedicinalProductDefinitionContact) then) =
      __$$_MedicinalProductDefinitionContactCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      Reference contact});

  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $ReferenceCopyWith<$Res> get contact;
}

/// @nodoc
class __$$_MedicinalProductDefinitionContactCopyWithImpl<$Res>
    extends _$MedicinalProductDefinitionContactCopyWithImpl<$Res,
        _$_MedicinalProductDefinitionContact>
    implements _$$_MedicinalProductDefinitionContactCopyWith<$Res> {
  __$$_MedicinalProductDefinitionContactCopyWithImpl(
      _$_MedicinalProductDefinitionContact _value,
      $Res Function(_$_MedicinalProductDefinitionContact) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? contact = null,
  }) {
    return _then(_$_MedicinalProductDefinitionContact(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      contact: null == contact
          ? _value.contact
          : contact // ignore: cast_nullable_to_non_nullable
              as Reference,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MedicinalProductDefinitionContact
    extends _MedicinalProductDefinitionContact {
  _$_MedicinalProductDefinitionContact(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.type,
      required this.contact})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_MedicinalProductDefinitionContact.fromJson(
          Map<String, dynamic> json) =>
      _$$_MedicinalProductDefinitionContactFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] Allows the contact to be classified, for example QPPV, Pharmacovigilance Enquiry Information.;
  @override
  final CodeableConcept? type;

  /// [contact] A product specific contact, person (in a role), or an organization.;
  @override
  final Reference contact;

  @override
  String toString() {
    return 'MedicinalProductDefinitionContact(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, contact: $contact)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MedicinalProductDefinitionContact &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.contact, contact) || other.contact == contact));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      contact);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MedicinalProductDefinitionContactCopyWith<
          _$_MedicinalProductDefinitionContact>
      get copyWith => __$$_MedicinalProductDefinitionContactCopyWithImpl<
          _$_MedicinalProductDefinitionContact>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MedicinalProductDefinitionContactToJson(
      this,
    );
  }
}

abstract class _MedicinalProductDefinitionContact
    extends MedicinalProductDefinitionContact {
  factory _MedicinalProductDefinitionContact(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? type,
      required final Reference contact}) = _$_MedicinalProductDefinitionContact;
  _MedicinalProductDefinitionContact._() : super._();

  factory _MedicinalProductDefinitionContact.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductDefinitionContact.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] Allows the contact to be classified, for example QPPV, Pharmacovigilance Enquiry Information.;
  CodeableConcept? get type;
  @override

  /// [contact] A product specific contact, person (in a role), or an organization.;
  Reference get contact;
  @override
  @JsonKey(ignore: true)
  _$$_MedicinalProductDefinitionContactCopyWith<
          _$_MedicinalProductDefinitionContact>
      get copyWith => throw _privateConstructorUsedError;
}

MedicinalProductDefinitionName _$MedicinalProductDefinitionNameFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductDefinitionName.fromJson(json);
}

/// @nodoc
mixin _$MedicinalProductDefinitionName {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [productName] The full product name.;
  String? get productName => throw _privateConstructorUsedError;

  /// [productNameElement] (_productName): Extensions for productName;
  @JsonKey(name: '_productName')
  Element? get productNameElement => throw _privateConstructorUsedError;

  /// [type] Type of product name, such as rINN, BAN, Proprietary, Non-Proprietary.;
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [namePart] Coding words or phrases of the name.;
  List<MedicinalProductDefinitionNamePart>? get namePart =>
      throw _privateConstructorUsedError;

  /// [countryLanguage] Country and jurisdiction where the name applies, and associated language.;
  List<MedicinalProductDefinitionCountryLanguage>? get countryLanguage =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MedicinalProductDefinitionNameCopyWith<MedicinalProductDefinitionName>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MedicinalProductDefinitionNameCopyWith<$Res> {
  factory $MedicinalProductDefinitionNameCopyWith(
          MedicinalProductDefinitionName value,
          $Res Function(MedicinalProductDefinitionName) then) =
      _$MedicinalProductDefinitionNameCopyWithImpl<$Res,
          MedicinalProductDefinitionName>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? productName,
      @JsonKey(name: '_productName') Element? productNameElement,
      CodeableConcept? type,
      List<MedicinalProductDefinitionNamePart>? namePart,
      List<MedicinalProductDefinitionCountryLanguage>? countryLanguage});

  $ElementCopyWith<$Res>? get productNameElement;
  $CodeableConceptCopyWith<$Res>? get type;
}

/// @nodoc
class _$MedicinalProductDefinitionNameCopyWithImpl<$Res,
        $Val extends MedicinalProductDefinitionName>
    implements $MedicinalProductDefinitionNameCopyWith<$Res> {
  _$MedicinalProductDefinitionNameCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? productName = freezed,
    Object? productNameElement = freezed,
    Object? type = freezed,
    Object? namePart = freezed,
    Object? countryLanguage = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      productName: freezed == productName
          ? _value.productName
          : productName // ignore: cast_nullable_to_non_nullable
              as String?,
      productNameElement: freezed == productNameElement
          ? _value.productNameElement
          : productNameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      namePart: freezed == namePart
          ? _value.namePart
          : namePart // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionNamePart>?,
      countryLanguage: freezed == countryLanguage
          ? _value.countryLanguage
          : countryLanguage // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionCountryLanguage>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get productNameElement {
    if (_value.productNameElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.productNameElement!, (value) {
      return _then(_value.copyWith(productNameElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MedicinalProductDefinitionNameCopyWith<$Res>
    implements $MedicinalProductDefinitionNameCopyWith<$Res> {
  factory _$$_MedicinalProductDefinitionNameCopyWith(
          _$_MedicinalProductDefinitionName value,
          $Res Function(_$_MedicinalProductDefinitionName) then) =
      __$$_MedicinalProductDefinitionNameCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? productName,
      @JsonKey(name: '_productName') Element? productNameElement,
      CodeableConcept? type,
      List<MedicinalProductDefinitionNamePart>? namePart,
      List<MedicinalProductDefinitionCountryLanguage>? countryLanguage});

  @override
  $ElementCopyWith<$Res>? get productNameElement;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
}

/// @nodoc
class __$$_MedicinalProductDefinitionNameCopyWithImpl<$Res>
    extends _$MedicinalProductDefinitionNameCopyWithImpl<$Res,
        _$_MedicinalProductDefinitionName>
    implements _$$_MedicinalProductDefinitionNameCopyWith<$Res> {
  __$$_MedicinalProductDefinitionNameCopyWithImpl(
      _$_MedicinalProductDefinitionName _value,
      $Res Function(_$_MedicinalProductDefinitionName) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? productName = freezed,
    Object? productNameElement = freezed,
    Object? type = freezed,
    Object? namePart = freezed,
    Object? countryLanguage = freezed,
  }) {
    return _then(_$_MedicinalProductDefinitionName(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      productName: freezed == productName
          ? _value.productName
          : productName // ignore: cast_nullable_to_non_nullable
              as String?,
      productNameElement: freezed == productNameElement
          ? _value.productNameElement
          : productNameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      namePart: freezed == namePart
          ? _value._namePart
          : namePart // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionNamePart>?,
      countryLanguage: freezed == countryLanguage
          ? _value._countryLanguage
          : countryLanguage // ignore: cast_nullable_to_non_nullable
              as List<MedicinalProductDefinitionCountryLanguage>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MedicinalProductDefinitionName
    extends _MedicinalProductDefinitionName {
  _$_MedicinalProductDefinitionName(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.productName,
      @JsonKey(name: '_productName') this.productNameElement,
      this.type,
      final List<MedicinalProductDefinitionNamePart>? namePart,
      final List<MedicinalProductDefinitionCountryLanguage>? countryLanguage})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _namePart = namePart,
        _countryLanguage = countryLanguage,
        super._();

  factory _$_MedicinalProductDefinitionName.fromJson(
          Map<String, dynamic> json) =>
      _$$_MedicinalProductDefinitionNameFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [productName] The full product name.;
  @override
  final String? productName;

  /// [productNameElement] (_productName): Extensions for productName;
  @override
  @JsonKey(name: '_productName')
  final Element? productNameElement;

  /// [type] Type of product name, such as rINN, BAN, Proprietary, Non-Proprietary.;
  @override
  final CodeableConcept? type;

  /// [namePart] Coding words or phrases of the name.;
  final List<MedicinalProductDefinitionNamePart>? _namePart;

  /// [namePart] Coding words or phrases of the name.;
  @override
  List<MedicinalProductDefinitionNamePart>? get namePart {
    final value = _namePart;
    if (value == null) return null;
    if (_namePart is EqualUnmodifiableListView) return _namePart;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [countryLanguage] Country and jurisdiction where the name applies, and associated language.;
  final List<MedicinalProductDefinitionCountryLanguage>? _countryLanguage;

  /// [countryLanguage] Country and jurisdiction where the name applies, and associated language.;
  @override
  List<MedicinalProductDefinitionCountryLanguage>? get countryLanguage {
    final value = _countryLanguage;
    if (value == null) return null;
    if (_countryLanguage is EqualUnmodifiableListView) return _countryLanguage;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'MedicinalProductDefinitionName(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, productName: $productName, productNameElement: $productNameElement, type: $type, namePart: $namePart, countryLanguage: $countryLanguage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MedicinalProductDefinitionName &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.productName, productName) ||
                other.productName == productName) &&
            (identical(other.productNameElement, productNameElement) ||
                other.productNameElement == productNameElement) &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality().equals(other._namePart, _namePart) &&
            const DeepCollectionEquality()
                .equals(other._countryLanguage, _countryLanguage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      productName,
      productNameElement,
      type,
      const DeepCollectionEquality().hash(_namePart),
      const DeepCollectionEquality().hash(_countryLanguage));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MedicinalProductDefinitionNameCopyWith<_$_MedicinalProductDefinitionName>
      get copyWith => __$$_MedicinalProductDefinitionNameCopyWithImpl<
          _$_MedicinalProductDefinitionName>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MedicinalProductDefinitionNameToJson(
      this,
    );
  }
}

abstract class _MedicinalProductDefinitionName
    extends MedicinalProductDefinitionName {
  factory _MedicinalProductDefinitionName(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final String? productName,
      @JsonKey(name: '_productName') final Element? productNameElement,
      final CodeableConcept? type,
      final List<MedicinalProductDefinitionNamePart>? namePart,
      final List<MedicinalProductDefinitionCountryLanguage>?
          countryLanguage}) = _$_MedicinalProductDefinitionName;
  _MedicinalProductDefinitionName._() : super._();

  factory _MedicinalProductDefinitionName.fromJson(Map<String, dynamic> json) =
      _$_MedicinalProductDefinitionName.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [productName] The full product name.;
  String? get productName;
  @override

  /// [productNameElement] (_productName): Extensions for productName;
  @JsonKey(name: '_productName')
  Element? get productNameElement;
  @override

  /// [type] Type of product name, such as rINN, BAN, Proprietary, Non-Proprietary.;
  CodeableConcept? get type;
  @override

  /// [namePart] Coding words or phrases of the name.;
  List<MedicinalProductDefinitionNamePart>? get namePart;
  @override

  /// [countryLanguage] Country and jurisdiction where the name applies, and associated language.;
  List<MedicinalProductDefinitionCountryLanguage>? get countryLanguage;
  @override
  @JsonKey(ignore: true)
  _$$_MedicinalProductDefinitionNameCopyWith<_$_MedicinalProductDefinitionName>
      get copyWith => throw _privateConstructorUsedError;
}

MedicinalProductDefinitionNamePart _$MedicinalProductDefinitionNamePartFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductDefinitionNamePart.fromJson(json);
}

/// @nodoc
mixin _$MedicinalProductDefinitionNamePart {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [part] A fragment of a product name.;
  @JsonKey(name: 'part')
  String? get part_ => throw _privateConstructorUsedError;

  /// [partElement] (_part): Extensions for part;
  @JsonKey(name: '_part')
  Element? get partElement => throw _privateConstructorUsedError;

  /// [type] Identifying type for this part of the name (e.g. strength part).;
  CodeableConcept get type => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MedicinalProductDefinitionNamePartCopyWith<
          MedicinalProductDefinitionNamePart>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MedicinalProductDefinitionNamePartCopyWith<$Res> {
  factory $MedicinalProductDefinitionNamePartCopyWith(
          MedicinalProductDefinitionNamePart value,
          $Res Function(MedicinalProductDefinitionNamePart) then) =
      _$MedicinalProductDefinitionNamePartCopyWithImpl<$Res,
          MedicinalProductDefinitionNamePart>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      @JsonKey(name: 'part') String? part_,
      @JsonKey(name: '_part') Element? partElement,
      CodeableConcept type});

  $ElementCopyWith<$Res>? get partElement;
  $CodeableConceptCopyWith<$Res> get type;
}

/// @nodoc
class _$MedicinalProductDefinitionNamePartCopyWithImpl<$Res,
        $Val extends MedicinalProductDefinitionNamePart>
    implements $MedicinalProductDefinitionNamePartCopyWith<$Res> {
  _$MedicinalProductDefinitionNamePartCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? part_ = freezed,
    Object? partElement = freezed,
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      part_: freezed == part_
          ? _value.part_
          : part_ // ignore: cast_nullable_to_non_nullable
              as String?,
      partElement: freezed == partElement
          ? _value.partElement
          : partElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get partElement {
    if (_value.partElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.partElement!, (value) {
      return _then(_value.copyWith(partElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MedicinalProductDefinitionNamePartCopyWith<$Res>
    implements $MedicinalProductDefinitionNamePartCopyWith<$Res> {
  factory _$$_MedicinalProductDefinitionNamePartCopyWith(
          _$_MedicinalProductDefinitionNamePart value,
          $Res Function(_$_MedicinalProductDefinitionNamePart) then) =
      __$$_MedicinalProductDefinitionNamePartCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      @JsonKey(name: 'part') String? part_,
      @JsonKey(name: '_part') Element? partElement,
      CodeableConcept type});

  @override
  $ElementCopyWith<$Res>? get partElement;
  @override
  $CodeableConceptCopyWith<$Res> get type;
}

/// @nodoc
class __$$_MedicinalProductDefinitionNamePartCopyWithImpl<$Res>
    extends _$MedicinalProductDefinitionNamePartCopyWithImpl<$Res,
        _$_MedicinalProductDefinitionNamePart>
    implements _$$_MedicinalProductDefinitionNamePartCopyWith<$Res> {
  __$$_MedicinalProductDefinitionNamePartCopyWithImpl(
      _$_MedicinalProductDefinitionNamePart _value,
      $Res Function(_$_MedicinalProductDefinitionNamePart) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? part_ = freezed,
    Object? partElement = freezed,
    Object? type = null,
  }) {
    return _then(_$_MedicinalProductDefinitionNamePart(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      part_: freezed == part_
          ? _value.part_
          : part_ // ignore: cast_nullable_to_non_nullable
              as String?,
      partElement: freezed == partElement
          ? _value.partElement
          : partElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MedicinalProductDefinitionNamePart
    extends _MedicinalProductDefinitionNamePart {
  _$_MedicinalProductDefinitionNamePart(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      @JsonKey(name: 'part') this.part_,
      @JsonKey(name: '_part') this.partElement,
      required this.type})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_MedicinalProductDefinitionNamePart.fromJson(
          Map<String, dynamic> json) =>
      _$$_MedicinalProductDefinitionNamePartFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [part] A fragment of a product name.;
  @override
  @JsonKey(name: 'part')
  final String? part_;

  /// [partElement] (_part): Extensions for part;
  @override
  @JsonKey(name: '_part')
  final Element? partElement;

  /// [type] Identifying type for this part of the name (e.g. strength part).;
  @override
  final CodeableConcept type;

  @override
  String toString() {
    return 'MedicinalProductDefinitionNamePart(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, part_: $part_, partElement: $partElement, type: $type)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MedicinalProductDefinitionNamePart &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.part_, part_) || other.part_ == part_) &&
            (identical(other.partElement, partElement) ||
                other.partElement == partElement) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      part_,
      partElement,
      type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MedicinalProductDefinitionNamePartCopyWith<
          _$_MedicinalProductDefinitionNamePart>
      get copyWith => __$$_MedicinalProductDefinitionNamePartCopyWithImpl<
          _$_MedicinalProductDefinitionNamePart>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MedicinalProductDefinitionNamePartToJson(
      this,
    );
  }
}

abstract class _MedicinalProductDefinitionNamePart
    extends MedicinalProductDefinitionNamePart {
  factory _MedicinalProductDefinitionNamePart(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          @JsonKey(name: 'part') final String? part_,
          @JsonKey(name: '_part') final Element? partElement,
          required final CodeableConcept type}) =
      _$_MedicinalProductDefinitionNamePart;
  _MedicinalProductDefinitionNamePart._() : super._();

  factory _MedicinalProductDefinitionNamePart.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductDefinitionNamePart.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [part] A fragment of a product name.;
  @JsonKey(name: 'part')
  String? get part_;
  @override

  /// [partElement] (_part): Extensions for part;
  @JsonKey(name: '_part')
  Element? get partElement;
  @override

  /// [type] Identifying type for this part of the name (e.g. strength part).;
  CodeableConcept get type;
  @override
  @JsonKey(ignore: true)
  _$$_MedicinalProductDefinitionNamePartCopyWith<
          _$_MedicinalProductDefinitionNamePart>
      get copyWith => throw _privateConstructorUsedError;
}

MedicinalProductDefinitionCountryLanguage
    _$MedicinalProductDefinitionCountryLanguageFromJson(
        Map<String, dynamic> json) {
  return _MedicinalProductDefinitionCountryLanguage.fromJson(json);
}

/// @nodoc
mixin _$MedicinalProductDefinitionCountryLanguage {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [country] Country code for where this name applies.;
  CodeableConcept get country => throw _privateConstructorUsedError;

  /// [jurisdiction] Jurisdiction code for where this name applies. A jurisdiction may be a sub- or supra-national entity (e.g. a state or a geographic region).;
  CodeableConcept? get jurisdiction => throw _privateConstructorUsedError;

  /// [language] Language code for this name.;
  CodeableConcept get language => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MedicinalProductDefinitionCountryLanguageCopyWith<
          MedicinalProductDefinitionCountryLanguage>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MedicinalProductDefinitionCountryLanguageCopyWith<$Res> {
  factory $MedicinalProductDefinitionCountryLanguageCopyWith(
          MedicinalProductDefinitionCountryLanguage value,
          $Res Function(MedicinalProductDefinitionCountryLanguage) then) =
      _$MedicinalProductDefinitionCountryLanguageCopyWithImpl<$Res,
          MedicinalProductDefinitionCountryLanguage>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept country,
      CodeableConcept? jurisdiction,
      CodeableConcept language});

  $CodeableConceptCopyWith<$Res> get country;
  $CodeableConceptCopyWith<$Res>? get jurisdiction;
  $CodeableConceptCopyWith<$Res> get language;
}

/// @nodoc
class _$MedicinalProductDefinitionCountryLanguageCopyWithImpl<$Res,
        $Val extends MedicinalProductDefinitionCountryLanguage>
    implements $MedicinalProductDefinitionCountryLanguageCopyWith<$Res> {
  _$MedicinalProductDefinitionCountryLanguageCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? country = null,
    Object? jurisdiction = freezed,
    Object? language = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      country: null == country
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      jurisdiction: freezed == jurisdiction
          ? _value.jurisdiction
          : jurisdiction // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      language: null == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get country {
    return $CodeableConceptCopyWith<$Res>(_value.country, (value) {
      return _then(_value.copyWith(country: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get jurisdiction {
    if (_value.jurisdiction == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.jurisdiction!, (value) {
      return _then(_value.copyWith(jurisdiction: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get language {
    return $CodeableConceptCopyWith<$Res>(_value.language, (value) {
      return _then(_value.copyWith(language: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MedicinalProductDefinitionCountryLanguageCopyWith<$Res>
    implements $MedicinalProductDefinitionCountryLanguageCopyWith<$Res> {
  factory _$$_MedicinalProductDefinitionCountryLanguageCopyWith(
          _$_MedicinalProductDefinitionCountryLanguage value,
          $Res Function(_$_MedicinalProductDefinitionCountryLanguage) then) =
      __$$_MedicinalProductDefinitionCountryLanguageCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept country,
      CodeableConcept? jurisdiction,
      CodeableConcept language});

  @override
  $CodeableConceptCopyWith<$Res> get country;
  @override
  $CodeableConceptCopyWith<$Res>? get jurisdiction;
  @override
  $CodeableConceptCopyWith<$Res> get language;
}

/// @nodoc
class __$$_MedicinalProductDefinitionCountryLanguageCopyWithImpl<$Res>
    extends _$MedicinalProductDefinitionCountryLanguageCopyWithImpl<$Res,
        _$_MedicinalProductDefinitionCountryLanguage>
    implements _$$_MedicinalProductDefinitionCountryLanguageCopyWith<$Res> {
  __$$_MedicinalProductDefinitionCountryLanguageCopyWithImpl(
      _$_MedicinalProductDefinitionCountryLanguage _value,
      $Res Function(_$_MedicinalProductDefinitionCountryLanguage) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? country = null,
    Object? jurisdiction = freezed,
    Object? language = null,
  }) {
    return _then(_$_MedicinalProductDefinitionCountryLanguage(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      country: null == country
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      jurisdiction: freezed == jurisdiction
          ? _value.jurisdiction
          : jurisdiction // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      language: null == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MedicinalProductDefinitionCountryLanguage
    extends _MedicinalProductDefinitionCountryLanguage {
  _$_MedicinalProductDefinitionCountryLanguage(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.country,
      this.jurisdiction,
      required this.language})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_MedicinalProductDefinitionCountryLanguage.fromJson(
          Map<String, dynamic> json) =>
      _$$_MedicinalProductDefinitionCountryLanguageFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [country] Country code for where this name applies.;
  @override
  final CodeableConcept country;

  /// [jurisdiction] Jurisdiction code for where this name applies. A jurisdiction may be a sub- or supra-national entity (e.g. a state or a geographic region).;
  @override
  final CodeableConcept? jurisdiction;

  /// [language] Language code for this name.;
  @override
  final CodeableConcept language;

  @override
  String toString() {
    return 'MedicinalProductDefinitionCountryLanguage(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, country: $country, jurisdiction: $jurisdiction, language: $language)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MedicinalProductDefinitionCountryLanguage &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.country, country) || other.country == country) &&
            (identical(other.jurisdiction, jurisdiction) ||
                other.jurisdiction == jurisdiction) &&
            (identical(other.language, language) ||
                other.language == language));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      country,
      jurisdiction,
      language);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MedicinalProductDefinitionCountryLanguageCopyWith<
          _$_MedicinalProductDefinitionCountryLanguage>
      get copyWith =>
          __$$_MedicinalProductDefinitionCountryLanguageCopyWithImpl<
              _$_MedicinalProductDefinitionCountryLanguage>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MedicinalProductDefinitionCountryLanguageToJson(
      this,
    );
  }
}

abstract class _MedicinalProductDefinitionCountryLanguage
    extends MedicinalProductDefinitionCountryLanguage {
  factory _MedicinalProductDefinitionCountryLanguage(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept country,
          final CodeableConcept? jurisdiction,
          required final CodeableConcept language}) =
      _$_MedicinalProductDefinitionCountryLanguage;
  _MedicinalProductDefinitionCountryLanguage._() : super._();

  factory _MedicinalProductDefinitionCountryLanguage.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductDefinitionCountryLanguage.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [country] Country code for where this name applies.;
  CodeableConcept get country;
  @override

  /// [jurisdiction] Jurisdiction code for where this name applies. A jurisdiction may be a sub- or supra-national entity (e.g. a state or a geographic region).;
  CodeableConcept? get jurisdiction;
  @override

  /// [language] Language code for this name.;
  CodeableConcept get language;
  @override
  @JsonKey(ignore: true)
  _$$_MedicinalProductDefinitionCountryLanguageCopyWith<
          _$_MedicinalProductDefinitionCountryLanguage>
      get copyWith => throw _privateConstructorUsedError;
}

MedicinalProductDefinitionCrossReference
    _$MedicinalProductDefinitionCrossReferenceFromJson(
        Map<String, dynamic> json) {
  return _MedicinalProductDefinitionCrossReference.fromJson(json);
}

/// @nodoc
mixin _$MedicinalProductDefinitionCrossReference {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [product] Reference to another product, e.g. for linking authorised to investigational product.;
  CodeableReference get product => throw _privateConstructorUsedError;

  /// [type] The type of relationship, for instance branded to generic, virtual to actual product, product to development product (investigational), parallel import version.;
  CodeableConcept? get type => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MedicinalProductDefinitionCrossReferenceCopyWith<
          MedicinalProductDefinitionCrossReference>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MedicinalProductDefinitionCrossReferenceCopyWith<$Res> {
  factory $MedicinalProductDefinitionCrossReferenceCopyWith(
          MedicinalProductDefinitionCrossReference value,
          $Res Function(MedicinalProductDefinitionCrossReference) then) =
      _$MedicinalProductDefinitionCrossReferenceCopyWithImpl<$Res,
          MedicinalProductDefinitionCrossReference>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference product,
      CodeableConcept? type});

  $CodeableReferenceCopyWith<$Res> get product;
  $CodeableConceptCopyWith<$Res>? get type;
}

/// @nodoc
class _$MedicinalProductDefinitionCrossReferenceCopyWithImpl<$Res,
        $Val extends MedicinalProductDefinitionCrossReference>
    implements $MedicinalProductDefinitionCrossReferenceCopyWith<$Res> {
  _$MedicinalProductDefinitionCrossReferenceCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? product = null,
    Object? type = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      product: null == product
          ? _value.product
          : product // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res> get product {
    return $CodeableReferenceCopyWith<$Res>(_value.product, (value) {
      return _then(_value.copyWith(product: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MedicinalProductDefinitionCrossReferenceCopyWith<$Res>
    implements $MedicinalProductDefinitionCrossReferenceCopyWith<$Res> {
  factory _$$_MedicinalProductDefinitionCrossReferenceCopyWith(
          _$_MedicinalProductDefinitionCrossReference value,
          $Res Function(_$_MedicinalProductDefinitionCrossReference) then) =
      __$$_MedicinalProductDefinitionCrossReferenceCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference product,
      CodeableConcept? type});

  @override
  $CodeableReferenceCopyWith<$Res> get product;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
}

/// @nodoc
class __$$_MedicinalProductDefinitionCrossReferenceCopyWithImpl<$Res>
    extends _$MedicinalProductDefinitionCrossReferenceCopyWithImpl<$Res,
        _$_MedicinalProductDefinitionCrossReference>
    implements _$$_MedicinalProductDefinitionCrossReferenceCopyWith<$Res> {
  __$$_MedicinalProductDefinitionCrossReferenceCopyWithImpl(
      _$_MedicinalProductDefinitionCrossReference _value,
      $Res Function(_$_MedicinalProductDefinitionCrossReference) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? product = null,
    Object? type = freezed,
  }) {
    return _then(_$_MedicinalProductDefinitionCrossReference(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      product: null == product
          ? _value.product
          : product // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MedicinalProductDefinitionCrossReference
    extends _MedicinalProductDefinitionCrossReference {
  _$_MedicinalProductDefinitionCrossReference(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.product,
      this.type})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_MedicinalProductDefinitionCrossReference.fromJson(
          Map<String, dynamic> json) =>
      _$$_MedicinalProductDefinitionCrossReferenceFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [product] Reference to another product, e.g. for linking authorised to investigational product.;
  @override
  final CodeableReference product;

  /// [type] The type of relationship, for instance branded to generic, virtual to actual product, product to development product (investigational), parallel import version.;
  @override
  final CodeableConcept? type;

  @override
  String toString() {
    return 'MedicinalProductDefinitionCrossReference(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, product: $product, type: $type)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MedicinalProductDefinitionCrossReference &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.product, product) || other.product == product) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      product,
      type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MedicinalProductDefinitionCrossReferenceCopyWith<
          _$_MedicinalProductDefinitionCrossReference>
      get copyWith => __$$_MedicinalProductDefinitionCrossReferenceCopyWithImpl<
          _$_MedicinalProductDefinitionCrossReference>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MedicinalProductDefinitionCrossReferenceToJson(
      this,
    );
  }
}

abstract class _MedicinalProductDefinitionCrossReference
    extends MedicinalProductDefinitionCrossReference {
  factory _MedicinalProductDefinitionCrossReference(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableReference product,
          final CodeableConcept? type}) =
      _$_MedicinalProductDefinitionCrossReference;
  _MedicinalProductDefinitionCrossReference._() : super._();

  factory _MedicinalProductDefinitionCrossReference.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductDefinitionCrossReference.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [product] Reference to another product, e.g. for linking authorised to investigational product.;
  CodeableReference get product;
  @override

  /// [type] The type of relationship, for instance branded to generic, virtual to actual product, product to development product (investigational), parallel import version.;
  CodeableConcept? get type;
  @override
  @JsonKey(ignore: true)
  _$$_MedicinalProductDefinitionCrossReferenceCopyWith<
          _$_MedicinalProductDefinitionCrossReference>
      get copyWith => throw _privateConstructorUsedError;
}

MedicinalProductDefinitionOperation
    _$MedicinalProductDefinitionOperationFromJson(Map<String, dynamic> json) {
  return _MedicinalProductDefinitionOperation.fromJson(json);
}

/// @nodoc
mixin _$MedicinalProductDefinitionOperation {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] The type of manufacturing operation e.g. manufacturing itself, re-packaging. For the authorization of this, a RegulatedAuthorization would point to the same plan or activity referenced here.;
  CodeableReference? get type => throw _privateConstructorUsedError;

  /// [effectiveDate] Date range of applicability.;
  Period? get effectiveDate => throw _privateConstructorUsedError;

  /// [organization] The organization or establishment responsible for (or associated with) the particular process or step, examples include the manufacturer, importer, agent.;
  List<Reference>? get organization => throw _privateConstructorUsedError;

  /// [confidentialityIndicator] Specifies whether this particular business or manufacturing process is considered proprietary or confidential.;
  CodeableConcept? get confidentialityIndicator =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MedicinalProductDefinitionOperationCopyWith<
          MedicinalProductDefinitionOperation>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MedicinalProductDefinitionOperationCopyWith<$Res> {
  factory $MedicinalProductDefinitionOperationCopyWith(
          MedicinalProductDefinitionOperation value,
          $Res Function(MedicinalProductDefinitionOperation) then) =
      _$MedicinalProductDefinitionOperationCopyWithImpl<$Res,
          MedicinalProductDefinitionOperation>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? type,
      Period? effectiveDate,
      List<Reference>? organization,
      CodeableConcept? confidentialityIndicator});

  $CodeableReferenceCopyWith<$Res>? get type;
  $PeriodCopyWith<$Res>? get effectiveDate;
  $CodeableConceptCopyWith<$Res>? get confidentialityIndicator;
}

/// @nodoc
class _$MedicinalProductDefinitionOperationCopyWithImpl<$Res,
        $Val extends MedicinalProductDefinitionOperation>
    implements $MedicinalProductDefinitionOperationCopyWith<$Res> {
  _$MedicinalProductDefinitionOperationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? effectiveDate = freezed,
    Object? organization = freezed,
    Object? confidentialityIndicator = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      effectiveDate: freezed == effectiveDate
          ? _value.effectiveDate
          : effectiveDate // ignore: cast_nullable_to_non_nullable
              as Period?,
      organization: freezed == organization
          ? _value.organization
          : organization // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      confidentialityIndicator: freezed == confidentialityIndicator
          ? _value.confidentialityIndicator
          : confidentialityIndicator // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableReferenceCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get effectiveDate {
    if (_value.effectiveDate == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.effectiveDate!, (value) {
      return _then(_value.copyWith(effectiveDate: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get confidentialityIndicator {
    if (_value.confidentialityIndicator == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.confidentialityIndicator!,
        (value) {
      return _then(_value.copyWith(confidentialityIndicator: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MedicinalProductDefinitionOperationCopyWith<$Res>
    implements $MedicinalProductDefinitionOperationCopyWith<$Res> {
  factory _$$_MedicinalProductDefinitionOperationCopyWith(
          _$_MedicinalProductDefinitionOperation value,
          $Res Function(_$_MedicinalProductDefinitionOperation) then) =
      __$$_MedicinalProductDefinitionOperationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference? type,
      Period? effectiveDate,
      List<Reference>? organization,
      CodeableConcept? confidentialityIndicator});

  @override
  $CodeableReferenceCopyWith<$Res>? get type;
  @override
  $PeriodCopyWith<$Res>? get effectiveDate;
  @override
  $CodeableConceptCopyWith<$Res>? get confidentialityIndicator;
}

/// @nodoc
class __$$_MedicinalProductDefinitionOperationCopyWithImpl<$Res>
    extends _$MedicinalProductDefinitionOperationCopyWithImpl<$Res,
        _$_MedicinalProductDefinitionOperation>
    implements _$$_MedicinalProductDefinitionOperationCopyWith<$Res> {
  __$$_MedicinalProductDefinitionOperationCopyWithImpl(
      _$_MedicinalProductDefinitionOperation _value,
      $Res Function(_$_MedicinalProductDefinitionOperation) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? effectiveDate = freezed,
    Object? organization = freezed,
    Object? confidentialityIndicator = freezed,
  }) {
    return _then(_$_MedicinalProductDefinitionOperation(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      effectiveDate: freezed == effectiveDate
          ? _value.effectiveDate
          : effectiveDate // ignore: cast_nullable_to_non_nullable
              as Period?,
      organization: freezed == organization
          ? _value._organization
          : organization // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      confidentialityIndicator: freezed == confidentialityIndicator
          ? _value.confidentialityIndicator
          : confidentialityIndicator // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MedicinalProductDefinitionOperation
    extends _MedicinalProductDefinitionOperation {
  _$_MedicinalProductDefinitionOperation(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.type,
      this.effectiveDate,
      final List<Reference>? organization,
      this.confidentialityIndicator})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _organization = organization,
        super._();

  factory _$_MedicinalProductDefinitionOperation.fromJson(
          Map<String, dynamic> json) =>
      _$$_MedicinalProductDefinitionOperationFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] The type of manufacturing operation e.g. manufacturing itself, re-packaging. For the authorization of this, a RegulatedAuthorization would point to the same plan or activity referenced here.;
  @override
  final CodeableReference? type;

  /// [effectiveDate] Date range of applicability.;
  @override
  final Period? effectiveDate;

  /// [organization] The organization or establishment responsible for (or associated with) the particular process or step, examples include the manufacturer, importer, agent.;
  final List<Reference>? _organization;

  /// [organization] The organization or establishment responsible for (or associated with) the particular process or step, examples include the manufacturer, importer, agent.;
  @override
  List<Reference>? get organization {
    final value = _organization;
    if (value == null) return null;
    if (_organization is EqualUnmodifiableListView) return _organization;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [confidentialityIndicator] Specifies whether this particular business or manufacturing process is considered proprietary or confidential.;
  @override
  final CodeableConcept? confidentialityIndicator;

  @override
  String toString() {
    return 'MedicinalProductDefinitionOperation(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, effectiveDate: $effectiveDate, organization: $organization, confidentialityIndicator: $confidentialityIndicator)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MedicinalProductDefinitionOperation &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.effectiveDate, effectiveDate) ||
                other.effectiveDate == effectiveDate) &&
            const DeepCollectionEquality()
                .equals(other._organization, _organization) &&
            (identical(
                    other.confidentialityIndicator, confidentialityIndicator) ||
                other.confidentialityIndicator == confidentialityIndicator));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      effectiveDate,
      const DeepCollectionEquality().hash(_organization),
      confidentialityIndicator);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MedicinalProductDefinitionOperationCopyWith<
          _$_MedicinalProductDefinitionOperation>
      get copyWith => __$$_MedicinalProductDefinitionOperationCopyWithImpl<
          _$_MedicinalProductDefinitionOperation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MedicinalProductDefinitionOperationToJson(
      this,
    );
  }
}

abstract class _MedicinalProductDefinitionOperation
    extends MedicinalProductDefinitionOperation {
  factory _MedicinalProductDefinitionOperation(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableReference? type,
          final Period? effectiveDate,
          final List<Reference>? organization,
          final CodeableConcept? confidentialityIndicator}) =
      _$_MedicinalProductDefinitionOperation;
  _MedicinalProductDefinitionOperation._() : super._();

  factory _MedicinalProductDefinitionOperation.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductDefinitionOperation.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] The type of manufacturing operation e.g. manufacturing itself, re-packaging. For the authorization of this, a RegulatedAuthorization would point to the same plan or activity referenced here.;
  CodeableReference? get type;
  @override

  /// [effectiveDate] Date range of applicability.;
  Period? get effectiveDate;
  @override

  /// [organization] The organization or establishment responsible for (or associated with) the particular process or step, examples include the manufacturer, importer, agent.;
  List<Reference>? get organization;
  @override

  /// [confidentialityIndicator] Specifies whether this particular business or manufacturing process is considered proprietary or confidential.;
  CodeableConcept? get confidentialityIndicator;
  @override
  @JsonKey(ignore: true)
  _$$_MedicinalProductDefinitionOperationCopyWith<
          _$_MedicinalProductDefinitionOperation>
      get copyWith => throw _privateConstructorUsedError;
}

MedicinalProductDefinitionCharacteristic
    _$MedicinalProductDefinitionCharacteristicFromJson(
        Map<String, dynamic> json) {
  return _MedicinalProductDefinitionCharacteristic.fromJson(json);
}

/// @nodoc
mixin _$MedicinalProductDefinitionCharacteristic {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] A code expressing the type of characteristic.;
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [valueCodeableConcept] A value for the characteristic.text.;
  CodeableConcept? get valueCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [valueQuantity] A value for the characteristic.text.;
  Quantity? get valueQuantity => throw _privateConstructorUsedError;

  /// [valueDate] A value for the characteristic.text.;
  Date? get valueDate => throw _privateConstructorUsedError;

  /// [valueDateElement] (_valueDate): Extensions for valueDate;
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement => throw _privateConstructorUsedError;

  /// [valueBoolean] A value for the characteristic.text.;
  Boolean? get valueBoolean => throw _privateConstructorUsedError;

  /// [valueBooleanElement] (_valueBoolean): Extensions for valueBoolean;
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement => throw _privateConstructorUsedError;

  /// [valueAttachment] A value for the characteristic.text.;
  Attachment? get valueAttachment => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MedicinalProductDefinitionCharacteristicCopyWith<
          MedicinalProductDefinitionCharacteristic>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MedicinalProductDefinitionCharacteristicCopyWith<$Res> {
  factory $MedicinalProductDefinitionCharacteristicCopyWith(
          MedicinalProductDefinitionCharacteristic value,
          $Res Function(MedicinalProductDefinitionCharacteristic) then) =
      _$MedicinalProductDefinitionCharacteristicCopyWithImpl<$Res,
          MedicinalProductDefinitionCharacteristic>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      Quantity? valueQuantity,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment});

  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  $QuantityCopyWith<$Res>? get valueQuantity;
  $ElementCopyWith<$Res>? get valueDateElement;
  $ElementCopyWith<$Res>? get valueBooleanElement;
  $AttachmentCopyWith<$Res>? get valueAttachment;
}

/// @nodoc
class _$MedicinalProductDefinitionCharacteristicCopyWithImpl<$Res,
        $Val extends MedicinalProductDefinitionCharacteristic>
    implements $MedicinalProductDefinitionCharacteristicCopyWith<$Res> {
  _$MedicinalProductDefinitionCharacteristicCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueQuantity = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept {
    if (_value.valueCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.valueCodeableConcept!,
        (value) {
      return _then(_value.copyWith(valueCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get valueQuantity {
    if (_value.valueQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.valueQuantity!, (value) {
      return _then(_value.copyWith(valueQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueDateElement {
    if (_value.valueDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueDateElement!, (value) {
      return _then(_value.copyWith(valueDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueBooleanElement {
    if (_value.valueBooleanElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueBooleanElement!, (value) {
      return _then(_value.copyWith(valueBooleanElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get valueAttachment {
    if (_value.valueAttachment == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.valueAttachment!, (value) {
      return _then(_value.copyWith(valueAttachment: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MedicinalProductDefinitionCharacteristicCopyWith<$Res>
    implements $MedicinalProductDefinitionCharacteristicCopyWith<$Res> {
  factory _$$_MedicinalProductDefinitionCharacteristicCopyWith(
          _$_MedicinalProductDefinitionCharacteristic value,
          $Res Function(_$_MedicinalProductDefinitionCharacteristic) then) =
      __$$_MedicinalProductDefinitionCharacteristicCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      Quantity? valueQuantity,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  @override
  $QuantityCopyWith<$Res>? get valueQuantity;
  @override
  $ElementCopyWith<$Res>? get valueDateElement;
  @override
  $ElementCopyWith<$Res>? get valueBooleanElement;
  @override
  $AttachmentCopyWith<$Res>? get valueAttachment;
}

/// @nodoc
class __$$_MedicinalProductDefinitionCharacteristicCopyWithImpl<$Res>
    extends _$MedicinalProductDefinitionCharacteristicCopyWithImpl<$Res,
        _$_MedicinalProductDefinitionCharacteristic>
    implements _$$_MedicinalProductDefinitionCharacteristicCopyWith<$Res> {
  __$$_MedicinalProductDefinitionCharacteristicCopyWithImpl(
      _$_MedicinalProductDefinitionCharacteristic _value,
      $Res Function(_$_MedicinalProductDefinitionCharacteristic) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueQuantity = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
  }) {
    return _then(_$_MedicinalProductDefinitionCharacteristic(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MedicinalProductDefinitionCharacteristic
    extends _MedicinalProductDefinitionCharacteristic {
  _$_MedicinalProductDefinitionCharacteristic(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.type,
      this.valueCodeableConcept,
      this.valueQuantity,
      this.valueDate,
      @JsonKey(name: '_valueDate') this.valueDateElement,
      this.valueBoolean,
      @JsonKey(name: '_valueBoolean') this.valueBooleanElement,
      this.valueAttachment})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_MedicinalProductDefinitionCharacteristic.fromJson(
          Map<String, dynamic> json) =>
      _$$_MedicinalProductDefinitionCharacteristicFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] A code expressing the type of characteristic.;
  @override
  final CodeableConcept type;

  /// [valueCodeableConcept] A value for the characteristic.text.;
  @override
  final CodeableConcept? valueCodeableConcept;

  /// [valueQuantity] A value for the characteristic.text.;
  @override
  final Quantity? valueQuantity;

  /// [valueDate] A value for the characteristic.text.;
  @override
  final Date? valueDate;

  /// [valueDateElement] (_valueDate): Extensions for valueDate;
  @override
  @JsonKey(name: '_valueDate')
  final Element? valueDateElement;

  /// [valueBoolean] A value for the characteristic.text.;
  @override
  final Boolean? valueBoolean;

  /// [valueBooleanElement] (_valueBoolean): Extensions for valueBoolean;
  @override
  @JsonKey(name: '_valueBoolean')
  final Element? valueBooleanElement;

  /// [valueAttachment] A value for the characteristic.text.;
  @override
  final Attachment? valueAttachment;

  @override
  String toString() {
    return 'MedicinalProductDefinitionCharacteristic(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, valueCodeableConcept: $valueCodeableConcept, valueQuantity: $valueQuantity, valueDate: $valueDate, valueDateElement: $valueDateElement, valueBoolean: $valueBoolean, valueBooleanElement: $valueBooleanElement, valueAttachment: $valueAttachment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MedicinalProductDefinitionCharacteristic &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.valueCodeableConcept, valueCodeableConcept) ||
                other.valueCodeableConcept == valueCodeableConcept) &&
            (identical(other.valueQuantity, valueQuantity) ||
                other.valueQuantity == valueQuantity) &&
            (identical(other.valueDate, valueDate) ||
                other.valueDate == valueDate) &&
            (identical(other.valueDateElement, valueDateElement) ||
                other.valueDateElement == valueDateElement) &&
            (identical(other.valueBoolean, valueBoolean) ||
                other.valueBoolean == valueBoolean) &&
            (identical(other.valueBooleanElement, valueBooleanElement) ||
                other.valueBooleanElement == valueBooleanElement) &&
            (identical(other.valueAttachment, valueAttachment) ||
                other.valueAttachment == valueAttachment));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      valueCodeableConcept,
      valueQuantity,
      valueDate,
      valueDateElement,
      valueBoolean,
      valueBooleanElement,
      valueAttachment);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MedicinalProductDefinitionCharacteristicCopyWith<
          _$_MedicinalProductDefinitionCharacteristic>
      get copyWith => __$$_MedicinalProductDefinitionCharacteristicCopyWithImpl<
          _$_MedicinalProductDefinitionCharacteristic>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MedicinalProductDefinitionCharacteristicToJson(
      this,
    );
  }
}

abstract class _MedicinalProductDefinitionCharacteristic
    extends MedicinalProductDefinitionCharacteristic {
  factory _MedicinalProductDefinitionCharacteristic(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept type,
          final CodeableConcept? valueCodeableConcept,
          final Quantity? valueQuantity,
          final Date? valueDate,
          @JsonKey(name: '_valueDate') final Element? valueDateElement,
          final Boolean? valueBoolean,
          @JsonKey(name: '_valueBoolean') final Element? valueBooleanElement,
          final Attachment? valueAttachment}) =
      _$_MedicinalProductDefinitionCharacteristic;
  _MedicinalProductDefinitionCharacteristic._() : super._();

  factory _MedicinalProductDefinitionCharacteristic.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductDefinitionCharacteristic.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] A code expressing the type of characteristic.;
  CodeableConcept get type;
  @override

  /// [valueCodeableConcept] A value for the characteristic.text.;
  CodeableConcept? get valueCodeableConcept;
  @override

  /// [valueQuantity] A value for the characteristic.text.;
  Quantity? get valueQuantity;
  @override

  /// [valueDate] A value for the characteristic.text.;
  Date? get valueDate;
  @override

  /// [valueDateElement] (_valueDate): Extensions for valueDate;
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement;
  @override

  /// [valueBoolean] A value for the characteristic.text.;
  Boolean? get valueBoolean;
  @override

  /// [valueBooleanElement] (_valueBoolean): Extensions for valueBoolean;
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement;
  @override

  /// [valueAttachment] A value for the characteristic.text.;
  Attachment? get valueAttachment;
  @override
  @JsonKey(ignore: true)
  _$$_MedicinalProductDefinitionCharacteristicCopyWith<
          _$_MedicinalProductDefinitionCharacteristic>
      get copyWith => throw _privateConstructorUsedError;
}

PackagedProductDefinition _$PackagedProductDefinitionFromJson(
    Map<String, dynamic> json) {
  return _PackagedProductDefinition.fromJson(json);
}

/// @nodoc
mixin _$PackagedProductDefinition {
  R4ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  String? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.;
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] (_language): Extensions for language;
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] A unique identifier for this package as whole - not the the content of the package. Unique instance identifiers assigned to a package by manufacturers, regulators, drug catalogue custodians or other organizations.;
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [name] A name for this package. Typically what it would be listed as in a drug formulary or catalogue, inventory etc.;
  String? get name => throw _privateConstructorUsedError;

  /// [nameElement] (_name): Extensions for name;
  @JsonKey(name: '_name')
  Element? get nameElement => throw _privateConstructorUsedError;

  /// [type] A high level category e.g. medicinal product, raw material, shipping/transport container, etc.;
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [packageFor] The product this package model relates to, not the contents of the package (for which see package.containedItem).;
  List<Reference>? get packageFor => throw _privateConstructorUsedError;

  /// [status] The status within the lifecycle of this item. A high level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization or marketing status.;
  CodeableConcept? get status => throw _privateConstructorUsedError;

  /// [statusDate] The date at which the given status became applicable.;
  FhirDateTime? get statusDate => throw _privateConstructorUsedError;

  /// [statusDateElement] (_statusDate): Extensions for statusDate;
  @JsonKey(name: '_statusDate')
  Element? get statusDateElement => throw _privateConstructorUsedError;

  /// [containedItemQuantity] A total of the complete count of contained items of a particular type/form, independent of sub-packaging or organization. This can be considered as the pack size. This attribute differs from containedItem.amount in that it can give a single aggregated count of all tablet types in a pack, even when these are different manufactured items. For example a pill pack of 21 tablets plus 7 sugar tablets, can be denoted here as '28 tablets'. This attribute is repeatable so that the different item types in one pack type can be counted (e.g. a count of vials and count of syringes). Each repeat must have different units, so that it is clear what the different sets of counted items are, and it is not intended to allow different counts of similar items (e.g. not '2 tubes and 3 tubes'). Repeats are not to be used to represent different pack sizes (e.g. 20 pack vs. 50 pack) - which would be different instances of this resource.;
  List<Quantity>? get containedItemQuantity =>
      throw _privateConstructorUsedError;

  /// [description] Textual description. Note that this is not the name of the package or product.;
  Markdown? get description => throw _privateConstructorUsedError;

  /// [descriptionElement] (_description): Extensions for description;
  @JsonKey(name: '_description')
  Element? get descriptionElement => throw _privateConstructorUsedError;

  /// [legalStatusOfSupply] The legal status of supply of the packaged item as classified by the regulator.;
  List<PackagedProductDefinitionLegalStatusOfSupply>? get legalStatusOfSupply =>
      throw _privateConstructorUsedError;

  /// [marketingStatus] Allows specifying that an item is on the market for sale, or that it is not available, and the dates and locations associated.;
  List<MarketingStatus>? get marketingStatus =>
      throw _privateConstructorUsedError;

  /// [characteristic] Allows the key features to be recorded, such as "hospital pack", "nurse prescribable", "calendar pack".;
  List<CodeableConcept>? get characteristic =>
      throw _privateConstructorUsedError;

  /// [copackagedIndicator] Identifies if the package contains different items, such as when a drug product is supplied with another item e.g. a diluent or adjuvant.;
  Boolean? get copackagedIndicator => throw _privateConstructorUsedError;

  /// [copackagedIndicatorElement] (_copackagedIndicator): Extensions for copackagedIndicator;
  @JsonKey(name: '_copackagedIndicator')
  Element? get copackagedIndicatorElement => throw _privateConstructorUsedError;

  /// [manufacturer] Manufacturer of this package type. When there are multiple it means these are all possible manufacturers.;
  List<Reference>? get manufacturer => throw _privateConstructorUsedError;

  /// [package] A packaging item, as a container for medically related items, possibly with other packaging items within, or a packaging component, such as bottle cap (which is not a device or a medication manufactured item).;
  PackagedProductDefinitionPackage? get package =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PackagedProductDefinitionCopyWith<PackagedProductDefinition> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PackagedProductDefinitionCopyWith<$Res> {
  factory $PackagedProductDefinitionCopyWith(PackagedProductDefinition value,
          $Res Function(PackagedProductDefinition) then) =
      _$PackagedProductDefinitionCopyWithImpl<$Res, PackagedProductDefinition>;
  @useResult
  $Res call(
      {R4ResourceType resourceType,
      String? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      String? name,
      @JsonKey(name: '_name')
          Element? nameElement,
      CodeableConcept? type,
      List<Reference>? packageFor,
      CodeableConcept? status,
      FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate')
          Element? statusDateElement,
      List<Quantity>? containedItemQuantity,
      Markdown? description,
      @JsonKey(name: '_description')
          Element? descriptionElement,
      List<PackagedProductDefinitionLegalStatusOfSupply>? legalStatusOfSupply,
      List<MarketingStatus>? marketingStatus,
      List<CodeableConcept>? characteristic,
      Boolean? copackagedIndicator,
      @JsonKey(name: '_copackagedIndicator')
          Element? copackagedIndicatorElement,
      List<Reference>? manufacturer,
      PackagedProductDefinitionPackage? package});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $ElementCopyWith<$Res>? get nameElement;
  $CodeableConceptCopyWith<$Res>? get type;
  $CodeableConceptCopyWith<$Res>? get status;
  $ElementCopyWith<$Res>? get statusDateElement;
  $ElementCopyWith<$Res>? get descriptionElement;
  $ElementCopyWith<$Res>? get copackagedIndicatorElement;
  $PackagedProductDefinitionPackageCopyWith<$Res>? get package;
}

/// @nodoc
class _$PackagedProductDefinitionCopyWithImpl<$Res,
        $Val extends PackagedProductDefinition>
    implements $PackagedProductDefinitionCopyWith<$Res> {
  _$PackagedProductDefinitionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? type = freezed,
    Object? packageFor = freezed,
    Object? status = freezed,
    Object? statusDate = freezed,
    Object? statusDateElement = freezed,
    Object? containedItemQuantity = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? legalStatusOfSupply = freezed,
    Object? marketingStatus = freezed,
    Object? characteristic = freezed,
    Object? copackagedIndicator = freezed,
    Object? copackagedIndicatorElement = freezed,
    Object? manufacturer = freezed,
    Object? package = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R4ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      packageFor: freezed == packageFor
          ? _value.packageFor
          : packageFor // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      statusDate: freezed == statusDate
          ? _value.statusDate
          : statusDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      statusDateElement: freezed == statusDateElement
          ? _value.statusDateElement
          : statusDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      containedItemQuantity: freezed == containedItemQuantity
          ? _value.containedItemQuantity
          : containedItemQuantity // ignore: cast_nullable_to_non_nullable
              as List<Quantity>?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      legalStatusOfSupply: freezed == legalStatusOfSupply
          ? _value.legalStatusOfSupply
          : legalStatusOfSupply // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionLegalStatusOfSupply>?,
      marketingStatus: freezed == marketingStatus
          ? _value.marketingStatus
          : marketingStatus // ignore: cast_nullable_to_non_nullable
              as List<MarketingStatus>?,
      characteristic: freezed == characteristic
          ? _value.characteristic
          : characteristic // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      copackagedIndicator: freezed == copackagedIndicator
          ? _value.copackagedIndicator
          : copackagedIndicator // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      copackagedIndicatorElement: freezed == copackagedIndicatorElement
          ? _value.copackagedIndicatorElement
          : copackagedIndicatorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      manufacturer: freezed == manufacturer
          ? _value.manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      package: freezed == package
          ? _value.package
          : package // ignore: cast_nullable_to_non_nullable
              as PackagedProductDefinitionPackage?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get nameElement {
    if (_value.nameElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.nameElement!, (value) {
      return _then(_value.copyWith(nameElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusDateElement {
    if (_value.statusDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusDateElement!, (value) {
      return _then(_value.copyWith(statusDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get descriptionElement {
    if (_value.descriptionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.descriptionElement!, (value) {
      return _then(_value.copyWith(descriptionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get copackagedIndicatorElement {
    if (_value.copackagedIndicatorElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.copackagedIndicatorElement!, (value) {
      return _then(_value.copyWith(copackagedIndicatorElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PackagedProductDefinitionPackageCopyWith<$Res>? get package {
    if (_value.package == null) {
      return null;
    }

    return $PackagedProductDefinitionPackageCopyWith<$Res>(_value.package!,
        (value) {
      return _then(_value.copyWith(package: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_PackagedProductDefinitionCopyWith<$Res>
    implements $PackagedProductDefinitionCopyWith<$Res> {
  factory _$$_PackagedProductDefinitionCopyWith(
          _$_PackagedProductDefinition value,
          $Res Function(_$_PackagedProductDefinition) then) =
      __$$_PackagedProductDefinitionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {R4ResourceType resourceType,
      String? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules')
          Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language')
          Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      String? name,
      @JsonKey(name: '_name')
          Element? nameElement,
      CodeableConcept? type,
      List<Reference>? packageFor,
      CodeableConcept? status,
      FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate')
          Element? statusDateElement,
      List<Quantity>? containedItemQuantity,
      Markdown? description,
      @JsonKey(name: '_description')
          Element? descriptionElement,
      List<PackagedProductDefinitionLegalStatusOfSupply>? legalStatusOfSupply,
      List<MarketingStatus>? marketingStatus,
      List<CodeableConcept>? characteristic,
      Boolean? copackagedIndicator,
      @JsonKey(name: '_copackagedIndicator')
          Element? copackagedIndicatorElement,
      List<Reference>? manufacturer,
      PackagedProductDefinitionPackage? package});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $ElementCopyWith<$Res>? get nameElement;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
  @override
  $ElementCopyWith<$Res>? get statusDateElement;
  @override
  $ElementCopyWith<$Res>? get descriptionElement;
  @override
  $ElementCopyWith<$Res>? get copackagedIndicatorElement;
  @override
  $PackagedProductDefinitionPackageCopyWith<$Res>? get package;
}

/// @nodoc
class __$$_PackagedProductDefinitionCopyWithImpl<$Res>
    extends _$PackagedProductDefinitionCopyWithImpl<$Res,
        _$_PackagedProductDefinition>
    implements _$$_PackagedProductDefinitionCopyWith<$Res> {
  __$$_PackagedProductDefinitionCopyWithImpl(
      _$_PackagedProductDefinition _value,
      $Res Function(_$_PackagedProductDefinition) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? type = freezed,
    Object? packageFor = freezed,
    Object? status = freezed,
    Object? statusDate = freezed,
    Object? statusDateElement = freezed,
    Object? containedItemQuantity = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? legalStatusOfSupply = freezed,
    Object? marketingStatus = freezed,
    Object? characteristic = freezed,
    Object? copackagedIndicator = freezed,
    Object? copackagedIndicatorElement = freezed,
    Object? manufacturer = freezed,
    Object? package = freezed,
  }) {
    return _then(_$_PackagedProductDefinition(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R4ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      packageFor: freezed == packageFor
          ? _value._packageFor
          : packageFor // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      statusDate: freezed == statusDate
          ? _value.statusDate
          : statusDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      statusDateElement: freezed == statusDateElement
          ? _value.statusDateElement
          : statusDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      containedItemQuantity: freezed == containedItemQuantity
          ? _value._containedItemQuantity
          : containedItemQuantity // ignore: cast_nullable_to_non_nullable
              as List<Quantity>?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      legalStatusOfSupply: freezed == legalStatusOfSupply
          ? _value._legalStatusOfSupply
          : legalStatusOfSupply // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionLegalStatusOfSupply>?,
      marketingStatus: freezed == marketingStatus
          ? _value._marketingStatus
          : marketingStatus // ignore: cast_nullable_to_non_nullable
              as List<MarketingStatus>?,
      characteristic: freezed == characteristic
          ? _value._characteristic
          : characteristic // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      copackagedIndicator: freezed == copackagedIndicator
          ? _value.copackagedIndicator
          : copackagedIndicator // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      copackagedIndicatorElement: freezed == copackagedIndicatorElement
          ? _value.copackagedIndicatorElement
          : copackagedIndicatorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      manufacturer: freezed == manufacturer
          ? _value._manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      package: freezed == package
          ? _value.package
          : package // ignore: cast_nullable_to_non_nullable
              as PackagedProductDefinitionPackage?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PackagedProductDefinition extends _PackagedProductDefinition {
  _$_PackagedProductDefinition(
      {this.resourceType = R4ResourceType.PackagedProductDefinition,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules') this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language') this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      this.name,
      @JsonKey(name: '_name') this.nameElement,
      this.type,
      final List<Reference>? packageFor,
      this.status,
      this.statusDate,
      @JsonKey(name: '_statusDate') this.statusDateElement,
      final List<Quantity>? containedItemQuantity,
      this.description,
      @JsonKey(name: '_description') this.descriptionElement,
      final List<PackagedProductDefinitionLegalStatusOfSupply>?
          legalStatusOfSupply,
      final List<MarketingStatus>? marketingStatus,
      final List<CodeableConcept>? characteristic,
      this.copackagedIndicator,
      @JsonKey(name: '_copackagedIndicator') this.copackagedIndicatorElement,
      final List<Reference>? manufacturer,
      this.package})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _packageFor = packageFor,
        _containedItemQuantity = containedItemQuantity,
        _legalStatusOfSupply = legalStatusOfSupply,
        _marketingStatus = marketingStatus,
        _characteristic = characteristic,
        _manufacturer = manufacturer,
        super._();

  factory _$_PackagedProductDefinition.fromJson(Map<String, dynamic> json) =>
      _$$_PackagedProductDefinitionFromJson(json);

  @override
  @JsonKey()
  final R4ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  @override
  final String? id;

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.;
  @override
  final Code? language;

  /// [languageElement] (_language): Extensions for language;
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] A unique identifier for this package as whole - not the the content of the package. Unique instance identifiers assigned to a package by manufacturers, regulators, drug catalogue custodians or other organizations.;
  final List<Identifier>? _identifier;

  /// [identifier] A unique identifier for this package as whole - not the the content of the package. Unique instance identifiers assigned to a package by manufacturers, regulators, drug catalogue custodians or other organizations.;
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [name] A name for this package. Typically what it would be listed as in a drug formulary or catalogue, inventory etc.;
  @override
  final String? name;

  /// [nameElement] (_name): Extensions for name;
  @override
  @JsonKey(name: '_name')
  final Element? nameElement;

  /// [type] A high level category e.g. medicinal product, raw material, shipping/transport container, etc.;
  @override
  final CodeableConcept? type;

  /// [packageFor] The product this package model relates to, not the contents of the package (for which see package.containedItem).;
  final List<Reference>? _packageFor;

  /// [packageFor] The product this package model relates to, not the contents of the package (for which see package.containedItem).;
  @override
  List<Reference>? get packageFor {
    final value = _packageFor;
    if (value == null) return null;
    if (_packageFor is EqualUnmodifiableListView) return _packageFor;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [status] The status within the lifecycle of this item. A high level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization or marketing status.;
  @override
  final CodeableConcept? status;

  /// [statusDate] The date at which the given status became applicable.;
  @override
  final FhirDateTime? statusDate;

  /// [statusDateElement] (_statusDate): Extensions for statusDate;
  @override
  @JsonKey(name: '_statusDate')
  final Element? statusDateElement;

  /// [containedItemQuantity] A total of the complete count of contained items of a particular type/form, independent of sub-packaging or organization. This can be considered as the pack size. This attribute differs from containedItem.amount in that it can give a single aggregated count of all tablet types in a pack, even when these are different manufactured items. For example a pill pack of 21 tablets plus 7 sugar tablets, can be denoted here as '28 tablets'. This attribute is repeatable so that the different item types in one pack type can be counted (e.g. a count of vials and count of syringes). Each repeat must have different units, so that it is clear what the different sets of counted items are, and it is not intended to allow different counts of similar items (e.g. not '2 tubes and 3 tubes'). Repeats are not to be used to represent different pack sizes (e.g. 20 pack vs. 50 pack) - which would be different instances of this resource.;
  final List<Quantity>? _containedItemQuantity;

  /// [containedItemQuantity] A total of the complete count of contained items of a particular type/form, independent of sub-packaging or organization. This can be considered as the pack size. This attribute differs from containedItem.amount in that it can give a single aggregated count of all tablet types in a pack, even when these are different manufactured items. For example a pill pack of 21 tablets plus 7 sugar tablets, can be denoted here as '28 tablets'. This attribute is repeatable so that the different item types in one pack type can be counted (e.g. a count of vials and count of syringes). Each repeat must have different units, so that it is clear what the different sets of counted items are, and it is not intended to allow different counts of similar items (e.g. not '2 tubes and 3 tubes'). Repeats are not to be used to represent different pack sizes (e.g. 20 pack vs. 50 pack) - which would be different instances of this resource.;
  @override
  List<Quantity>? get containedItemQuantity {
    final value = _containedItemQuantity;
    if (value == null) return null;
    if (_containedItemQuantity is EqualUnmodifiableListView)
      return _containedItemQuantity;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [description] Textual description. Note that this is not the name of the package or product.;
  @override
  final Markdown? description;

  /// [descriptionElement] (_description): Extensions for description;
  @override
  @JsonKey(name: '_description')
  final Element? descriptionElement;

  /// [legalStatusOfSupply] The legal status of supply of the packaged item as classified by the regulator.;
  final List<PackagedProductDefinitionLegalStatusOfSupply>?
      _legalStatusOfSupply;

  /// [legalStatusOfSupply] The legal status of supply of the packaged item as classified by the regulator.;
  @override
  List<PackagedProductDefinitionLegalStatusOfSupply>? get legalStatusOfSupply {
    final value = _legalStatusOfSupply;
    if (value == null) return null;
    if (_legalStatusOfSupply is EqualUnmodifiableListView)
      return _legalStatusOfSupply;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [marketingStatus] Allows specifying that an item is on the market for sale, or that it is not available, and the dates and locations associated.;
  final List<MarketingStatus>? _marketingStatus;

  /// [marketingStatus] Allows specifying that an item is on the market for sale, or that it is not available, and the dates and locations associated.;
  @override
  List<MarketingStatus>? get marketingStatus {
    final value = _marketingStatus;
    if (value == null) return null;
    if (_marketingStatus is EqualUnmodifiableListView) return _marketingStatus;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [characteristic] Allows the key features to be recorded, such as "hospital pack", "nurse prescribable", "calendar pack".;
  final List<CodeableConcept>? _characteristic;

  /// [characteristic] Allows the key features to be recorded, such as "hospital pack", "nurse prescribable", "calendar pack".;
  @override
  List<CodeableConcept>? get characteristic {
    final value = _characteristic;
    if (value == null) return null;
    if (_characteristic is EqualUnmodifiableListView) return _characteristic;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [copackagedIndicator] Identifies if the package contains different items, such as when a drug product is supplied with another item e.g. a diluent or adjuvant.;
  @override
  final Boolean? copackagedIndicator;

  /// [copackagedIndicatorElement] (_copackagedIndicator): Extensions for copackagedIndicator;
  @override
  @JsonKey(name: '_copackagedIndicator')
  final Element? copackagedIndicatorElement;

  /// [manufacturer] Manufacturer of this package type. When there are multiple it means these are all possible manufacturers.;
  final List<Reference>? _manufacturer;

  /// [manufacturer] Manufacturer of this package type. When there are multiple it means these are all possible manufacturers.;
  @override
  List<Reference>? get manufacturer {
    final value = _manufacturer;
    if (value == null) return null;
    if (_manufacturer is EqualUnmodifiableListView) return _manufacturer;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [package] A packaging item, as a container for medically related items, possibly with other packaging items within, or a packaging component, such as bottle cap (which is not a device or a medication manufactured item).;
  @override
  final PackagedProductDefinitionPackage? package;

  @override
  String toString() {
    return 'PackagedProductDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, name: $name, nameElement: $nameElement, type: $type, packageFor: $packageFor, status: $status, statusDate: $statusDate, statusDateElement: $statusDateElement, containedItemQuantity: $containedItemQuantity, description: $description, descriptionElement: $descriptionElement, legalStatusOfSupply: $legalStatusOfSupply, marketingStatus: $marketingStatus, characteristic: $characteristic, copackagedIndicator: $copackagedIndicator, copackagedIndicatorElement: $copackagedIndicatorElement, manufacturer: $manufacturer, package: $package)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PackagedProductDefinition &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.nameElement, nameElement) ||
                other.nameElement == nameElement) &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality()
                .equals(other._packageFor, _packageFor) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusDate, statusDate) ||
                other.statusDate == statusDate) &&
            (identical(other.statusDateElement, statusDateElement) ||
                other.statusDateElement == statusDateElement) &&
            const DeepCollectionEquality()
                .equals(other._containedItemQuantity, _containedItemQuantity) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.descriptionElement, descriptionElement) ||
                other.descriptionElement == descriptionElement) &&
            const DeepCollectionEquality()
                .equals(other._legalStatusOfSupply, _legalStatusOfSupply) &&
            const DeepCollectionEquality()
                .equals(other._marketingStatus, _marketingStatus) &&
            const DeepCollectionEquality()
                .equals(other._characteristic, _characteristic) &&
            (identical(other.copackagedIndicator, copackagedIndicator) ||
                other.copackagedIndicator == copackagedIndicator) &&
            (identical(other.copackagedIndicatorElement,
                    copackagedIndicatorElement) ||
                other.copackagedIndicatorElement ==
                    copackagedIndicatorElement) &&
            const DeepCollectionEquality()
                .equals(other._manufacturer, _manufacturer) &&
            (identical(other.package, package) || other.package == package));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_identifier),
        name,
        nameElement,
        type,
        const DeepCollectionEquality().hash(_packageFor),
        status,
        statusDate,
        statusDateElement,
        const DeepCollectionEquality().hash(_containedItemQuantity),
        description,
        descriptionElement,
        const DeepCollectionEquality().hash(_legalStatusOfSupply),
        const DeepCollectionEquality().hash(_marketingStatus),
        const DeepCollectionEquality().hash(_characteristic),
        copackagedIndicator,
        copackagedIndicatorElement,
        const DeepCollectionEquality().hash(_manufacturer),
        package
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PackagedProductDefinitionCopyWith<_$_PackagedProductDefinition>
      get copyWith => __$$_PackagedProductDefinitionCopyWithImpl<
          _$_PackagedProductDefinition>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PackagedProductDefinitionToJson(
      this,
    );
  }
}

abstract class _PackagedProductDefinition extends PackagedProductDefinition {
  factory _PackagedProductDefinition(
      {final R4ResourceType resourceType,
      final String? id,
      final Meta? meta,
      final FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') final Element? implicitRulesElement,
      final Code? language,
      @JsonKey(name: '_language') final Element? languageElement,
      final Narrative? text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      final String? name,
      @JsonKey(name: '_name') final Element? nameElement,
      final CodeableConcept? type,
      final List<Reference>? packageFor,
      final CodeableConcept? status,
      final FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate') final Element? statusDateElement,
      final List<Quantity>? containedItemQuantity,
      final Markdown? description,
      @JsonKey(name: '_description') final Element? descriptionElement,
      final List<PackagedProductDefinitionLegalStatusOfSupply>?
          legalStatusOfSupply,
      final List<MarketingStatus>? marketingStatus,
      final List<CodeableConcept>? characteristic,
      final Boolean? copackagedIndicator,
      @JsonKey(name: '_copackagedIndicator') final Element? copackagedIndicatorElement,
      final List<Reference>? manufacturer,
      final PackagedProductDefinitionPackage? package}) = _$_PackagedProductDefinition;
  _PackagedProductDefinition._() : super._();

  factory _PackagedProductDefinition.fromJson(Map<String, dynamic> json) =
      _$_PackagedProductDefinition.fromJson;

  @override
  R4ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  String? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.;
  Code? get language;
  @override

  /// [languageElement] (_language): Extensions for language;
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  List<Resource>? get contained;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] A unique identifier for this package as whole - not the the content of the package. Unique instance identifiers assigned to a package by manufacturers, regulators, drug catalogue custodians or other organizations.;
  List<Identifier>? get identifier;
  @override

  /// [name] A name for this package. Typically what it would be listed as in a drug formulary or catalogue, inventory etc.;
  String? get name;
  @override

  /// [nameElement] (_name): Extensions for name;
  @JsonKey(name: '_name')
  Element? get nameElement;
  @override

  /// [type] A high level category e.g. medicinal product, raw material, shipping/transport container, etc.;
  CodeableConcept? get type;
  @override

  /// [packageFor] The product this package model relates to, not the contents of the package (for which see package.containedItem).;
  List<Reference>? get packageFor;
  @override

  /// [status] The status within the lifecycle of this item. A high level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization or marketing status.;
  CodeableConcept? get status;
  @override

  /// [statusDate] The date at which the given status became applicable.;
  FhirDateTime? get statusDate;
  @override

  /// [statusDateElement] (_statusDate): Extensions for statusDate;
  @JsonKey(name: '_statusDate')
  Element? get statusDateElement;
  @override

  /// [containedItemQuantity] A total of the complete count of contained items of a particular type/form, independent of sub-packaging or organization. This can be considered as the pack size. This attribute differs from containedItem.amount in that it can give a single aggregated count of all tablet types in a pack, even when these are different manufactured items. For example a pill pack of 21 tablets plus 7 sugar tablets, can be denoted here as '28 tablets'. This attribute is repeatable so that the different item types in one pack type can be counted (e.g. a count of vials and count of syringes). Each repeat must have different units, so that it is clear what the different sets of counted items are, and it is not intended to allow different counts of similar items (e.g. not '2 tubes and 3 tubes'). Repeats are not to be used to represent different pack sizes (e.g. 20 pack vs. 50 pack) - which would be different instances of this resource.;
  List<Quantity>? get containedItemQuantity;
  @override

  /// [description] Textual description. Note that this is not the name of the package or product.;
  Markdown? get description;
  @override

  /// [descriptionElement] (_description): Extensions for description;
  @JsonKey(name: '_description')
  Element? get descriptionElement;
  @override

  /// [legalStatusOfSupply] The legal status of supply of the packaged item as classified by the regulator.;
  List<PackagedProductDefinitionLegalStatusOfSupply>? get legalStatusOfSupply;
  @override

  /// [marketingStatus] Allows specifying that an item is on the market for sale, or that it is not available, and the dates and locations associated.;
  List<MarketingStatus>? get marketingStatus;
  @override

  /// [characteristic] Allows the key features to be recorded, such as "hospital pack", "nurse prescribable", "calendar pack".;
  List<CodeableConcept>? get characteristic;
  @override

  /// [copackagedIndicator] Identifies if the package contains different items, such as when a drug product is supplied with another item e.g. a diluent or adjuvant.;
  Boolean? get copackagedIndicator;
  @override

  /// [copackagedIndicatorElement] (_copackagedIndicator): Extensions for copackagedIndicator;
  @JsonKey(name: '_copackagedIndicator')
  Element? get copackagedIndicatorElement;
  @override

  /// [manufacturer] Manufacturer of this package type. When there are multiple it means these are all possible manufacturers.;
  List<Reference>? get manufacturer;
  @override

  /// [package] A packaging item, as a container for medically related items, possibly with other packaging items within, or a packaging component, such as bottle cap (which is not a device or a medication manufactured item).;
  PackagedProductDefinitionPackage? get package;
  @override
  @JsonKey(ignore: true)
  _$$_PackagedProductDefinitionCopyWith<_$_PackagedProductDefinition>
      get copyWith => throw _privateConstructorUsedError;
}

PackagedProductDefinitionLegalStatusOfSupply
    _$PackagedProductDefinitionLegalStatusOfSupplyFromJson(
        Map<String, dynamic> json) {
  return _PackagedProductDefinitionLegalStatusOfSupply.fromJson(json);
}

/// @nodoc
mixin _$PackagedProductDefinitionLegalStatusOfSupply {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [code] The actual status of supply. Conveys in what situation this package type may be supplied for use.;
  CodeableConcept? get code => throw _privateConstructorUsedError;

  /// [jurisdiction] The place where the legal status of supply applies. When not specified, this indicates it is unknown in this context.;
  CodeableConcept? get jurisdiction => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PackagedProductDefinitionLegalStatusOfSupplyCopyWith<
          PackagedProductDefinitionLegalStatusOfSupply>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PackagedProductDefinitionLegalStatusOfSupplyCopyWith<$Res> {
  factory $PackagedProductDefinitionLegalStatusOfSupplyCopyWith(
          PackagedProductDefinitionLegalStatusOfSupply value,
          $Res Function(PackagedProductDefinitionLegalStatusOfSupply) then) =
      _$PackagedProductDefinitionLegalStatusOfSupplyCopyWithImpl<$Res,
          PackagedProductDefinitionLegalStatusOfSupply>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? code,
      CodeableConcept? jurisdiction});

  $CodeableConceptCopyWith<$Res>? get code;
  $CodeableConceptCopyWith<$Res>? get jurisdiction;
}

/// @nodoc
class _$PackagedProductDefinitionLegalStatusOfSupplyCopyWithImpl<$Res,
        $Val extends PackagedProductDefinitionLegalStatusOfSupply>
    implements $PackagedProductDefinitionLegalStatusOfSupplyCopyWith<$Res> {
  _$PackagedProductDefinitionLegalStatusOfSupplyCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = freezed,
    Object? jurisdiction = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      jurisdiction: freezed == jurisdiction
          ? _value.jurisdiction
          : jurisdiction // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get code {
    if (_value.code == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.code!, (value) {
      return _then(_value.copyWith(code: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get jurisdiction {
    if (_value.jurisdiction == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.jurisdiction!, (value) {
      return _then(_value.copyWith(jurisdiction: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_PackagedProductDefinitionLegalStatusOfSupplyCopyWith<$Res>
    implements $PackagedProductDefinitionLegalStatusOfSupplyCopyWith<$Res> {
  factory _$$_PackagedProductDefinitionLegalStatusOfSupplyCopyWith(
          _$_PackagedProductDefinitionLegalStatusOfSupply value,
          $Res Function(_$_PackagedProductDefinitionLegalStatusOfSupply) then) =
      __$$_PackagedProductDefinitionLegalStatusOfSupplyCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? code,
      CodeableConcept? jurisdiction});

  @override
  $CodeableConceptCopyWith<$Res>? get code;
  @override
  $CodeableConceptCopyWith<$Res>? get jurisdiction;
}

/// @nodoc
class __$$_PackagedProductDefinitionLegalStatusOfSupplyCopyWithImpl<$Res>
    extends _$PackagedProductDefinitionLegalStatusOfSupplyCopyWithImpl<$Res,
        _$_PackagedProductDefinitionLegalStatusOfSupply>
    implements _$$_PackagedProductDefinitionLegalStatusOfSupplyCopyWith<$Res> {
  __$$_PackagedProductDefinitionLegalStatusOfSupplyCopyWithImpl(
      _$_PackagedProductDefinitionLegalStatusOfSupply _value,
      $Res Function(_$_PackagedProductDefinitionLegalStatusOfSupply) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = freezed,
    Object? jurisdiction = freezed,
  }) {
    return _then(_$_PackagedProductDefinitionLegalStatusOfSupply(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      jurisdiction: freezed == jurisdiction
          ? _value.jurisdiction
          : jurisdiction // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PackagedProductDefinitionLegalStatusOfSupply
    extends _PackagedProductDefinitionLegalStatusOfSupply {
  _$_PackagedProductDefinitionLegalStatusOfSupply(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.code,
      this.jurisdiction})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_PackagedProductDefinitionLegalStatusOfSupply.fromJson(
          Map<String, dynamic> json) =>
      _$$_PackagedProductDefinitionLegalStatusOfSupplyFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [code] The actual status of supply. Conveys in what situation this package type may be supplied for use.;
  @override
  final CodeableConcept? code;

  /// [jurisdiction] The place where the legal status of supply applies. When not specified, this indicates it is unknown in this context.;
  @override
  final CodeableConcept? jurisdiction;

  @override
  String toString() {
    return 'PackagedProductDefinitionLegalStatusOfSupply(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, jurisdiction: $jurisdiction)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PackagedProductDefinitionLegalStatusOfSupply &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.jurisdiction, jurisdiction) ||
                other.jurisdiction == jurisdiction));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      code,
      jurisdiction);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PackagedProductDefinitionLegalStatusOfSupplyCopyWith<
          _$_PackagedProductDefinitionLegalStatusOfSupply>
      get copyWith =>
          __$$_PackagedProductDefinitionLegalStatusOfSupplyCopyWithImpl<
                  _$_PackagedProductDefinitionLegalStatusOfSupply>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PackagedProductDefinitionLegalStatusOfSupplyToJson(
      this,
    );
  }
}

abstract class _PackagedProductDefinitionLegalStatusOfSupply
    extends PackagedProductDefinitionLegalStatusOfSupply {
  factory _PackagedProductDefinitionLegalStatusOfSupply(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableConcept? code,
          final CodeableConcept? jurisdiction}) =
      _$_PackagedProductDefinitionLegalStatusOfSupply;
  _PackagedProductDefinitionLegalStatusOfSupply._() : super._();

  factory _PackagedProductDefinitionLegalStatusOfSupply.fromJson(
          Map<String, dynamic> json) =
      _$_PackagedProductDefinitionLegalStatusOfSupply.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [code] The actual status of supply. Conveys in what situation this package type may be supplied for use.;
  CodeableConcept? get code;
  @override

  /// [jurisdiction] The place where the legal status of supply applies. When not specified, this indicates it is unknown in this context.;
  CodeableConcept? get jurisdiction;
  @override
  @JsonKey(ignore: true)
  _$$_PackagedProductDefinitionLegalStatusOfSupplyCopyWith<
          _$_PackagedProductDefinitionLegalStatusOfSupply>
      get copyWith => throw _privateConstructorUsedError;
}

PackagedProductDefinitionPackage _$PackagedProductDefinitionPackageFromJson(
    Map<String, dynamic> json) {
  return _PackagedProductDefinitionPackage.fromJson(json);
}

/// @nodoc
mixin _$PackagedProductDefinitionPackage {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] A business identifier that is specific to this particular part of the packaging, often assigned by the manufacturer. Including possibly Data Carrier Identifier (a GS1 barcode).;
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [type] The physical type of the container of the items.;
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [quantity] The quantity of packaging items contained at this layer of the package. This does not relate to the number of contained items but relates solely to the number of packaging items. When looking at the outermost layer it is always 1. If there are two boxes within, at the next layer it would be 2.;
  Integer? get quantity => throw _privateConstructorUsedError;

  /// [quantityElement] (_quantity): Extensions for quantity;
  @JsonKey(name: '_quantity')
  Element? get quantityElement => throw _privateConstructorUsedError;

  /// [material] Material type of the package item.;
  List<CodeableConcept>? get material => throw _privateConstructorUsedError;

  /// [alternateMaterial] A possible alternate material for this part of the packaging, that is allowed to be used instead of the usual material (e.g. different types of plastic for a blister sleeve).;
  List<CodeableConcept>? get alternateMaterial =>
      throw _privateConstructorUsedError;

  /// [shelfLifeStorage] Shelf Life and storage information.;
  List<PackagedProductDefinitionShelfLifeStorage>? get shelfLifeStorage =>
      throw _privateConstructorUsedError;

  /// [manufacturer] Manufacturer of this packaging item. When there are multiple values each one is a potential manufacturer of this packaging item.;
  List<Reference>? get manufacturer => throw _privateConstructorUsedError;

  /// [property] General characteristics of this item.;
  List<PackagedProductDefinitionProperty>? get property =>
      throw _privateConstructorUsedError;

  /// [containedItem] The item(s) within the packaging.;
  List<PackagedProductDefinitionContainedItem>? get containedItem =>
      throw _privateConstructorUsedError;

  /// [package] Allows containers (and parts of containers) parwithin containers, still a single packaged product.  See also PackagedProductDefinition.package.containedItem.item(PackagedProductDefinition).;
  List<PackagedProductDefinitionPackage>? get package =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PackagedProductDefinitionPackageCopyWith<PackagedProductDefinitionPackage>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PackagedProductDefinitionPackageCopyWith<$Res> {
  factory $PackagedProductDefinitionPackageCopyWith(
          PackagedProductDefinitionPackage value,
          $Res Function(PackagedProductDefinitionPackage) then) =
      _$PackagedProductDefinitionPackageCopyWithImpl<$Res,
          PackagedProductDefinitionPackage>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      CodeableConcept? type,
      Integer? quantity,
      @JsonKey(name: '_quantity') Element? quantityElement,
      List<CodeableConcept>? material,
      List<CodeableConcept>? alternateMaterial,
      List<PackagedProductDefinitionShelfLifeStorage>? shelfLifeStorage,
      List<Reference>? manufacturer,
      List<PackagedProductDefinitionProperty>? property,
      List<PackagedProductDefinitionContainedItem>? containedItem,
      List<PackagedProductDefinitionPackage>? package});

  $CodeableConceptCopyWith<$Res>? get type;
  $ElementCopyWith<$Res>? get quantityElement;
}

/// @nodoc
class _$PackagedProductDefinitionPackageCopyWithImpl<$Res,
        $Val extends PackagedProductDefinitionPackage>
    implements $PackagedProductDefinitionPackageCopyWith<$Res> {
  _$PackagedProductDefinitionPackageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = freezed,
    Object? quantity = freezed,
    Object? quantityElement = freezed,
    Object? material = freezed,
    Object? alternateMaterial = freezed,
    Object? shelfLifeStorage = freezed,
    Object? manufacturer = freezed,
    Object? property = freezed,
    Object? containedItem = freezed,
    Object? package = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Integer?,
      quantityElement: freezed == quantityElement
          ? _value.quantityElement
          : quantityElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      material: freezed == material
          ? _value.material
          : material // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      alternateMaterial: freezed == alternateMaterial
          ? _value.alternateMaterial
          : alternateMaterial // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      shelfLifeStorage: freezed == shelfLifeStorage
          ? _value.shelfLifeStorage
          : shelfLifeStorage // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionShelfLifeStorage>?,
      manufacturer: freezed == manufacturer
          ? _value.manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      property: freezed == property
          ? _value.property
          : property // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionProperty>?,
      containedItem: freezed == containedItem
          ? _value.containedItem
          : containedItem // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionContainedItem>?,
      package: freezed == package
          ? _value.package
          : package // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionPackage>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get quantityElement {
    if (_value.quantityElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.quantityElement!, (value) {
      return _then(_value.copyWith(quantityElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_PackagedProductDefinitionPackageCopyWith<$Res>
    implements $PackagedProductDefinitionPackageCopyWith<$Res> {
  factory _$$_PackagedProductDefinitionPackageCopyWith(
          _$_PackagedProductDefinitionPackage value,
          $Res Function(_$_PackagedProductDefinitionPackage) then) =
      __$$_PackagedProductDefinitionPackageCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      CodeableConcept? type,
      Integer? quantity,
      @JsonKey(name: '_quantity') Element? quantityElement,
      List<CodeableConcept>? material,
      List<CodeableConcept>? alternateMaterial,
      List<PackagedProductDefinitionShelfLifeStorage>? shelfLifeStorage,
      List<Reference>? manufacturer,
      List<PackagedProductDefinitionProperty>? property,
      List<PackagedProductDefinitionContainedItem>? containedItem,
      List<PackagedProductDefinitionPackage>? package});

  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $ElementCopyWith<$Res>? get quantityElement;
}

/// @nodoc
class __$$_PackagedProductDefinitionPackageCopyWithImpl<$Res>
    extends _$PackagedProductDefinitionPackageCopyWithImpl<$Res,
        _$_PackagedProductDefinitionPackage>
    implements _$$_PackagedProductDefinitionPackageCopyWith<$Res> {
  __$$_PackagedProductDefinitionPackageCopyWithImpl(
      _$_PackagedProductDefinitionPackage _value,
      $Res Function(_$_PackagedProductDefinitionPackage) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = freezed,
    Object? quantity = freezed,
    Object? quantityElement = freezed,
    Object? material = freezed,
    Object? alternateMaterial = freezed,
    Object? shelfLifeStorage = freezed,
    Object? manufacturer = freezed,
    Object? property = freezed,
    Object? containedItem = freezed,
    Object? package = freezed,
  }) {
    return _then(_$_PackagedProductDefinitionPackage(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Integer?,
      quantityElement: freezed == quantityElement
          ? _value.quantityElement
          : quantityElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      material: freezed == material
          ? _value._material
          : material // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      alternateMaterial: freezed == alternateMaterial
          ? _value._alternateMaterial
          : alternateMaterial // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      shelfLifeStorage: freezed == shelfLifeStorage
          ? _value._shelfLifeStorage
          : shelfLifeStorage // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionShelfLifeStorage>?,
      manufacturer: freezed == manufacturer
          ? _value._manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      property: freezed == property
          ? _value._property
          : property // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionProperty>?,
      containedItem: freezed == containedItem
          ? _value._containedItem
          : containedItem // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionContainedItem>?,
      package: freezed == package
          ? _value._package
          : package // ignore: cast_nullable_to_non_nullable
              as List<PackagedProductDefinitionPackage>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PackagedProductDefinitionPackage
    extends _PackagedProductDefinitionPackage {
  _$_PackagedProductDefinitionPackage(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      this.type,
      this.quantity,
      @JsonKey(name: '_quantity') this.quantityElement,
      final List<CodeableConcept>? material,
      final List<CodeableConcept>? alternateMaterial,
      final List<PackagedProductDefinitionShelfLifeStorage>? shelfLifeStorage,
      final List<Reference>? manufacturer,
      final List<PackagedProductDefinitionProperty>? property,
      final List<PackagedProductDefinitionContainedItem>? containedItem,
      final List<PackagedProductDefinitionPackage>? package})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _material = material,
        _alternateMaterial = alternateMaterial,
        _shelfLifeStorage = shelfLifeStorage,
        _manufacturer = manufacturer,
        _property = property,
        _containedItem = containedItem,
        _package = package,
        super._();

  factory _$_PackagedProductDefinitionPackage.fromJson(
          Map<String, dynamic> json) =>
      _$$_PackagedProductDefinitionPackageFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] A business identifier that is specific to this particular part of the packaging, often assigned by the manufacturer. Including possibly Data Carrier Identifier (a GS1 barcode).;
  final List<Identifier>? _identifier;

  /// [identifier] A business identifier that is specific to this particular part of the packaging, often assigned by the manufacturer. Including possibly Data Carrier Identifier (a GS1 barcode).;
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] The physical type of the container of the items.;
  @override
  final CodeableConcept? type;

  /// [quantity] The quantity of packaging items contained at this layer of the package. This does not relate to the number of contained items but relates solely to the number of packaging items. When looking at the outermost layer it is always 1. If there are two boxes within, at the next layer it would be 2.;
  @override
  final Integer? quantity;

  /// [quantityElement] (_quantity): Extensions for quantity;
  @override
  @JsonKey(name: '_quantity')
  final Element? quantityElement;

  /// [material] Material type of the package item.;
  final List<CodeableConcept>? _material;

  /// [material] Material type of the package item.;
  @override
  List<CodeableConcept>? get material {
    final value = _material;
    if (value == null) return null;
    if (_material is EqualUnmodifiableListView) return _material;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [alternateMaterial] A possible alternate material for this part of the packaging, that is allowed to be used instead of the usual material (e.g. different types of plastic for a blister sleeve).;
  final List<CodeableConcept>? _alternateMaterial;

  /// [alternateMaterial] A possible alternate material for this part of the packaging, that is allowed to be used instead of the usual material (e.g. different types of plastic for a blister sleeve).;
  @override
  List<CodeableConcept>? get alternateMaterial {
    final value = _alternateMaterial;
    if (value == null) return null;
    if (_alternateMaterial is EqualUnmodifiableListView)
      return _alternateMaterial;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [shelfLifeStorage] Shelf Life and storage information.;
  final List<PackagedProductDefinitionShelfLifeStorage>? _shelfLifeStorage;

  /// [shelfLifeStorage] Shelf Life and storage information.;
  @override
  List<PackagedProductDefinitionShelfLifeStorage>? get shelfLifeStorage {
    final value = _shelfLifeStorage;
    if (value == null) return null;
    if (_shelfLifeStorage is EqualUnmodifiableListView)
      return _shelfLifeStorage;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [manufacturer] Manufacturer of this packaging item. When there are multiple values each one is a potential manufacturer of this packaging item.;
  final List<Reference>? _manufacturer;

  /// [manufacturer] Manufacturer of this packaging item. When there are multiple values each one is a potential manufacturer of this packaging item.;
  @override
  List<Reference>? get manufacturer {
    final value = _manufacturer;
    if (value == null) return null;
    if (_manufacturer is EqualUnmodifiableListView) return _manufacturer;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [property] General characteristics of this item.;
  final List<PackagedProductDefinitionProperty>? _property;

  /// [property] General characteristics of this item.;
  @override
  List<PackagedProductDefinitionProperty>? get property {
    final value = _property;
    if (value == null) return null;
    if (_property is EqualUnmodifiableListView) return _property;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [containedItem] The item(s) within the packaging.;
  final List<PackagedProductDefinitionContainedItem>? _containedItem;

  /// [containedItem] The item(s) within the packaging.;
  @override
  List<PackagedProductDefinitionContainedItem>? get containedItem {
    final value = _containedItem;
    if (value == null) return null;
    if (_containedItem is EqualUnmodifiableListView) return _containedItem;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [package] Allows containers (and parts of containers) parwithin containers, still a single packaged product.  See also PackagedProductDefinition.package.containedItem.item(PackagedProductDefinition).;
  final List<PackagedProductDefinitionPackage>? _package;

  /// [package] Allows containers (and parts of containers) parwithin containers, still a single packaged product.  See also PackagedProductDefinition.package.containedItem.item(PackagedProductDefinition).;
  @override
  List<PackagedProductDefinitionPackage>? get package {
    final value = _package;
    if (value == null) return null;
    if (_package is EqualUnmodifiableListView) return _package;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'PackagedProductDefinitionPackage(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, type: $type, quantity: $quantity, quantityElement: $quantityElement, material: $material, alternateMaterial: $alternateMaterial, shelfLifeStorage: $shelfLifeStorage, manufacturer: $manufacturer, property: $property, containedItem: $containedItem, package: $package)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PackagedProductDefinitionPackage &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            (identical(other.quantityElement, quantityElement) ||
                other.quantityElement == quantityElement) &&
            const DeepCollectionEquality().equals(other._material, _material) &&
            const DeepCollectionEquality()
                .equals(other._alternateMaterial, _alternateMaterial) &&
            const DeepCollectionEquality()
                .equals(other._shelfLifeStorage, _shelfLifeStorage) &&
            const DeepCollectionEquality()
                .equals(other._manufacturer, _manufacturer) &&
            const DeepCollectionEquality().equals(other._property, _property) &&
            const DeepCollectionEquality()
                .equals(other._containedItem, _containedItem) &&
            const DeepCollectionEquality().equals(other._package, _package));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      const DeepCollectionEquality().hash(_identifier),
      type,
      quantity,
      quantityElement,
      const DeepCollectionEquality().hash(_material),
      const DeepCollectionEquality().hash(_alternateMaterial),
      const DeepCollectionEquality().hash(_shelfLifeStorage),
      const DeepCollectionEquality().hash(_manufacturer),
      const DeepCollectionEquality().hash(_property),
      const DeepCollectionEquality().hash(_containedItem),
      const DeepCollectionEquality().hash(_package));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PackagedProductDefinitionPackageCopyWith<
          _$_PackagedProductDefinitionPackage>
      get copyWith => __$$_PackagedProductDefinitionPackageCopyWithImpl<
          _$_PackagedProductDefinitionPackage>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PackagedProductDefinitionPackageToJson(
      this,
    );
  }
}

abstract class _PackagedProductDefinitionPackage
    extends PackagedProductDefinitionPackage {
  factory _PackagedProductDefinitionPackage(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      final CodeableConcept? type,
      final Integer? quantity,
      @JsonKey(name: '_quantity') final Element? quantityElement,
      final List<CodeableConcept>? material,
      final List<CodeableConcept>? alternateMaterial,
      final List<PackagedProductDefinitionShelfLifeStorage>? shelfLifeStorage,
      final List<Reference>? manufacturer,
      final List<PackagedProductDefinitionProperty>? property,
      final List<PackagedProductDefinitionContainedItem>? containedItem,
      final List<PackagedProductDefinitionPackage>?
          package}) = _$_PackagedProductDefinitionPackage;
  _PackagedProductDefinitionPackage._() : super._();

  factory _PackagedProductDefinitionPackage.fromJson(
      Map<String, dynamic> json) = _$_PackagedProductDefinitionPackage.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] A business identifier that is specific to this particular part of the packaging, often assigned by the manufacturer. Including possibly Data Carrier Identifier (a GS1 barcode).;
  List<Identifier>? get identifier;
  @override

  /// [type] The physical type of the container of the items.;
  CodeableConcept? get type;
  @override

  /// [quantity] The quantity of packaging items contained at this layer of the package. This does not relate to the number of contained items but relates solely to the number of packaging items. When looking at the outermost layer it is always 1. If there are two boxes within, at the next layer it would be 2.;
  Integer? get quantity;
  @override

  /// [quantityElement] (_quantity): Extensions for quantity;
  @JsonKey(name: '_quantity')
  Element? get quantityElement;
  @override

  /// [material] Material type of the package item.;
  List<CodeableConcept>? get material;
  @override

  /// [alternateMaterial] A possible alternate material for this part of the packaging, that is allowed to be used instead of the usual material (e.g. different types of plastic for a blister sleeve).;
  List<CodeableConcept>? get alternateMaterial;
  @override

  /// [shelfLifeStorage] Shelf Life and storage information.;
  List<PackagedProductDefinitionShelfLifeStorage>? get shelfLifeStorage;
  @override

  /// [manufacturer] Manufacturer of this packaging item. When there are multiple values each one is a potential manufacturer of this packaging item.;
  List<Reference>? get manufacturer;
  @override

  /// [property] General characteristics of this item.;
  List<PackagedProductDefinitionProperty>? get property;
  @override

  /// [containedItem] The item(s) within the packaging.;
  List<PackagedProductDefinitionContainedItem>? get containedItem;
  @override

  /// [package] Allows containers (and parts of containers) parwithin containers, still a single packaged product.  See also PackagedProductDefinition.package.containedItem.item(PackagedProductDefinition).;
  List<PackagedProductDefinitionPackage>? get package;
  @override
  @JsonKey(ignore: true)
  _$$_PackagedProductDefinitionPackageCopyWith<
          _$_PackagedProductDefinitionPackage>
      get copyWith => throw _privateConstructorUsedError;
}

PackagedProductDefinitionShelfLifeStorage
    _$PackagedProductDefinitionShelfLifeStorageFromJson(
        Map<String, dynamic> json) {
  return _PackagedProductDefinitionShelfLifeStorage.fromJson(json);
}

/// @nodoc
mixin _$PackagedProductDefinitionShelfLifeStorage {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not
  /// part of the basic definition of the element. To make the use of extensions
  /// safe and manageable, there is a strict set of governance  applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of the
  ///  definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies the
  /// understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of the
  /// definition of the extension. Applications processing a resource are
  ///  required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on
  /// Resource or DomainResource (including cannot change the meaning of
  ///  modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] Unique identifier for the packaged Medicinal Product.
  Identifier? get identifier => throw _privateConstructorUsedError;

  /// [type] This describes the shelf life, taking into account various
  /// scenarios such as shelf life of the packaged Medicinal Product itself,
  /// shelf life after transformation where necessary and shelf life after the
  /// first opening of a bottle, etc. The shelf life type shall be specified
  /// using an appropriate controlled vocabulary The controlled term and the
  ///  controlled term identifier shall be specified.
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [periodDuration] The shelf life time period can be specified using a
  /// numerical value for the period of time and its unit of time measurement
  /// The unit of measurement shall be specified in accordance with ISO 11240
  /// and the resulting terminology The symbol and the symbol identifier shall
  /// be used.
  FhirDuration? get periodDuration => throw _privateConstructorUsedError;

  /// [periodString] The shelf life time period can be specified using a
  /// numerical value for the period of time and its unit of time measurement
  /// The unit of measurement shall be specified in accordance with ISO 11240
  /// and the resulting terminology The symbol and the symbol identifier shall
  /// be used.
  String? get periodString => throw _privateConstructorUsedError;

  /// [periodStringElement] (_periodString) Extensions for periodString
  @JsonKey(name: '_periodString')
  Element? get periodStringElement => throw _privateConstructorUsedError;

  /// [specialPrecautionsForStorage] Special precautions for storage, if any,
  /// can be specified using an appropriate controlled vocabulary The controlled
  ///  term and the controlled term identifier shall be specified.
  List<CodeableConcept>? get specialPrecautionsForStorage =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PackagedProductDefinitionShelfLifeStorageCopyWith<
          PackagedProductDefinitionShelfLifeStorage>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PackagedProductDefinitionShelfLifeStorageCopyWith<$Res> {
  factory $PackagedProductDefinitionShelfLifeStorageCopyWith(
          PackagedProductDefinitionShelfLifeStorage value,
          $Res Function(PackagedProductDefinitionShelfLifeStorage) then) =
      _$PackagedProductDefinitionShelfLifeStorageCopyWithImpl<$Res,
          PackagedProductDefinitionShelfLifeStorage>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Identifier? identifier,
      CodeableConcept type,
      FhirDuration? periodDuration,
      String? periodString,
      @JsonKey(name: '_periodString') Element? periodStringElement,
      List<CodeableConcept>? specialPrecautionsForStorage});

  $IdentifierCopyWith<$Res>? get identifier;
  $CodeableConceptCopyWith<$Res> get type;
  $FhirDurationCopyWith<$Res>? get periodDuration;
  $ElementCopyWith<$Res>? get periodStringElement;
}

/// @nodoc
class _$PackagedProductDefinitionShelfLifeStorageCopyWithImpl<$Res,
        $Val extends PackagedProductDefinitionShelfLifeStorage>
    implements $PackagedProductDefinitionShelfLifeStorageCopyWith<$Res> {
  _$PackagedProductDefinitionShelfLifeStorageCopyWithImpl(
      this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = null,
    Object? periodDuration = freezed,
    Object? periodString = freezed,
    Object? periodStringElement = freezed,
    Object? specialPrecautionsForStorage = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      periodDuration: freezed == periodDuration
          ? _value.periodDuration
          : periodDuration // ignore: cast_nullable_to_non_nullable
              as FhirDuration?,
      periodString: freezed == periodString
          ? _value.periodString
          : periodString // ignore: cast_nullable_to_non_nullable
              as String?,
      periodStringElement: freezed == periodStringElement
          ? _value.periodStringElement
          : periodStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      specialPrecautionsForStorage: freezed == specialPrecautionsForStorage
          ? _value.specialPrecautionsForStorage
          : specialPrecautionsForStorage // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get identifier {
    if (_value.identifier == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.identifier!, (value) {
      return _then(_value.copyWith(identifier: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FhirDurationCopyWith<$Res>? get periodDuration {
    if (_value.periodDuration == null) {
      return null;
    }

    return $FhirDurationCopyWith<$Res>(_value.periodDuration!, (value) {
      return _then(_value.copyWith(periodDuration: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get periodStringElement {
    if (_value.periodStringElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.periodStringElement!, (value) {
      return _then(_value.copyWith(periodStringElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_PackagedProductDefinitionShelfLifeStorageCopyWith<$Res>
    implements $PackagedProductDefinitionShelfLifeStorageCopyWith<$Res> {
  factory _$$_PackagedProductDefinitionShelfLifeStorageCopyWith(
          _$_PackagedProductDefinitionShelfLifeStorage value,
          $Res Function(_$_PackagedProductDefinitionShelfLifeStorage) then) =
      __$$_PackagedProductDefinitionShelfLifeStorageCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Identifier? identifier,
      CodeableConcept type,
      FhirDuration? periodDuration,
      String? periodString,
      @JsonKey(name: '_periodString') Element? periodStringElement,
      List<CodeableConcept>? specialPrecautionsForStorage});

  @override
  $IdentifierCopyWith<$Res>? get identifier;
  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $FhirDurationCopyWith<$Res>? get periodDuration;
  @override
  $ElementCopyWith<$Res>? get periodStringElement;
}

/// @nodoc
class __$$_PackagedProductDefinitionShelfLifeStorageCopyWithImpl<$Res>
    extends _$PackagedProductDefinitionShelfLifeStorageCopyWithImpl<$Res,
        _$_PackagedProductDefinitionShelfLifeStorage>
    implements _$$_PackagedProductDefinitionShelfLifeStorageCopyWith<$Res> {
  __$$_PackagedProductDefinitionShelfLifeStorageCopyWithImpl(
      _$_PackagedProductDefinitionShelfLifeStorage _value,
      $Res Function(_$_PackagedProductDefinitionShelfLifeStorage) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = null,
    Object? periodDuration = freezed,
    Object? periodString = freezed,
    Object? periodStringElement = freezed,
    Object? specialPrecautionsForStorage = freezed,
  }) {
    return _then(_$_PackagedProductDefinitionShelfLifeStorage(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      periodDuration: freezed == periodDuration
          ? _value.periodDuration
          : periodDuration // ignore: cast_nullable_to_non_nullable
              as FhirDuration?,
      periodString: freezed == periodString
          ? _value.periodString
          : periodString // ignore: cast_nullable_to_non_nullable
              as String?,
      periodStringElement: freezed == periodStringElement
          ? _value.periodStringElement
          : periodStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      specialPrecautionsForStorage: freezed == specialPrecautionsForStorage
          ? _value._specialPrecautionsForStorage
          : specialPrecautionsForStorage // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PackagedProductDefinitionShelfLifeStorage
    extends _PackagedProductDefinitionShelfLifeStorage {
  _$_PackagedProductDefinitionShelfLifeStorage(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.identifier,
      required this.type,
      this.periodDuration,
      this.periodString,
      @JsonKey(name: '_periodString') this.periodStringElement,
      final List<CodeableConcept>? specialPrecautionsForStorage})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _specialPrecautionsForStorage = specialPrecautionsForStorage,
        super._();

  factory _$_PackagedProductDefinitionShelfLifeStorage.fromJson(
          Map<String, dynamic> json) =>
      _$$_PackagedProductDefinitionShelfLifeStorageFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not
  /// part of the basic definition of the element. To make the use of extensions
  /// safe and manageable, there is a strict set of governance  applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of the
  ///  definition of the extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not
  /// part of the basic definition of the element. To make the use of extensions
  /// safe and manageable, there is a strict set of governance  applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of the
  ///  definition of the extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies the
  /// understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of the
  /// definition of the extension. Applications processing a resource are
  ///  required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on
  /// Resource or DomainResource (including cannot change the meaning of
  ///  modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies the
  /// understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of the
  /// definition of the extension. Applications processing a resource are
  ///  required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on
  /// Resource or DomainResource (including cannot change the meaning of
  ///  modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] Unique identifier for the packaged Medicinal Product.
  @override
  final Identifier? identifier;

  /// [type] This describes the shelf life, taking into account various
  /// scenarios such as shelf life of the packaged Medicinal Product itself,
  /// shelf life after transformation where necessary and shelf life after the
  /// first opening of a bottle, etc. The shelf life type shall be specified
  /// using an appropriate controlled vocabulary The controlled term and the
  ///  controlled term identifier shall be specified.
  @override
  final CodeableConcept type;

  /// [periodDuration] The shelf life time period can be specified using a
  /// numerical value for the period of time and its unit of time measurement
  /// The unit of measurement shall be specified in accordance with ISO 11240
  /// and the resulting terminology The symbol and the symbol identifier shall
  /// be used.
  @override
  final FhirDuration? periodDuration;

  /// [periodString] The shelf life time period can be specified using a
  /// numerical value for the period of time and its unit of time measurement
  /// The unit of measurement shall be specified in accordance with ISO 11240
  /// and the resulting terminology The symbol and the symbol identifier shall
  /// be used.
  @override
  final String? periodString;

  /// [periodStringElement] (_periodString) Extensions for periodString
  @override
  @JsonKey(name: '_periodString')
  final Element? periodStringElement;

  /// [specialPrecautionsForStorage] Special precautions for storage, if any,
  /// can be specified using an appropriate controlled vocabulary The controlled
  ///  term and the controlled term identifier shall be specified.
  final List<CodeableConcept>? _specialPrecautionsForStorage;

  /// [specialPrecautionsForStorage] Special precautions for storage, if any,
  /// can be specified using an appropriate controlled vocabulary The controlled
  ///  term and the controlled term identifier shall be specified.
  @override
  List<CodeableConcept>? get specialPrecautionsForStorage {
    final value = _specialPrecautionsForStorage;
    if (value == null) return null;
    if (_specialPrecautionsForStorage is EqualUnmodifiableListView)
      return _specialPrecautionsForStorage;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'PackagedProductDefinitionShelfLifeStorage(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, type: $type, periodDuration: $periodDuration, periodString: $periodString, periodStringElement: $periodStringElement, specialPrecautionsForStorage: $specialPrecautionsForStorage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PackagedProductDefinitionShelfLifeStorage &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.periodDuration, periodDuration) ||
                other.periodDuration == periodDuration) &&
            (identical(other.periodString, periodString) ||
                other.periodString == periodString) &&
            (identical(other.periodStringElement, periodStringElement) ||
                other.periodStringElement == periodStringElement) &&
            const DeepCollectionEquality().equals(
                other._specialPrecautionsForStorage,
                _specialPrecautionsForStorage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      identifier,
      type,
      periodDuration,
      periodString,
      periodStringElement,
      const DeepCollectionEquality().hash(_specialPrecautionsForStorage));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PackagedProductDefinitionShelfLifeStorageCopyWith<
          _$_PackagedProductDefinitionShelfLifeStorage>
      get copyWith =>
          __$$_PackagedProductDefinitionShelfLifeStorageCopyWithImpl<
              _$_PackagedProductDefinitionShelfLifeStorage>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PackagedProductDefinitionShelfLifeStorageToJson(
      this,
    );
  }
}

abstract class _PackagedProductDefinitionShelfLifeStorage
    extends PackagedProductDefinitionShelfLifeStorage {
  factory _PackagedProductDefinitionShelfLifeStorage(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final Identifier? identifier,
          required final CodeableConcept type,
          final FhirDuration? periodDuration,
          final String? periodString,
          @JsonKey(name: '_periodString') final Element? periodStringElement,
          final List<CodeableConcept>? specialPrecautionsForStorage}) =
      _$_PackagedProductDefinitionShelfLifeStorage;
  _PackagedProductDefinitionShelfLifeStorage._() : super._();

  factory _PackagedProductDefinitionShelfLifeStorage.fromJson(
          Map<String, dynamic> json) =
      _$_PackagedProductDefinitionShelfLifeStorage.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not
  /// part of the basic definition of the element. To make the use of extensions
  /// safe and manageable, there is a strict set of governance  applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of the
  ///  definition of the extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that
  /// is not part of the basic definition of the element and that modifies the
  /// understanding of the element in which it is contained and/or the
  /// understanding of the containing element's descendants. Usually modifier
  /// elements provide negation or qualification. To make the use of extensions
  /// safe and manageable, there is a strict set of governance applied to the
  /// definition and use of extensions. Though any implementer can define an
  /// extension, there is a set of requirements that SHALL be met as part of the
  /// definition of the extension. Applications processing a resource are
  ///  required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on
  /// Resource or DomainResource (including cannot change the meaning of
  ///  modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] Unique identifier for the packaged Medicinal Product.
  Identifier? get identifier;
  @override

  /// [type] This describes the shelf life, taking into account various
  /// scenarios such as shelf life of the packaged Medicinal Product itself,
  /// shelf life after transformation where necessary and shelf life after the
  /// first opening of a bottle, etc. The shelf life type shall be specified
  /// using an appropriate controlled vocabulary The controlled term and the
  ///  controlled term identifier shall be specified.
  CodeableConcept get type;
  @override

  /// [periodDuration] The shelf life time period can be specified using a
  /// numerical value for the period of time and its unit of time measurement
  /// The unit of measurement shall be specified in accordance with ISO 11240
  /// and the resulting terminology The symbol and the symbol identifier shall
  /// be used.
  FhirDuration? get periodDuration;
  @override

  /// [periodString] The shelf life time period can be specified using a
  /// numerical value for the period of time and its unit of time measurement
  /// The unit of measurement shall be specified in accordance with ISO 11240
  /// and the resulting terminology The symbol and the symbol identifier shall
  /// be used.
  String? get periodString;
  @override

  /// [periodStringElement] (_periodString) Extensions for periodString
  @JsonKey(name: '_periodString')
  Element? get periodStringElement;
  @override

  /// [specialPrecautionsForStorage] Special precautions for storage, if any,
  /// can be specified using an appropriate controlled vocabulary The controlled
  ///  term and the controlled term identifier shall be specified.
  List<CodeableConcept>? get specialPrecautionsForStorage;
  @override
  @JsonKey(ignore: true)
  _$$_PackagedProductDefinitionShelfLifeStorageCopyWith<
          _$_PackagedProductDefinitionShelfLifeStorage>
      get copyWith => throw _privateConstructorUsedError;
}

PackagedProductDefinitionProperty _$PackagedProductDefinitionPropertyFromJson(
    Map<String, dynamic> json) {
  return _PackagedProductDefinitionProperty.fromJson(json);
}

/// @nodoc
mixin _$PackagedProductDefinitionProperty {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] A code expressing the type of characteristic.;
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [valueCodeableConcept] A value for the characteristic.;
  CodeableConcept? get valueCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [valueQuantity] A value for the characteristic.;
  Quantity? get valueQuantity => throw _privateConstructorUsedError;

  /// [valueDate] A value for the characteristic.;
  Date? get valueDate => throw _privateConstructorUsedError;

  /// [valueDateElement] (_valueDate): Extensions for valueDate;
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement => throw _privateConstructorUsedError;

  /// [valueBoolean] A value for the characteristic.;
  Boolean? get valueBoolean => throw _privateConstructorUsedError;

  /// [valueBooleanElement] (_valueBoolean): Extensions for valueBoolean;
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement => throw _privateConstructorUsedError;

  /// [valueAttachment] A value for the characteristic.;
  Attachment? get valueAttachment => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PackagedProductDefinitionPropertyCopyWith<PackagedProductDefinitionProperty>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PackagedProductDefinitionPropertyCopyWith<$Res> {
  factory $PackagedProductDefinitionPropertyCopyWith(
          PackagedProductDefinitionProperty value,
          $Res Function(PackagedProductDefinitionProperty) then) =
      _$PackagedProductDefinitionPropertyCopyWithImpl<$Res,
          PackagedProductDefinitionProperty>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      Quantity? valueQuantity,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment});

  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  $QuantityCopyWith<$Res>? get valueQuantity;
  $ElementCopyWith<$Res>? get valueDateElement;
  $ElementCopyWith<$Res>? get valueBooleanElement;
  $AttachmentCopyWith<$Res>? get valueAttachment;
}

/// @nodoc
class _$PackagedProductDefinitionPropertyCopyWithImpl<$Res,
        $Val extends PackagedProductDefinitionProperty>
    implements $PackagedProductDefinitionPropertyCopyWith<$Res> {
  _$PackagedProductDefinitionPropertyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueQuantity = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept {
    if (_value.valueCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.valueCodeableConcept!,
        (value) {
      return _then(_value.copyWith(valueCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get valueQuantity {
    if (_value.valueQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.valueQuantity!, (value) {
      return _then(_value.copyWith(valueQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueDateElement {
    if (_value.valueDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueDateElement!, (value) {
      return _then(_value.copyWith(valueDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueBooleanElement {
    if (_value.valueBooleanElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueBooleanElement!, (value) {
      return _then(_value.copyWith(valueBooleanElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get valueAttachment {
    if (_value.valueAttachment == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.valueAttachment!, (value) {
      return _then(_value.copyWith(valueAttachment: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_PackagedProductDefinitionPropertyCopyWith<$Res>
    implements $PackagedProductDefinitionPropertyCopyWith<$Res> {
  factory _$$_PackagedProductDefinitionPropertyCopyWith(
          _$_PackagedProductDefinitionProperty value,
          $Res Function(_$_PackagedProductDefinitionProperty) then) =
      __$$_PackagedProductDefinitionPropertyCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      Quantity? valueQuantity,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  @override
  $QuantityCopyWith<$Res>? get valueQuantity;
  @override
  $ElementCopyWith<$Res>? get valueDateElement;
  @override
  $ElementCopyWith<$Res>? get valueBooleanElement;
  @override
  $AttachmentCopyWith<$Res>? get valueAttachment;
}

/// @nodoc
class __$$_PackagedProductDefinitionPropertyCopyWithImpl<$Res>
    extends _$PackagedProductDefinitionPropertyCopyWithImpl<$Res,
        _$_PackagedProductDefinitionProperty>
    implements _$$_PackagedProductDefinitionPropertyCopyWith<$Res> {
  __$$_PackagedProductDefinitionPropertyCopyWithImpl(
      _$_PackagedProductDefinitionProperty _value,
      $Res Function(_$_PackagedProductDefinitionProperty) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueQuantity = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
  }) {
    return _then(_$_PackagedProductDefinitionProperty(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PackagedProductDefinitionProperty
    extends _PackagedProductDefinitionProperty {
  _$_PackagedProductDefinitionProperty(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.type,
      this.valueCodeableConcept,
      this.valueQuantity,
      this.valueDate,
      @JsonKey(name: '_valueDate') this.valueDateElement,
      this.valueBoolean,
      @JsonKey(name: '_valueBoolean') this.valueBooleanElement,
      this.valueAttachment})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_PackagedProductDefinitionProperty.fromJson(
          Map<String, dynamic> json) =>
      _$$_PackagedProductDefinitionPropertyFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] A code expressing the type of characteristic.;
  @override
  final CodeableConcept type;

  /// [valueCodeableConcept] A value for the characteristic.;
  @override
  final CodeableConcept? valueCodeableConcept;

  /// [valueQuantity] A value for the characteristic.;
  @override
  final Quantity? valueQuantity;

  /// [valueDate] A value for the characteristic.;
  @override
  final Date? valueDate;

  /// [valueDateElement] (_valueDate): Extensions for valueDate;
  @override
  @JsonKey(name: '_valueDate')
  final Element? valueDateElement;

  /// [valueBoolean] A value for the characteristic.;
  @override
  final Boolean? valueBoolean;

  /// [valueBooleanElement] (_valueBoolean): Extensions for valueBoolean;
  @override
  @JsonKey(name: '_valueBoolean')
  final Element? valueBooleanElement;

  /// [valueAttachment] A value for the characteristic.;
  @override
  final Attachment? valueAttachment;

  @override
  String toString() {
    return 'PackagedProductDefinitionProperty(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, valueCodeableConcept: $valueCodeableConcept, valueQuantity: $valueQuantity, valueDate: $valueDate, valueDateElement: $valueDateElement, valueBoolean: $valueBoolean, valueBooleanElement: $valueBooleanElement, valueAttachment: $valueAttachment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PackagedProductDefinitionProperty &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.valueCodeableConcept, valueCodeableConcept) ||
                other.valueCodeableConcept == valueCodeableConcept) &&
            (identical(other.valueQuantity, valueQuantity) ||
                other.valueQuantity == valueQuantity) &&
            (identical(other.valueDate, valueDate) ||
                other.valueDate == valueDate) &&
            (identical(other.valueDateElement, valueDateElement) ||
                other.valueDateElement == valueDateElement) &&
            (identical(other.valueBoolean, valueBoolean) ||
                other.valueBoolean == valueBoolean) &&
            (identical(other.valueBooleanElement, valueBooleanElement) ||
                other.valueBooleanElement == valueBooleanElement) &&
            (identical(other.valueAttachment, valueAttachment) ||
                other.valueAttachment == valueAttachment));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      valueCodeableConcept,
      valueQuantity,
      valueDate,
      valueDateElement,
      valueBoolean,
      valueBooleanElement,
      valueAttachment);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PackagedProductDefinitionPropertyCopyWith<
          _$_PackagedProductDefinitionProperty>
      get copyWith => __$$_PackagedProductDefinitionPropertyCopyWithImpl<
          _$_PackagedProductDefinitionProperty>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PackagedProductDefinitionPropertyToJson(
      this,
    );
  }
}

abstract class _PackagedProductDefinitionProperty
    extends PackagedProductDefinitionProperty {
  factory _PackagedProductDefinitionProperty(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept type,
          final CodeableConcept? valueCodeableConcept,
          final Quantity? valueQuantity,
          final Date? valueDate,
          @JsonKey(name: '_valueDate') final Element? valueDateElement,
          final Boolean? valueBoolean,
          @JsonKey(name: '_valueBoolean') final Element? valueBooleanElement,
          final Attachment? valueAttachment}) =
      _$_PackagedProductDefinitionProperty;
  _PackagedProductDefinitionProperty._() : super._();

  factory _PackagedProductDefinitionProperty.fromJson(
          Map<String, dynamic> json) =
      _$_PackagedProductDefinitionProperty.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] A code expressing the type of characteristic.;
  CodeableConcept get type;
  @override

  /// [valueCodeableConcept] A value for the characteristic.;
  CodeableConcept? get valueCodeableConcept;
  @override

  /// [valueQuantity] A value for the characteristic.;
  Quantity? get valueQuantity;
  @override

  /// [valueDate] A value for the characteristic.;
  Date? get valueDate;
  @override

  /// [valueDateElement] (_valueDate): Extensions for valueDate;
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement;
  @override

  /// [valueBoolean] A value for the characteristic.;
  Boolean? get valueBoolean;
  @override

  /// [valueBooleanElement] (_valueBoolean): Extensions for valueBoolean;
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement;
  @override

  /// [valueAttachment] A value for the characteristic.;
  Attachment? get valueAttachment;
  @override
  @JsonKey(ignore: true)
  _$$_PackagedProductDefinitionPropertyCopyWith<
          _$_PackagedProductDefinitionProperty>
      get copyWith => throw _privateConstructorUsedError;
}

PackagedProductDefinitionContainedItem
    _$PackagedProductDefinitionContainedItemFromJson(
        Map<String, dynamic> json) {
  return _PackagedProductDefinitionContainedItem.fromJson(json);
}

/// @nodoc
mixin _$PackagedProductDefinitionContainedItem {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [item] The actual item(s) of medication, as manufactured, or a device (typically, but not necessarily, a co-packaged one), or other medically related item (such as food, biologicals, raw materials, medical fluids, gases etc.), as contained in the package. This also allows another whole packaged product to be included, which is solely for the case where a package of other entire packages is wanted - such as a wholesale or distribution pack (for layers within one package, use PackagedProductDefinition.package.package).;
  CodeableReference get item => throw _privateConstructorUsedError;

  /// [amount] The number of this type of item within this packaging.;
  Quantity? get amount => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PackagedProductDefinitionContainedItemCopyWith<
          PackagedProductDefinitionContainedItem>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PackagedProductDefinitionContainedItemCopyWith<$Res> {
  factory $PackagedProductDefinitionContainedItemCopyWith(
          PackagedProductDefinitionContainedItem value,
          $Res Function(PackagedProductDefinitionContainedItem) then) =
      _$PackagedProductDefinitionContainedItemCopyWithImpl<$Res,
          PackagedProductDefinitionContainedItem>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference item,
      Quantity? amount});

  $CodeableReferenceCopyWith<$Res> get item;
  $QuantityCopyWith<$Res>? get amount;
}

/// @nodoc
class _$PackagedProductDefinitionContainedItemCopyWithImpl<$Res,
        $Val extends PackagedProductDefinitionContainedItem>
    implements $PackagedProductDefinitionContainedItemCopyWith<$Res> {
  _$PackagedProductDefinitionContainedItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? item = null,
    Object? amount = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      item: null == item
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Quantity?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res> get item {
    return $CodeableReferenceCopyWith<$Res>(_value.item, (value) {
      return _then(_value.copyWith(item: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get amount {
    if (_value.amount == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.amount!, (value) {
      return _then(_value.copyWith(amount: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_PackagedProductDefinitionContainedItemCopyWith<$Res>
    implements $PackagedProductDefinitionContainedItemCopyWith<$Res> {
  factory _$$_PackagedProductDefinitionContainedItemCopyWith(
          _$_PackagedProductDefinitionContainedItem value,
          $Res Function(_$_PackagedProductDefinitionContainedItem) then) =
      __$$_PackagedProductDefinitionContainedItemCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableReference item,
      Quantity? amount});

  @override
  $CodeableReferenceCopyWith<$Res> get item;
  @override
  $QuantityCopyWith<$Res>? get amount;
}

/// @nodoc
class __$$_PackagedProductDefinitionContainedItemCopyWithImpl<$Res>
    extends _$PackagedProductDefinitionContainedItemCopyWithImpl<$Res,
        _$_PackagedProductDefinitionContainedItem>
    implements _$$_PackagedProductDefinitionContainedItemCopyWith<$Res> {
  __$$_PackagedProductDefinitionContainedItemCopyWithImpl(
      _$_PackagedProductDefinitionContainedItem _value,
      $Res Function(_$_PackagedProductDefinitionContainedItem) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? item = null,
    Object? amount = freezed,
  }) {
    return _then(_$_PackagedProductDefinitionContainedItem(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      item: null == item
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Quantity?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PackagedProductDefinitionContainedItem
    extends _PackagedProductDefinitionContainedItem {
  _$_PackagedProductDefinitionContainedItem(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.item,
      this.amount})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_PackagedProductDefinitionContainedItem.fromJson(
          Map<String, dynamic> json) =>
      _$$_PackagedProductDefinitionContainedItemFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [item] The actual item(s) of medication, as manufactured, or a device (typically, but not necessarily, a co-packaged one), or other medically related item (such as food, biologicals, raw materials, medical fluids, gases etc.), as contained in the package. This also allows another whole packaged product to be included, which is solely for the case where a package of other entire packages is wanted - such as a wholesale or distribution pack (for layers within one package, use PackagedProductDefinition.package.package).;
  @override
  final CodeableReference item;

  /// [amount] The number of this type of item within this packaging.;
  @override
  final Quantity? amount;

  @override
  String toString() {
    return 'PackagedProductDefinitionContainedItem(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, item: $item, amount: $amount)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PackagedProductDefinitionContainedItem &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.item, item) || other.item == item) &&
            (identical(other.amount, amount) || other.amount == amount));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      item,
      amount);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PackagedProductDefinitionContainedItemCopyWith<
          _$_PackagedProductDefinitionContainedItem>
      get copyWith => __$$_PackagedProductDefinitionContainedItemCopyWithImpl<
          _$_PackagedProductDefinitionContainedItem>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PackagedProductDefinitionContainedItemToJson(
      this,
    );
  }
}

abstract class _PackagedProductDefinitionContainedItem
    extends PackagedProductDefinitionContainedItem {
  factory _PackagedProductDefinitionContainedItem(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final CodeableReference item,
      final Quantity? amount}) = _$_PackagedProductDefinitionContainedItem;
  _PackagedProductDefinitionContainedItem._() : super._();

  factory _PackagedProductDefinitionContainedItem.fromJson(
          Map<String, dynamic> json) =
      _$_PackagedProductDefinitionContainedItem.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [item] The actual item(s) of medication, as manufactured, or a device (typically, but not necessarily, a co-packaged one), or other medically related item (such as food, biologicals, raw materials, medical fluids, gases etc.), as contained in the package. This also allows another whole packaged product to be included, which is solely for the case where a package of other entire packages is wanted - such as a wholesale or distribution pack (for layers within one package, use PackagedProductDefinition.package.package).;
  CodeableReference get item;
  @override

  /// [amount] The number of this type of item within this packaging.;
  Quantity? get amount;
  @override
  @JsonKey(ignore: true)
  _$$_PackagedProductDefinitionContainedItemCopyWith<
          _$_PackagedProductDefinitionContainedItem>
      get copyWith => throw _privateConstructorUsedError;
}

RegulatedAuthorization _$RegulatedAuthorizationFromJson(
    Map<String, dynamic> json) {
  return _RegulatedAuthorization.fromJson(json);
}

/// @nodoc
mixin _$RegulatedAuthorization {
  /// [resourceType] This is a RegulatedAuthorization resource;
  R4ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  String? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.;
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] (_language): Extensions for language;
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] Business identifier for the authorization, typically assigned by the authorizing body.;
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [subject] The product type, treatment, facility or activity that is being authorized.;
  List<Reference>? get subject => throw _privateConstructorUsedError;

  /// [type] Overall type of this authorization, for example drug marketing approval, orphan drug designation.;
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [description] General textual supporting information.;
  Markdown? get description => throw _privateConstructorUsedError;

  /// [descriptionElement] (_description): Extensions for description;
  @JsonKey(name: '_description')
  Element? get descriptionElement => throw _privateConstructorUsedError;

  /// [region] The territory (e.g., country, jurisdiction etc.) in which the authorization has been granted.;
  List<CodeableConcept>? get region => throw _privateConstructorUsedError;

  /// [status] The status that is authorised e.g. approved. Intermediate states and actions can be tracked with cases and applications.;
  CodeableConcept? get status => throw _privateConstructorUsedError;

  /// [statusDate] The date at which the current status was assigned.;
  FhirDateTime? get statusDate => throw _privateConstructorUsedError;

  /// [statusDateElement] (_statusDate): Extensions for statusDate;
  @JsonKey(name: '_statusDate')
  Element? get statusDateElement => throw _privateConstructorUsedError;

  /// [validityPeriod] The time period in which the regulatory approval, clearance or licencing is in effect. As an example, a Marketing Authorization includes the date of authorization and/or an expiration date.;
  Period? get validityPeriod => throw _privateConstructorUsedError;

  /// [indication] Condition for which the use of the regulated product applies.;
  CodeableReference? get indication => throw _privateConstructorUsedError;

  /// [intendedUse] The intended use of the product, e.g. prevention, treatment, diagnosis.;
  CodeableConcept? get intendedUse => throw _privateConstructorUsedError;

  /// [basis] The legal or regulatory framework against which this authorization is granted, or other reasons for it.;
  List<CodeableConcept>? get basis => throw _privateConstructorUsedError;

  /// [holder] The organization that has been granted this authorization, by some authoritative body (the 'regulator').;
  Reference? get holder => throw _privateConstructorUsedError;

  /// [regulator] The regulatory authority or authorizing body granting the authorization. For example, European Medicines Agency (EMA), Food and Drug Administration (FDA), Health Canada (HC), etc.;
  Reference? get regulator => throw _privateConstructorUsedError;

  /// [case_] The case or regulatory procedure for granting or amending a regulated authorization. An authorization is granted in response to submissions/applications by those seeking authorization. A case is the administrative process that deals with the application(s) that relate to this and assesses them. Note: This area is subject to ongoing review and the workgroup is seeking implementer feedback on its use (see link at bottom of page).;
  @JsonKey(name: 'case')
  RegulatedAuthorizationCase? get case_ => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RegulatedAuthorizationCopyWith<RegulatedAuthorization> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RegulatedAuthorizationCopyWith<$Res> {
  factory $RegulatedAuthorizationCopyWith(RegulatedAuthorization value,
          $Res Function(RegulatedAuthorization) then) =
      _$RegulatedAuthorizationCopyWithImpl<$Res, RegulatedAuthorization>;
  @useResult
  $Res call(
      {R4ResourceType resourceType,
      String? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      List<Reference>? subject,
      CodeableConcept? type,
      Markdown? description,
      @JsonKey(name: '_description') Element? descriptionElement,
      List<CodeableConcept>? region,
      CodeableConcept? status,
      FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate') Element? statusDateElement,
      Period? validityPeriod,
      CodeableReference? indication,
      CodeableConcept? intendedUse,
      List<CodeableConcept>? basis,
      Reference? holder,
      Reference? regulator,
      @JsonKey(name: 'case') RegulatedAuthorizationCase? case_});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $CodeableConceptCopyWith<$Res>? get type;
  $ElementCopyWith<$Res>? get descriptionElement;
  $CodeableConceptCopyWith<$Res>? get status;
  $ElementCopyWith<$Res>? get statusDateElement;
  $PeriodCopyWith<$Res>? get validityPeriod;
  $CodeableReferenceCopyWith<$Res>? get indication;
  $CodeableConceptCopyWith<$Res>? get intendedUse;
  $ReferenceCopyWith<$Res>? get holder;
  $ReferenceCopyWith<$Res>? get regulator;
  $RegulatedAuthorizationCaseCopyWith<$Res>? get case_;
}

/// @nodoc
class _$RegulatedAuthorizationCopyWithImpl<$Res,
        $Val extends RegulatedAuthorization>
    implements $RegulatedAuthorizationCopyWith<$Res> {
  _$RegulatedAuthorizationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? subject = freezed,
    Object? type = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? region = freezed,
    Object? status = freezed,
    Object? statusDate = freezed,
    Object? statusDateElement = freezed,
    Object? validityPeriod = freezed,
    Object? indication = freezed,
    Object? intendedUse = freezed,
    Object? basis = freezed,
    Object? holder = freezed,
    Object? regulator = freezed,
    Object? case_ = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R4ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      subject: freezed == subject
          ? _value.subject
          : subject // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      region: freezed == region
          ? _value.region
          : region // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      statusDate: freezed == statusDate
          ? _value.statusDate
          : statusDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      statusDateElement: freezed == statusDateElement
          ? _value.statusDateElement
          : statusDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      validityPeriod: freezed == validityPeriod
          ? _value.validityPeriod
          : validityPeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      indication: freezed == indication
          ? _value.indication
          : indication // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      intendedUse: freezed == intendedUse
          ? _value.intendedUse
          : intendedUse // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      basis: freezed == basis
          ? _value.basis
          : basis // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      holder: freezed == holder
          ? _value.holder
          : holder // ignore: cast_nullable_to_non_nullable
              as Reference?,
      regulator: freezed == regulator
          ? _value.regulator
          : regulator // ignore: cast_nullable_to_non_nullable
              as Reference?,
      case_: freezed == case_
          ? _value.case_
          : case_ // ignore: cast_nullable_to_non_nullable
              as RegulatedAuthorizationCase?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get descriptionElement {
    if (_value.descriptionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.descriptionElement!, (value) {
      return _then(_value.copyWith(descriptionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusDateElement {
    if (_value.statusDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusDateElement!, (value) {
      return _then(_value.copyWith(statusDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get validityPeriod {
    if (_value.validityPeriod == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.validityPeriod!, (value) {
      return _then(_value.copyWith(validityPeriod: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res>? get indication {
    if (_value.indication == null) {
      return null;
    }

    return $CodeableReferenceCopyWith<$Res>(_value.indication!, (value) {
      return _then(_value.copyWith(indication: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get intendedUse {
    if (_value.intendedUse == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.intendedUse!, (value) {
      return _then(_value.copyWith(intendedUse: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get holder {
    if (_value.holder == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.holder!, (value) {
      return _then(_value.copyWith(holder: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get regulator {
    if (_value.regulator == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.regulator!, (value) {
      return _then(_value.copyWith(regulator: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RegulatedAuthorizationCaseCopyWith<$Res>? get case_ {
    if (_value.case_ == null) {
      return null;
    }

    return $RegulatedAuthorizationCaseCopyWith<$Res>(_value.case_!, (value) {
      return _then(_value.copyWith(case_: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_RegulatedAuthorizationCopyWith<$Res>
    implements $RegulatedAuthorizationCopyWith<$Res> {
  factory _$$_RegulatedAuthorizationCopyWith(_$_RegulatedAuthorization value,
          $Res Function(_$_RegulatedAuthorization) then) =
      __$$_RegulatedAuthorizationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {R4ResourceType resourceType,
      String? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      List<Reference>? subject,
      CodeableConcept? type,
      Markdown? description,
      @JsonKey(name: '_description') Element? descriptionElement,
      List<CodeableConcept>? region,
      CodeableConcept? status,
      FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate') Element? statusDateElement,
      Period? validityPeriod,
      CodeableReference? indication,
      CodeableConcept? intendedUse,
      List<CodeableConcept>? basis,
      Reference? holder,
      Reference? regulator,
      @JsonKey(name: 'case') RegulatedAuthorizationCase? case_});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $ElementCopyWith<$Res>? get descriptionElement;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
  @override
  $ElementCopyWith<$Res>? get statusDateElement;
  @override
  $PeriodCopyWith<$Res>? get validityPeriod;
  @override
  $CodeableReferenceCopyWith<$Res>? get indication;
  @override
  $CodeableConceptCopyWith<$Res>? get intendedUse;
  @override
  $ReferenceCopyWith<$Res>? get holder;
  @override
  $ReferenceCopyWith<$Res>? get regulator;
  @override
  $RegulatedAuthorizationCaseCopyWith<$Res>? get case_;
}

/// @nodoc
class __$$_RegulatedAuthorizationCopyWithImpl<$Res>
    extends _$RegulatedAuthorizationCopyWithImpl<$Res,
        _$_RegulatedAuthorization>
    implements _$$_RegulatedAuthorizationCopyWith<$Res> {
  __$$_RegulatedAuthorizationCopyWithImpl(_$_RegulatedAuthorization _value,
      $Res Function(_$_RegulatedAuthorization) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? subject = freezed,
    Object? type = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? region = freezed,
    Object? status = freezed,
    Object? statusDate = freezed,
    Object? statusDateElement = freezed,
    Object? validityPeriod = freezed,
    Object? indication = freezed,
    Object? intendedUse = freezed,
    Object? basis = freezed,
    Object? holder = freezed,
    Object? regulator = freezed,
    Object? case_ = freezed,
  }) {
    return _then(_$_RegulatedAuthorization(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R4ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      subject: freezed == subject
          ? _value._subject
          : subject // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      region: freezed == region
          ? _value._region
          : region // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      statusDate: freezed == statusDate
          ? _value.statusDate
          : statusDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      statusDateElement: freezed == statusDateElement
          ? _value.statusDateElement
          : statusDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      validityPeriod: freezed == validityPeriod
          ? _value.validityPeriod
          : validityPeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      indication: freezed == indication
          ? _value.indication
          : indication // ignore: cast_nullable_to_non_nullable
              as CodeableReference?,
      intendedUse: freezed == intendedUse
          ? _value.intendedUse
          : intendedUse // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      basis: freezed == basis
          ? _value._basis
          : basis // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      holder: freezed == holder
          ? _value.holder
          : holder // ignore: cast_nullable_to_non_nullable
              as Reference?,
      regulator: freezed == regulator
          ? _value.regulator
          : regulator // ignore: cast_nullable_to_non_nullable
              as Reference?,
      case_: freezed == case_
          ? _value.case_
          : case_ // ignore: cast_nullable_to_non_nullable
              as RegulatedAuthorizationCase?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_RegulatedAuthorization extends _RegulatedAuthorization {
  _$_RegulatedAuthorization(
      {this.resourceType = R4ResourceType.RegulatedAuthorization,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules') this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language') this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      final List<Reference>? subject,
      this.type,
      this.description,
      @JsonKey(name: '_description') this.descriptionElement,
      final List<CodeableConcept>? region,
      this.status,
      this.statusDate,
      @JsonKey(name: '_statusDate') this.statusDateElement,
      this.validityPeriod,
      this.indication,
      this.intendedUse,
      final List<CodeableConcept>? basis,
      this.holder,
      this.regulator,
      @JsonKey(name: 'case') this.case_})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _subject = subject,
        _region = region,
        _basis = basis,
        super._();

  factory _$_RegulatedAuthorization.fromJson(Map<String, dynamic> json) =>
      _$$_RegulatedAuthorizationFromJson(json);

  /// [resourceType] This is a RegulatedAuthorization resource;
  @override
  @JsonKey()
  final R4ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  @override
  final String? id;

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.;
  @override
  final Code? language;

  /// [languageElement] (_language): Extensions for language;
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] Business identifier for the authorization, typically assigned by the authorizing body.;
  final List<Identifier>? _identifier;

  /// [identifier] Business identifier for the authorization, typically assigned by the authorizing body.;
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [subject] The product type, treatment, facility or activity that is being authorized.;
  final List<Reference>? _subject;

  /// [subject] The product type, treatment, facility or activity that is being authorized.;
  @override
  List<Reference>? get subject {
    final value = _subject;
    if (value == null) return null;
    if (_subject is EqualUnmodifiableListView) return _subject;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] Overall type of this authorization, for example drug marketing approval, orphan drug designation.;
  @override
  final CodeableConcept? type;

  /// [description] General textual supporting information.;
  @override
  final Markdown? description;

  /// [descriptionElement] (_description): Extensions for description;
  @override
  @JsonKey(name: '_description')
  final Element? descriptionElement;

  /// [region] The territory (e.g., country, jurisdiction etc.) in which the authorization has been granted.;
  final List<CodeableConcept>? _region;

  /// [region] The territory (e.g., country, jurisdiction etc.) in which the authorization has been granted.;
  @override
  List<CodeableConcept>? get region {
    final value = _region;
    if (value == null) return null;
    if (_region is EqualUnmodifiableListView) return _region;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [status] The status that is authorised e.g. approved. Intermediate states and actions can be tracked with cases and applications.;
  @override
  final CodeableConcept? status;

  /// [statusDate] The date at which the current status was assigned.;
  @override
  final FhirDateTime? statusDate;

  /// [statusDateElement] (_statusDate): Extensions for statusDate;
  @override
  @JsonKey(name: '_statusDate')
  final Element? statusDateElement;

  /// [validityPeriod] The time period in which the regulatory approval, clearance or licencing is in effect. As an example, a Marketing Authorization includes the date of authorization and/or an expiration date.;
  @override
  final Period? validityPeriod;

  /// [indication] Condition for which the use of the regulated product applies.;
  @override
  final CodeableReference? indication;

  /// [intendedUse] The intended use of the product, e.g. prevention, treatment, diagnosis.;
  @override
  final CodeableConcept? intendedUse;

  /// [basis] The legal or regulatory framework against which this authorization is granted, or other reasons for it.;
  final List<CodeableConcept>? _basis;

  /// [basis] The legal or regulatory framework against which this authorization is granted, or other reasons for it.;
  @override
  List<CodeableConcept>? get basis {
    final value = _basis;
    if (value == null) return null;
    if (_basis is EqualUnmodifiableListView) return _basis;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [holder] The organization that has been granted this authorization, by some authoritative body (the 'regulator').;
  @override
  final Reference? holder;

  /// [regulator] The regulatory authority or authorizing body granting the authorization. For example, European Medicines Agency (EMA), Food and Drug Administration (FDA), Health Canada (HC), etc.;
  @override
  final Reference? regulator;

  /// [case_] The case or regulatory procedure for granting or amending a regulated authorization. An authorization is granted in response to submissions/applications by those seeking authorization. A case is the administrative process that deals with the application(s) that relate to this and assesses them. Note: This area is subject to ongoing review and the workgroup is seeking implementer feedback on its use (see link at bottom of page).;
  @override
  @JsonKey(name: 'case')
  final RegulatedAuthorizationCase? case_;

  @override
  String toString() {
    return 'RegulatedAuthorization(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, subject: $subject, type: $type, description: $description, descriptionElement: $descriptionElement, region: $region, status: $status, statusDate: $statusDate, statusDateElement: $statusDateElement, validityPeriod: $validityPeriod, indication: $indication, intendedUse: $intendedUse, basis: $basis, holder: $holder, regulator: $regulator, case_: $case_)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_RegulatedAuthorization &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            const DeepCollectionEquality().equals(other._subject, _subject) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.descriptionElement, descriptionElement) ||
                other.descriptionElement == descriptionElement) &&
            const DeepCollectionEquality().equals(other._region, _region) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusDate, statusDate) ||
                other.statusDate == statusDate) &&
            (identical(other.statusDateElement, statusDateElement) ||
                other.statusDateElement == statusDateElement) &&
            (identical(other.validityPeriod, validityPeriod) ||
                other.validityPeriod == validityPeriod) &&
            (identical(other.indication, indication) ||
                other.indication == indication) &&
            (identical(other.intendedUse, intendedUse) ||
                other.intendedUse == intendedUse) &&
            const DeepCollectionEquality().equals(other._basis, _basis) &&
            (identical(other.holder, holder) || other.holder == holder) &&
            (identical(other.regulator, regulator) ||
                other.regulator == regulator) &&
            (identical(other.case_, case_) || other.case_ == case_));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_identifier),
        const DeepCollectionEquality().hash(_subject),
        type,
        description,
        descriptionElement,
        const DeepCollectionEquality().hash(_region),
        status,
        statusDate,
        statusDateElement,
        validityPeriod,
        indication,
        intendedUse,
        const DeepCollectionEquality().hash(_basis),
        holder,
        regulator,
        case_
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_RegulatedAuthorizationCopyWith<_$_RegulatedAuthorization> get copyWith =>
      __$$_RegulatedAuthorizationCopyWithImpl<_$_RegulatedAuthorization>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_RegulatedAuthorizationToJson(
      this,
    );
  }
}

abstract class _RegulatedAuthorization extends RegulatedAuthorization {
  factory _RegulatedAuthorization(
          {final R4ResourceType resourceType,
          final String? id,
          final Meta? meta,
          final FhirUri? implicitRules,
          @JsonKey(name: '_implicitRules') final Element? implicitRulesElement,
          final Code? language,
          @JsonKey(name: '_language') final Element? languageElement,
          final Narrative? text,
          final List<Resource>? contained,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final List<Identifier>? identifier,
          final List<Reference>? subject,
          final CodeableConcept? type,
          final Markdown? description,
          @JsonKey(name: '_description') final Element? descriptionElement,
          final List<CodeableConcept>? region,
          final CodeableConcept? status,
          final FhirDateTime? statusDate,
          @JsonKey(name: '_statusDate') final Element? statusDateElement,
          final Period? validityPeriod,
          final CodeableReference? indication,
          final CodeableConcept? intendedUse,
          final List<CodeableConcept>? basis,
          final Reference? holder,
          final Reference? regulator,
          @JsonKey(name: 'case') final RegulatedAuthorizationCase? case_}) =
      _$_RegulatedAuthorization;
  _RegulatedAuthorization._() : super._();

  factory _RegulatedAuthorization.fromJson(Map<String, dynamic> json) =
      _$_RegulatedAuthorization.fromJson;

  @override

  /// [resourceType] This is a RegulatedAuthorization resource;
  R4ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  String? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.;
  Code? get language;
  @override

  /// [languageElement] (_language): Extensions for language;
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  List<Resource>? get contained;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] Business identifier for the authorization, typically assigned by the authorizing body.;
  List<Identifier>? get identifier;
  @override

  /// [subject] The product type, treatment, facility or activity that is being authorized.;
  List<Reference>? get subject;
  @override

  /// [type] Overall type of this authorization, for example drug marketing approval, orphan drug designation.;
  CodeableConcept? get type;
  @override

  /// [description] General textual supporting information.;
  Markdown? get description;
  @override

  /// [descriptionElement] (_description): Extensions for description;
  @JsonKey(name: '_description')
  Element? get descriptionElement;
  @override

  /// [region] The territory (e.g., country, jurisdiction etc.) in which the authorization has been granted.;
  List<CodeableConcept>? get region;
  @override

  /// [status] The status that is authorised e.g. approved. Intermediate states and actions can be tracked with cases and applications.;
  CodeableConcept? get status;
  @override

  /// [statusDate] The date at which the current status was assigned.;
  FhirDateTime? get statusDate;
  @override

  /// [statusDateElement] (_statusDate): Extensions for statusDate;
  @JsonKey(name: '_statusDate')
  Element? get statusDateElement;
  @override

  /// [validityPeriod] The time period in which the regulatory approval, clearance or licencing is in effect. As an example, a Marketing Authorization includes the date of authorization and/or an expiration date.;
  Period? get validityPeriod;
  @override

  /// [indication] Condition for which the use of the regulated product applies.;
  CodeableReference? get indication;
  @override

  /// [intendedUse] The intended use of the product, e.g. prevention, treatment, diagnosis.;
  CodeableConcept? get intendedUse;
  @override

  /// [basis] The legal or regulatory framework against which this authorization is granted, or other reasons for it.;
  List<CodeableConcept>? get basis;
  @override

  /// [holder] The organization that has been granted this authorization, by some authoritative body (the 'regulator').;
  Reference? get holder;
  @override

  /// [regulator] The regulatory authority or authorizing body granting the authorization. For example, European Medicines Agency (EMA), Food and Drug Administration (FDA), Health Canada (HC), etc.;
  Reference? get regulator;
  @override

  /// [case_] The case or regulatory procedure for granting or amending a regulated authorization. An authorization is granted in response to submissions/applications by those seeking authorization. A case is the administrative process that deals with the application(s) that relate to this and assesses them. Note: This area is subject to ongoing review and the workgroup is seeking implementer feedback on its use (see link at bottom of page).;
  @JsonKey(name: 'case')
  RegulatedAuthorizationCase? get case_;
  @override
  @JsonKey(ignore: true)
  _$$_RegulatedAuthorizationCopyWith<_$_RegulatedAuthorization> get copyWith =>
      throw _privateConstructorUsedError;
}

RegulatedAuthorizationCase _$RegulatedAuthorizationCaseFromJson(
    Map<String, dynamic> json) {
  return _RegulatedAuthorizationCase.fromJson(json);
}

/// @nodoc
mixin _$RegulatedAuthorizationCase {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] Identifier by which this case can be referenced.;
  Identifier? get identifier => throw _privateConstructorUsedError;

  /// [type] The defining type of case.;
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [status] The status associated with the case.;
  CodeableConcept? get status => throw _privateConstructorUsedError;

  /// [datePeriod] Relevant date for this case.;
  Period? get datePeriod => throw _privateConstructorUsedError;

  /// [dateDateTime] Relevant date for this case.;
  FhirDateTime? get dateDateTime => throw _privateConstructorUsedError;

  /// [dateDateTimeElement] (_dateDateTime): Extensions for dateDateTime;
  @JsonKey(name: '_dateDateTime')
  Element? get dateDateTimeElement => throw _privateConstructorUsedError;

  /// [application] A regulatory submission from an organization to a regulator, as part of an assessing case. Multiple applications may occur over time, with more or different information to support or modify the submission or the authorization. The applications can be considered as steps within the longer running case or procedure for this authorization process.;
  List<RegulatedAuthorizationCase>? get application =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RegulatedAuthorizationCaseCopyWith<RegulatedAuthorizationCase>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RegulatedAuthorizationCaseCopyWith<$Res> {
  factory $RegulatedAuthorizationCaseCopyWith(RegulatedAuthorizationCase value,
          $Res Function(RegulatedAuthorizationCase) then) =
      _$RegulatedAuthorizationCaseCopyWithImpl<$Res,
          RegulatedAuthorizationCase>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Identifier? identifier,
      CodeableConcept? type,
      CodeableConcept? status,
      Period? datePeriod,
      FhirDateTime? dateDateTime,
      @JsonKey(name: '_dateDateTime') Element? dateDateTimeElement,
      List<RegulatedAuthorizationCase>? application});

  $IdentifierCopyWith<$Res>? get identifier;
  $CodeableConceptCopyWith<$Res>? get type;
  $CodeableConceptCopyWith<$Res>? get status;
  $PeriodCopyWith<$Res>? get datePeriod;
  $ElementCopyWith<$Res>? get dateDateTimeElement;
}

/// @nodoc
class _$RegulatedAuthorizationCaseCopyWithImpl<$Res,
        $Val extends RegulatedAuthorizationCase>
    implements $RegulatedAuthorizationCaseCopyWith<$Res> {
  _$RegulatedAuthorizationCaseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = freezed,
    Object? status = freezed,
    Object? datePeriod = freezed,
    Object? dateDateTime = freezed,
    Object? dateDateTimeElement = freezed,
    Object? application = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      datePeriod: freezed == datePeriod
          ? _value.datePeriod
          : datePeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      dateDateTime: freezed == dateDateTime
          ? _value.dateDateTime
          : dateDateTime // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      dateDateTimeElement: freezed == dateDateTimeElement
          ? _value.dateDateTimeElement
          : dateDateTimeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      application: freezed == application
          ? _value.application
          : application // ignore: cast_nullable_to_non_nullable
              as List<RegulatedAuthorizationCase>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get identifier {
    if (_value.identifier == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.identifier!, (value) {
      return _then(_value.copyWith(identifier: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get datePeriod {
    if (_value.datePeriod == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.datePeriod!, (value) {
      return _then(_value.copyWith(datePeriod: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get dateDateTimeElement {
    if (_value.dateDateTimeElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.dateDateTimeElement!, (value) {
      return _then(_value.copyWith(dateDateTimeElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_RegulatedAuthorizationCaseCopyWith<$Res>
    implements $RegulatedAuthorizationCaseCopyWith<$Res> {
  factory _$$_RegulatedAuthorizationCaseCopyWith(
          _$_RegulatedAuthorizationCase value,
          $Res Function(_$_RegulatedAuthorizationCase) then) =
      __$$_RegulatedAuthorizationCaseCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Identifier? identifier,
      CodeableConcept? type,
      CodeableConcept? status,
      Period? datePeriod,
      FhirDateTime? dateDateTime,
      @JsonKey(name: '_dateDateTime') Element? dateDateTimeElement,
      List<RegulatedAuthorizationCase>? application});

  @override
  $IdentifierCopyWith<$Res>? get identifier;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
  @override
  $PeriodCopyWith<$Res>? get datePeriod;
  @override
  $ElementCopyWith<$Res>? get dateDateTimeElement;
}

/// @nodoc
class __$$_RegulatedAuthorizationCaseCopyWithImpl<$Res>
    extends _$RegulatedAuthorizationCaseCopyWithImpl<$Res,
        _$_RegulatedAuthorizationCase>
    implements _$$_RegulatedAuthorizationCaseCopyWith<$Res> {
  __$$_RegulatedAuthorizationCaseCopyWithImpl(
      _$_RegulatedAuthorizationCase _value,
      $Res Function(_$_RegulatedAuthorizationCase) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = freezed,
    Object? status = freezed,
    Object? datePeriod = freezed,
    Object? dateDateTime = freezed,
    Object? dateDateTimeElement = freezed,
    Object? application = freezed,
  }) {
    return _then(_$_RegulatedAuthorizationCase(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      datePeriod: freezed == datePeriod
          ? _value.datePeriod
          : datePeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      dateDateTime: freezed == dateDateTime
          ? _value.dateDateTime
          : dateDateTime // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      dateDateTimeElement: freezed == dateDateTimeElement
          ? _value.dateDateTimeElement
          : dateDateTimeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      application: freezed == application
          ? _value._application
          : application // ignore: cast_nullable_to_non_nullable
              as List<RegulatedAuthorizationCase>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_RegulatedAuthorizationCase extends _RegulatedAuthorizationCase {
  _$_RegulatedAuthorizationCase(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.identifier,
      this.type,
      this.status,
      this.datePeriod,
      this.dateDateTime,
      @JsonKey(name: '_dateDateTime') this.dateDateTimeElement,
      final List<RegulatedAuthorizationCase>? application})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _application = application,
        super._();

  factory _$_RegulatedAuthorizationCase.fromJson(Map<String, dynamic> json) =>
      _$$_RegulatedAuthorizationCaseFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] Identifier by which this case can be referenced.;
  @override
  final Identifier? identifier;

  /// [type] The defining type of case.;
  @override
  final CodeableConcept? type;

  /// [status] The status associated with the case.;
  @override
  final CodeableConcept? status;

  /// [datePeriod] Relevant date for this case.;
  @override
  final Period? datePeriod;

  /// [dateDateTime] Relevant date for this case.;
  @override
  final FhirDateTime? dateDateTime;

  /// [dateDateTimeElement] (_dateDateTime): Extensions for dateDateTime;
  @override
  @JsonKey(name: '_dateDateTime')
  final Element? dateDateTimeElement;

  /// [application] A regulatory submission from an organization to a regulator, as part of an assessing case. Multiple applications may occur over time, with more or different information to support or modify the submission or the authorization. The applications can be considered as steps within the longer running case or procedure for this authorization process.;
  final List<RegulatedAuthorizationCase>? _application;

  /// [application] A regulatory submission from an organization to a regulator, as part of an assessing case. Multiple applications may occur over time, with more or different information to support or modify the submission or the authorization. The applications can be considered as steps within the longer running case or procedure for this authorization process.;
  @override
  List<RegulatedAuthorizationCase>? get application {
    final value = _application;
    if (value == null) return null;
    if (_application is EqualUnmodifiableListView) return _application;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'RegulatedAuthorizationCase(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, type: $type, status: $status, datePeriod: $datePeriod, dateDateTime: $dateDateTime, dateDateTimeElement: $dateDateTimeElement, application: $application)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_RegulatedAuthorizationCase &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.datePeriod, datePeriod) ||
                other.datePeriod == datePeriod) &&
            (identical(other.dateDateTime, dateDateTime) ||
                other.dateDateTime == dateDateTime) &&
            (identical(other.dateDateTimeElement, dateDateTimeElement) ||
                other.dateDateTimeElement == dateDateTimeElement) &&
            const DeepCollectionEquality()
                .equals(other._application, _application));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      identifier,
      type,
      status,
      datePeriod,
      dateDateTime,
      dateDateTimeElement,
      const DeepCollectionEquality().hash(_application));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_RegulatedAuthorizationCaseCopyWith<_$_RegulatedAuthorizationCase>
      get copyWith => __$$_RegulatedAuthorizationCaseCopyWithImpl<
          _$_RegulatedAuthorizationCase>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_RegulatedAuthorizationCaseToJson(
      this,
    );
  }
}

abstract class _RegulatedAuthorizationCase extends RegulatedAuthorizationCase {
  factory _RegulatedAuthorizationCase(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final Identifier? identifier,
          final CodeableConcept? type,
          final CodeableConcept? status,
          final Period? datePeriod,
          final FhirDateTime? dateDateTime,
          @JsonKey(name: '_dateDateTime') final Element? dateDateTimeElement,
          final List<RegulatedAuthorizationCase>? application}) =
      _$_RegulatedAuthorizationCase;
  _RegulatedAuthorizationCase._() : super._();

  factory _RegulatedAuthorizationCase.fromJson(Map<String, dynamic> json) =
      _$_RegulatedAuthorizationCase.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] Identifier by which this case can be referenced.;
  Identifier? get identifier;
  @override

  /// [type] The defining type of case.;
  CodeableConcept? get type;
  @override

  /// [status] The status associated with the case.;
  CodeableConcept? get status;
  @override

  /// [datePeriod] Relevant date for this case.;
  Period? get datePeriod;
  @override

  /// [dateDateTime] Relevant date for this case.;
  FhirDateTime? get dateDateTime;
  @override

  /// [dateDateTimeElement] (_dateDateTime): Extensions for dateDateTime;
  @JsonKey(name: '_dateDateTime')
  Element? get dateDateTimeElement;
  @override

  /// [application] A regulatory submission from an organization to a regulator, as part of an assessing case. Multiple applications may occur over time, with more or different information to support or modify the submission or the authorization. The applications can be considered as steps within the longer running case or procedure for this authorization process.;
  List<RegulatedAuthorizationCase>? get application;
  @override
  @JsonKey(ignore: true)
  _$$_RegulatedAuthorizationCaseCopyWith<_$_RegulatedAuthorizationCase>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinition _$SubstanceDefinitionFromJson(Map<String, dynamic> json) {
  return _SubstanceDefinition.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinition {
  /// [resourceType] This is a SubstanceDefinition resource;
  R4ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  String? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  Meta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.;
  Code? get language => throw _privateConstructorUsedError;

  /// [languageElement] (_language): Extensions for language;
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] Identifier by which this substance is known.;
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [version] A business level version identifier of the substance.;
  String? get version => throw _privateConstructorUsedError;

  /// [versionElement] (_version): Extensions for version;
  @JsonKey(name: '_version')
  Element? get versionElement => throw _privateConstructorUsedError;

  /// [status] Status of substance within the catalogue e.g. active, retired.;
  CodeableConcept? get status => throw _privateConstructorUsedError;

  /// [classification] A high level categorization, e.g. polymer or nucleic acid, or food, chemical, biological, or a lower level such as the general types of polymer (linear or branch chain) or type of impurity (process related or contaminant).;
  List<CodeableConcept>? get classification =>
      throw _privateConstructorUsedError;

  /// [domain] If the substance applies to human or veterinary use.;
  CodeableConcept? get domain => throw _privateConstructorUsedError;

  /// [grade] The quality standard, established benchmark, to which substance complies (e.g. USP/NF, Ph. Eur, JP, BP, Company Standard).;
  List<CodeableConcept>? get grade => throw _privateConstructorUsedError;

  /// [description] Textual description of the substance.;
  Markdown? get description => throw _privateConstructorUsedError;

  /// [descriptionElement] (_description): Extensions for description;
  @JsonKey(name: '_description')
  Element? get descriptionElement => throw _privateConstructorUsedError;

  /// [informationSource] Supporting literature.;
  List<Reference>? get informationSource => throw _privateConstructorUsedError;

  /// [note] Textual comment about the substance's catalogue or registry record.;
  List<Annotation>? get note => throw _privateConstructorUsedError;

  /// [manufacturer] The entity that creates, makes, produces or fabricates the substance. This is a set of potential manufacturers but is not necessarily comprehensive.;
  List<Reference>? get manufacturer => throw _privateConstructorUsedError;

  /// [supplier] An entity that is the source for the substance. It may be different from the manufacturer. Supplier is synonymous to a distributor.;
  List<Reference>? get supplier => throw _privateConstructorUsedError;

  /// [moiety] Moiety, for structural modifications.;
  List<SubstanceDefinitionMoiety>? get moiety =>
      throw _privateConstructorUsedError;

  /// [property] General specifications for this substance.;
  List<SubstanceDefinitionProperty>? get property =>
      throw _privateConstructorUsedError;

  /// [molecularWeight] The molecular weight or weight range (for proteins, polymers or nucleic acids).;
  List<SubstanceDefinitionMolecularWeight>? get molecularWeight =>
      throw _privateConstructorUsedError;

  /// [structure] Structural information.;
  SubstanceDefinitionStructure? get structure =>
      throw _privateConstructorUsedError;

  /// [code] Codes associated with the substance.;
  List<SubstanceDefinitionCode>? get code => throw _privateConstructorUsedError;

  /// [name] Names applicable to this substance.;
  List<SubstanceDefinitionName>? get name => throw _privateConstructorUsedError;

  /// [relationship] A link between this substance and another, with details of the relationship.;
  List<SubstanceDefinitionRelationship>? get relationship =>
      throw _privateConstructorUsedError;

  /// [sourceMaterial] Material or taxonomic/anatomical source for the substance.;
  SubstanceDefinitionSourceMaterial? get sourceMaterial =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionCopyWith<SubstanceDefinition> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionCopyWith<$Res> {
  factory $SubstanceDefinitionCopyWith(
          SubstanceDefinition value, $Res Function(SubstanceDefinition) then) =
      _$SubstanceDefinitionCopyWithImpl<$Res, SubstanceDefinition>;
  @useResult
  $Res call(
      {R4ResourceType resourceType,
      String? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      String? version,
      @JsonKey(name: '_version') Element? versionElement,
      CodeableConcept? status,
      List<CodeableConcept>? classification,
      CodeableConcept? domain,
      List<CodeableConcept>? grade,
      Markdown? description,
      @JsonKey(name: '_description') Element? descriptionElement,
      List<Reference>? informationSource,
      List<Annotation>? note,
      List<Reference>? manufacturer,
      List<Reference>? supplier,
      List<SubstanceDefinitionMoiety>? moiety,
      List<SubstanceDefinitionProperty>? property,
      List<SubstanceDefinitionMolecularWeight>? molecularWeight,
      SubstanceDefinitionStructure? structure,
      List<SubstanceDefinitionCode>? code,
      List<SubstanceDefinitionName>? name,
      List<SubstanceDefinitionRelationship>? relationship,
      SubstanceDefinitionSourceMaterial? sourceMaterial});

  $MetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $ElementCopyWith<$Res>? get versionElement;
  $CodeableConceptCopyWith<$Res>? get status;
  $CodeableConceptCopyWith<$Res>? get domain;
  $ElementCopyWith<$Res>? get descriptionElement;
  $SubstanceDefinitionStructureCopyWith<$Res>? get structure;
  $SubstanceDefinitionSourceMaterialCopyWith<$Res>? get sourceMaterial;
}

/// @nodoc
class _$SubstanceDefinitionCopyWithImpl<$Res, $Val extends SubstanceDefinition>
    implements $SubstanceDefinitionCopyWith<$Res> {
  _$SubstanceDefinitionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? version = freezed,
    Object? versionElement = freezed,
    Object? status = freezed,
    Object? classification = freezed,
    Object? domain = freezed,
    Object? grade = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? informationSource = freezed,
    Object? note = freezed,
    Object? manufacturer = freezed,
    Object? supplier = freezed,
    Object? moiety = freezed,
    Object? property = freezed,
    Object? molecularWeight = freezed,
    Object? structure = freezed,
    Object? code = freezed,
    Object? name = freezed,
    Object? relationship = freezed,
    Object? sourceMaterial = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R4ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      version: freezed == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String?,
      versionElement: freezed == versionElement
          ? _value.versionElement
          : versionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      classification: freezed == classification
          ? _value.classification
          : classification // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      domain: freezed == domain
          ? _value.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      grade: freezed == grade
          ? _value.grade
          : grade // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      informationSource: freezed == informationSource
          ? _value.informationSource
          : informationSource // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      note: freezed == note
          ? _value.note
          : note // ignore: cast_nullable_to_non_nullable
              as List<Annotation>?,
      manufacturer: freezed == manufacturer
          ? _value.manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      supplier: freezed == supplier
          ? _value.supplier
          : supplier // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      moiety: freezed == moiety
          ? _value.moiety
          : moiety // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionMoiety>?,
      property: freezed == property
          ? _value.property
          : property // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionProperty>?,
      molecularWeight: freezed == molecularWeight
          ? _value.molecularWeight
          : molecularWeight // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionMolecularWeight>?,
      structure: freezed == structure
          ? _value.structure
          : structure // ignore: cast_nullable_to_non_nullable
              as SubstanceDefinitionStructure?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionCode>?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionName>?,
      relationship: freezed == relationship
          ? _value.relationship
          : relationship // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionRelationship>?,
      sourceMaterial: freezed == sourceMaterial
          ? _value.sourceMaterial
          : sourceMaterial // ignore: cast_nullable_to_non_nullable
              as SubstanceDefinitionSourceMaterial?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $MetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get versionElement {
    if (_value.versionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.versionElement!, (value) {
      return _then(_value.copyWith(versionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get domain {
    if (_value.domain == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.domain!, (value) {
      return _then(_value.copyWith(domain: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get descriptionElement {
    if (_value.descriptionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.descriptionElement!, (value) {
      return _then(_value.copyWith(descriptionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SubstanceDefinitionStructureCopyWith<$Res>? get structure {
    if (_value.structure == null) {
      return null;
    }

    return $SubstanceDefinitionStructureCopyWith<$Res>(_value.structure!,
        (value) {
      return _then(_value.copyWith(structure: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SubstanceDefinitionSourceMaterialCopyWith<$Res>? get sourceMaterial {
    if (_value.sourceMaterial == null) {
      return null;
    }

    return $SubstanceDefinitionSourceMaterialCopyWith<$Res>(
        _value.sourceMaterial!, (value) {
      return _then(_value.copyWith(sourceMaterial: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionCopyWith<$Res>
    implements $SubstanceDefinitionCopyWith<$Res> {
  factory _$$_SubstanceDefinitionCopyWith(_$_SubstanceDefinition value,
          $Res Function(_$_SubstanceDefinition) then) =
      __$$_SubstanceDefinitionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {R4ResourceType resourceType,
      String? id,
      Meta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      Code? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      String? version,
      @JsonKey(name: '_version') Element? versionElement,
      CodeableConcept? status,
      List<CodeableConcept>? classification,
      CodeableConcept? domain,
      List<CodeableConcept>? grade,
      Markdown? description,
      @JsonKey(name: '_description') Element? descriptionElement,
      List<Reference>? informationSource,
      List<Annotation>? note,
      List<Reference>? manufacturer,
      List<Reference>? supplier,
      List<SubstanceDefinitionMoiety>? moiety,
      List<SubstanceDefinitionProperty>? property,
      List<SubstanceDefinitionMolecularWeight>? molecularWeight,
      SubstanceDefinitionStructure? structure,
      List<SubstanceDefinitionCode>? code,
      List<SubstanceDefinitionName>? name,
      List<SubstanceDefinitionRelationship>? relationship,
      SubstanceDefinitionSourceMaterial? sourceMaterial});

  @override
  $MetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $ElementCopyWith<$Res>? get versionElement;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
  @override
  $CodeableConceptCopyWith<$Res>? get domain;
  @override
  $ElementCopyWith<$Res>? get descriptionElement;
  @override
  $SubstanceDefinitionStructureCopyWith<$Res>? get structure;
  @override
  $SubstanceDefinitionSourceMaterialCopyWith<$Res>? get sourceMaterial;
}

/// @nodoc
class __$$_SubstanceDefinitionCopyWithImpl<$Res>
    extends _$SubstanceDefinitionCopyWithImpl<$Res, _$_SubstanceDefinition>
    implements _$$_SubstanceDefinitionCopyWith<$Res> {
  __$$_SubstanceDefinitionCopyWithImpl(_$_SubstanceDefinition _value,
      $Res Function(_$_SubstanceDefinition) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? version = freezed,
    Object? versionElement = freezed,
    Object? status = freezed,
    Object? classification = freezed,
    Object? domain = freezed,
    Object? grade = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? informationSource = freezed,
    Object? note = freezed,
    Object? manufacturer = freezed,
    Object? supplier = freezed,
    Object? moiety = freezed,
    Object? property = freezed,
    Object? molecularWeight = freezed,
    Object? structure = freezed,
    Object? code = freezed,
    Object? name = freezed,
    Object? relationship = freezed,
    Object? sourceMaterial = freezed,
  }) {
    return _then(_$_SubstanceDefinition(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R4ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Meta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as Code?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      version: freezed == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String?,
      versionElement: freezed == versionElement
          ? _value.versionElement
          : versionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      classification: freezed == classification
          ? _value._classification
          : classification // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      domain: freezed == domain
          ? _value.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      grade: freezed == grade
          ? _value._grade
          : grade // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      informationSource: freezed == informationSource
          ? _value._informationSource
          : informationSource // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      note: freezed == note
          ? _value._note
          : note // ignore: cast_nullable_to_non_nullable
              as List<Annotation>?,
      manufacturer: freezed == manufacturer
          ? _value._manufacturer
          : manufacturer // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      supplier: freezed == supplier
          ? _value._supplier
          : supplier // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      moiety: freezed == moiety
          ? _value._moiety
          : moiety // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionMoiety>?,
      property: freezed == property
          ? _value._property
          : property // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionProperty>?,
      molecularWeight: freezed == molecularWeight
          ? _value._molecularWeight
          : molecularWeight // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionMolecularWeight>?,
      structure: freezed == structure
          ? _value.structure
          : structure // ignore: cast_nullable_to_non_nullable
              as SubstanceDefinitionStructure?,
      code: freezed == code
          ? _value._code
          : code // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionCode>?,
      name: freezed == name
          ? _value._name
          : name // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionName>?,
      relationship: freezed == relationship
          ? _value._relationship
          : relationship // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionRelationship>?,
      sourceMaterial: freezed == sourceMaterial
          ? _value.sourceMaterial
          : sourceMaterial // ignore: cast_nullable_to_non_nullable
              as SubstanceDefinitionSourceMaterial?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinition extends _SubstanceDefinition {
  _$_SubstanceDefinition(
      {this.resourceType = R4ResourceType.SubstanceDefinition,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules') this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language') this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      this.version,
      @JsonKey(name: '_version') this.versionElement,
      this.status,
      final List<CodeableConcept>? classification,
      this.domain,
      final List<CodeableConcept>? grade,
      this.description,
      @JsonKey(name: '_description') this.descriptionElement,
      final List<Reference>? informationSource,
      final List<Annotation>? note,
      final List<Reference>? manufacturer,
      final List<Reference>? supplier,
      final List<SubstanceDefinitionMoiety>? moiety,
      final List<SubstanceDefinitionProperty>? property,
      final List<SubstanceDefinitionMolecularWeight>? molecularWeight,
      this.structure,
      final List<SubstanceDefinitionCode>? code,
      final List<SubstanceDefinitionName>? name,
      final List<SubstanceDefinitionRelationship>? relationship,
      this.sourceMaterial})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _classification = classification,
        _grade = grade,
        _informationSource = informationSource,
        _note = note,
        _manufacturer = manufacturer,
        _supplier = supplier,
        _moiety = moiety,
        _property = property,
        _molecularWeight = molecularWeight,
        _code = code,
        _name = name,
        _relationship = relationship,
        super._();

  factory _$_SubstanceDefinition.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionFromJson(json);

  /// [resourceType] This is a SubstanceDefinition resource;
  @override
  @JsonKey()
  final R4ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  @override
  final String? id;

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  @override
  final Meta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.;
  @override
  final Code? language;

  /// [languageElement] (_language): Extensions for language;
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] Identifier by which this substance is known.;
  final List<Identifier>? _identifier;

  /// [identifier] Identifier by which this substance is known.;
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [version] A business level version identifier of the substance.;
  @override
  final String? version;

  /// [versionElement] (_version): Extensions for version;
  @override
  @JsonKey(name: '_version')
  final Element? versionElement;

  /// [status] Status of substance within the catalogue e.g. active, retired.;
  @override
  final CodeableConcept? status;

  /// [classification] A high level categorization, e.g. polymer or nucleic acid, or food, chemical, biological, or a lower level such as the general types of polymer (linear or branch chain) or type of impurity (process related or contaminant).;
  final List<CodeableConcept>? _classification;

  /// [classification] A high level categorization, e.g. polymer or nucleic acid, or food, chemical, biological, or a lower level such as the general types of polymer (linear or branch chain) or type of impurity (process related or contaminant).;
  @override
  List<CodeableConcept>? get classification {
    final value = _classification;
    if (value == null) return null;
    if (_classification is EqualUnmodifiableListView) return _classification;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [domain] If the substance applies to human or veterinary use.;
  @override
  final CodeableConcept? domain;

  /// [grade] The quality standard, established benchmark, to which substance complies (e.g. USP/NF, Ph. Eur, JP, BP, Company Standard).;
  final List<CodeableConcept>? _grade;

  /// [grade] The quality standard, established benchmark, to which substance complies (e.g. USP/NF, Ph. Eur, JP, BP, Company Standard).;
  @override
  List<CodeableConcept>? get grade {
    final value = _grade;
    if (value == null) return null;
    if (_grade is EqualUnmodifiableListView) return _grade;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [description] Textual description of the substance.;
  @override
  final Markdown? description;

  /// [descriptionElement] (_description): Extensions for description;
  @override
  @JsonKey(name: '_description')
  final Element? descriptionElement;

  /// [informationSource] Supporting literature.;
  final List<Reference>? _informationSource;

  /// [informationSource] Supporting literature.;
  @override
  List<Reference>? get informationSource {
    final value = _informationSource;
    if (value == null) return null;
    if (_informationSource is EqualUnmodifiableListView)
      return _informationSource;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [note] Textual comment about the substance's catalogue or registry record.;
  final List<Annotation>? _note;

  /// [note] Textual comment about the substance's catalogue or registry record.;
  @override
  List<Annotation>? get note {
    final value = _note;
    if (value == null) return null;
    if (_note is EqualUnmodifiableListView) return _note;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [manufacturer] The entity that creates, makes, produces or fabricates the substance. This is a set of potential manufacturers but is not necessarily comprehensive.;
  final List<Reference>? _manufacturer;

  /// [manufacturer] The entity that creates, makes, produces or fabricates the substance. This is a set of potential manufacturers but is not necessarily comprehensive.;
  @override
  List<Reference>? get manufacturer {
    final value = _manufacturer;
    if (value == null) return null;
    if (_manufacturer is EqualUnmodifiableListView) return _manufacturer;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [supplier] An entity that is the source for the substance. It may be different from the manufacturer. Supplier is synonymous to a distributor.;
  final List<Reference>? _supplier;

  /// [supplier] An entity that is the source for the substance. It may be different from the manufacturer. Supplier is synonymous to a distributor.;
  @override
  List<Reference>? get supplier {
    final value = _supplier;
    if (value == null) return null;
    if (_supplier is EqualUnmodifiableListView) return _supplier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [moiety] Moiety, for structural modifications.;
  final List<SubstanceDefinitionMoiety>? _moiety;

  /// [moiety] Moiety, for structural modifications.;
  @override
  List<SubstanceDefinitionMoiety>? get moiety {
    final value = _moiety;
    if (value == null) return null;
    if (_moiety is EqualUnmodifiableListView) return _moiety;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [property] General specifications for this substance.;
  final List<SubstanceDefinitionProperty>? _property;

  /// [property] General specifications for this substance.;
  @override
  List<SubstanceDefinitionProperty>? get property {
    final value = _property;
    if (value == null) return null;
    if (_property is EqualUnmodifiableListView) return _property;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [molecularWeight] The molecular weight or weight range (for proteins, polymers or nucleic acids).;
  final List<SubstanceDefinitionMolecularWeight>? _molecularWeight;

  /// [molecularWeight] The molecular weight or weight range (for proteins, polymers or nucleic acids).;
  @override
  List<SubstanceDefinitionMolecularWeight>? get molecularWeight {
    final value = _molecularWeight;
    if (value == null) return null;
    if (_molecularWeight is EqualUnmodifiableListView) return _molecularWeight;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [structure] Structural information.;
  @override
  final SubstanceDefinitionStructure? structure;

  /// [code] Codes associated with the substance.;
  final List<SubstanceDefinitionCode>? _code;

  /// [code] Codes associated with the substance.;
  @override
  List<SubstanceDefinitionCode>? get code {
    final value = _code;
    if (value == null) return null;
    if (_code is EqualUnmodifiableListView) return _code;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [name] Names applicable to this substance.;
  final List<SubstanceDefinitionName>? _name;

  /// [name] Names applicable to this substance.;
  @override
  List<SubstanceDefinitionName>? get name {
    final value = _name;
    if (value == null) return null;
    if (_name is EqualUnmodifiableListView) return _name;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [relationship] A link between this substance and another, with details of the relationship.;
  final List<SubstanceDefinitionRelationship>? _relationship;

  /// [relationship] A link between this substance and another, with details of the relationship.;
  @override
  List<SubstanceDefinitionRelationship>? get relationship {
    final value = _relationship;
    if (value == null) return null;
    if (_relationship is EqualUnmodifiableListView) return _relationship;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [sourceMaterial] Material or taxonomic/anatomical source for the substance.;
  @override
  final SubstanceDefinitionSourceMaterial? sourceMaterial;

  @override
  String toString() {
    return 'SubstanceDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, version: $version, versionElement: $versionElement, status: $status, classification: $classification, domain: $domain, grade: $grade, description: $description, descriptionElement: $descriptionElement, informationSource: $informationSource, note: $note, manufacturer: $manufacturer, supplier: $supplier, moiety: $moiety, property: $property, molecularWeight: $molecularWeight, structure: $structure, code: $code, name: $name, relationship: $relationship, sourceMaterial: $sourceMaterial)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinition &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            (identical(other.version, version) || other.version == version) &&
            (identical(other.versionElement, versionElement) ||
                other.versionElement == versionElement) &&
            (identical(other.status, status) || other.status == status) &&
            const DeepCollectionEquality()
                .equals(other._classification, _classification) &&
            (identical(other.domain, domain) || other.domain == domain) &&
            const DeepCollectionEquality().equals(other._grade, _grade) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.descriptionElement, descriptionElement) ||
                other.descriptionElement == descriptionElement) &&
            const DeepCollectionEquality()
                .equals(other._informationSource, _informationSource) &&
            const DeepCollectionEquality().equals(other._note, _note) &&
            const DeepCollectionEquality()
                .equals(other._manufacturer, _manufacturer) &&
            const DeepCollectionEquality().equals(other._supplier, _supplier) &&
            const DeepCollectionEquality().equals(other._moiety, _moiety) &&
            const DeepCollectionEquality().equals(other._property, _property) &&
            const DeepCollectionEquality()
                .equals(other._molecularWeight, _molecularWeight) &&
            (identical(other.structure, structure) ||
                other.structure == structure) &&
            const DeepCollectionEquality().equals(other._code, _code) &&
            const DeepCollectionEquality().equals(other._name, _name) &&
            const DeepCollectionEquality()
                .equals(other._relationship, _relationship) &&
            (identical(other.sourceMaterial, sourceMaterial) ||
                other.sourceMaterial == sourceMaterial));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_identifier),
        version,
        versionElement,
        status,
        const DeepCollectionEquality().hash(_classification),
        domain,
        const DeepCollectionEquality().hash(_grade),
        description,
        descriptionElement,
        const DeepCollectionEquality().hash(_informationSource),
        const DeepCollectionEquality().hash(_note),
        const DeepCollectionEquality().hash(_manufacturer),
        const DeepCollectionEquality().hash(_supplier),
        const DeepCollectionEquality().hash(_moiety),
        const DeepCollectionEquality().hash(_property),
        const DeepCollectionEquality().hash(_molecularWeight),
        structure,
        const DeepCollectionEquality().hash(_code),
        const DeepCollectionEquality().hash(_name),
        const DeepCollectionEquality().hash(_relationship),
        sourceMaterial
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionCopyWith<_$_SubstanceDefinition> get copyWith =>
      __$$_SubstanceDefinitionCopyWithImpl<_$_SubstanceDefinition>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinition extends SubstanceDefinition {
  factory _SubstanceDefinition(
          {final R4ResourceType resourceType,
          final String? id,
          final Meta? meta,
          final FhirUri? implicitRules,
          @JsonKey(name: '_implicitRules') final Element? implicitRulesElement,
          final Code? language,
          @JsonKey(name: '_language') final Element? languageElement,
          final Narrative? text,
          final List<Resource>? contained,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final List<Identifier>? identifier,
          final String? version,
          @JsonKey(name: '_version') final Element? versionElement,
          final CodeableConcept? status,
          final List<CodeableConcept>? classification,
          final CodeableConcept? domain,
          final List<CodeableConcept>? grade,
          final Markdown? description,
          @JsonKey(name: '_description') final Element? descriptionElement,
          final List<Reference>? informationSource,
          final List<Annotation>? note,
          final List<Reference>? manufacturer,
          final List<Reference>? supplier,
          final List<SubstanceDefinitionMoiety>? moiety,
          final List<SubstanceDefinitionProperty>? property,
          final List<SubstanceDefinitionMolecularWeight>? molecularWeight,
          final SubstanceDefinitionStructure? structure,
          final List<SubstanceDefinitionCode>? code,
          final List<SubstanceDefinitionName>? name,
          final List<SubstanceDefinitionRelationship>? relationship,
          final SubstanceDefinitionSourceMaterial? sourceMaterial}) =
      _$_SubstanceDefinition;
  _SubstanceDefinition._() : super._();

  factory _SubstanceDefinition.fromJson(Map<String, dynamic> json) =
      _$_SubstanceDefinition.fromJson;

  @override

  /// [resourceType] This is a SubstanceDefinition resource;
  R4ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the resource. Once assigned, this value never changes.;
  String? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is maintained by the infrastructure. Changes to the content might not always be associated with version changes to the resource.;
  Meta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.;
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] (_implicitRules): Extensions for implicitRules;
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.;
  Code? get language;
  @override

  /// [languageElement] (_language): Extensions for language;
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.;
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, nor can they have their own independent transaction scope.;
  List<Resource>? get contained;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the resource. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] Identifier by which this substance is known.;
  List<Identifier>? get identifier;
  @override

  /// [version] A business level version identifier of the substance.;
  String? get version;
  @override

  /// [versionElement] (_version): Extensions for version;
  @JsonKey(name: '_version')
  Element? get versionElement;
  @override

  /// [status] Status of substance within the catalogue e.g. active, retired.;
  CodeableConcept? get status;
  @override

  /// [classification] A high level categorization, e.g. polymer or nucleic acid, or food, chemical, biological, or a lower level such as the general types of polymer (linear or branch chain) or type of impurity (process related or contaminant).;
  List<CodeableConcept>? get classification;
  @override

  /// [domain] If the substance applies to human or veterinary use.;
  CodeableConcept? get domain;
  @override

  /// [grade] The quality standard, established benchmark, to which substance complies (e.g. USP/NF, Ph. Eur, JP, BP, Company Standard).;
  List<CodeableConcept>? get grade;
  @override

  /// [description] Textual description of the substance.;
  Markdown? get description;
  @override

  /// [descriptionElement] (_description): Extensions for description;
  @JsonKey(name: '_description')
  Element? get descriptionElement;
  @override

  /// [informationSource] Supporting literature.;
  List<Reference>? get informationSource;
  @override

  /// [note] Textual comment about the substance's catalogue or registry record.;
  List<Annotation>? get note;
  @override

  /// [manufacturer] The entity that creates, makes, produces or fabricates the substance. This is a set of potential manufacturers but is not necessarily comprehensive.;
  List<Reference>? get manufacturer;
  @override

  /// [supplier] An entity that is the source for the substance. It may be different from the manufacturer. Supplier is synonymous to a distributor.;
  List<Reference>? get supplier;
  @override

  /// [moiety] Moiety, for structural modifications.;
  List<SubstanceDefinitionMoiety>? get moiety;
  @override

  /// [property] General specifications for this substance.;
  List<SubstanceDefinitionProperty>? get property;
  @override

  /// [molecularWeight] The molecular weight or weight range (for proteins, polymers or nucleic acids).;
  List<SubstanceDefinitionMolecularWeight>? get molecularWeight;
  @override

  /// [structure] Structural information.;
  SubstanceDefinitionStructure? get structure;
  @override

  /// [code] Codes associated with the substance.;
  List<SubstanceDefinitionCode>? get code;
  @override

  /// [name] Names applicable to this substance.;
  List<SubstanceDefinitionName>? get name;
  @override

  /// [relationship] A link between this substance and another, with details of the relationship.;
  List<SubstanceDefinitionRelationship>? get relationship;
  @override

  /// [sourceMaterial] Material or taxonomic/anatomical source for the substance.;
  SubstanceDefinitionSourceMaterial? get sourceMaterial;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionCopyWith<_$_SubstanceDefinition> get copyWith =>
      throw _privateConstructorUsedError;
}

SubstanceDefinitionMoiety _$SubstanceDefinitionMoietyFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionMoiety.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionMoiety {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [role] Role that the moiety is playing.;
  CodeableConcept? get role => throw _privateConstructorUsedError;

  /// [identifier] Identifier by which this moiety substance is known.;
  Identifier? get identifier => throw _privateConstructorUsedError;

  /// [name] Textual name for this moiety substance.;
  String? get name => throw _privateConstructorUsedError;

  /// [nameElement] (_name): Extensions for name;
  @JsonKey(name: '_name')
  Element? get nameElement => throw _privateConstructorUsedError;

  /// [stereochemistry] Stereochemistry type.;
  CodeableConcept? get stereochemistry => throw _privateConstructorUsedError;

  /// [opticalActivity] Optical activity type.;
  CodeableConcept? get opticalActivity => throw _privateConstructorUsedError;

  /// [molecularFormula] Molecular formula for this moiety of this substance, typically using the Hill system.;
  String? get molecularFormula => throw _privateConstructorUsedError;

  /// [molecularFormulaElement] (_molecularFormula): Extensions for molecularFormula;
  @JsonKey(name: '_molecularFormula')
  Element? get molecularFormulaElement => throw _privateConstructorUsedError;

  /// [amountQuantity] Quantitative value for this moiety.;
  Quantity? get amountQuantity => throw _privateConstructorUsedError;

  /// [amountString] Quantitative value for this moiety.;
  Markdown? get amountString => throw _privateConstructorUsedError;

  /// [amountStringElement] (_amountString): Extensions for amountString;
  @JsonKey(name: '_amountString')
  Element? get amountStringElement => throw _privateConstructorUsedError;

  /// [measurementType] The measurement type of the quantitative value. In capturing the actual relative amounts of substances or molecular fragments it may be necessary to indicate whether the amount refers to, for example, a mole ratio or weight ratio.;
  CodeableConcept? get measurementType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionMoietyCopyWith<SubstanceDefinitionMoiety> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionMoietyCopyWith<$Res> {
  factory $SubstanceDefinitionMoietyCopyWith(SubstanceDefinitionMoiety value,
          $Res Function(SubstanceDefinitionMoiety) then) =
      _$SubstanceDefinitionMoietyCopyWithImpl<$Res, SubstanceDefinitionMoiety>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? role,
      Identifier? identifier,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      CodeableConcept? stereochemistry,
      CodeableConcept? opticalActivity,
      String? molecularFormula,
      @JsonKey(name: '_molecularFormula') Element? molecularFormulaElement,
      Quantity? amountQuantity,
      Markdown? amountString,
      @JsonKey(name: '_amountString') Element? amountStringElement,
      CodeableConcept? measurementType});

  $CodeableConceptCopyWith<$Res>? get role;
  $IdentifierCopyWith<$Res>? get identifier;
  $ElementCopyWith<$Res>? get nameElement;
  $CodeableConceptCopyWith<$Res>? get stereochemistry;
  $CodeableConceptCopyWith<$Res>? get opticalActivity;
  $ElementCopyWith<$Res>? get molecularFormulaElement;
  $QuantityCopyWith<$Res>? get amountQuantity;
  $ElementCopyWith<$Res>? get amountStringElement;
  $CodeableConceptCopyWith<$Res>? get measurementType;
}

/// @nodoc
class _$SubstanceDefinitionMoietyCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionMoiety>
    implements $SubstanceDefinitionMoietyCopyWith<$Res> {
  _$SubstanceDefinitionMoietyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? role = freezed,
    Object? identifier = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? stereochemistry = freezed,
    Object? opticalActivity = freezed,
    Object? molecularFormula = freezed,
    Object? molecularFormulaElement = freezed,
    Object? amountQuantity = freezed,
    Object? amountString = freezed,
    Object? amountStringElement = freezed,
    Object? measurementType = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      stereochemistry: freezed == stereochemistry
          ? _value.stereochemistry
          : stereochemistry // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      opticalActivity: freezed == opticalActivity
          ? _value.opticalActivity
          : opticalActivity // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      molecularFormula: freezed == molecularFormula
          ? _value.molecularFormula
          : molecularFormula // ignore: cast_nullable_to_non_nullable
              as String?,
      molecularFormulaElement: freezed == molecularFormulaElement
          ? _value.molecularFormulaElement
          : molecularFormulaElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      amountQuantity: freezed == amountQuantity
          ? _value.amountQuantity
          : amountQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      amountString: freezed == amountString
          ? _value.amountString
          : amountString // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      amountStringElement: freezed == amountStringElement
          ? _value.amountStringElement
          : amountStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      measurementType: freezed == measurementType
          ? _value.measurementType
          : measurementType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get role {
    if (_value.role == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.role!, (value) {
      return _then(_value.copyWith(role: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get identifier {
    if (_value.identifier == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.identifier!, (value) {
      return _then(_value.copyWith(identifier: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get nameElement {
    if (_value.nameElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.nameElement!, (value) {
      return _then(_value.copyWith(nameElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get stereochemistry {
    if (_value.stereochemistry == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.stereochemistry!, (value) {
      return _then(_value.copyWith(stereochemistry: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get opticalActivity {
    if (_value.opticalActivity == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.opticalActivity!, (value) {
      return _then(_value.copyWith(opticalActivity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get molecularFormulaElement {
    if (_value.molecularFormulaElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.molecularFormulaElement!, (value) {
      return _then(_value.copyWith(molecularFormulaElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get amountQuantity {
    if (_value.amountQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.amountQuantity!, (value) {
      return _then(_value.copyWith(amountQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get amountStringElement {
    if (_value.amountStringElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.amountStringElement!, (value) {
      return _then(_value.copyWith(amountStringElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get measurementType {
    if (_value.measurementType == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.measurementType!, (value) {
      return _then(_value.copyWith(measurementType: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionMoietyCopyWith<$Res>
    implements $SubstanceDefinitionMoietyCopyWith<$Res> {
  factory _$$_SubstanceDefinitionMoietyCopyWith(
          _$_SubstanceDefinitionMoiety value,
          $Res Function(_$_SubstanceDefinitionMoiety) then) =
      __$$_SubstanceDefinitionMoietyCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? role,
      Identifier? identifier,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      CodeableConcept? stereochemistry,
      CodeableConcept? opticalActivity,
      String? molecularFormula,
      @JsonKey(name: '_molecularFormula') Element? molecularFormulaElement,
      Quantity? amountQuantity,
      Markdown? amountString,
      @JsonKey(name: '_amountString') Element? amountStringElement,
      CodeableConcept? measurementType});

  @override
  $CodeableConceptCopyWith<$Res>? get role;
  @override
  $IdentifierCopyWith<$Res>? get identifier;
  @override
  $ElementCopyWith<$Res>? get nameElement;
  @override
  $CodeableConceptCopyWith<$Res>? get stereochemistry;
  @override
  $CodeableConceptCopyWith<$Res>? get opticalActivity;
  @override
  $ElementCopyWith<$Res>? get molecularFormulaElement;
  @override
  $QuantityCopyWith<$Res>? get amountQuantity;
  @override
  $ElementCopyWith<$Res>? get amountStringElement;
  @override
  $CodeableConceptCopyWith<$Res>? get measurementType;
}

/// @nodoc
class __$$_SubstanceDefinitionMoietyCopyWithImpl<$Res>
    extends _$SubstanceDefinitionMoietyCopyWithImpl<$Res,
        _$_SubstanceDefinitionMoiety>
    implements _$$_SubstanceDefinitionMoietyCopyWith<$Res> {
  __$$_SubstanceDefinitionMoietyCopyWithImpl(
      _$_SubstanceDefinitionMoiety _value,
      $Res Function(_$_SubstanceDefinitionMoiety) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? role = freezed,
    Object? identifier = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? stereochemistry = freezed,
    Object? opticalActivity = freezed,
    Object? molecularFormula = freezed,
    Object? molecularFormulaElement = freezed,
    Object? amountQuantity = freezed,
    Object? amountString = freezed,
    Object? amountStringElement = freezed,
    Object? measurementType = freezed,
  }) {
    return _then(_$_SubstanceDefinitionMoiety(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      stereochemistry: freezed == stereochemistry
          ? _value.stereochemistry
          : stereochemistry // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      opticalActivity: freezed == opticalActivity
          ? _value.opticalActivity
          : opticalActivity // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      molecularFormula: freezed == molecularFormula
          ? _value.molecularFormula
          : molecularFormula // ignore: cast_nullable_to_non_nullable
              as String?,
      molecularFormulaElement: freezed == molecularFormulaElement
          ? _value.molecularFormulaElement
          : molecularFormulaElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      amountQuantity: freezed == amountQuantity
          ? _value.amountQuantity
          : amountQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      amountString: freezed == amountString
          ? _value.amountString
          : amountString // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      amountStringElement: freezed == amountStringElement
          ? _value.amountStringElement
          : amountStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      measurementType: freezed == measurementType
          ? _value.measurementType
          : measurementType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionMoiety extends _SubstanceDefinitionMoiety {
  _$_SubstanceDefinitionMoiety(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.role,
      this.identifier,
      this.name,
      @JsonKey(name: '_name') this.nameElement,
      this.stereochemistry,
      this.opticalActivity,
      this.molecularFormula,
      @JsonKey(name: '_molecularFormula') this.molecularFormulaElement,
      this.amountQuantity,
      this.amountString,
      @JsonKey(name: '_amountString') this.amountStringElement,
      this.measurementType})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstanceDefinitionMoiety.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionMoietyFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [role] Role that the moiety is playing.;
  @override
  final CodeableConcept? role;

  /// [identifier] Identifier by which this moiety substance is known.;
  @override
  final Identifier? identifier;

  /// [name] Textual name for this moiety substance.;
  @override
  final String? name;

  /// [nameElement] (_name): Extensions for name;
  @override
  @JsonKey(name: '_name')
  final Element? nameElement;

  /// [stereochemistry] Stereochemistry type.;
  @override
  final CodeableConcept? stereochemistry;

  /// [opticalActivity] Optical activity type.;
  @override
  final CodeableConcept? opticalActivity;

  /// [molecularFormula] Molecular formula for this moiety of this substance, typically using the Hill system.;
  @override
  final String? molecularFormula;

  /// [molecularFormulaElement] (_molecularFormula): Extensions for molecularFormula;
  @override
  @JsonKey(name: '_molecularFormula')
  final Element? molecularFormulaElement;

  /// [amountQuantity] Quantitative value for this moiety.;
  @override
  final Quantity? amountQuantity;

  /// [amountString] Quantitative value for this moiety.;
  @override
  final Markdown? amountString;

  /// [amountStringElement] (_amountString): Extensions for amountString;
  @override
  @JsonKey(name: '_amountString')
  final Element? amountStringElement;

  /// [measurementType] The measurement type of the quantitative value. In capturing the actual relative amounts of substances or molecular fragments it may be necessary to indicate whether the amount refers to, for example, a mole ratio or weight ratio.;
  @override
  final CodeableConcept? measurementType;

  @override
  String toString() {
    return 'SubstanceDefinitionMoiety(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, role: $role, identifier: $identifier, name: $name, nameElement: $nameElement, stereochemistry: $stereochemistry, opticalActivity: $opticalActivity, molecularFormula: $molecularFormula, molecularFormulaElement: $molecularFormulaElement, amountQuantity: $amountQuantity, amountString: $amountString, amountStringElement: $amountStringElement, measurementType: $measurementType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionMoiety &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.nameElement, nameElement) ||
                other.nameElement == nameElement) &&
            (identical(other.stereochemistry, stereochemistry) ||
                other.stereochemistry == stereochemistry) &&
            (identical(other.opticalActivity, opticalActivity) ||
                other.opticalActivity == opticalActivity) &&
            (identical(other.molecularFormula, molecularFormula) ||
                other.molecularFormula == molecularFormula) &&
            (identical(
                    other.molecularFormulaElement, molecularFormulaElement) ||
                other.molecularFormulaElement == molecularFormulaElement) &&
            (identical(other.amountQuantity, amountQuantity) ||
                other.amountQuantity == amountQuantity) &&
            (identical(other.amountString, amountString) ||
                other.amountString == amountString) &&
            (identical(other.amountStringElement, amountStringElement) ||
                other.amountStringElement == amountStringElement) &&
            (identical(other.measurementType, measurementType) ||
                other.measurementType == measurementType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      role,
      identifier,
      name,
      nameElement,
      stereochemistry,
      opticalActivity,
      molecularFormula,
      molecularFormulaElement,
      amountQuantity,
      amountString,
      amountStringElement,
      measurementType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionMoietyCopyWith<_$_SubstanceDefinitionMoiety>
      get copyWith => __$$_SubstanceDefinitionMoietyCopyWithImpl<
          _$_SubstanceDefinitionMoiety>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionMoietyToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionMoiety extends SubstanceDefinitionMoiety {
  factory _SubstanceDefinitionMoiety(
      {final String? id,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? role,
      final Identifier? identifier,
      final String? name,
      @JsonKey(name: '_name')
          final Element? nameElement,
      final CodeableConcept? stereochemistry,
      final CodeableConcept? opticalActivity,
      final String? molecularFormula,
      @JsonKey(name: '_molecularFormula')
          final Element? molecularFormulaElement,
      final Quantity? amountQuantity,
      final Markdown? amountString,
      @JsonKey(name: '_amountString')
          final Element? amountStringElement,
      final CodeableConcept? measurementType}) = _$_SubstanceDefinitionMoiety;
  _SubstanceDefinitionMoiety._() : super._();

  factory _SubstanceDefinitionMoiety.fromJson(Map<String, dynamic> json) =
      _$_SubstanceDefinitionMoiety.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [role] Role that the moiety is playing.;
  CodeableConcept? get role;
  @override

  /// [identifier] Identifier by which this moiety substance is known.;
  Identifier? get identifier;
  @override

  /// [name] Textual name for this moiety substance.;
  String? get name;
  @override

  /// [nameElement] (_name): Extensions for name;
  @JsonKey(name: '_name')
  Element? get nameElement;
  @override

  /// [stereochemistry] Stereochemistry type.;
  CodeableConcept? get stereochemistry;
  @override

  /// [opticalActivity] Optical activity type.;
  CodeableConcept? get opticalActivity;
  @override

  /// [molecularFormula] Molecular formula for this moiety of this substance, typically using the Hill system.;
  String? get molecularFormula;
  @override

  /// [molecularFormulaElement] (_molecularFormula): Extensions for molecularFormula;
  @JsonKey(name: '_molecularFormula')
  Element? get molecularFormulaElement;
  @override

  /// [amountQuantity] Quantitative value for this moiety.;
  Quantity? get amountQuantity;
  @override

  /// [amountString] Quantitative value for this moiety.;
  Markdown? get amountString;
  @override

  /// [amountStringElement] (_amountString): Extensions for amountString;
  @JsonKey(name: '_amountString')
  Element? get amountStringElement;
  @override

  /// [measurementType] The measurement type of the quantitative value. In capturing the actual relative amounts of substances or molecular fragments it may be necessary to indicate whether the amount refers to, for example, a mole ratio or weight ratio.;
  CodeableConcept? get measurementType;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionMoietyCopyWith<_$_SubstanceDefinitionMoiety>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinitionProperty _$SubstanceDefinitionPropertyFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionProperty.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionProperty {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] A code expressing the type of property.;
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [valueCodeableConcept] A value for the property.;
  CodeableConcept? get valueCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [valueQuantity] A value for the property.;
  Quantity? get valueQuantity => throw _privateConstructorUsedError;

  /// [valueDate] A value for the property.;
  Date? get valueDate => throw _privateConstructorUsedError;

  /// [valueDateElement] (_valueDate): Extensions for valueDate;
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement => throw _privateConstructorUsedError;

  /// [valueBoolean] A value for the property.;
  Boolean? get valueBoolean => throw _privateConstructorUsedError;

  /// [valueBooleanElement] (_valueBoolean): Extensions for valueBoolean;
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement => throw _privateConstructorUsedError;

  /// [valueAttachment] A value for the property.;
  Attachment? get valueAttachment => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionPropertyCopyWith<SubstanceDefinitionProperty>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionPropertyCopyWith<$Res> {
  factory $SubstanceDefinitionPropertyCopyWith(
          SubstanceDefinitionProperty value,
          $Res Function(SubstanceDefinitionProperty) then) =
      _$SubstanceDefinitionPropertyCopyWithImpl<$Res,
          SubstanceDefinitionProperty>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      Quantity? valueQuantity,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment});

  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  $QuantityCopyWith<$Res>? get valueQuantity;
  $ElementCopyWith<$Res>? get valueDateElement;
  $ElementCopyWith<$Res>? get valueBooleanElement;
  $AttachmentCopyWith<$Res>? get valueAttachment;
}

/// @nodoc
class _$SubstanceDefinitionPropertyCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionProperty>
    implements $SubstanceDefinitionPropertyCopyWith<$Res> {
  _$SubstanceDefinitionPropertyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueQuantity = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept {
    if (_value.valueCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.valueCodeableConcept!,
        (value) {
      return _then(_value.copyWith(valueCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get valueQuantity {
    if (_value.valueQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.valueQuantity!, (value) {
      return _then(_value.copyWith(valueQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueDateElement {
    if (_value.valueDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueDateElement!, (value) {
      return _then(_value.copyWith(valueDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueBooleanElement {
    if (_value.valueBooleanElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueBooleanElement!, (value) {
      return _then(_value.copyWith(valueBooleanElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get valueAttachment {
    if (_value.valueAttachment == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.valueAttachment!, (value) {
      return _then(_value.copyWith(valueAttachment: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionPropertyCopyWith<$Res>
    implements $SubstanceDefinitionPropertyCopyWith<$Res> {
  factory _$$_SubstanceDefinitionPropertyCopyWith(
          _$_SubstanceDefinitionProperty value,
          $Res Function(_$_SubstanceDefinitionProperty) then) =
      __$$_SubstanceDefinitionPropertyCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? valueCodeableConcept,
      Quantity? valueQuantity,
      Date? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      Attachment? valueAttachment});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res>? get valueCodeableConcept;
  @override
  $QuantityCopyWith<$Res>? get valueQuantity;
  @override
  $ElementCopyWith<$Res>? get valueDateElement;
  @override
  $ElementCopyWith<$Res>? get valueBooleanElement;
  @override
  $AttachmentCopyWith<$Res>? get valueAttachment;
}

/// @nodoc
class __$$_SubstanceDefinitionPropertyCopyWithImpl<$Res>
    extends _$SubstanceDefinitionPropertyCopyWithImpl<$Res,
        _$_SubstanceDefinitionProperty>
    implements _$$_SubstanceDefinitionPropertyCopyWith<$Res> {
  __$$_SubstanceDefinitionPropertyCopyWithImpl(
      _$_SubstanceDefinitionProperty _value,
      $Res Function(_$_SubstanceDefinitionProperty) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? valueCodeableConcept = freezed,
    Object? valueQuantity = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueAttachment = freezed,
  }) {
    return _then(_$_SubstanceDefinitionProperty(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      valueCodeableConcept: freezed == valueCodeableConcept
          ? _value.valueCodeableConcept
          : valueCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as Date?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionProperty extends _SubstanceDefinitionProperty {
  _$_SubstanceDefinitionProperty(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.type,
      this.valueCodeableConcept,
      this.valueQuantity,
      this.valueDate,
      @JsonKey(name: '_valueDate') this.valueDateElement,
      this.valueBoolean,
      @JsonKey(name: '_valueBoolean') this.valueBooleanElement,
      this.valueAttachment})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstanceDefinitionProperty.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionPropertyFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] A code expressing the type of property.;
  @override
  final CodeableConcept type;

  /// [valueCodeableConcept] A value for the property.;
  @override
  final CodeableConcept? valueCodeableConcept;

  /// [valueQuantity] A value for the property.;
  @override
  final Quantity? valueQuantity;

  /// [valueDate] A value for the property.;
  @override
  final Date? valueDate;

  /// [valueDateElement] (_valueDate): Extensions for valueDate;
  @override
  @JsonKey(name: '_valueDate')
  final Element? valueDateElement;

  /// [valueBoolean] A value for the property.;
  @override
  final Boolean? valueBoolean;

  /// [valueBooleanElement] (_valueBoolean): Extensions for valueBoolean;
  @override
  @JsonKey(name: '_valueBoolean')
  final Element? valueBooleanElement;

  /// [valueAttachment] A value for the property.;
  @override
  final Attachment? valueAttachment;

  @override
  String toString() {
    return 'SubstanceDefinitionProperty(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, valueCodeableConcept: $valueCodeableConcept, valueQuantity: $valueQuantity, valueDate: $valueDate, valueDateElement: $valueDateElement, valueBoolean: $valueBoolean, valueBooleanElement: $valueBooleanElement, valueAttachment: $valueAttachment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionProperty &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.valueCodeableConcept, valueCodeableConcept) ||
                other.valueCodeableConcept == valueCodeableConcept) &&
            (identical(other.valueQuantity, valueQuantity) ||
                other.valueQuantity == valueQuantity) &&
            (identical(other.valueDate, valueDate) ||
                other.valueDate == valueDate) &&
            (identical(other.valueDateElement, valueDateElement) ||
                other.valueDateElement == valueDateElement) &&
            (identical(other.valueBoolean, valueBoolean) ||
                other.valueBoolean == valueBoolean) &&
            (identical(other.valueBooleanElement, valueBooleanElement) ||
                other.valueBooleanElement == valueBooleanElement) &&
            (identical(other.valueAttachment, valueAttachment) ||
                other.valueAttachment == valueAttachment));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      valueCodeableConcept,
      valueQuantity,
      valueDate,
      valueDateElement,
      valueBoolean,
      valueBooleanElement,
      valueAttachment);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionPropertyCopyWith<_$_SubstanceDefinitionProperty>
      get copyWith => __$$_SubstanceDefinitionPropertyCopyWithImpl<
          _$_SubstanceDefinitionProperty>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionPropertyToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionProperty
    extends SubstanceDefinitionProperty {
  factory _SubstanceDefinitionProperty(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final CodeableConcept type,
      final CodeableConcept? valueCodeableConcept,
      final Quantity? valueQuantity,
      final Date? valueDate,
      @JsonKey(name: '_valueDate') final Element? valueDateElement,
      final Boolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') final Element? valueBooleanElement,
      final Attachment? valueAttachment}) = _$_SubstanceDefinitionProperty;
  _SubstanceDefinitionProperty._() : super._();

  factory _SubstanceDefinitionProperty.fromJson(Map<String, dynamic> json) =
      _$_SubstanceDefinitionProperty.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] A code expressing the type of property.;
  CodeableConcept get type;
  @override

  /// [valueCodeableConcept] A value for the property.;
  CodeableConcept? get valueCodeableConcept;
  @override

  /// [valueQuantity] A value for the property.;
  Quantity? get valueQuantity;
  @override

  /// [valueDate] A value for the property.;
  Date? get valueDate;
  @override

  /// [valueDateElement] (_valueDate): Extensions for valueDate;
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement;
  @override

  /// [valueBoolean] A value for the property.;
  Boolean? get valueBoolean;
  @override

  /// [valueBooleanElement] (_valueBoolean): Extensions for valueBoolean;
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement;
  @override

  /// [valueAttachment] A value for the property.;
  Attachment? get valueAttachment;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionPropertyCopyWith<_$_SubstanceDefinitionProperty>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinitionMolecularWeight _$SubstanceDefinitionMolecularWeightFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionMolecularWeight.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionMolecularWeight {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [method] The method by which the molecular weight was determined.;
  CodeableConcept? get method => throw _privateConstructorUsedError;

  /// [type] Type of molecular weight such as exact, average (also known as. number average), weight average.;
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [amount] Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.;
  Quantity get amount => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionMolecularWeightCopyWith<
          SubstanceDefinitionMolecularWeight>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionMolecularWeightCopyWith<$Res> {
  factory $SubstanceDefinitionMolecularWeightCopyWith(
          SubstanceDefinitionMolecularWeight value,
          $Res Function(SubstanceDefinitionMolecularWeight) then) =
      _$SubstanceDefinitionMolecularWeightCopyWithImpl<$Res,
          SubstanceDefinitionMolecularWeight>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? method,
      CodeableConcept? type,
      Quantity amount});

  $CodeableConceptCopyWith<$Res>? get method;
  $CodeableConceptCopyWith<$Res>? get type;
  $QuantityCopyWith<$Res> get amount;
}

/// @nodoc
class _$SubstanceDefinitionMolecularWeightCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionMolecularWeight>
    implements $SubstanceDefinitionMolecularWeightCopyWith<$Res> {
  _$SubstanceDefinitionMolecularWeightCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? method = freezed,
    Object? type = freezed,
    Object? amount = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      method: freezed == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Quantity,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get method {
    if (_value.method == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.method!, (value) {
      return _then(_value.copyWith(method: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res> get amount {
    return $QuantityCopyWith<$Res>(_value.amount, (value) {
      return _then(_value.copyWith(amount: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionMolecularWeightCopyWith<$Res>
    implements $SubstanceDefinitionMolecularWeightCopyWith<$Res> {
  factory _$$_SubstanceDefinitionMolecularWeightCopyWith(
          _$_SubstanceDefinitionMolecularWeight value,
          $Res Function(_$_SubstanceDefinitionMolecularWeight) then) =
      __$$_SubstanceDefinitionMolecularWeightCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? method,
      CodeableConcept? type,
      Quantity amount});

  @override
  $CodeableConceptCopyWith<$Res>? get method;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $QuantityCopyWith<$Res> get amount;
}

/// @nodoc
class __$$_SubstanceDefinitionMolecularWeightCopyWithImpl<$Res>
    extends _$SubstanceDefinitionMolecularWeightCopyWithImpl<$Res,
        _$_SubstanceDefinitionMolecularWeight>
    implements _$$_SubstanceDefinitionMolecularWeightCopyWith<$Res> {
  __$$_SubstanceDefinitionMolecularWeightCopyWithImpl(
      _$_SubstanceDefinitionMolecularWeight _value,
      $Res Function(_$_SubstanceDefinitionMolecularWeight) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? method = freezed,
    Object? type = freezed,
    Object? amount = null,
  }) {
    return _then(_$_SubstanceDefinitionMolecularWeight(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      method: freezed == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Quantity,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionMolecularWeight
    extends _SubstanceDefinitionMolecularWeight {
  _$_SubstanceDefinitionMolecularWeight(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.method,
      this.type,
      required this.amount})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstanceDefinitionMolecularWeight.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionMolecularWeightFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [method] The method by which the molecular weight was determined.;
  @override
  final CodeableConcept? method;

  /// [type] Type of molecular weight such as exact, average (also known as. number average), weight average.;
  @override
  final CodeableConcept? type;

  /// [amount] Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.;
  @override
  final Quantity amount;

  @override
  String toString() {
    return 'SubstanceDefinitionMolecularWeight(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, method: $method, type: $type, amount: $amount)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionMolecularWeight &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.method, method) || other.method == method) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.amount, amount) || other.amount == amount));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      method,
      type,
      amount);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionMolecularWeightCopyWith<
          _$_SubstanceDefinitionMolecularWeight>
      get copyWith => __$$_SubstanceDefinitionMolecularWeightCopyWithImpl<
          _$_SubstanceDefinitionMolecularWeight>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionMolecularWeightToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionMolecularWeight
    extends SubstanceDefinitionMolecularWeight {
  factory _SubstanceDefinitionMolecularWeight(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? method,
      final CodeableConcept? type,
      required final Quantity amount}) = _$_SubstanceDefinitionMolecularWeight;
  _SubstanceDefinitionMolecularWeight._() : super._();

  factory _SubstanceDefinitionMolecularWeight.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceDefinitionMolecularWeight.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [method] The method by which the molecular weight was determined.;
  CodeableConcept? get method;
  @override

  /// [type] Type of molecular weight such as exact, average (also known as. number average), weight average.;
  CodeableConcept? get type;
  @override

  /// [amount] Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.;
  Quantity get amount;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionMolecularWeightCopyWith<
          _$_SubstanceDefinitionMolecularWeight>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinitionStructure _$SubstanceDefinitionStructureFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionStructure.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionStructure {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [stereochemistry] Stereochemistry type.;
  CodeableConcept? get stereochemistry => throw _privateConstructorUsedError;

  /// [opticalActivity] Optical activity type.;
  CodeableConcept? get opticalActivity => throw _privateConstructorUsedError;

  /// [molecularFormula] Molecular formula of this substance, typically using the Hill system.;
  String? get molecularFormula => throw _privateConstructorUsedError;

  /// [molecularFormulaElement] (_molecularFormula): Extensions for molecularFormula;
  @JsonKey(name: '_molecularFormula')
  Element? get molecularFormulaElement => throw _privateConstructorUsedError;

  /// [molecularFormulaByMoiety] Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.;
  String? get molecularFormulaByMoiety => throw _privateConstructorUsedError;
  @JsonKey(name: '_molecularFormulaByMoiety')
  Element? get molecularFormulaByMoietyElement =>
      throw _privateConstructorUsedError;

  /// [molecularWeight] The molecular weight or weight range (for proteins, polymers or nucleic acids).;
  SubstanceDefinitionMolecularWeight? get molecularWeight =>
      throw _privateConstructorUsedError;

  /// [technique] The method used to elucidate the structure or characterization of the drug substance. Examples: X-ray, HPLC, NMR, Peptide mapping, Ligand binding assay.;
  List<CodeableConcept>? get technique => throw _privateConstructorUsedError;

  /// [sourceDocument] The source of information about the structure.;
  List<Reference>? get sourceDocument => throw _privateConstructorUsedError;

  /// [representation] A depiction of the structure or characterization of the substance.;
  List<SubstanceDefinitionRepresentation>? get representation =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionStructureCopyWith<SubstanceDefinitionStructure>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionStructureCopyWith<$Res> {
  factory $SubstanceDefinitionStructureCopyWith(
          SubstanceDefinitionStructure value,
          $Res Function(SubstanceDefinitionStructure) then) =
      _$SubstanceDefinitionStructureCopyWithImpl<$Res,
          SubstanceDefinitionStructure>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? stereochemistry,
      CodeableConcept? opticalActivity,
      String? molecularFormula,
      @JsonKey(name: '_molecularFormula')
          Element? molecularFormulaElement,
      String? molecularFormulaByMoiety,
      @JsonKey(name: '_molecularFormulaByMoiety')
          Element? molecularFormulaByMoietyElement,
      SubstanceDefinitionMolecularWeight? molecularWeight,
      List<CodeableConcept>? technique,
      List<Reference>? sourceDocument,
      List<SubstanceDefinitionRepresentation>? representation});

  $CodeableConceptCopyWith<$Res>? get stereochemistry;
  $CodeableConceptCopyWith<$Res>? get opticalActivity;
  $ElementCopyWith<$Res>? get molecularFormulaElement;
  $ElementCopyWith<$Res>? get molecularFormulaByMoietyElement;
  $SubstanceDefinitionMolecularWeightCopyWith<$Res>? get molecularWeight;
}

/// @nodoc
class _$SubstanceDefinitionStructureCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionStructure>
    implements $SubstanceDefinitionStructureCopyWith<$Res> {
  _$SubstanceDefinitionStructureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? stereochemistry = freezed,
    Object? opticalActivity = freezed,
    Object? molecularFormula = freezed,
    Object? molecularFormulaElement = freezed,
    Object? molecularFormulaByMoiety = freezed,
    Object? molecularFormulaByMoietyElement = freezed,
    Object? molecularWeight = freezed,
    Object? technique = freezed,
    Object? sourceDocument = freezed,
    Object? representation = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      stereochemistry: freezed == stereochemistry
          ? _value.stereochemistry
          : stereochemistry // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      opticalActivity: freezed == opticalActivity
          ? _value.opticalActivity
          : opticalActivity // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      molecularFormula: freezed == molecularFormula
          ? _value.molecularFormula
          : molecularFormula // ignore: cast_nullable_to_non_nullable
              as String?,
      molecularFormulaElement: freezed == molecularFormulaElement
          ? _value.molecularFormulaElement
          : molecularFormulaElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      molecularFormulaByMoiety: freezed == molecularFormulaByMoiety
          ? _value.molecularFormulaByMoiety
          : molecularFormulaByMoiety // ignore: cast_nullable_to_non_nullable
              as String?,
      molecularFormulaByMoietyElement: freezed ==
              molecularFormulaByMoietyElement
          ? _value.molecularFormulaByMoietyElement
          : molecularFormulaByMoietyElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      molecularWeight: freezed == molecularWeight
          ? _value.molecularWeight
          : molecularWeight // ignore: cast_nullable_to_non_nullable
              as SubstanceDefinitionMolecularWeight?,
      technique: freezed == technique
          ? _value.technique
          : technique // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      sourceDocument: freezed == sourceDocument
          ? _value.sourceDocument
          : sourceDocument // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      representation: freezed == representation
          ? _value.representation
          : representation // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionRepresentation>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get stereochemistry {
    if (_value.stereochemistry == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.stereochemistry!, (value) {
      return _then(_value.copyWith(stereochemistry: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get opticalActivity {
    if (_value.opticalActivity == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.opticalActivity!, (value) {
      return _then(_value.copyWith(opticalActivity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get molecularFormulaElement {
    if (_value.molecularFormulaElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.molecularFormulaElement!, (value) {
      return _then(_value.copyWith(molecularFormulaElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get molecularFormulaByMoietyElement {
    if (_value.molecularFormulaByMoietyElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.molecularFormulaByMoietyElement!,
        (value) {
      return _then(
          _value.copyWith(molecularFormulaByMoietyElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SubstanceDefinitionMolecularWeightCopyWith<$Res>? get molecularWeight {
    if (_value.molecularWeight == null) {
      return null;
    }

    return $SubstanceDefinitionMolecularWeightCopyWith<$Res>(
        _value.molecularWeight!, (value) {
      return _then(_value.copyWith(molecularWeight: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionStructureCopyWith<$Res>
    implements $SubstanceDefinitionStructureCopyWith<$Res> {
  factory _$$_SubstanceDefinitionStructureCopyWith(
          _$_SubstanceDefinitionStructure value,
          $Res Function(_$_SubstanceDefinitionStructure) then) =
      __$$_SubstanceDefinitionStructureCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension')
          List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? stereochemistry,
      CodeableConcept? opticalActivity,
      String? molecularFormula,
      @JsonKey(name: '_molecularFormula')
          Element? molecularFormulaElement,
      String? molecularFormulaByMoiety,
      @JsonKey(name: '_molecularFormulaByMoiety')
          Element? molecularFormulaByMoietyElement,
      SubstanceDefinitionMolecularWeight? molecularWeight,
      List<CodeableConcept>? technique,
      List<Reference>? sourceDocument,
      List<SubstanceDefinitionRepresentation>? representation});

  @override
  $CodeableConceptCopyWith<$Res>? get stereochemistry;
  @override
  $CodeableConceptCopyWith<$Res>? get opticalActivity;
  @override
  $ElementCopyWith<$Res>? get molecularFormulaElement;
  @override
  $ElementCopyWith<$Res>? get molecularFormulaByMoietyElement;
  @override
  $SubstanceDefinitionMolecularWeightCopyWith<$Res>? get molecularWeight;
}

/// @nodoc
class __$$_SubstanceDefinitionStructureCopyWithImpl<$Res>
    extends _$SubstanceDefinitionStructureCopyWithImpl<$Res,
        _$_SubstanceDefinitionStructure>
    implements _$$_SubstanceDefinitionStructureCopyWith<$Res> {
  __$$_SubstanceDefinitionStructureCopyWithImpl(
      _$_SubstanceDefinitionStructure _value,
      $Res Function(_$_SubstanceDefinitionStructure) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? stereochemistry = freezed,
    Object? opticalActivity = freezed,
    Object? molecularFormula = freezed,
    Object? molecularFormulaElement = freezed,
    Object? molecularFormulaByMoiety = freezed,
    Object? molecularFormulaByMoietyElement = freezed,
    Object? molecularWeight = freezed,
    Object? technique = freezed,
    Object? sourceDocument = freezed,
    Object? representation = freezed,
  }) {
    return _then(_$_SubstanceDefinitionStructure(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      stereochemistry: freezed == stereochemistry
          ? _value.stereochemistry
          : stereochemistry // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      opticalActivity: freezed == opticalActivity
          ? _value.opticalActivity
          : opticalActivity // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      molecularFormula: freezed == molecularFormula
          ? _value.molecularFormula
          : molecularFormula // ignore: cast_nullable_to_non_nullable
              as String?,
      molecularFormulaElement: freezed == molecularFormulaElement
          ? _value.molecularFormulaElement
          : molecularFormulaElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      molecularFormulaByMoiety: freezed == molecularFormulaByMoiety
          ? _value.molecularFormulaByMoiety
          : molecularFormulaByMoiety // ignore: cast_nullable_to_non_nullable
              as String?,
      molecularFormulaByMoietyElement: freezed ==
              molecularFormulaByMoietyElement
          ? _value.molecularFormulaByMoietyElement
          : molecularFormulaByMoietyElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      molecularWeight: freezed == molecularWeight
          ? _value.molecularWeight
          : molecularWeight // ignore: cast_nullable_to_non_nullable
              as SubstanceDefinitionMolecularWeight?,
      technique: freezed == technique
          ? _value._technique
          : technique // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      sourceDocument: freezed == sourceDocument
          ? _value._sourceDocument
          : sourceDocument // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      representation: freezed == representation
          ? _value._representation
          : representation // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionRepresentation>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionStructure extends _SubstanceDefinitionStructure {
  _$_SubstanceDefinitionStructure(
      {this.id,
      @JsonKey(name: 'extension')
          final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.stereochemistry,
      this.opticalActivity,
      this.molecularFormula,
      @JsonKey(name: '_molecularFormula')
          this.molecularFormulaElement,
      this.molecularFormulaByMoiety,
      @JsonKey(name: '_molecularFormulaByMoiety')
          this.molecularFormulaByMoietyElement,
      this.molecularWeight,
      final List<CodeableConcept>? technique,
      final List<Reference>? sourceDocument,
      final List<SubstanceDefinitionRepresentation>? representation})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _technique = technique,
        _sourceDocument = sourceDocument,
        _representation = representation,
        super._();

  factory _$_SubstanceDefinitionStructure.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionStructureFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [stereochemistry] Stereochemistry type.;
  @override
  final CodeableConcept? stereochemistry;

  /// [opticalActivity] Optical activity type.;
  @override
  final CodeableConcept? opticalActivity;

  /// [molecularFormula] Molecular formula of this substance, typically using the Hill system.;
  @override
  final String? molecularFormula;

  /// [molecularFormulaElement] (_molecularFormula): Extensions for molecularFormula;
  @override
  @JsonKey(name: '_molecularFormula')
  final Element? molecularFormulaElement;

  /// [molecularFormulaByMoiety] Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.;
  @override
  final String? molecularFormulaByMoiety;
  @override
  @JsonKey(name: '_molecularFormulaByMoiety')
  final Element? molecularFormulaByMoietyElement;

  /// [molecularWeight] The molecular weight or weight range (for proteins, polymers or nucleic acids).;
  @override
  final SubstanceDefinitionMolecularWeight? molecularWeight;

  /// [technique] The method used to elucidate the structure or characterization of the drug substance. Examples: X-ray, HPLC, NMR, Peptide mapping, Ligand binding assay.;
  final List<CodeableConcept>? _technique;

  /// [technique] The method used to elucidate the structure or characterization of the drug substance. Examples: X-ray, HPLC, NMR, Peptide mapping, Ligand binding assay.;
  @override
  List<CodeableConcept>? get technique {
    final value = _technique;
    if (value == null) return null;
    if (_technique is EqualUnmodifiableListView) return _technique;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [sourceDocument] The source of information about the structure.;
  final List<Reference>? _sourceDocument;

  /// [sourceDocument] The source of information about the structure.;
  @override
  List<Reference>? get sourceDocument {
    final value = _sourceDocument;
    if (value == null) return null;
    if (_sourceDocument is EqualUnmodifiableListView) return _sourceDocument;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [representation] A depiction of the structure or characterization of the substance.;
  final List<SubstanceDefinitionRepresentation>? _representation;

  /// [representation] A depiction of the structure or characterization of the substance.;
  @override
  List<SubstanceDefinitionRepresentation>? get representation {
    final value = _representation;
    if (value == null) return null;
    if (_representation is EqualUnmodifiableListView) return _representation;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstanceDefinitionStructure(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, stereochemistry: $stereochemistry, opticalActivity: $opticalActivity, molecularFormula: $molecularFormula, molecularFormulaElement: $molecularFormulaElement, molecularFormulaByMoiety: $molecularFormulaByMoiety, molecularFormulaByMoietyElement: $molecularFormulaByMoietyElement, molecularWeight: $molecularWeight, technique: $technique, sourceDocument: $sourceDocument, representation: $representation)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionStructure &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.stereochemistry, stereochemistry) ||
                other.stereochemistry == stereochemistry) &&
            (identical(other.opticalActivity, opticalActivity) ||
                other.opticalActivity == opticalActivity) &&
            (identical(other.molecularFormula, molecularFormula) ||
                other.molecularFormula == molecularFormula) &&
            (identical(
                    other.molecularFormulaElement, molecularFormulaElement) ||
                other.molecularFormulaElement == molecularFormulaElement) &&
            (identical(
                    other.molecularFormulaByMoiety, molecularFormulaByMoiety) ||
                other.molecularFormulaByMoiety == molecularFormulaByMoiety) &&
            (identical(other.molecularFormulaByMoietyElement,
                    molecularFormulaByMoietyElement) ||
                other.molecularFormulaByMoietyElement ==
                    molecularFormulaByMoietyElement) &&
            (identical(other.molecularWeight, molecularWeight) ||
                other.molecularWeight == molecularWeight) &&
            const DeepCollectionEquality()
                .equals(other._technique, _technique) &&
            const DeepCollectionEquality()
                .equals(other._sourceDocument, _sourceDocument) &&
            const DeepCollectionEquality()
                .equals(other._representation, _representation));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      stereochemistry,
      opticalActivity,
      molecularFormula,
      molecularFormulaElement,
      molecularFormulaByMoiety,
      molecularFormulaByMoietyElement,
      molecularWeight,
      const DeepCollectionEquality().hash(_technique),
      const DeepCollectionEquality().hash(_sourceDocument),
      const DeepCollectionEquality().hash(_representation));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionStructureCopyWith<_$_SubstanceDefinitionStructure>
      get copyWith => __$$_SubstanceDefinitionStructureCopyWithImpl<
          _$_SubstanceDefinitionStructure>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionStructureToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionStructure
    extends SubstanceDefinitionStructure {
  factory _SubstanceDefinitionStructure(
          {final String? id,
          @JsonKey(name: 'extension')
              final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableConcept? stereochemistry,
          final CodeableConcept? opticalActivity,
          final String? molecularFormula,
          @JsonKey(name: '_molecularFormula')
              final Element? molecularFormulaElement,
          final String? molecularFormulaByMoiety,
          @JsonKey(name: '_molecularFormulaByMoiety')
              final Element? molecularFormulaByMoietyElement,
          final SubstanceDefinitionMolecularWeight? molecularWeight,
          final List<CodeableConcept>? technique,
          final List<Reference>? sourceDocument,
          final List<SubstanceDefinitionRepresentation>? representation}) =
      _$_SubstanceDefinitionStructure;
  _SubstanceDefinitionStructure._() : super._();

  factory _SubstanceDefinitionStructure.fromJson(Map<String, dynamic> json) =
      _$_SubstanceDefinitionStructure.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [stereochemistry] Stereochemistry type.;
  CodeableConcept? get stereochemistry;
  @override

  /// [opticalActivity] Optical activity type.;
  CodeableConcept? get opticalActivity;
  @override

  /// [molecularFormula] Molecular formula of this substance, typically using the Hill system.;
  String? get molecularFormula;
  @override

  /// [molecularFormulaElement] (_molecularFormula): Extensions for molecularFormula;
  @JsonKey(name: '_molecularFormula')
  Element? get molecularFormulaElement;
  @override

  /// [molecularFormulaByMoiety] Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.;
  String? get molecularFormulaByMoiety;
  @override
  @JsonKey(name: '_molecularFormulaByMoiety')
  Element? get molecularFormulaByMoietyElement;
  @override

  /// [molecularWeight] The molecular weight or weight range (for proteins, polymers or nucleic acids).;
  SubstanceDefinitionMolecularWeight? get molecularWeight;
  @override

  /// [technique] The method used to elucidate the structure or characterization of the drug substance. Examples: X-ray, HPLC, NMR, Peptide mapping, Ligand binding assay.;
  List<CodeableConcept>? get technique;
  @override

  /// [sourceDocument] The source of information about the structure.;
  List<Reference>? get sourceDocument;
  @override

  /// [representation] A depiction of the structure or characterization of the substance.;
  List<SubstanceDefinitionRepresentation>? get representation;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionStructureCopyWith<_$_SubstanceDefinitionStructure>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinitionRepresentation _$SubstanceDefinitionRepresentationFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionRepresentation.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionRepresentation {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] The kind of structural representation (e.g. full, partial).;
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [representation] The structural representation or characterization as a text string in a standard format.;
  String? get representation => throw _privateConstructorUsedError;

  /// [representationElement] (_representation): Extensions for representation;
  @JsonKey(name: '_representation')
  Element? get representationElement => throw _privateConstructorUsedError;

  /// [format] The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF. The logical content type rather than the physical file format of a document.;
  CodeableConcept? get format => throw _privateConstructorUsedError;

  /// [document] An attached file with the structural representation or characterization e.g. a molecular structure graphic of the substance, a JCAMP or AnIML file.;
  Reference? get document => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionRepresentationCopyWith<SubstanceDefinitionRepresentation>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionRepresentationCopyWith<$Res> {
  factory $SubstanceDefinitionRepresentationCopyWith(
          SubstanceDefinitionRepresentation value,
          $Res Function(SubstanceDefinitionRepresentation) then) =
      _$SubstanceDefinitionRepresentationCopyWithImpl<$Res,
          SubstanceDefinitionRepresentation>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      String? representation,
      @JsonKey(name: '_representation') Element? representationElement,
      CodeableConcept? format,
      Reference? document});

  $CodeableConceptCopyWith<$Res>? get type;
  $ElementCopyWith<$Res>? get representationElement;
  $CodeableConceptCopyWith<$Res>? get format;
  $ReferenceCopyWith<$Res>? get document;
}

/// @nodoc
class _$SubstanceDefinitionRepresentationCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionRepresentation>
    implements $SubstanceDefinitionRepresentationCopyWith<$Res> {
  _$SubstanceDefinitionRepresentationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? representation = freezed,
    Object? representationElement = freezed,
    Object? format = freezed,
    Object? document = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      representation: freezed == representation
          ? _value.representation
          : representation // ignore: cast_nullable_to_non_nullable
              as String?,
      representationElement: freezed == representationElement
          ? _value.representationElement
          : representationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      format: freezed == format
          ? _value.format
          : format // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      document: freezed == document
          ? _value.document
          : document // ignore: cast_nullable_to_non_nullable
              as Reference?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get representationElement {
    if (_value.representationElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.representationElement!, (value) {
      return _then(_value.copyWith(representationElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get format {
    if (_value.format == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.format!, (value) {
      return _then(_value.copyWith(format: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get document {
    if (_value.document == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.document!, (value) {
      return _then(_value.copyWith(document: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionRepresentationCopyWith<$Res>
    implements $SubstanceDefinitionRepresentationCopyWith<$Res> {
  factory _$$_SubstanceDefinitionRepresentationCopyWith(
          _$_SubstanceDefinitionRepresentation value,
          $Res Function(_$_SubstanceDefinitionRepresentation) then) =
      __$$_SubstanceDefinitionRepresentationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      String? representation,
      @JsonKey(name: '_representation') Element? representationElement,
      CodeableConcept? format,
      Reference? document});

  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $ElementCopyWith<$Res>? get representationElement;
  @override
  $CodeableConceptCopyWith<$Res>? get format;
  @override
  $ReferenceCopyWith<$Res>? get document;
}

/// @nodoc
class __$$_SubstanceDefinitionRepresentationCopyWithImpl<$Res>
    extends _$SubstanceDefinitionRepresentationCopyWithImpl<$Res,
        _$_SubstanceDefinitionRepresentation>
    implements _$$_SubstanceDefinitionRepresentationCopyWith<$Res> {
  __$$_SubstanceDefinitionRepresentationCopyWithImpl(
      _$_SubstanceDefinitionRepresentation _value,
      $Res Function(_$_SubstanceDefinitionRepresentation) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? representation = freezed,
    Object? representationElement = freezed,
    Object? format = freezed,
    Object? document = freezed,
  }) {
    return _then(_$_SubstanceDefinitionRepresentation(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      representation: freezed == representation
          ? _value.representation
          : representation // ignore: cast_nullable_to_non_nullable
              as String?,
      representationElement: freezed == representationElement
          ? _value.representationElement
          : representationElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      format: freezed == format
          ? _value.format
          : format // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      document: freezed == document
          ? _value.document
          : document // ignore: cast_nullable_to_non_nullable
              as Reference?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionRepresentation
    extends _SubstanceDefinitionRepresentation {
  _$_SubstanceDefinitionRepresentation(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.type,
      this.representation,
      @JsonKey(name: '_representation') this.representationElement,
      this.format,
      this.document})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstanceDefinitionRepresentation.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionRepresentationFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] The kind of structural representation (e.g. full, partial).;
  @override
  final CodeableConcept? type;

  /// [representation] The structural representation or characterization as a text string in a standard format.;
  @override
  final String? representation;

  /// [representationElement] (_representation): Extensions for representation;
  @override
  @JsonKey(name: '_representation')
  final Element? representationElement;

  /// [format] The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF. The logical content type rather than the physical file format of a document.;
  @override
  final CodeableConcept? format;

  /// [document] An attached file with the structural representation or characterization e.g. a molecular structure graphic of the substance, a JCAMP or AnIML file.;
  @override
  final Reference? document;

  @override
  String toString() {
    return 'SubstanceDefinitionRepresentation(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, representation: $representation, representationElement: $representationElement, format: $format, document: $document)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionRepresentation &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.representation, representation) ||
                other.representation == representation) &&
            (identical(other.representationElement, representationElement) ||
                other.representationElement == representationElement) &&
            (identical(other.format, format) || other.format == format) &&
            (identical(other.document, document) ||
                other.document == document));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      representation,
      representationElement,
      format,
      document);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionRepresentationCopyWith<
          _$_SubstanceDefinitionRepresentation>
      get copyWith => __$$_SubstanceDefinitionRepresentationCopyWithImpl<
          _$_SubstanceDefinitionRepresentation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionRepresentationToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionRepresentation
    extends SubstanceDefinitionRepresentation {
  factory _SubstanceDefinitionRepresentation(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? type,
      final String? representation,
      @JsonKey(name: '_representation') final Element? representationElement,
      final CodeableConcept? format,
      final Reference? document}) = _$_SubstanceDefinitionRepresentation;
  _SubstanceDefinitionRepresentation._() : super._();

  factory _SubstanceDefinitionRepresentation.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceDefinitionRepresentation.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] The kind of structural representation (e.g. full, partial).;
  CodeableConcept? get type;
  @override

  /// [representation] The structural representation or characterization as a text string in a standard format.;
  String? get representation;
  @override

  /// [representationElement] (_representation): Extensions for representation;
  @JsonKey(name: '_representation')
  Element? get representationElement;
  @override

  /// [format] The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF. The logical content type rather than the physical file format of a document.;
  CodeableConcept? get format;
  @override

  /// [document] An attached file with the structural representation or characterization e.g. a molecular structure graphic of the substance, a JCAMP or AnIML file.;
  Reference? get document;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionRepresentationCopyWith<
          _$_SubstanceDefinitionRepresentation>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinitionCode _$SubstanceDefinitionCodeFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionCode.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionCode {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [code] The specific code.;
  CodeableConcept? get code => throw _privateConstructorUsedError;

  /// [status] Status of the code assignment, for example 'provisional', 'approved'.;
  CodeableConcept? get status => throw _privateConstructorUsedError;

  /// [statusDate] The date at which the code status was changed as part of the terminology maintenance.;
  FhirDateTime? get statusDate => throw _privateConstructorUsedError;

  /// [statusDateElement] (_statusDate): Extensions for statusDate;
  @JsonKey(name: '_statusDate')
  Element? get statusDateElement => throw _privateConstructorUsedError;

  /// [note] Any comment can be provided in this field, if necessary.;
  List<Annotation>? get note => throw _privateConstructorUsedError;

  /// [source] Supporting literature.;
  List<Reference>? get source => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionCodeCopyWith<SubstanceDefinitionCode> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionCodeCopyWith<$Res> {
  factory $SubstanceDefinitionCodeCopyWith(SubstanceDefinitionCode value,
          $Res Function(SubstanceDefinitionCode) then) =
      _$SubstanceDefinitionCodeCopyWithImpl<$Res, SubstanceDefinitionCode>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? code,
      CodeableConcept? status,
      FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate') Element? statusDateElement,
      List<Annotation>? note,
      List<Reference>? source});

  $CodeableConceptCopyWith<$Res>? get code;
  $CodeableConceptCopyWith<$Res>? get status;
  $ElementCopyWith<$Res>? get statusDateElement;
}

/// @nodoc
class _$SubstanceDefinitionCodeCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionCode>
    implements $SubstanceDefinitionCodeCopyWith<$Res> {
  _$SubstanceDefinitionCodeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = freezed,
    Object? status = freezed,
    Object? statusDate = freezed,
    Object? statusDateElement = freezed,
    Object? note = freezed,
    Object? source = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      statusDate: freezed == statusDate
          ? _value.statusDate
          : statusDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      statusDateElement: freezed == statusDateElement
          ? _value.statusDateElement
          : statusDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      note: freezed == note
          ? _value.note
          : note // ignore: cast_nullable_to_non_nullable
              as List<Annotation>?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get code {
    if (_value.code == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.code!, (value) {
      return _then(_value.copyWith(code: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusDateElement {
    if (_value.statusDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusDateElement!, (value) {
      return _then(_value.copyWith(statusDateElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionCodeCopyWith<$Res>
    implements $SubstanceDefinitionCodeCopyWith<$Res> {
  factory _$$_SubstanceDefinitionCodeCopyWith(_$_SubstanceDefinitionCode value,
          $Res Function(_$_SubstanceDefinitionCode) then) =
      __$$_SubstanceDefinitionCodeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? code,
      CodeableConcept? status,
      FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate') Element? statusDateElement,
      List<Annotation>? note,
      List<Reference>? source});

  @override
  $CodeableConceptCopyWith<$Res>? get code;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
  @override
  $ElementCopyWith<$Res>? get statusDateElement;
}

/// @nodoc
class __$$_SubstanceDefinitionCodeCopyWithImpl<$Res>
    extends _$SubstanceDefinitionCodeCopyWithImpl<$Res,
        _$_SubstanceDefinitionCode>
    implements _$$_SubstanceDefinitionCodeCopyWith<$Res> {
  __$$_SubstanceDefinitionCodeCopyWithImpl(_$_SubstanceDefinitionCode _value,
      $Res Function(_$_SubstanceDefinitionCode) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? code = freezed,
    Object? status = freezed,
    Object? statusDate = freezed,
    Object? statusDateElement = freezed,
    Object? note = freezed,
    Object? source = freezed,
  }) {
    return _then(_$_SubstanceDefinitionCode(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      statusDate: freezed == statusDate
          ? _value.statusDate
          : statusDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      statusDateElement: freezed == statusDateElement
          ? _value.statusDateElement
          : statusDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      note: freezed == note
          ? _value._note
          : note // ignore: cast_nullable_to_non_nullable
              as List<Annotation>?,
      source: freezed == source
          ? _value._source
          : source // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionCode extends _SubstanceDefinitionCode {
  _$_SubstanceDefinitionCode(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.code,
      this.status,
      this.statusDate,
      @JsonKey(name: '_statusDate') this.statusDateElement,
      final List<Annotation>? note,
      final List<Reference>? source})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _note = note,
        _source = source,
        super._();

  factory _$_SubstanceDefinitionCode.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionCodeFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [code] The specific code.;
  @override
  final CodeableConcept? code;

  /// [status] Status of the code assignment, for example 'provisional', 'approved'.;
  @override
  final CodeableConcept? status;

  /// [statusDate] The date at which the code status was changed as part of the terminology maintenance.;
  @override
  final FhirDateTime? statusDate;

  /// [statusDateElement] (_statusDate): Extensions for statusDate;
  @override
  @JsonKey(name: '_statusDate')
  final Element? statusDateElement;

  /// [note] Any comment can be provided in this field, if necessary.;
  final List<Annotation>? _note;

  /// [note] Any comment can be provided in this field, if necessary.;
  @override
  List<Annotation>? get note {
    final value = _note;
    if (value == null) return null;
    if (_note is EqualUnmodifiableListView) return _note;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [source] Supporting literature.;
  final List<Reference>? _source;

  /// [source] Supporting literature.;
  @override
  List<Reference>? get source {
    final value = _source;
    if (value == null) return null;
    if (_source is EqualUnmodifiableListView) return _source;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstanceDefinitionCode(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, status: $status, statusDate: $statusDate, statusDateElement: $statusDateElement, note: $note, source: $source)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionCode &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusDate, statusDate) ||
                other.statusDate == statusDate) &&
            (identical(other.statusDateElement, statusDateElement) ||
                other.statusDateElement == statusDateElement) &&
            const DeepCollectionEquality().equals(other._note, _note) &&
            const DeepCollectionEquality().equals(other._source, _source));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      code,
      status,
      statusDate,
      statusDateElement,
      const DeepCollectionEquality().hash(_note),
      const DeepCollectionEquality().hash(_source));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionCodeCopyWith<_$_SubstanceDefinitionCode>
      get copyWith =>
          __$$_SubstanceDefinitionCodeCopyWithImpl<_$_SubstanceDefinitionCode>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionCodeToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionCode extends SubstanceDefinitionCode {
  factory _SubstanceDefinitionCode(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? code,
      final CodeableConcept? status,
      final FhirDateTime? statusDate,
      @JsonKey(name: '_statusDate') final Element? statusDateElement,
      final List<Annotation>? note,
      final List<Reference>? source}) = _$_SubstanceDefinitionCode;
  _SubstanceDefinitionCode._() : super._();

  factory _SubstanceDefinitionCode.fromJson(Map<String, dynamic> json) =
      _$_SubstanceDefinitionCode.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [code] The specific code.;
  CodeableConcept? get code;
  @override

  /// [status] Status of the code assignment, for example 'provisional', 'approved'.;
  CodeableConcept? get status;
  @override

  /// [statusDate] The date at which the code status was changed as part of the terminology maintenance.;
  FhirDateTime? get statusDate;
  @override

  /// [statusDateElement] (_statusDate): Extensions for statusDate;
  @JsonKey(name: '_statusDate')
  Element? get statusDateElement;
  @override

  /// [note] Any comment can be provided in this field, if necessary.;
  List<Annotation>? get note;
  @override

  /// [source] Supporting literature.;
  List<Reference>? get source;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionCodeCopyWith<_$_SubstanceDefinitionCode>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinitionName _$SubstanceDefinitionNameFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionName.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionName {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [name] The actual name.;
  String? get name => throw _privateConstructorUsedError;

  /// [nameElement] (_name): Extensions for name;
  @JsonKey(name: '_name')
  Element? get nameElement => throw _privateConstructorUsedError;

  /// [type] Name type, for example 'systematic',  'scientific, 'brand'.;
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [status] The status of the name, for example 'current', 'proposed'.;
  CodeableConcept? get status => throw _privateConstructorUsedError;

  /// [preferred] If this is the preferred name for this substance.;
  Boolean? get preferred => throw _privateConstructorUsedError;

  /// [preferredElement] (_preferred): Extensions for preferred;
  @JsonKey(name: '_preferred')
  Element? get preferredElement => throw _privateConstructorUsedError;

  /// [language] Human language that the name is written in.;
  List<CodeableConcept>? get language => throw _privateConstructorUsedError;

  /// [domain] The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive.;
  List<CodeableConcept>? get domain => throw _privateConstructorUsedError;

  /// [jurisdiction] The jurisdiction where this name applies.;
  List<CodeableConcept>? get jurisdiction => throw _privateConstructorUsedError;

  /// [synonym] A synonym of this particular name, by which the substance is also known.;
  List<SubstanceDefinitionName>? get synonym =>
      throw _privateConstructorUsedError;

  /// [translation] A translation for this name into another human language.;
  List<SubstanceDefinitionName>? get translation =>
      throw _privateConstructorUsedError;

  /// [official] Details of the official nature of this name.;
  List<SubstanceDefinitionOfficial>? get official =>
      throw _privateConstructorUsedError;

  /// [source] Supporting literature.;
  List<Reference>? get source => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionNameCopyWith<SubstanceDefinitionName> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionNameCopyWith<$Res> {
  factory $SubstanceDefinitionNameCopyWith(SubstanceDefinitionName value,
          $Res Function(SubstanceDefinitionName) then) =
      _$SubstanceDefinitionNameCopyWithImpl<$Res, SubstanceDefinitionName>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      CodeableConcept? type,
      CodeableConcept? status,
      Boolean? preferred,
      @JsonKey(name: '_preferred') Element? preferredElement,
      List<CodeableConcept>? language,
      List<CodeableConcept>? domain,
      List<CodeableConcept>? jurisdiction,
      List<SubstanceDefinitionName>? synonym,
      List<SubstanceDefinitionName>? translation,
      List<SubstanceDefinitionOfficial>? official,
      List<Reference>? source});

  $ElementCopyWith<$Res>? get nameElement;
  $CodeableConceptCopyWith<$Res>? get type;
  $CodeableConceptCopyWith<$Res>? get status;
  $ElementCopyWith<$Res>? get preferredElement;
}

/// @nodoc
class _$SubstanceDefinitionNameCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionName>
    implements $SubstanceDefinitionNameCopyWith<$Res> {
  _$SubstanceDefinitionNameCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? type = freezed,
    Object? status = freezed,
    Object? preferred = freezed,
    Object? preferredElement = freezed,
    Object? language = freezed,
    Object? domain = freezed,
    Object? jurisdiction = freezed,
    Object? synonym = freezed,
    Object? translation = freezed,
    Object? official = freezed,
    Object? source = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      preferred: freezed == preferred
          ? _value.preferred
          : preferred // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      preferredElement: freezed == preferredElement
          ? _value.preferredElement
          : preferredElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      domain: freezed == domain
          ? _value.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      jurisdiction: freezed == jurisdiction
          ? _value.jurisdiction
          : jurisdiction // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      synonym: freezed == synonym
          ? _value.synonym
          : synonym // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionName>?,
      translation: freezed == translation
          ? _value.translation
          : translation // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionName>?,
      official: freezed == official
          ? _value.official
          : official // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionOfficial>?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get nameElement {
    if (_value.nameElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.nameElement!, (value) {
      return _then(_value.copyWith(nameElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get preferredElement {
    if (_value.preferredElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.preferredElement!, (value) {
      return _then(_value.copyWith(preferredElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionNameCopyWith<$Res>
    implements $SubstanceDefinitionNameCopyWith<$Res> {
  factory _$$_SubstanceDefinitionNameCopyWith(_$_SubstanceDefinitionName value,
          $Res Function(_$_SubstanceDefinitionName) then) =
      __$$_SubstanceDefinitionNameCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      CodeableConcept? type,
      CodeableConcept? status,
      Boolean? preferred,
      @JsonKey(name: '_preferred') Element? preferredElement,
      List<CodeableConcept>? language,
      List<CodeableConcept>? domain,
      List<CodeableConcept>? jurisdiction,
      List<SubstanceDefinitionName>? synonym,
      List<SubstanceDefinitionName>? translation,
      List<SubstanceDefinitionOfficial>? official,
      List<Reference>? source});

  @override
  $ElementCopyWith<$Res>? get nameElement;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
  @override
  $ElementCopyWith<$Res>? get preferredElement;
}

/// @nodoc
class __$$_SubstanceDefinitionNameCopyWithImpl<$Res>
    extends _$SubstanceDefinitionNameCopyWithImpl<$Res,
        _$_SubstanceDefinitionName>
    implements _$$_SubstanceDefinitionNameCopyWith<$Res> {
  __$$_SubstanceDefinitionNameCopyWithImpl(_$_SubstanceDefinitionName _value,
      $Res Function(_$_SubstanceDefinitionName) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? type = freezed,
    Object? status = freezed,
    Object? preferred = freezed,
    Object? preferredElement = freezed,
    Object? language = freezed,
    Object? domain = freezed,
    Object? jurisdiction = freezed,
    Object? synonym = freezed,
    Object? translation = freezed,
    Object? official = freezed,
    Object? source = freezed,
  }) {
    return _then(_$_SubstanceDefinitionName(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      preferred: freezed == preferred
          ? _value.preferred
          : preferred // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      preferredElement: freezed == preferredElement
          ? _value.preferredElement
          : preferredElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value._language
          : language // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      domain: freezed == domain
          ? _value._domain
          : domain // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      jurisdiction: freezed == jurisdiction
          ? _value._jurisdiction
          : jurisdiction // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      synonym: freezed == synonym
          ? _value._synonym
          : synonym // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionName>?,
      translation: freezed == translation
          ? _value._translation
          : translation // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionName>?,
      official: freezed == official
          ? _value._official
          : official // ignore: cast_nullable_to_non_nullable
              as List<SubstanceDefinitionOfficial>?,
      source: freezed == source
          ? _value._source
          : source // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionName extends _SubstanceDefinitionName {
  _$_SubstanceDefinitionName(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.name,
      @JsonKey(name: '_name') this.nameElement,
      this.type,
      this.status,
      this.preferred,
      @JsonKey(name: '_preferred') this.preferredElement,
      final List<CodeableConcept>? language,
      final List<CodeableConcept>? domain,
      final List<CodeableConcept>? jurisdiction,
      final List<SubstanceDefinitionName>? synonym,
      final List<SubstanceDefinitionName>? translation,
      final List<SubstanceDefinitionOfficial>? official,
      final List<Reference>? source})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _language = language,
        _domain = domain,
        _jurisdiction = jurisdiction,
        _synonym = synonym,
        _translation = translation,
        _official = official,
        _source = source,
        super._();

  factory _$_SubstanceDefinitionName.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionNameFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [name] The actual name.;
  @override
  final String? name;

  /// [nameElement] (_name): Extensions for name;
  @override
  @JsonKey(name: '_name')
  final Element? nameElement;

  /// [type] Name type, for example 'systematic',  'scientific, 'brand'.;
  @override
  final CodeableConcept? type;

  /// [status] The status of the name, for example 'current', 'proposed'.;
  @override
  final CodeableConcept? status;

  /// [preferred] If this is the preferred name for this substance.;
  @override
  final Boolean? preferred;

  /// [preferredElement] (_preferred): Extensions for preferred;
  @override
  @JsonKey(name: '_preferred')
  final Element? preferredElement;

  /// [language] Human language that the name is written in.;
  final List<CodeableConcept>? _language;

  /// [language] Human language that the name is written in.;
  @override
  List<CodeableConcept>? get language {
    final value = _language;
    if (value == null) return null;
    if (_language is EqualUnmodifiableListView) return _language;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [domain] The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive.;
  final List<CodeableConcept>? _domain;

  /// [domain] The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive.;
  @override
  List<CodeableConcept>? get domain {
    final value = _domain;
    if (value == null) return null;
    if (_domain is EqualUnmodifiableListView) return _domain;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [jurisdiction] The jurisdiction where this name applies.;
  final List<CodeableConcept>? _jurisdiction;

  /// [jurisdiction] The jurisdiction where this name applies.;
  @override
  List<CodeableConcept>? get jurisdiction {
    final value = _jurisdiction;
    if (value == null) return null;
    if (_jurisdiction is EqualUnmodifiableListView) return _jurisdiction;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [synonym] A synonym of this particular name, by which the substance is also known.;
  final List<SubstanceDefinitionName>? _synonym;

  /// [synonym] A synonym of this particular name, by which the substance is also known.;
  @override
  List<SubstanceDefinitionName>? get synonym {
    final value = _synonym;
    if (value == null) return null;
    if (_synonym is EqualUnmodifiableListView) return _synonym;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [translation] A translation for this name into another human language.;
  final List<SubstanceDefinitionName>? _translation;

  /// [translation] A translation for this name into another human language.;
  @override
  List<SubstanceDefinitionName>? get translation {
    final value = _translation;
    if (value == null) return null;
    if (_translation is EqualUnmodifiableListView) return _translation;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [official] Details of the official nature of this name.;
  final List<SubstanceDefinitionOfficial>? _official;

  /// [official] Details of the official nature of this name.;
  @override
  List<SubstanceDefinitionOfficial>? get official {
    final value = _official;
    if (value == null) return null;
    if (_official is EqualUnmodifiableListView) return _official;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [source] Supporting literature.;
  final List<Reference>? _source;

  /// [source] Supporting literature.;
  @override
  List<Reference>? get source {
    final value = _source;
    if (value == null) return null;
    if (_source is EqualUnmodifiableListView) return _source;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstanceDefinitionName(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, name: $name, nameElement: $nameElement, type: $type, status: $status, preferred: $preferred, preferredElement: $preferredElement, language: $language, domain: $domain, jurisdiction: $jurisdiction, synonym: $synonym, translation: $translation, official: $official, source: $source)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionName &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.nameElement, nameElement) ||
                other.nameElement == nameElement) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.preferred, preferred) ||
                other.preferred == preferred) &&
            (identical(other.preferredElement, preferredElement) ||
                other.preferredElement == preferredElement) &&
            const DeepCollectionEquality().equals(other._language, _language) &&
            const DeepCollectionEquality().equals(other._domain, _domain) &&
            const DeepCollectionEquality()
                .equals(other._jurisdiction, _jurisdiction) &&
            const DeepCollectionEquality().equals(other._synonym, _synonym) &&
            const DeepCollectionEquality()
                .equals(other._translation, _translation) &&
            const DeepCollectionEquality().equals(other._official, _official) &&
            const DeepCollectionEquality().equals(other._source, _source));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      name,
      nameElement,
      type,
      status,
      preferred,
      preferredElement,
      const DeepCollectionEquality().hash(_language),
      const DeepCollectionEquality().hash(_domain),
      const DeepCollectionEquality().hash(_jurisdiction),
      const DeepCollectionEquality().hash(_synonym),
      const DeepCollectionEquality().hash(_translation),
      const DeepCollectionEquality().hash(_official),
      const DeepCollectionEquality().hash(_source));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionNameCopyWith<_$_SubstanceDefinitionName>
      get copyWith =>
          __$$_SubstanceDefinitionNameCopyWithImpl<_$_SubstanceDefinitionName>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionNameToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionName extends SubstanceDefinitionName {
  factory _SubstanceDefinitionName(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final String? name,
      @JsonKey(name: '_name') final Element? nameElement,
      final CodeableConcept? type,
      final CodeableConcept? status,
      final Boolean? preferred,
      @JsonKey(name: '_preferred') final Element? preferredElement,
      final List<CodeableConcept>? language,
      final List<CodeableConcept>? domain,
      final List<CodeableConcept>? jurisdiction,
      final List<SubstanceDefinitionName>? synonym,
      final List<SubstanceDefinitionName>? translation,
      final List<SubstanceDefinitionOfficial>? official,
      final List<Reference>? source}) = _$_SubstanceDefinitionName;
  _SubstanceDefinitionName._() : super._();

  factory _SubstanceDefinitionName.fromJson(Map<String, dynamic> json) =
      _$_SubstanceDefinitionName.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [name] The actual name.;
  String? get name;
  @override

  /// [nameElement] (_name): Extensions for name;
  @JsonKey(name: '_name')
  Element? get nameElement;
  @override

  /// [type] Name type, for example 'systematic',  'scientific, 'brand'.;
  CodeableConcept? get type;
  @override

  /// [status] The status of the name, for example 'current', 'proposed'.;
  CodeableConcept? get status;
  @override

  /// [preferred] If this is the preferred name for this substance.;
  Boolean? get preferred;
  @override

  /// [preferredElement] (_preferred): Extensions for preferred;
  @JsonKey(name: '_preferred')
  Element? get preferredElement;
  @override

  /// [language] Human language that the name is written in.;
  List<CodeableConcept>? get language;
  @override

  /// [domain] The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive.;
  List<CodeableConcept>? get domain;
  @override

  /// [jurisdiction] The jurisdiction where this name applies.;
  List<CodeableConcept>? get jurisdiction;
  @override

  /// [synonym] A synonym of this particular name, by which the substance is also known.;
  List<SubstanceDefinitionName>? get synonym;
  @override

  /// [translation] A translation for this name into another human language.;
  List<SubstanceDefinitionName>? get translation;
  @override

  /// [official] Details of the official nature of this name.;
  List<SubstanceDefinitionOfficial>? get official;
  @override

  /// [source] Supporting literature.;
  List<Reference>? get source;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionNameCopyWith<_$_SubstanceDefinitionName>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinitionOfficial _$SubstanceDefinitionOfficialFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionOfficial.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionOfficial {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [authority] Which authority uses this official name.;
  CodeableConcept? get authority => throw _privateConstructorUsedError;

  /// [status] The status of the official name, for example 'draft', 'active', 'retired'.;
  CodeableConcept? get status => throw _privateConstructorUsedError;

  /// [date] Date of the official name change.;
  FhirDateTime? get date => throw _privateConstructorUsedError;

  /// [dateElement] (_date): Extensions for date;
  @JsonKey(name: '_date')
  Element? get dateElement => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionOfficialCopyWith<SubstanceDefinitionOfficial>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionOfficialCopyWith<$Res> {
  factory $SubstanceDefinitionOfficialCopyWith(
          SubstanceDefinitionOfficial value,
          $Res Function(SubstanceDefinitionOfficial) then) =
      _$SubstanceDefinitionOfficialCopyWithImpl<$Res,
          SubstanceDefinitionOfficial>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? authority,
      CodeableConcept? status,
      FhirDateTime? date,
      @JsonKey(name: '_date') Element? dateElement});

  $CodeableConceptCopyWith<$Res>? get authority;
  $CodeableConceptCopyWith<$Res>? get status;
  $ElementCopyWith<$Res>? get dateElement;
}

/// @nodoc
class _$SubstanceDefinitionOfficialCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionOfficial>
    implements $SubstanceDefinitionOfficialCopyWith<$Res> {
  _$SubstanceDefinitionOfficialCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? authority = freezed,
    Object? status = freezed,
    Object? date = freezed,
    Object? dateElement = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      authority: freezed == authority
          ? _value.authority
          : authority // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      date: freezed == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      dateElement: freezed == dateElement
          ? _value.dateElement
          : dateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get authority {
    if (_value.authority == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.authority!, (value) {
      return _then(_value.copyWith(authority: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get status {
    if (_value.status == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.status!, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get dateElement {
    if (_value.dateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.dateElement!, (value) {
      return _then(_value.copyWith(dateElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionOfficialCopyWith<$Res>
    implements $SubstanceDefinitionOfficialCopyWith<$Res> {
  factory _$$_SubstanceDefinitionOfficialCopyWith(
          _$_SubstanceDefinitionOfficial value,
          $Res Function(_$_SubstanceDefinitionOfficial) then) =
      __$$_SubstanceDefinitionOfficialCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? authority,
      CodeableConcept? status,
      FhirDateTime? date,
      @JsonKey(name: '_date') Element? dateElement});

  @override
  $CodeableConceptCopyWith<$Res>? get authority;
  @override
  $CodeableConceptCopyWith<$Res>? get status;
  @override
  $ElementCopyWith<$Res>? get dateElement;
}

/// @nodoc
class __$$_SubstanceDefinitionOfficialCopyWithImpl<$Res>
    extends _$SubstanceDefinitionOfficialCopyWithImpl<$Res,
        _$_SubstanceDefinitionOfficial>
    implements _$$_SubstanceDefinitionOfficialCopyWith<$Res> {
  __$$_SubstanceDefinitionOfficialCopyWithImpl(
      _$_SubstanceDefinitionOfficial _value,
      $Res Function(_$_SubstanceDefinitionOfficial) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? authority = freezed,
    Object? status = freezed,
    Object? date = freezed,
    Object? dateElement = freezed,
  }) {
    return _then(_$_SubstanceDefinitionOfficial(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      authority: freezed == authority
          ? _value.authority
          : authority // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      date: freezed == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      dateElement: freezed == dateElement
          ? _value.dateElement
          : dateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionOfficial extends _SubstanceDefinitionOfficial {
  _$_SubstanceDefinitionOfficial(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.authority,
      this.status,
      this.date,
      @JsonKey(name: '_date') this.dateElement})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$_SubstanceDefinitionOfficial.fromJson(Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionOfficialFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [authority] Which authority uses this official name.;
  @override
  final CodeableConcept? authority;

  /// [status] The status of the official name, for example 'draft', 'active', 'retired'.;
  @override
  final CodeableConcept? status;

  /// [date] Date of the official name change.;
  @override
  final FhirDateTime? date;

  /// [dateElement] (_date): Extensions for date;
  @override
  @JsonKey(name: '_date')
  final Element? dateElement;

  @override
  String toString() {
    return 'SubstanceDefinitionOfficial(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, authority: $authority, status: $status, date: $date, dateElement: $dateElement)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionOfficial &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.authority, authority) ||
                other.authority == authority) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.dateElement, dateElement) ||
                other.dateElement == dateElement));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      authority,
      status,
      date,
      dateElement);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionOfficialCopyWith<_$_SubstanceDefinitionOfficial>
      get copyWith => __$$_SubstanceDefinitionOfficialCopyWithImpl<
          _$_SubstanceDefinitionOfficial>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionOfficialToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionOfficial
    extends SubstanceDefinitionOfficial {
  factory _SubstanceDefinitionOfficial(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableConcept? authority,
          final CodeableConcept? status,
          final FhirDateTime? date,
          @JsonKey(name: '_date') final Element? dateElement}) =
      _$_SubstanceDefinitionOfficial;
  _SubstanceDefinitionOfficial._() : super._();

  factory _SubstanceDefinitionOfficial.fromJson(Map<String, dynamic> json) =
      _$_SubstanceDefinitionOfficial.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [authority] Which authority uses this official name.;
  CodeableConcept? get authority;
  @override

  /// [status] The status of the official name, for example 'draft', 'active', 'retired'.;
  CodeableConcept? get status;
  @override

  /// [date] Date of the official name change.;
  FhirDateTime? get date;
  @override

  /// [dateElement] (_date): Extensions for date;
  @JsonKey(name: '_date')
  Element? get dateElement;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionOfficialCopyWith<_$_SubstanceDefinitionOfficial>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinitionRelationship _$SubstanceDefinitionRelationshipFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionRelationship.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionRelationship {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [substanceDefinitionReference] A pointer to another substance, as a resource or just a representational code.;
  Reference? get substanceDefinitionReference =>
      throw _privateConstructorUsedError;

  /// [substanceDefinitionCodeableConcept] A pointer to another substance, as a resource or just a representational code.;
  CodeableConcept? get substanceDefinitionCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [type] For example "salt to parent", "active moiety", "starting material", "polymorph", "impurity of".;
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [isDefining] For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.;
  Boolean? get isDefining => throw _privateConstructorUsedError;

  /// [isDefiningElement] (_isDefining): Extensions for isDefining;
  @JsonKey(name: '_isDefining')
  Element? get isDefiningElement => throw _privateConstructorUsedError;

  /// [amountQuantity] A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.;
  Quantity? get amountQuantity => throw _privateConstructorUsedError;

  /// [amountRatio] A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.;
  Ratio? get amountRatio => throw _privateConstructorUsedError;

  /// [amountString] A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.;
  Markdown? get amountString => throw _privateConstructorUsedError;

  /// [amountStringElement] (_amountString): Extensions for amountString;
  @JsonKey(name: '_amountString')
  Element? get amountStringElement => throw _privateConstructorUsedError;

  /// [ratioHighLimitAmount] For use when the numeric has an uncertain range.;
  Ratio? get ratioHighLimitAmount => throw _privateConstructorUsedError;

  /// [comparator] An operator for the amount, for example "average", "approximately", "less than".;
  CodeableConcept? get comparator => throw _privateConstructorUsedError;

  /// [source] Supporting literature.;
  List<Reference>? get source => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionRelationshipCopyWith<SubstanceDefinitionRelationship>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionRelationshipCopyWith<$Res> {
  factory $SubstanceDefinitionRelationshipCopyWith(
          SubstanceDefinitionRelationship value,
          $Res Function(SubstanceDefinitionRelationship) then) =
      _$SubstanceDefinitionRelationshipCopyWithImpl<$Res,
          SubstanceDefinitionRelationship>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Reference? substanceDefinitionReference,
      CodeableConcept? substanceDefinitionCodeableConcept,
      CodeableConcept type,
      Boolean? isDefining,
      @JsonKey(name: '_isDefining') Element? isDefiningElement,
      Quantity? amountQuantity,
      Ratio? amountRatio,
      Markdown? amountString,
      @JsonKey(name: '_amountString') Element? amountStringElement,
      Ratio? ratioHighLimitAmount,
      CodeableConcept? comparator,
      List<Reference>? source});

  $ReferenceCopyWith<$Res>? get substanceDefinitionReference;
  $CodeableConceptCopyWith<$Res>? get substanceDefinitionCodeableConcept;
  $CodeableConceptCopyWith<$Res> get type;
  $ElementCopyWith<$Res>? get isDefiningElement;
  $QuantityCopyWith<$Res>? get amountQuantity;
  $RatioCopyWith<$Res>? get amountRatio;
  $ElementCopyWith<$Res>? get amountStringElement;
  $RatioCopyWith<$Res>? get ratioHighLimitAmount;
  $CodeableConceptCopyWith<$Res>? get comparator;
}

/// @nodoc
class _$SubstanceDefinitionRelationshipCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionRelationship>
    implements $SubstanceDefinitionRelationshipCopyWith<$Res> {
  _$SubstanceDefinitionRelationshipCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? substanceDefinitionReference = freezed,
    Object? substanceDefinitionCodeableConcept = freezed,
    Object? type = null,
    Object? isDefining = freezed,
    Object? isDefiningElement = freezed,
    Object? amountQuantity = freezed,
    Object? amountRatio = freezed,
    Object? amountString = freezed,
    Object? amountStringElement = freezed,
    Object? ratioHighLimitAmount = freezed,
    Object? comparator = freezed,
    Object? source = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      substanceDefinitionReference: freezed == substanceDefinitionReference
          ? _value.substanceDefinitionReference
          : substanceDefinitionReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      substanceDefinitionCodeableConcept: freezed ==
              substanceDefinitionCodeableConcept
          ? _value.substanceDefinitionCodeableConcept
          : substanceDefinitionCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      isDefining: freezed == isDefining
          ? _value.isDefining
          : isDefining // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      isDefiningElement: freezed == isDefiningElement
          ? _value.isDefiningElement
          : isDefiningElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      amountQuantity: freezed == amountQuantity
          ? _value.amountQuantity
          : amountQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      amountRatio: freezed == amountRatio
          ? _value.amountRatio
          : amountRatio // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      amountString: freezed == amountString
          ? _value.amountString
          : amountString // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      amountStringElement: freezed == amountStringElement
          ? _value.amountStringElement
          : amountStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      ratioHighLimitAmount: freezed == ratioHighLimitAmount
          ? _value.ratioHighLimitAmount
          : ratioHighLimitAmount // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      comparator: freezed == comparator
          ? _value.comparator
          : comparator // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get substanceDefinitionReference {
    if (_value.substanceDefinitionReference == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.substanceDefinitionReference!,
        (value) {
      return _then(
          _value.copyWith(substanceDefinitionReference: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get substanceDefinitionCodeableConcept {
    if (_value.substanceDefinitionCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(
        _value.substanceDefinitionCodeableConcept!, (value) {
      return _then(
          _value.copyWith(substanceDefinitionCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get isDefiningElement {
    if (_value.isDefiningElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.isDefiningElement!, (value) {
      return _then(_value.copyWith(isDefiningElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get amountQuantity {
    if (_value.amountQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.amountQuantity!, (value) {
      return _then(_value.copyWith(amountQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RatioCopyWith<$Res>? get amountRatio {
    if (_value.amountRatio == null) {
      return null;
    }

    return $RatioCopyWith<$Res>(_value.amountRatio!, (value) {
      return _then(_value.copyWith(amountRatio: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get amountStringElement {
    if (_value.amountStringElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.amountStringElement!, (value) {
      return _then(_value.copyWith(amountStringElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RatioCopyWith<$Res>? get ratioHighLimitAmount {
    if (_value.ratioHighLimitAmount == null) {
      return null;
    }

    return $RatioCopyWith<$Res>(_value.ratioHighLimitAmount!, (value) {
      return _then(_value.copyWith(ratioHighLimitAmount: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get comparator {
    if (_value.comparator == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.comparator!, (value) {
      return _then(_value.copyWith(comparator: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionRelationshipCopyWith<$Res>
    implements $SubstanceDefinitionRelationshipCopyWith<$Res> {
  factory _$$_SubstanceDefinitionRelationshipCopyWith(
          _$_SubstanceDefinitionRelationship value,
          $Res Function(_$_SubstanceDefinitionRelationship) then) =
      __$$_SubstanceDefinitionRelationshipCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Reference? substanceDefinitionReference,
      CodeableConcept? substanceDefinitionCodeableConcept,
      CodeableConcept type,
      Boolean? isDefining,
      @JsonKey(name: '_isDefining') Element? isDefiningElement,
      Quantity? amountQuantity,
      Ratio? amountRatio,
      Markdown? amountString,
      @JsonKey(name: '_amountString') Element? amountStringElement,
      Ratio? ratioHighLimitAmount,
      CodeableConcept? comparator,
      List<Reference>? source});

  @override
  $ReferenceCopyWith<$Res>? get substanceDefinitionReference;
  @override
  $CodeableConceptCopyWith<$Res>? get substanceDefinitionCodeableConcept;
  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $ElementCopyWith<$Res>? get isDefiningElement;
  @override
  $QuantityCopyWith<$Res>? get amountQuantity;
  @override
  $RatioCopyWith<$Res>? get amountRatio;
  @override
  $ElementCopyWith<$Res>? get amountStringElement;
  @override
  $RatioCopyWith<$Res>? get ratioHighLimitAmount;
  @override
  $CodeableConceptCopyWith<$Res>? get comparator;
}

/// @nodoc
class __$$_SubstanceDefinitionRelationshipCopyWithImpl<$Res>
    extends _$SubstanceDefinitionRelationshipCopyWithImpl<$Res,
        _$_SubstanceDefinitionRelationship>
    implements _$$_SubstanceDefinitionRelationshipCopyWith<$Res> {
  __$$_SubstanceDefinitionRelationshipCopyWithImpl(
      _$_SubstanceDefinitionRelationship _value,
      $Res Function(_$_SubstanceDefinitionRelationship) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? substanceDefinitionReference = freezed,
    Object? substanceDefinitionCodeableConcept = freezed,
    Object? type = null,
    Object? isDefining = freezed,
    Object? isDefiningElement = freezed,
    Object? amountQuantity = freezed,
    Object? amountRatio = freezed,
    Object? amountString = freezed,
    Object? amountStringElement = freezed,
    Object? ratioHighLimitAmount = freezed,
    Object? comparator = freezed,
    Object? source = freezed,
  }) {
    return _then(_$_SubstanceDefinitionRelationship(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      substanceDefinitionReference: freezed == substanceDefinitionReference
          ? _value.substanceDefinitionReference
          : substanceDefinitionReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      substanceDefinitionCodeableConcept: freezed ==
              substanceDefinitionCodeableConcept
          ? _value.substanceDefinitionCodeableConcept
          : substanceDefinitionCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      isDefining: freezed == isDefining
          ? _value.isDefining
          : isDefining // ignore: cast_nullable_to_non_nullable
              as Boolean?,
      isDefiningElement: freezed == isDefiningElement
          ? _value.isDefiningElement
          : isDefiningElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      amountQuantity: freezed == amountQuantity
          ? _value.amountQuantity
          : amountQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      amountRatio: freezed == amountRatio
          ? _value.amountRatio
          : amountRatio // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      amountString: freezed == amountString
          ? _value.amountString
          : amountString // ignore: cast_nullable_to_non_nullable
              as Markdown?,
      amountStringElement: freezed == amountStringElement
          ? _value.amountStringElement
          : amountStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      ratioHighLimitAmount: freezed == ratioHighLimitAmount
          ? _value.ratioHighLimitAmount
          : ratioHighLimitAmount // ignore: cast_nullable_to_non_nullable
              as Ratio?,
      comparator: freezed == comparator
          ? _value.comparator
          : comparator // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      source: freezed == source
          ? _value._source
          : source // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionRelationship
    extends _SubstanceDefinitionRelationship {
  _$_SubstanceDefinitionRelationship(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.substanceDefinitionReference,
      this.substanceDefinitionCodeableConcept,
      required this.type,
      this.isDefining,
      @JsonKey(name: '_isDefining') this.isDefiningElement,
      this.amountQuantity,
      this.amountRatio,
      this.amountString,
      @JsonKey(name: '_amountString') this.amountStringElement,
      this.ratioHighLimitAmount,
      this.comparator,
      final List<Reference>? source})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _source = source,
        super._();

  factory _$_SubstanceDefinitionRelationship.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionRelationshipFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [substanceDefinitionReference] A pointer to another substance, as a resource or just a representational code.;
  @override
  final Reference? substanceDefinitionReference;

  /// [substanceDefinitionCodeableConcept] A pointer to another substance, as a resource or just a representational code.;
  @override
  final CodeableConcept? substanceDefinitionCodeableConcept;

  /// [type] For example "salt to parent", "active moiety", "starting material", "polymorph", "impurity of".;
  @override
  final CodeableConcept type;

  /// [isDefining] For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.;
  @override
  final Boolean? isDefining;

  /// [isDefiningElement] (_isDefining): Extensions for isDefining;
  @override
  @JsonKey(name: '_isDefining')
  final Element? isDefiningElement;

  /// [amountQuantity] A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.;
  @override
  final Quantity? amountQuantity;

  /// [amountRatio] A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.;
  @override
  final Ratio? amountRatio;

  /// [amountString] A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.;
  @override
  final Markdown? amountString;

  /// [amountStringElement] (_amountString): Extensions for amountString;
  @override
  @JsonKey(name: '_amountString')
  final Element? amountStringElement;

  /// [ratioHighLimitAmount] For use when the numeric has an uncertain range.;
  @override
  final Ratio? ratioHighLimitAmount;

  /// [comparator] An operator for the amount, for example "average", "approximately", "less than".;
  @override
  final CodeableConcept? comparator;

  /// [source] Supporting literature.;
  final List<Reference>? _source;

  /// [source] Supporting literature.;
  @override
  List<Reference>? get source {
    final value = _source;
    if (value == null) return null;
    if (_source is EqualUnmodifiableListView) return _source;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstanceDefinitionRelationship(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, substanceDefinitionReference: $substanceDefinitionReference, substanceDefinitionCodeableConcept: $substanceDefinitionCodeableConcept, type: $type, isDefining: $isDefining, isDefiningElement: $isDefiningElement, amountQuantity: $amountQuantity, amountRatio: $amountRatio, amountString: $amountString, amountStringElement: $amountStringElement, ratioHighLimitAmount: $ratioHighLimitAmount, comparator: $comparator, source: $source)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionRelationship &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.substanceDefinitionReference,
                    substanceDefinitionReference) ||
                other.substanceDefinitionReference ==
                    substanceDefinitionReference) &&
            (identical(other.substanceDefinitionCodeableConcept,
                    substanceDefinitionCodeableConcept) ||
                other.substanceDefinitionCodeableConcept ==
                    substanceDefinitionCodeableConcept) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.isDefining, isDefining) ||
                other.isDefining == isDefining) &&
            (identical(other.isDefiningElement, isDefiningElement) ||
                other.isDefiningElement == isDefiningElement) &&
            (identical(other.amountQuantity, amountQuantity) ||
                other.amountQuantity == amountQuantity) &&
            (identical(other.amountRatio, amountRatio) ||
                other.amountRatio == amountRatio) &&
            (identical(other.amountString, amountString) ||
                other.amountString == amountString) &&
            (identical(other.amountStringElement, amountStringElement) ||
                other.amountStringElement == amountStringElement) &&
            (identical(other.ratioHighLimitAmount, ratioHighLimitAmount) ||
                other.ratioHighLimitAmount == ratioHighLimitAmount) &&
            (identical(other.comparator, comparator) ||
                other.comparator == comparator) &&
            const DeepCollectionEquality().equals(other._source, _source));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      substanceDefinitionReference,
      substanceDefinitionCodeableConcept,
      type,
      isDefining,
      isDefiningElement,
      amountQuantity,
      amountRatio,
      amountString,
      amountStringElement,
      ratioHighLimitAmount,
      comparator,
      const DeepCollectionEquality().hash(_source));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionRelationshipCopyWith<
          _$_SubstanceDefinitionRelationship>
      get copyWith => __$$_SubstanceDefinitionRelationshipCopyWithImpl<
          _$_SubstanceDefinitionRelationship>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionRelationshipToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionRelationship
    extends SubstanceDefinitionRelationship {
  factory _SubstanceDefinitionRelationship(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final Reference? substanceDefinitionReference,
      final CodeableConcept? substanceDefinitionCodeableConcept,
      required final CodeableConcept type,
      final Boolean? isDefining,
      @JsonKey(name: '_isDefining') final Element? isDefiningElement,
      final Quantity? amountQuantity,
      final Ratio? amountRatio,
      final Markdown? amountString,
      @JsonKey(name: '_amountString') final Element? amountStringElement,
      final Ratio? ratioHighLimitAmount,
      final CodeableConcept? comparator,
      final List<Reference>? source}) = _$_SubstanceDefinitionRelationship;
  _SubstanceDefinitionRelationship._() : super._();

  factory _SubstanceDefinitionRelationship.fromJson(Map<String, dynamic> json) =
      _$_SubstanceDefinitionRelationship.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [substanceDefinitionReference] A pointer to another substance, as a resource or just a representational code.;
  Reference? get substanceDefinitionReference;
  @override

  /// [substanceDefinitionCodeableConcept] A pointer to another substance, as a resource or just a representational code.;
  CodeableConcept? get substanceDefinitionCodeableConcept;
  @override

  /// [type] For example "salt to parent", "active moiety", "starting material", "polymorph", "impurity of".;
  CodeableConcept get type;
  @override

  /// [isDefining] For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.;
  Boolean? get isDefining;
  @override

  /// [isDefiningElement] (_isDefining): Extensions for isDefining;
  @JsonKey(name: '_isDefining')
  Element? get isDefiningElement;
  @override

  /// [amountQuantity] A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.;
  Quantity? get amountQuantity;
  @override

  /// [amountRatio] A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.;
  Ratio? get amountRatio;
  @override

  /// [amountString] A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.;
  Markdown? get amountString;
  @override

  /// [amountStringElement] (_amountString): Extensions for amountString;
  @JsonKey(name: '_amountString')
  Element? get amountStringElement;
  @override

  /// [ratioHighLimitAmount] For use when the numeric has an uncertain range.;
  Ratio? get ratioHighLimitAmount;
  @override

  /// [comparator] An operator for the amount, for example "average", "approximately", "less than".;
  CodeableConcept? get comparator;
  @override

  /// [source] Supporting literature.;
  List<Reference>? get source;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionRelationshipCopyWith<
          _$_SubstanceDefinitionRelationship>
      get copyWith => throw _privateConstructorUsedError;
}

SubstanceDefinitionSourceMaterial _$SubstanceDefinitionSourceMaterialFromJson(
    Map<String, dynamic> json) {
  return _SubstanceDefinitionSourceMaterial.fromJson(json);
}

/// @nodoc
mixin _$SubstanceDefinitionSourceMaterial {
  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] A classification that provides the origin of the raw material. Example: cat hair would be an Animal source type.;
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [genus] The genus of an organism, typically referring to the Latin epithet of the genus element of the plant/animal scientific name.;
  CodeableConcept? get genus => throw _privateConstructorUsedError;

  /// [species] The species of an organism, typically referring to the Latin epithet of the species of the plant/animal.;
  CodeableConcept? get species => throw _privateConstructorUsedError;

  /// [part_] An anatomical origin of the source material within an organism.;
  @JsonKey(name: 'part')
  CodeableConcept? get part_ => throw _privateConstructorUsedError;

  /// [countryOfOrigin] The country or countries where the material is harvested.;
  List<CodeableConcept>? get countryOfOrigin =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SubstanceDefinitionSourceMaterialCopyWith<SubstanceDefinitionSourceMaterial>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubstanceDefinitionSourceMaterialCopyWith<$Res> {
  factory $SubstanceDefinitionSourceMaterialCopyWith(
          SubstanceDefinitionSourceMaterial value,
          $Res Function(SubstanceDefinitionSourceMaterial) then) =
      _$SubstanceDefinitionSourceMaterialCopyWithImpl<$Res,
          SubstanceDefinitionSourceMaterial>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      CodeableConcept? genus,
      CodeableConcept? species,
      @JsonKey(name: 'part') CodeableConcept? part_,
      List<CodeableConcept>? countryOfOrigin});

  $CodeableConceptCopyWith<$Res>? get type;
  $CodeableConceptCopyWith<$Res>? get genus;
  $CodeableConceptCopyWith<$Res>? get species;
  $CodeableConceptCopyWith<$Res>? get part_;
}

/// @nodoc
class _$SubstanceDefinitionSourceMaterialCopyWithImpl<$Res,
        $Val extends SubstanceDefinitionSourceMaterial>
    implements $SubstanceDefinitionSourceMaterialCopyWith<$Res> {
  _$SubstanceDefinitionSourceMaterialCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? genus = freezed,
    Object? species = freezed,
    Object? part_ = freezed,
    Object? countryOfOrigin = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      genus: freezed == genus
          ? _value.genus
          : genus // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      species: freezed == species
          ? _value.species
          : species // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      part_: freezed == part_
          ? _value.part_
          : part_ // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      countryOfOrigin: freezed == countryOfOrigin
          ? _value.countryOfOrigin
          : countryOfOrigin // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get genus {
    if (_value.genus == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.genus!, (value) {
      return _then(_value.copyWith(genus: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get species {
    if (_value.species == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.species!, (value) {
      return _then(_value.copyWith(species: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get part_ {
    if (_value.part_ == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.part_!, (value) {
      return _then(_value.copyWith(part_: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SubstanceDefinitionSourceMaterialCopyWith<$Res>
    implements $SubstanceDefinitionSourceMaterialCopyWith<$Res> {
  factory _$$_SubstanceDefinitionSourceMaterialCopyWith(
          _$_SubstanceDefinitionSourceMaterial value,
          $Res Function(_$_SubstanceDefinitionSourceMaterial) then) =
      __$$_SubstanceDefinitionSourceMaterialCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      CodeableConcept? genus,
      CodeableConcept? species,
      @JsonKey(name: 'part') CodeableConcept? part_,
      List<CodeableConcept>? countryOfOrigin});

  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $CodeableConceptCopyWith<$Res>? get genus;
  @override
  $CodeableConceptCopyWith<$Res>? get species;
  @override
  $CodeableConceptCopyWith<$Res>? get part_;
}

/// @nodoc
class __$$_SubstanceDefinitionSourceMaterialCopyWithImpl<$Res>
    extends _$SubstanceDefinitionSourceMaterialCopyWithImpl<$Res,
        _$_SubstanceDefinitionSourceMaterial>
    implements _$$_SubstanceDefinitionSourceMaterialCopyWith<$Res> {
  __$$_SubstanceDefinitionSourceMaterialCopyWithImpl(
      _$_SubstanceDefinitionSourceMaterial _value,
      $Res Function(_$_SubstanceDefinitionSourceMaterial) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? genus = freezed,
    Object? species = freezed,
    Object? part_ = freezed,
    Object? countryOfOrigin = freezed,
  }) {
    return _then(_$_SubstanceDefinitionSourceMaterial(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      genus: freezed == genus
          ? _value.genus
          : genus // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      species: freezed == species
          ? _value.species
          : species // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      part_: freezed == part_
          ? _value.part_
          : part_ // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      countryOfOrigin: freezed == countryOfOrigin
          ? _value._countryOfOrigin
          : countryOfOrigin // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SubstanceDefinitionSourceMaterial
    extends _SubstanceDefinitionSourceMaterial {
  _$_SubstanceDefinitionSourceMaterial(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.type,
      this.genus,
      this.species,
      @JsonKey(name: 'part') this.part_,
      final List<CodeableConcept>? countryOfOrigin})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _countryOfOrigin = countryOfOrigin,
        super._();

  factory _$_SubstanceDefinitionSourceMaterial.fromJson(
          Map<String, dynamic> json) =>
      _$$_SubstanceDefinitionSourceMaterialFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  @override
  final String? id;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  final List<FhirExtension>? _extension_;

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] A classification that provides the origin of the raw material. Example: cat hair would be an Animal source type.;
  @override
  final CodeableConcept? type;

  /// [genus] The genus of an organism, typically referring to the Latin epithet of the genus element of the plant/animal scientific name.;
  @override
  final CodeableConcept? genus;

  /// [species] The species of an organism, typically referring to the Latin epithet of the species of the plant/animal.;
  @override
  final CodeableConcept? species;

  /// [part_] An anatomical origin of the source material within an organism.;
  @override
  @JsonKey(name: 'part')
  final CodeableConcept? part_;

  /// [countryOfOrigin] The country or countries where the material is harvested.;
  final List<CodeableConcept>? _countryOfOrigin;

  /// [countryOfOrigin] The country or countries where the material is harvested.;
  @override
  List<CodeableConcept>? get countryOfOrigin {
    final value = _countryOfOrigin;
    if (value == null) return null;
    if (_countryOfOrigin is EqualUnmodifiableListView) return _countryOfOrigin;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SubstanceDefinitionSourceMaterial(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, genus: $genus, species: $species, part_: $part_, countryOfOrigin: $countryOfOrigin)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SubstanceDefinitionSourceMaterial &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.genus, genus) || other.genus == genus) &&
            (identical(other.species, species) || other.species == species) &&
            (identical(other.part_, part_) || other.part_ == part_) &&
            const DeepCollectionEquality()
                .equals(other._countryOfOrigin, _countryOfOrigin));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      genus,
      species,
      part_,
      const DeepCollectionEquality().hash(_countryOfOrigin));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SubstanceDefinitionSourceMaterialCopyWith<
          _$_SubstanceDefinitionSourceMaterial>
      get copyWith => __$$_SubstanceDefinitionSourceMaterialCopyWithImpl<
          _$_SubstanceDefinitionSourceMaterial>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SubstanceDefinitionSourceMaterialToJson(
      this,
    );
  }
}

abstract class _SubstanceDefinitionSourceMaterial
    extends SubstanceDefinitionSourceMaterial {
  factory _SubstanceDefinitionSourceMaterial(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableConcept? type,
          final CodeableConcept? genus,
          final CodeableConcept? species,
          @JsonKey(name: 'part') final CodeableConcept? part_,
          final List<CodeableConcept>? countryOfOrigin}) =
      _$_SubstanceDefinitionSourceMaterial;
  _SubstanceDefinitionSourceMaterial._() : super._();

  factory _SubstanceDefinitionSourceMaterial.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceDefinitionSourceMaterial.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.;
  String? get id;
  @override

  /// [extension_] May be used to represent additional information that is not part of the basic definition of the element. To make the use of extensions safe and manageable, there is a strict set of governance  applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension.;
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.
  /// Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).;
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] A classification that provides the origin of the raw material. Example: cat hair would be an Animal source type.;
  CodeableConcept? get type;
  @override

  /// [genus] The genus of an organism, typically referring to the Latin epithet of the genus element of the plant/animal scientific name.;
  CodeableConcept? get genus;
  @override

  /// [species] The species of an organism, typically referring to the Latin epithet of the species of the plant/animal.;
  CodeableConcept? get species;
  @override

  /// [part_] An anatomical origin of the source material within an organism.;
  @JsonKey(name: 'part')
  CodeableConcept? get part_;
  @override

  /// [countryOfOrigin] The country or countries where the material is harvested.;
  List<CodeableConcept>? get countryOfOrigin;
  @override
  @JsonKey(ignore: true)
  _$$_SubstanceDefinitionSourceMaterialCopyWith<
          _$_SubstanceDefinitionSourceMaterial>
      get copyWith => throw _privateConstructorUsedError;
}
